#define eTeX_version = 2{\.{\\eTeXversion}}
#define eTeX_revision ==".6"{\.{\\eTeXrevision}}
#define eTeX_version_string =='-2.6'{current\eTeX\version} \

#define eTeX_banner =='This is e-TeX, Version 3.14159265',eTeX_version_string \
{printed when\eTeX\starts} \

#define pdftex_version ==140{\.{\\pdftexversion}}
#define pdftex_revision =="21"{\.{\\pdftexrevision}}
#define pdftex_version_string =='-1.40.21'{current\pdfTeX\version} \

#define pdfTeX_banner =='This is pdfTeX, Version 3.14159265',eTeX_version_string,pdftex_version_string \
{printed when\pdfTeX\starts} \

#define TeX_banner_k =='This is TeXk, Version 3.14159265'{printed when\TeX\starts}
#define TeX_banner =='This is TeX, Version 3.14159265'{printed when\TeX\starts} \

#define banner ==pdfTeX_banner
#define banner_k ==pdfTeX_banner \

#define TEX ==PDFTEX{change program name into|PDFTEX|} \

#define TeXXeT_code = 0{the\TeXXeT\feature is optional} \

#define eTeX_states = 1{number of\eTeX\state variables in|eqtb|} \

#define mtype ==type{this is a\.{WEB}coding trick:}
#define start_of_TEX = 1{go here when\TeX's variables are initialized}
#define final_end = 9999{this label marks the ending of the program} \

#define debug ==ifdef('TEXMF_DEBUG') 
#define gubed ==endif('TEXMF_DEBUG') 
#define stat ==ifdef('STAT') 
#define tats ==endif('STAT') 
#define init ==ifdef('INITEX') 
#define tini ==endif('INITEX') 
#define Init ==init if ini_version then begin
#define Tini ==end;tini
#define othercases ==others:{default for cases not listed explicitly}
#define endcases ==end{follows the default case in an extended|case|statement}
#define file_name_size ==maxint
#define ssup_error_line = 255
#define ssup_max_strings ==2097151 \
{Larger values than 65536 cause the arrays to consume much more memory.}
#define ssup_trie_opcode ==65535
#define ssup_trie_size ==3FFFFF \

#define ssup_hyph_size ==65535{Changing this requires changing(un) dumping!}
#define iinf_hyphen_size ==610{Must be not less than|hyph_prime|!} \

#define max_font_max = 9000{maximum number of internal fonts;this can be \
increased,but|hash_size+max_font_max| \
should not exceed 29000.}
#define font_base = 0{smallest internal font number;must be \
|>=min_quarterword|;do not change this without \
modifying the dynamic definition of the font arrays.} \
 \

#define hash_size = 15000{maximum number of control sequences;it should be at most \
about|(mem_max-mem_min) /10|;see also|font_max|}
#define hash_prime = 8501{a prime number equal to about 85\pct!of|hash_size|}
#define hyph_prime = 607{another prime for hashing\.{\\hyphenation}exceptions; \
if you change this,you should also change|iinf_hyphen_size|.} \
 \

#define exit = 10{go here to leave a procedure}
#define restart = 20{go here to start a procedure again}
#define reswitch = 21{go here to start a case statement again}
#define continue = 22{go here to resume a loop}
#define done = 30{go here to exit a loop}
#define done1 = 31{like|done|,when there is more than one loop}
#define done2 = 32{for exiting the second loop in a long block}
#define done3 = 33{for exiting the third loop in a very long block}
#define done4 = 34{for exiting the fourth loop in an extremely long block}
#define done5 = 35{for exiting the fifth loop in an immense block}
#define done6 = 36{for exiting the sixth loop in a block}
#define found = 40{go here when you've found it}
#define found1 = 41{like|found|,when there's more than one per routine}
#define found2 = 42{like|found|,when there's more than two per routine}
#define not_found = 45{go here when you've found nothing}
#define not_found1 = 46{like|not_found|,when there's more than one}
#define not_found2 = 47{like|not_found|,when there's more than two}
#define not_found3 = 48{like|not_found|,when there's more than three}
#define not_found4 = 49{like|not_found|,when there's more than four}
#define common_ending = 50{go here when you want to merge with another branch} \

#define negate(#) ==#:= -#{change the sign of a variable}
#define loop ==while true do{repeat over and over until a|goto|happens}
#define do_nothing =={empty statement}
#define return ==goto exit{terminate a procedure call}
#define empty = 0{symbolic name for a null constant} \

#define text_char ==ASCII_code{the data type of characters in text files}
#define first_text_char = 0{ordinal number of the smallest element of|text_char|}
#define last_text_char = 255{ordinal number of the largest element of|text_char|} \

#define null_code = 48
#define carriage_return = 49
#define invalid_code = 49 \

#define term_in ==stdin{the terminal as an input file}
#define term_out ==stdout{the terminal as an output file} \

#define t_open_out =={output already open for text output} \

#define update_terminal ==fflush(term_out) 
#define clear_terminal ==do_nothing
#define wake_up_terminal ==do_nothing{cancel the user's cancellation of output} \

#define loc ==cur_input.loc_field{location of first unread character in|buffer|} \

#define si(#) ==#{convert from|ASCII_code|to|packed_ASCII_code|}
#define so(#) ==#{convert from|packed_ASCII_code|to|ASCII_code|} \

#define length(#) ==(str_start[#+1]-str_start[#]) {the number of characters \
in string number\#} \

#define cur_length ==(pool_ptr-str_start[str_ptr])  \

#define append_char(#) =={put|ASCII_code|\#at the end of|str_pool|} \
begin str_pool[pool_ptr]:= si(#) ;incr(pool_ptr) ; \
end
#define flush_char ==decr(pool_ptr) {forget the last character in the pool}
#define str_room(#) =={make sure that the pool hasn't overflowed} \
begin if pool_ptr+#> pool_size then \
overflow("pool size",pool_size-init_pool_ptr) ; \
 \
end \

#define flush_string ==begin decr(str_ptr) ;pool_ptr:= str_start[str_ptr]; \
end \

#define app_lc_hex(#) ==l:= #; \
if l<10 then append_char(l+"0") else append_char(l-10+"a")  \

#define no_print = 16{|selector|setting that makes data disappear}
#define term_only = 17{printing is destined for the terminal only}
#define log_only = 18{printing is destined for the transcript file only}
#define term_and_log = 19{normal|selector|setting}
#define pseudo = 20{special|selector|setting for|show_context|}
#define new_string = 21{printing is deflected to the string pool}
#define max_selector = 21{highest selector setting} \

#define wterm(#) ==write(term_out,#) 
#define wterm_ln(#) ==write_ln(term_out,#) 
#define wterm_cr ==write_ln(term_out) 
#define wlog(#) ==write(log_file,#) 
#define wlog_ln(#) ==write_ln(log_file,#) 
#define wlog_cr ==write_ln(log_file)  \

#define print_ASCII ==print \

#define prompt_input(#) ==begin wake_up_terminal;print(#) ;term_input; \
end{prints a string and gets a line of input} \

#define batch_mode = 0{omits all stops and omits terminal output}
#define nonstop_mode = 1{omits all stops}
#define scroll_mode = 2{omits error stops}
#define error_stop_mode = 3{stops at every opportunity to interact}
#define unspecified_mode = 4{extra value for command-line switch}
#define print_err(#) ==begin if interaction= error_stop_mode then wake_up_terminal; \
if file_line_error_style_p then print_file_line \
else print_nl("! ") ; \
print(#) ; \
end \

#define spotless = 0{|history|value when nothing has been amiss yet}
#define warning_issued = 1{|history|value when|begin_diagnostic|has been called}
#define error_message_issued = 2{|history|value when|error|has been called}
#define fatal_error_stop = 3{|history|value when termination was premature} \

#define hlp1(#) ==help_line[0]:= #;end
#define hlp2(#) ==help_line[1]:= #;hlp1
#define hlp3(#) ==help_line[2]:= #;hlp2
#define hlp4(#) ==help_line[3]:= #;hlp3
#define hlp5(#) ==help_line[4]:= #;hlp4
#define hlp6(#) ==help_line[5]:= #;hlp5
#define help0 ==help_ptr:= 0{sometimes there might be no help}
#define help1 ==begin help_ptr:= 1;hlp1{use this with one help line}
#define help2 ==begin help_ptr:= 2;hlp2{use this with two help lines}
#define help3 ==begin help_ptr:= 3;hlp3{use this with three help lines}
#define help4 ==begin help_ptr:= 4;hlp4{use this with four help lines}
#define help5 ==begin help_ptr:= 5;hlp5{use this with five help lines}
#define help6 ==begin help_ptr:= 6;hlp6{use this with six help lines} \

#define do_final_end ==begin \
update_terminal; \
ready_already:= 0; \
if(history<> spotless) and(history<> warning_issued) then \
uexit(1)  \
else \
uexit(0) ; \
end \

#define edit_file ==input_stack[base_ptr] \

#define succumb ==begin if interaction= error_stop_mode then \
interaction:= scroll_mode;{no more interaction} \
if log_opened then error; \
debug if interaction> batch_mode then debug_help;gubed \
history:= fatal_error_stop;jump_out;{irrecoverable error} \
end \

#define check_interrupt ==begin if interrupt<> 0 then pause_for_instructions; \
end \

#define unity ==50
#define two ==52 \

#define remainder ==tex_remainder \

#define nx_plus_y(#) ==mult_and_add(#,55
#define mult_integers(#) ==mult_and_add(#,0,49 \

#define inf_bad = 10000{infinitely bad value} \

#define set_glue_ratio_zero(#) ==#:= 0.0{store the representation of zero ratio}
#define set_glue_ratio_one(#) ==#:= 1.0{store the representation of unit ratio}
#define float(#) ==#{convert from|glue_ratio|to type|real|}
#define unfloat(#) ==#{convert from|real|to type|glue_ratio|}
#define float_constant(#) ==#.0{convert|integer|constant to|real|} \

#define fraction_half ==49
#define fraction_one ==50
#define fraction_four ==49
#define el_gordo ==49
#define halfp(#) ==(#) div 2
#define double(#) ==#:= #+#{multiply a variable by two} \

#define return_sign(#) ==begin ab_vs_cd:= #;return; \
end \

#define next_random ==if j_random= 0 then new_randoms \
else decr(j_random)  \

#define min_quarterword = 0{smallest allowable value in a|quarterword|}
#define max_quarterword = 255{largest allowable value in a|quarterword|}
#define min_halfword ==-FFFFFFF{smallest allowable value in a|halfword|}
#define max_halfword ==FFFFFFF{largest allowable value in a|halfword|} \

#define qi(#) ==#{to put an|eight_bits|item into a quarterword}
#define qo(#) ==#{to take an|eight_bits|item from a quarterword}
#define hi(#) ==#{to put a sixteen-bit item into a halfword}
#define ho(#) ==#{to take a sixteen-bit item from a halfword} \

#define sc ==int{|scaled|data is equivalent to|integer|} \

#define pointer ==halfword{a flag or a location in|mem|or|eqtb|}
#define null ==min_halfword{the null pointer} \

#define link(#) ==mem[#].hh.rh{the|link|field of a memory word}
#define info(#) ==mem[#].hh.lh{the|info|field of a memory word} \

#define free_avail(#) =={single-word node liberation} \
begin link(#) := avail;avail:= #; \
stat decr(dyn_used) ;tats \
end \

#define fast_get_avail(#) == \
begin#:= avail;{avoid|get_avail|if possible,to save time} \
if#= null then#:= get_avail \
else begin avail:= link(#) ;link(#) := null; \
stat incr(dyn_used) ;tats \
end; \
end \

#define empty_flag ==max_halfword{the|link|of an empty variable-size node}
#define is_empty(#) ==(link(#) = empty_flag) {tests for empty node}
#define node_size ==info{the size field in empty variable-size nodes}
#define llink(#) ==info(#+1) {left link in doubly-linked list of empty nodes}
#define rlink(#) ==link(#+1) {right link in doubly-linked list of empty nodes} \

#define type(#) ==mem[#].hh.b0{identifies what kind of node this is}
#define subtype(#) ==mem[#].hh.b1{secondary identification in some cases} \

#define is_char_node(#) ==(#>=hi_mem_min)  \
{does the argument point to a|char_node|?}
#define font ==type{the font code in a|char_node|}
#define character ==subtype{the character code in a|char_node|} \

#define synctex_field_size = 2{Declare the{\sl Sync\TeX}field size to store the{\sl Sync\TeX}information: \
2 integers for file tag and line}
#define sync_tag(#) ==mem[#-synctex_field_size].int{The tag subfield}
#define sync_line(#) ==mem[#-synctex_field_size+1].int{The line subfield} \

#define hlist_node = 0{|type|of hlist nodes}
#define box_node_size = 7+synctex_field_size{number of words to allocate for a box node}
#define width_offset = 1{position of|width|field in a box node}
#define depth_offset = 2{position of|depth|field in a box node}
#define height_offset = 3{position of|height|field in a box node}
#define width(#) ==mem[#+width_offset].sc{width of the box,in sp}
#define depth(#) ==mem[#+depth_offset].sc{depth of the box,in sp}
#define height(#) ==mem[#+height_offset].sc{height of the box,in sp}
#define shift_amount(#) ==mem[#+4].sc{repositioning distance,in sp}
#define list_offset = 5{position of|list_ptr|field in a box node}
#define list_ptr(#) ==link(#+list_offset) {beginning of the list inside the box}
#define glue_order(#) ==subtype(#+list_offset) {applicable order of infinity}
#define glue_sign(#) ==type(#+list_offset) {stretching or shrinking}
#define normal = 0{the most common case when several cases are named}
#define stretching = 1{glue setting applies to the stretch components}
#define shrinking = 2{glue setting applies to the shrink components}
#define glue_offset = 6{position of|glue_set|in a box node}
#define glue_set(#) ==mem[#+glue_offset].gr \
{a word of type|glue_ratio|for glue setting} \

#define vlist_node = 1{|type|of vlist nodes} \

#define rule_node = 2{|type|of rule nodes}
#define rule_node_size = 4+synctex_field_size{number of words to allocate for a rule node}
#define null_flag ==-49
#define is_running(#) ==(#= null_flag) {tests for a running dimension} \

#define ins_node = 3{|type|of insertion nodes}
#define ins_node_size = 5{number of words to allocate for an insertion}
#define float_cost(#) ==mem[#+1].int{the|floating_penalty|to be used}
#define ins_ptr(#) ==info(#+4) {the vertical list to be inserted}
#define split_top_ptr(#) ==link(#+4) {the|split_top_skip|to be used} \

#define mark_node = 4{|type|of a mark node}
#define small_node_size = 2{number of words to allocate for most node types}
#define medium_node_size = small_node_size+synctex_field_size{number of words to \
allocate for synchronized node types like math,kern,glue and penalty nodes}
#define mark_ptr(#) ==link(#+1) {head of the token list for a mark}
#define mark_class(#) ==info(#+1) {the mark class} \

#define adjust_node = 5{|type|of an adjust node}
#define adjust_pre ==subtype{<> 0= > pre-adjustment} \
{|append_list|is used to append a list to|tail|}
#define append_list(#) ==begin link(tail) := link(#) ;append_list_end
#define append_list_end(#) ==tail:= #;end \

#define adjust_ptr(#) ==mem[#+1].int \
{vertical list to be moved out of horizontal list} \

#define ligature_node = 6{|type|of a ligature node}
#define lig_char(#) ==#+1{the word where the ligature is to be found}
#define lig_ptr(#) ==link(lig_char(#) ) {the list of characters} \

#define disc_node = 7{|type|of a discretionary node}
#define replace_count ==subtype{how many subsequent nodes to replace}
#define pre_break ==llink{text that precedes a discretionary break}
#define post_break ==rlink{text that follows a discretionary break} \

#define whatsit_node = 8{|type|of special extension nodes} \

#define math_node = 9{|type|of a math node}
#define before = 0{|subtype|for math node that introduces a formula}
#define after = 1{|subtype|for math node that winds up a formula} \

#define M_code = 2
#define begin_M_code = M_code+before{|subtype|for\.{\\beginM}node}
#define end_M_code = M_code+after{|subtype|for\.{\\endM}node}
#define L_code = 4
#define begin_L_code = L_code+begin_M_code{|subtype|for\.{\\beginL}node}
#define end_L_code = L_code+end_M_code{|subtype|for\.{\\endL}node}
#define R_code = L_code+L_code
#define begin_R_code = R_code+begin_M_code{|subtype|for\.{\\beginR}node}
#define end_R_code = R_code+end_M_code{|subtype|for\.{\\endR}node} \

#define end_LR(#) ==odd(subtype(#) ) 
#define end_LR_type(#) ==(L_code*(subtype(#) div L_code) +end_M_code) 
#define begin_LR_type(#) ==(#-after+before)  \

#define precedes_break(#) ==(type(#) <math_node) 
#define non_discardable(#) ==(type(#) <math_node)  \

#define glue_node = 10{|type|of node that points to a glue specification}
#define cond_math_glue = 98{special|subtype|to suppress glue in the next node}
#define mu_glue = 99{|subtype|for math glue}
#define a_leaders = 100{|subtype|for aligned leaders}
#define c_leaders = 101{|subtype|for centered leaders}
#define x_leaders = 102{|subtype|for expanded leaders}
#define glue_ptr ==llink{pointer to a glue specification}
#define leader_ptr ==rlink{pointer to box or rule node for leaders} \

#define glue_spec_size = 4{number of words to allocate for a glue specification}
#define glue_ref_count(#) ==link(#) {reference count of a glue specification}
#define stretch(#) ==mem[#+2].sc{the stretchability of this glob of glue}
#define shrink(#) ==mem[#+3].sc{the shrinkability of this glob of glue}
#define stretch_order ==type{order of infinity for stretching}
#define shrink_order ==subtype{order of infinity for shrinking}
#define fil = 1{first-order infinity}
#define fill = 2{second-order infinity}
#define filll = 3{third-order infinity} \

#define kern_node = 11{|type|of a kern node}
#define explicit = 1{|subtype|of kern nodes from\.{\\kern}and\.{\\/}}
#define acc_kern = 2{|subtype|of kern nodes from accents}
#define auto_kern = 3{|subtype|of kern nodes created by|get_auto_kern|} \
 \
{memory structure for marginal kerns}
#define margin_kern_node = 40
#define margin_kern_node_size = 3
#define margin_char(#) ==info(#+2)  \
 \
{|subtype|of marginal kerns}
#define left_side ==0
#define right_side ==1 \
 \
{base for lp/rp/ef codes starts from 2: \
0 for|hyphen_char|, \
1 for|skew_char|}
#define lp_code_base ==2
#define rp_code_base ==3
#define ef_code_base ==4
#define tag_code ==5
#define kn_bs_code_base ==7
#define st_bs_code_base ==8
#define sh_bs_code_base ==9
#define kn_bc_code_base ==10
#define kn_ac_code_base ==11 \
 \

#define no_lig_code ==6 \

#define max_hlist_stack = 512{maximum fill level for|hlist_stack|} \
{maybe good if larger than|2*max_quarterword|,so that box nesting level would overflow first} \

#define penalty_node = 12{|type|of a penalty node}
#define inf_penalty = inf_bad{``infinite''penalty value}
#define eject_penalty = -inf_penalty{``negatively infinite''penalty value}
#define penalty(#) ==mem[#+1].int{the added cost of breaking a list here} \

#define unset_node = 13{|type|for an unset node}
#define glue_stretch(#) ==mem[#+glue_offset].sc{total stretch in an unset node}
#define glue_shrink ==shift_amount{total shrink in an unset node}
#define span_count ==subtype{indicates the number of spanned columns} \

#define zero_glue ==mem_bot{specification for\.{0 pt plus 0 pt minus 0 pt}}
#define fil_glue ==zero_glue+glue_spec_size{\.{0 pt plus 1f il minus 0 pt}}
#define fill_glue ==fil_glue+glue_spec_size{\.{0 pt plus 1f ill minus 0 pt}}
#define ss_glue ==fill_glue+glue_spec_size{\.{0 pt plus 1f il minus 1f il}}
#define fil_neg_glue ==ss_glue+glue_spec_size{\.{0 pt plus-1f il minus 0 pt}}
#define lo_mem_stat_max ==fil_neg_glue+glue_spec_size-1{largest statically \
allocated word in the variable-size|mem|} \

#define page_ins_head ==mem_top{list of insertion data for current page}
#define contrib_head ==mem_top-1{vlist of items not yet on current page}
#define page_head ==mem_top-2{vlist for current page}
#define temp_head ==mem_top-3{head of a temporary list of some kind}
#define hold_head ==mem_top-4{head of a temporary list of another kind}
#define adjust_head ==mem_top-5{head of adjustment list returned by|hpack|}
#define active ==mem_top-7{head of active list in|line_break|,needs two words}
#define align_head ==mem_top-8{head of preamble list for alignments}
#define end_span ==mem_top-9{tail of spanned-width lists}
#define omit_template ==mem_top-10{a constant token list}
#define null_list ==mem_top-11{permanently empty list}
#define lig_trick ==mem_top-12{a ligature masquerading as a|char_node|}
#define garbage ==mem_top-12{used for scrap information}
#define backup_head ==mem_top-13{head of token list built by|scan_keyword|}
#define pre_adjust_head ==mem_top-14{head of pre-adjustment list returned by|hpack|}
#define hi_mem_stat_min ==mem_top-14{smallest statically allocated word in \
the one-word|mem|}
#define hi_mem_stat_usage = 15{the number of one-word nodes always present} \

#define free ==free_arr \

#define node_list_display(#) == \
begin append_char(".") ;show_node_list(#) ;flush_char; \
end{|str_room|need not be checked;see|show_box|below} \

#define token_ref_count(#) ==info(#) {reference count preceding a token list} \

#define fast_delete_glue_ref(#) == \
begin if glue_ref_count(#) = null then free_node(#,glue_spec_size)  \
else decr(glue_ref_count(#) ) ; \
end \

#define add_token_ref(#) ==incr(token_ref_count(#) ) {new reference to a token list}
#define add_glue_ref(#) ==incr(glue_ref_count(#) ) {new reference to a glue spec} \

#define escape = 0{escape delimiter(called\.\\in{\sl The\TeX book\/}) } \

#define relax = 0{do nothing(\.{\\relax}) }
#define left_brace = 1{beginning of a group(\.\{) }
#define right_brace = 2{ending of a group(\.\}) }
#define math_shift = 3{mathematics shift character(\.\$) }
#define tab_mark = 4{alignment delimiter(\.\&,\.{\\span}) }
#define car_ret = 5{end of line(|carriage_return|,\.{\\cr},\.{\\crcr}) }
#define out_param = 5{output a macro parameter}
#define mac_param = 6{macro parameter symbol(\.\#) }
#define sup_mark = 7{superscript(\.{\char'136} )}
#define sub_mark = 8{subscript(\.{\char'137} )}
#define ignore = 9{characters to ignore(\.{\^\^@}) }
#define endv = 9{end of\<v_j> list in alignment template}
#define spacer = 10{characters equivalent to blank space(\.{\}) }
#define letter = 11{characters regarded as letters(\.{A..Z},\.{a..z}) }
#define other_char = 12{none of the special character types}
#define active_char = 13{characters that invoke macros(\.{\char`\~}) }
#define par_end = 13{end of paragraph(\.{\\par}) }
#define match = 13{match a macro parameter}
#define comment = 14{characters that introduce comments(\.\%) }
#define end_match = 14{end of parameters to macro}
#define stop = 14{end of job(\.{\\end},\.{\\dump}) }
#define invalid_char = 15{characters that shouldn't appear ( \.{\^\^?} )}
#define delim_num = 15{specify delimiter numerically(\.{\\delimiter}) }
#define max_char_code = 15{largest catcode for individual characters} \

#define char_num = 16{character specified numerically(\.{\\char}) }
#define math_char_num = 17{explicit math code(\.{\\mathchar}) }
#define mark = 18{mark definition(\.{\\mark}) }
#define xray = 19{peek inside of\TeX\(\.{\\show},\.{\\showbox},etc.~) }
#define make_box = 20{make a box(\.{\\box},\.{\\copy},\.{\\hbox},etc.~) }
#define hmove = 21{horizontal motion(\.{\\moveleft},\.{\\moveright}) }
#define vmove = 22{vertical motion(\.{\\raise},\.{\\lower}) }
#define un_hbox = 23{unglue a box(\.{\\unhbox},\.{\\unhcopy}) }
#define un_vbox = 24{unglue a box(\.{\\unvbox},\.{\\unvcopy}) } \
{(or\.{\\pagediscards},\.{\\splitdiscards}) }
#define remove_item = 25{nullify last item(\.{\\unpenalty}, \
\.{\\unkern},\.{\\unskip}) }
#define hskip = 26{horizontal glue(\.{\\hskip},\.{\\hfil},etc.~) }
#define vskip = 27{vertical glue(\.{\\vskip},\.{\\vfil},etc.~) }
#define mskip = 28{math glue(\.{\\mskip}) }
#define kern = 29{fixed space(\.{\\kern}) }
#define mkern = 30{math kern(\.{\\mkern}) }
#define leader_ship = 31{use a box(\.{\\shipout},\.{\\leaders},etc.~) }
#define halign = 32{horizontal table alignment(\.{\\halign}) }
#define valign = 33{vertical table alignment(\.{\\valign}) } \
{or text direction directives(\.{\\beginL},etc.~) }
#define no_align = 34{temporary escape from alignment(\.{\\noalign}) }
#define vrule = 35{vertical rule(\.{\\vrule}) }
#define hrule = 36{horizontal rule(\.{\\hrule}) }
#define insert = 37{vlist inserted in box(\.{\\insert}) }
#define vadjust = 38{vlist inserted in enclosing paragraph(\.{\\vadjust}) }
#define ignore_spaces = 39{gobble|spacer|tokens(\.{\\ignorespaces}) }
#define after_assignment = 40{save till assignment is done(\.{\\afterassignment}) }
#define after_group = 41{save till group is done(\.{\\aftergroup}) }
#define break_penalty = 42{additional badness(\.{\\penalty}) }
#define start_par = 43{begin paragraph(\.{\\indent},\.{\\noindent}) }
#define ital_corr = 44{italic correction(\.{\\/}) }
#define accent = 45{attach accent in text(\.{\\accent}) }
#define math_accent = 46{attach accent in math(\.{\\mathaccent}) }
#define discretionary = 47{discretionary texts(\.{\\-},\.{\\discretionary}) }
#define eq_no = 48{equation number(\.{\\eqno},\.{\\leqno}) }
#define left_right = 49{variable delimiter(\.{\\left},\.{\\right}) } \
{(or\.{\\middle}) }
#define math_comp = 50{component of formula(\.{\\mathbin},etc.~) }
#define limit_switch = 51{diddle limit conventions(\.{\\displaylimits},etc.~) }
#define above = 52{generalized fraction(\.{\\above},\.{\\atop},etc.~) }
#define math_style = 53{style specification(\.{\\displaystyle},etc.~) }
#define math_choice = 54{choice specification(\.{\\mathchoice}) }
#define non_script = 55{conditional math glue(\.{\\nonscript}) }
#define vcenter = 56{vertically center a vbox(\.{\\vcenter}) }
#define case_shift = 57{force specific case(\.{\\lowercase},\.{\\uppercase}~) }
#define message = 58{send to user(\.{\\message},\.{\\errmessage}) }
#define extension = 59{extensions to\TeX\(\.{\\write},\.{\\special},etc.~) }
#define in_stream = 60{files for reading(\.{\\openin},\.{\\closein}) }
#define begin_group = 61{begin local grouping(\.{\\begingroup}) }
#define end_group = 62{end local grouping(\.{\\endgroup}) }
#define omit = 63{omit alignment template(\.{\\omit}) }
#define ex_space = 64{explicit space(\.{\\\}) }
#define no_boundary = 65{suppress boundary ligatures(\.{\\noboundary}) }
#define radical = 66{square root and similar signs(\.{\\radical}) }
#define end_cs_name = 67{end control sequence(\.{\\endcsname}) }
#define min_internal = 68{the smallest code that can follow\.{\\the}}
#define char_given = 68{character code defined by\.{\\chardef}}
#define math_given = 69{math code defined by\.{\\mathchardef}}
#define last_item = 70{most recent item(\.{\\lastpenalty}, \
\.{\\lastkern},\.{\\lastskip}) }
#define max_non_prefixed_command = 70{largest command code that can't be \.{\\global}} \

#define toks_register = 71{token list register(\.{\\toks}) }
#define assign_toks = 72{special token list(\.{\\output},\.{\\everypar},etc.~) }
#define assign_int = 73{user-defined integer(\.{\\tolerance},\.{\\day},etc.~) }
#define assign_dimen = 74{user-defined length(\.{\\hsize},etc.~) }
#define assign_glue = 75{user-defined glue(\.{\\baselineskip},etc.~) }
#define assign_mu_glue = 76{user-defined muglue(\.{\\thinmuskip},etc.~) }
#define assign_font_dimen = 77{user-defined font dimension(\.{\\fontdimen}) }
#define assign_font_int = 78{user-defined font integer(\.{\\hyphenchar}, \
\.{\\skewchar}) }
#define set_aux = 79{specify state info(\.{\\spacefactor},\.{\\prevdepth}) }
#define set_prev_graf = 80{specify state info(\.{\\prevgraf}) }
#define set_page_dimen = 81{specify state info(\.{\\pagegoal},etc.~) }
#define set_page_int = 82{specify state info(\.{\\deadcycles}, \
\.{\\insertpenalties}) } \
{(or\.{\\interactionmode}) }
#define set_box_dimen = 83{change dimension of box(\.{\\wd},\.{\\ht},\.{\\dp}) }
#define set_shape = 84{specify fancy paragraph shape(\.{\\parshape}) } \
{(or\.{\\interlinepenalties},etc.~) }
#define def_code = 85{define a character code(\.{\\catcode},etc.~) }
#define def_family = 86{declare math fonts(\.{\\textfont},etc.~) }
#define set_font = 87{set current font(font identifiers) }
#define def_font = 88{define a font file(\.{\\font}) }
#define register = 89{internal register(\.{\\count},\.{\\dimen},etc.~) }
#define max_internal = 89{the largest code that can follow\.{\\the}}
#define advance = 90{advance a register or parameter(\.{\\advance}) }
#define multiply = 91{multiply a register or parameter(\.{\\multiply}) }
#define divide = 92{divide a register or parameter(\.{\\divide}) }
#define prefix = 93{qualify a definition(\.{\\global},\.{\\long},\.{\\outer}) } \
{(or\.{\\protected}) }
#define let = 94{assign a command code(\.{\\let},\.{\\futurelet}) }
#define shorthand_def = 95{code definition(\.{\\chardef},\.{\\countdef},etc.~) } \
{or\.{\\charsubdef}}
#define read_to_cs = 96{read into a control sequence(\.{\\read}) } \
{(or\.{\\readline}) }
#define def = 97{macro definition(\.{\\def},\.{\\gdef},\.{\\xdef},\.{\\edef}) }
#define set_box = 98{set a box(\.{\\setbox}) }
#define hyph_data = 99{hyphenation data(\.{\\hyphenation},\.{\\patterns}) }
#define set_interaction = 100{define level of interaction(\.{\\batchmode},etc.~) }
#define letterspace_font = 101{letterspace a font(\.{\\letterspacefont}) }
#define pdf_copy_font = 102{create a new font instance(\.{\\pdfcopyfont}) }
#define max_command = 102{the largest command code seen at|big_switch|} \

#define undefined_cs = max_command+1{initial state of most|eq_type|fields}
#define expand_after = max_command+2{special expansion(\.{\\expandafter}) }
#define no_expand = max_command+3{special nonexpansion(\.{\\noexpand}) }
#define input = max_command+4{input a source file(\.{\\input},\.{\\endinput}) } \
{(or\.{\\scantokens}) }
#define if_test = max_command+5{conditional text(\.{\\if},\.{\\ifcase},etc.~) }
#define fi_or_else = max_command+6{delimiters for conditionals(\.{\\else},etc.~) }
#define cs_name = max_command+7{make a control sequence from tokens(\.{\\csname}) }
#define convert = max_command+8{convert to text(\.{\\number},\.{\\string},etc.~) }
#define the = max_command+9{expand an internal quantity(\.{\\the}) } \
{(or\.{\\unexpanded},\.{\\detokenize}) }
#define top_bot_mark = max_command+10{inserted mark(\.{\\topmark},etc.~) }
#define call = max_command+11{non-long,non-outer control sequence}
#define long_call = max_command+12{long,non-outer control sequence}
#define outer_call = max_command+13{non-long,outer control sequence}
#define long_outer_call = max_command+14{long,outer control sequence}
#define end_template = max_command+15{end of an alignment template}
#define dont_expand = max_command+16{the following token was marked by\.{\\noexpand}}
#define glue_ref = max_command+17{the equivalent points to a glue specification}
#define shape_ref = max_command+18{the equivalent points to a parshape specification}
#define box_ref = max_command+19{the equivalent points to a box node,or is|null|}
#define data = max_command+20{the equivalent is simply a halfword number} \

#define vmode = 1{vertical mode}
#define hmode = vmode+max_command+1{horizontal mode}
#define mmode = hmode+max_command+1{math mode} \

#define ignore_depth ==-65536000{magic dimension value to mean`ignore me'} \

#define mode ==cur_list.mode_field{current mode}
#define head ==cur_list.head_field{header node of current list}
#define tail ==cur_list.tail_field{final node on current list}
#define eTeX_aux ==cur_list.eTeX_aux_field{auxiliary data for\eTeX}
#define LR_save ==eTeX_aux{LR stack when a paragraph is interrupted}
#define LR_box ==eTeX_aux{prototype box for display}
#define delim_ptr ==eTeX_aux{most recent left or right noad of a math left group}
#define prev_graf ==cur_list.pg_field{number of paragraph lines accumulated}
#define aux ==cur_list.aux_field{auxiliary data about the current list}
#define prev_depth ==aux.sc{the name of|aux|in vertical mode}
#define space_factor ==aux.hh.lh{part of|aux|in horizontal mode}
#define clang ==aux.hh.rh{the other part of|aux|in horizontal mode}
#define incompleat_noad ==aux.int{the name of|aux|in math mode}
#define mode_line ==cur_list.ml_field{source file line number at beginning of list} \

#define tail_append(#) ==begin link(tail) := #;tail:= link(tail) ; \
end \

#define eq_level_field(#) ==#.hh.b1
#define eq_type_field(#) ==#.hh.b0
#define equiv_field(#) ==#.hh.rh
#define eq_level(#) ==eq_level_field(eqtb[#]) {level of definition}
#define eq_type(#) ==eq_type_field(eqtb[#]) {command code for equivalent}
#define equiv(#) ==equiv_field(eqtb[#]) {equivalent value}
#define level_zero = min_quarterword{level for undefined quantities}
#define level_one = level_zero+1{outermost level for defined quantities} \

#define active_base = 1{beginning of region 1,for active character equivalents}
#define single_base = active_base+256{equivalents of one-character control sequences}
#define null_cs = single_base+256{equivalent of\.{\\csname\\endcsname}}
#define hash_base = null_cs+1{beginning of region 2,for the hash table}
#define frozen_control_sequence = hash_base+hash_size{for error recovery}
#define frozen_protection = frozen_control_sequence{inaccessible but definable}
#define frozen_cr = frozen_control_sequence+1{permanent`\.{\\cr}'}
#define frozen_end_group = frozen_control_sequence+2{permanent`\.{\\endgroup}'}
#define frozen_right = frozen_control_sequence+3{permanent`\.{\\right}'}
#define frozen_fi = frozen_control_sequence+4{permanent`\.{\\fi}'}
#define frozen_end_template = frozen_control_sequence+5{permanent`\.{\\endtemplate}'}
#define frozen_endv = frozen_control_sequence+6{second permanent`\.{\\endtemplate}'}
#define frozen_relax = frozen_control_sequence+7{permanent`\.{\\relax}'}
#define end_write = frozen_control_sequence+8{permanent`\.{\\endwrite}'}
#define frozen_dont_expand = frozen_control_sequence+9 \
{permanent`\.{\\notexpanded:}'}
#define prim_size = 2100{maximum number of primitives}
#define frozen_special = frozen_control_sequence+10 \
{permanent`\.{\\special}'}
#define frozen_null_font = frozen_control_sequence+12+prim_size \
{permanent`\.{\\nullfont}'}
#define frozen_primitive = frozen_control_sequence+11 \
{permanent`\.{\\pdfprimitive}'}
#define prim_eqtb_base = frozen_primitive+1
#define font_id_base = frozen_null_font-font_base \
{begins table of 257 permanent font identifiers}
#define undefined_control_sequence = frozen_null_font+max_font_max+1{dummy location}
#define glue_base = undefined_control_sequence+1{beginning of region 3} \

#define line_skip_code = 0{interline glue if|baseline_skip|is infeasible}
#define baseline_skip_code = 1{desired glue between baselines}
#define par_skip_code = 2{extra glue just above a paragraph}
#define above_display_skip_code = 3{extra glue just above displayed math}
#define below_display_skip_code = 4{extra glue just below displayed math}
#define above_display_short_skip_code = 5 \
{glue above displayed math following short lines}
#define below_display_short_skip_code = 6 \
{glue below displayed math following short lines}
#define left_skip_code = 7{glue at left of justified lines}
#define right_skip_code = 8{glue at right of justified lines}
#define top_skip_code = 9{glue at top of main pages}
#define split_top_skip_code = 10{glue at top of split pages}
#define tab_skip_code = 11{glue between aligned entries}
#define space_skip_code = 12{glue between words(if not|zero_glue|) }
#define xspace_skip_code = 13{glue after sentences(if not|zero_glue|) }
#define par_fill_skip_code = 14{glue on last line of paragraph}
#define thin_mu_skip_code = 15{thin space in math formula}
#define med_mu_skip_code = 16{medium space in math formula}
#define thick_mu_skip_code = 17{thick space in math formula}
#define glue_pars = 18{total number of glue parameters}
#define skip_base = glue_base+glue_pars{table of 256``skip''registers}
#define mu_skip_base = skip_base+256{table of 256``muskip''registers}
#define local_base = mu_skip_base+256{beginning of region 4} \

#define skip(#) ==equiv(skip_base+#) {|mem|location of glue specification}
#define mu_skip(#) ==equiv(mu_skip_base+#) {|mem|location of math glue spec}
#define glue_par(#) ==equiv(glue_base+#) {|mem|location of glue specification}
#define line_skip ==glue_par(line_skip_code) 
#define baseline_skip ==glue_par(baseline_skip_code) 
#define par_skip ==glue_par(par_skip_code) 
#define above_display_skip ==glue_par(above_display_skip_code) 
#define below_display_skip ==glue_par(below_display_skip_code) 
#define above_display_short_skip ==glue_par(above_display_short_skip_code) 
#define below_display_short_skip ==glue_par(below_display_short_skip_code) 
#define left_skip ==glue_par(left_skip_code) 
#define right_skip ==glue_par(right_skip_code) 
#define top_skip ==glue_par(top_skip_code) 
#define split_top_skip ==glue_par(split_top_skip_code) 
#define tab_skip ==glue_par(tab_skip_code) 
#define space_skip ==glue_par(space_skip_code) 
#define xspace_skip ==glue_par(xspace_skip_code) 
#define par_fill_skip ==glue_par(par_fill_skip_code) 
#define thin_mu_skip ==glue_par(thin_mu_skip_code) 
#define med_mu_skip ==glue_par(med_mu_skip_code) 
#define thick_mu_skip ==glue_par(thick_mu_skip_code)  \

#define par_shape_loc = local_base{specifies paragraph shape}
#define output_routine_loc = local_base+1{points to token list for\.{\\output}}
#define every_par_loc = local_base+2{points to token list for\.{\\everypar}}
#define every_math_loc = local_base+3{points to token list for\.{\\everymath}}
#define every_display_loc = local_base+4{points to token list for\.{\\everydisplay}}
#define every_hbox_loc = local_base+5{points to token list for\.{\\everyhbox}}
#define every_vbox_loc = local_base+6{points to token list for\.{\\everyvbox}}
#define every_job_loc = local_base+7{points to token list for\.{\\everyjob}}
#define every_cr_loc = local_base+8{points to token list for\.{\\everycr}}
#define err_help_loc = local_base+9{points to token list for\.{\\errhelp}}
#define tex_toks = local_base+10{end of\TeX's token list parameters} \

#define pdftex_first_loc = tex_toks{base for\pdfTeX's token list parameters}
#define pdf_pages_attr_loc = pdftex_first_loc+0{points to token list for\.{\\pdfpagesattr}}
#define pdf_page_attr_loc = pdftex_first_loc+1{points to token list for\.{\\pdfpageattr}}
#define pdf_page_resources_loc = pdftex_first_loc+2{points to token list for\.{\\pdfpageresources}}
#define pdf_pk_mode_loc = pdftex_first_loc+3{points to token list for\.{\\pdfpkmode}}
#define pdf_toks = pdftex_first_loc+4{end of\pdfTeX's token list parameters} \

#define etex_toks_base = pdf_toks{base for\eTeX's token list parameters}
#define every_eof_loc = etex_toks_base{points to token list for\.{\\everyeof}}
#define etex_toks = etex_toks_base+1{end of\eTeX's token list parameters} \

#define toks_base = etex_toks{table of 256 token list registers} \

#define etex_pen_base = toks_base+256{start of table of\eTeX's penalties}
#define inter_line_penalties_loc = etex_pen_base{additional penalties between lines}
#define club_penalties_loc = etex_pen_base+1{penalties for creating club lines}
#define widow_penalties_loc = etex_pen_base+2{penalties for creating widow lines}
#define display_widow_penalties_loc = etex_pen_base+3{ditto,just before a display}
#define etex_pens = etex_pen_base+4{end of table of\eTeX's penalties} \

#define box_base = etex_pens{table of 256 box registers}
#define cur_font_loc = box_base+256{internal font number outside math mode}
#define xord_code_base = cur_font_loc+1
#define xchr_code_base = xord_code_base+1
#define xprn_code_base = xchr_code_base+1
#define math_font_base = xprn_code_base+1
#define cat_code_base = math_font_base+48 \
{table of 256 command codes(the``catcodes'') }
#define lc_code_base = cat_code_base+256{table of 256 lowercase mappings}
#define uc_code_base = lc_code_base+256{table of 256 uppercase mappings}
#define sf_code_base = uc_code_base+256{table of 256 spacefactor mappings}
#define math_code_base = sf_code_base+256{table of 256 math mode mappings}
#define char_sub_code_base = math_code_base+256{table of character substitutions}
#define int_base = char_sub_code_base+256{beginning of region 5} \

#define par_shape_ptr ==equiv(par_shape_loc) 
#define output_routine ==equiv(output_routine_loc) 
#define every_par ==equiv(every_par_loc) 
#define every_math ==equiv(every_math_loc) 
#define every_display ==equiv(every_display_loc) 
#define every_hbox ==equiv(every_hbox_loc) 
#define every_vbox ==equiv(every_vbox_loc) 
#define every_job ==equiv(every_job_loc) 
#define every_cr ==equiv(every_cr_loc) 
#define err_help ==equiv(err_help_loc) 
#define pdf_pages_attr ==equiv(pdf_pages_attr_loc) 
#define pdf_page_attr ==equiv(pdf_page_attr_loc) 
#define pdf_page_resources ==equiv(pdf_page_resources_loc) 
#define pdf_pk_mode ==equiv(pdf_pk_mode_loc) 
#define toks(#) ==equiv(toks_base+#) 
#define box(#) ==equiv(box_base+#) 
#define cur_font ==equiv(cur_font_loc) 
#define fam_fnt(#) ==equiv(math_font_base+#) 
#define cat_code(#) ==equiv(cat_code_base+#) 
#define lc_code(#) ==equiv(lc_code_base+#) 
#define uc_code(#) ==equiv(uc_code_base+#) 
#define sf_code(#) ==equiv(sf_code_base+#) 
#define math_code(#) ==equiv(math_code_base+#)  \
{Note:|math_code(c) |is the true math code plus|min_halfword|}
#define char_sub_code(#) ==equiv(char_sub_code_base+#)  \
{Note:|char_sub_code(c) |is the true substitution info plus|min_halfword|} \

#define null_font ==font_base
#define var_code ==55'} \

#define pretolerance_code = 0{badness tolerance before hyphenation}
#define tolerance_code = 1{badness tolerance after hyphenation}
#define line_penalty_code = 2{added to the badness of every line}
#define hyphen_penalty_code = 3{penalty for break after discretionary hyphen}
#define ex_hyphen_penalty_code = 4{penalty for break after explicit hyphen}
#define club_penalty_code = 5{penalty for creating a club line}
#define widow_penalty_code = 6{penalty for creating a widow line}
#define display_widow_penalty_code = 7{ditto,just before a display}
#define broken_penalty_code = 8{penalty for breaking a page at a broken line}
#define bin_op_penalty_code = 9{penalty for breaking after a binary operation}
#define rel_penalty_code = 10{penalty for breaking after a relation}
#define pre_display_penalty_code = 11 \
{penalty for breaking just before a displayed formula}
#define post_display_penalty_code = 12 \
{penalty for breaking just after a displayed formula}
#define inter_line_penalty_code = 13{additional penalty between lines}
#define double_hyphen_demerits_code = 14{demerits for double hyphen break}
#define final_hyphen_demerits_code = 15{demerits for final hyphen break}
#define adj_demerits_code = 16{demerits for adjacent incompatible lines}
#define mag_code = 17{magnification ratio}
#define delimiter_factor_code = 18{ratio for variable-size delimiters}
#define looseness_code = 19{change in number of lines for a paragraph}
#define time_code = 20{current time of day}
#define day_code = 21{current day of the month}
#define month_code = 22{current month of the year}
#define year_code = 23{current year of our Lord}
#define show_box_breadth_code = 24{nodes per level in|show_box|}
#define show_box_depth_code = 25{maximum level in|show_box|}
#define hbadness_code = 26{hboxes exceeding this badness will be shown by|hpack|}
#define vbadness_code = 27{vboxes exceeding this badness will be shown by|vpack|}
#define pausing_code = 28{pause after each line is read from a file}
#define tracing_online_code = 29{show diagnostic output on terminal}
#define tracing_macros_code = 30{show macros as they are being expanded}
#define tracing_stats_code = 31{show memory usage if\TeX\knows it}
#define tracing_paragraphs_code = 32{show line-break calculations}
#define tracing_pages_code = 33{show page-break calculations}
#define tracing_output_code = 34{show boxes when they are shipped out}
#define tracing_lost_chars_code = 35{show characters that aren't in the font}
#define tracing_commands_code = 36{show command codes at|big_switch|}
#define tracing_restores_code = 37{show equivalents when they are restored}
#define uc_hyph_code = 38{hyphenate words beginning with a capital letter}
#define output_penalty_code = 39{penalty found at current page break}
#define max_dead_cycles_code = 40{bound on consecutive dead cycles of output}
#define hang_after_code = 41{hanging indentation changes after this many lines}
#define floating_penalty_code = 42{penalty for insertions heldover after a split}
#define global_defs_code = 43{override\.{\\global}specifications}
#define cur_fam_code = 44{current family}
#define escape_char_code = 45{escape character for token output}
#define default_hyphen_char_code = 46{value of\.{\\hyphenchar}when a font is loaded}
#define default_skew_char_code = 47{value of\.{\\skewchar}when a font is loaded}
#define end_line_char_code = 48{character placed at the right end of the buffer}
#define new_line_char_code = 49{character that prints as|print_ln|}
#define language_code = 50{current hyphenation table}
#define left_hyphen_min_code = 51{minimum left hyphenation fragment size}
#define right_hyphen_min_code = 52{minimum right hyphenation fragment size}
#define holding_inserts_code = 53{do not remove insertion nodes from\.{\\box255}}
#define error_context_lines_code = 54{maximum intermediate line pairs shown}
#define tex_int_pars = 55{total number of\TeX's integer parameters} \

#define web2c_int_base = tex_int_pars{base for web2c's integer parameters}
#define char_sub_def_min_code = web2c_int_base{smallest value in the charsubdef list}
#define char_sub_def_max_code = web2c_int_base+1{largest value in the charsubdef list}
#define tracing_char_sub_def_code = web2c_int_base+2{traces changes to a charsubdef def}
#define mubyte_in_code = web2c_int_base+3{if positive then reading mubytes is active}
#define mubyte_out_code = web2c_int_base+4{if positive then printing mubytes is active}
#define mubyte_log_code = web2c_int_base+5{if positive then print mubytes to log and terminal}
#define spec_out_code = web2c_int_base+6{if positive then print specials by mubytes}
#define web2c_int_pars = web2c_int_base+7{total number of web2c's integer parameters} \

#define pdftex_first_integer_code = web2c_int_pars{base for\pdfTeX's integer parameters}
#define pdf_output_code = pdftex_first_integer_code+0{switch on PDF output if positive}
#define pdf_compress_level_code = pdftex_first_integer_code+1{compress level of streams}
#define pdf_decimal_digits_code = pdftex_first_integer_code+2{digits after the decimal point of numbers}
#define pdf_move_chars_code = pdftex_first_integer_code+3{move chars 0. .31 to higher area if possible}
#define pdf_image_resolution_code = pdftex_first_integer_code+4{default image resolution}
#define pdf_pk_resolution_code = pdftex_first_integer_code+5{default resolution of PK font}
#define pdf_unique_resname_code = pdftex_first_integer_code+6{generate unique names for resouces}
#define pdf_option_always_use_pdfpagebox_code = pdftex_first_integer_code+7{if the PDF inclusion should always use a specific PDF page box}
#define pdf_option_pdf_inclusion_errorlevel_code = pdftex_first_integer_code+8{if the PDF inclusion should treat pdfs newer than|pdf_minor_version|as an error}
#define pdf_major_version_code = pdftex_first_integer_code+9{integer part of the PDF version produced}
#define pdf_minor_version_code = pdftex_first_integer_code+10{fractional part of the PDF version produced}
#define pdf_force_pagebox_code = pdftex_first_integer_code+11{if the PDF inclusion should always use a specific PDF page box}
#define pdf_pagebox_code = pdftex_first_integer_code+12{default pagebox to use for PDF inclusion}
#define pdf_inclusion_errorlevel_code = pdftex_first_integer_code+13{if the PDF inclusion should treat pdfs newer than|pdf_minor_version|as an error}
#define pdf_gamma_code = pdftex_first_integer_code+14
#define pdf_image_gamma_code = pdftex_first_integer_code+15
#define pdf_image_hicolor_code = pdftex_first_integer_code+16
#define pdf_image_apply_gamma_code = pdftex_first_integer_code+17
#define pdf_adjust_spacing_code = pdftex_first_integer_code+18{level of spacing adjusting}
#define pdf_protrude_chars_code = pdftex_first_integer_code+19{protrude chars at left/right edge of paragraphs}
#define pdf_tracing_fonts_code = pdftex_first_integer_code+20{level of font detail in log}
#define pdf_objcompresslevel_code = pdftex_first_integer_code+21{activate object streams}
#define pdf_adjust_interword_glue_code = pdftex_first_integer_code+22{adjust interword glue?}
#define pdf_prepend_kern_code = pdftex_first_integer_code+23{prepend kern before certain characters?}
#define pdf_append_kern_code = pdftex_first_integer_code+24{append kern before certain characters?}
#define pdf_gen_tounicode_code = pdftex_first_integer_code+25{generate ToUnicode for fonts?}
#define pdf_draftmode_code = pdftex_first_integer_code+26{switch on draftmode if positive}
#define pdf_inclusion_copy_font_code = pdftex_first_integer_code+27{generate ToUnicode for fonts?}
#define pdf_suppress_warning_dup_dest_code = pdftex_first_integer_code+28{suppress warning about duplicated destinations}
#define pdf_suppress_warning_dup_map_code = pdftex_first_integer_code+29{suppress warning about duplicated map lines}
#define pdf_suppress_warning_page_group_code = pdftex_first_integer_code+30{suppress warning about multiple pdfs with page group}
#define pdf_info_omit_date_code = pdftex_first_integer_code+31{omit generating CreationDate and ModDate}
#define pdf_suppress_ptex_info_code = pdftex_first_integer_code+32{suppress/PTEX.*entries in PDF dictionaries}
#define pdf_omit_charset_code = pdftex_first_integer_code+33{suppress/PTEX.*entries in PDF dictionaries}
#define pdf_int_pars = pdftex_first_integer_code+34{total number of\pdfTeX's integer parameters} \

#define etex_int_base = pdf_int_pars{base for\eTeX's integer parameters}
#define tracing_assigns_code = etex_int_base{show assignments}
#define tracing_groups_code = etex_int_base+1{show save/restore groups}
#define tracing_ifs_code = etex_int_base+2{show conditionals}
#define tracing_scan_tokens_code = etex_int_base+3{show pseudo file open and close}
#define tracing_nesting_code = etex_int_base+4{show incomplete groups and ifs within files}
#define pre_display_direction_code = etex_int_base+5{text direction preceding a display}
#define last_line_fit_code = etex_int_base+6{adjustment for last line of paragraph}
#define saving_vdiscards_code = etex_int_base+7{save items discarded from vlists}
#define saving_hyph_codes_code = etex_int_base+8{save hyphenation codes for languages}
#define eTeX_state_code = etex_int_base+9{\eTeX\state variables}
#define etex_int_pars = eTeX_state_code+eTeX_states{total number of\eTeX's integer parameters} \

#define synctex_code = etex_int_pars
#define int_pars = synctex_code+1{total number of integer parameters}
#define count_base = int_base+int_pars{256 user\.{\\count}registers}
#define del_code_base = count_base+256{256 delimiter code mappings}
#define dimen_base = del_code_base+256{beginning of region 6} \

#define del_code(#) ==eqtb[del_code_base+#].int
#define count(#) ==eqtb[count_base+#].int
#define int_par(#) ==eqtb[int_base+#].int{an integer parameter}
#define pretolerance ==int_par(pretolerance_code) 
#define tolerance ==int_par(tolerance_code) 
#define line_penalty ==int_par(line_penalty_code) 
#define hyphen_penalty ==int_par(hyphen_penalty_code) 
#define ex_hyphen_penalty ==int_par(ex_hyphen_penalty_code) 
#define club_penalty ==int_par(club_penalty_code) 
#define widow_penalty ==int_par(widow_penalty_code) 
#define display_widow_penalty ==int_par(display_widow_penalty_code) 
#define broken_penalty ==int_par(broken_penalty_code) 
#define bin_op_penalty ==int_par(bin_op_penalty_code) 
#define rel_penalty ==int_par(rel_penalty_code) 
#define pre_display_penalty ==int_par(pre_display_penalty_code) 
#define post_display_penalty ==int_par(post_display_penalty_code) 
#define inter_line_penalty ==int_par(inter_line_penalty_code) 
#define double_hyphen_demerits ==int_par(double_hyphen_demerits_code) 
#define final_hyphen_demerits ==int_par(final_hyphen_demerits_code) 
#define adj_demerits ==int_par(adj_demerits_code) 
#define mag ==int_par(mag_code) 
#define delimiter_factor ==int_par(delimiter_factor_code) 
#define looseness ==int_par(looseness_code) 
#define time ==int_par(time_code) 
#define day ==int_par(day_code) 
#define month ==int_par(month_code) 
#define year ==int_par(year_code) 
#define show_box_breadth ==int_par(show_box_breadth_code) 
#define show_box_depth ==int_par(show_box_depth_code) 
#define hbadness ==int_par(hbadness_code) 
#define vbadness ==int_par(vbadness_code) 
#define pausing ==int_par(pausing_code) 
#define tracing_online ==int_par(tracing_online_code) 
#define tracing_macros ==int_par(tracing_macros_code) 
#define tracing_stats ==int_par(tracing_stats_code) 
#define tracing_paragraphs ==int_par(tracing_paragraphs_code) 
#define tracing_pages ==int_par(tracing_pages_code) 
#define tracing_output ==int_par(tracing_output_code) 
#define tracing_lost_chars ==int_par(tracing_lost_chars_code) 
#define tracing_commands ==int_par(tracing_commands_code) 
#define tracing_restores ==int_par(tracing_restores_code) 
#define uc_hyph ==int_par(uc_hyph_code) 
#define output_penalty ==int_par(output_penalty_code) 
#define max_dead_cycles ==int_par(max_dead_cycles_code) 
#define hang_after ==int_par(hang_after_code) 
#define floating_penalty ==int_par(floating_penalty_code) 
#define global_defs ==int_par(global_defs_code) 
#define cur_fam ==int_par(cur_fam_code) 
#define escape_char ==int_par(escape_char_code) 
#define default_hyphen_char ==int_par(default_hyphen_char_code) 
#define default_skew_char ==int_par(default_skew_char_code) 
#define end_line_char ==int_par(end_line_char_code) 
#define new_line_char ==int_par(new_line_char_code) 
#define language ==int_par(language_code) 
#define left_hyphen_min ==int_par(left_hyphen_min_code) 
#define right_hyphen_min ==int_par(right_hyphen_min_code) 
#define holding_inserts ==int_par(holding_inserts_code) 
#define error_context_lines ==int_par(error_context_lines_code)  \

#define synctex ==int_par(synctex_code)  \

#define char_sub_def_min ==int_par(char_sub_def_min_code) 
#define char_sub_def_max ==int_par(char_sub_def_max_code) 
#define tracing_char_sub_def ==int_par(tracing_char_sub_def_code) 
#define mubyte_in ==int_par(mubyte_in_code) 
#define mubyte_out ==int_par(mubyte_out_code) 
#define mubyte_log ==int_par(mubyte_log_code) 
#define spec_out ==int_par(spec_out_code)  \

#define pdf_adjust_spacing ==int_par(pdf_adjust_spacing_code) 
#define pdf_protrude_chars ==int_par(pdf_protrude_chars_code) 
#define pdf_tracing_fonts ==int_par(pdf_tracing_fonts_code) 
#define pdf_adjust_interword_glue ==int_par(pdf_adjust_interword_glue_code) 
#define pdf_prepend_kern ==int_par(pdf_prepend_kern_code) 
#define pdf_append_kern ==int_par(pdf_append_kern_code) 
#define pdf_gen_tounicode ==int_par(pdf_gen_tounicode_code) 
#define pdf_output ==int_par(pdf_output_code) 
#define pdf_compress_level ==int_par(pdf_compress_level_code) 
#define pdf_objcompresslevel ==int_par(pdf_objcompresslevel_code) 
#define pdf_decimal_digits ==int_par(pdf_decimal_digits_code) 
#define pdf_move_chars ==int_par(pdf_move_chars_code) 
#define pdf_image_resolution ==int_par(pdf_image_resolution_code) 
#define pdf_pk_resolution ==int_par(pdf_pk_resolution_code) 
#define pdf_unique_resname ==int_par(pdf_unique_resname_code) 
#define pdf_option_always_use_pdfpagebox ==int_par(pdf_option_always_use_pdfpagebox_code) 
#define pdf_option_pdf_inclusion_errorlevel ==int_par(pdf_option_pdf_inclusion_errorlevel_code) 
#define pdf_major_version ==int_par(pdf_major_version_code) 
#define pdf_minor_version ==int_par(pdf_minor_version_code) 
#define pdf_force_pagebox ==int_par(pdf_force_pagebox_code) 
#define pdf_pagebox ==int_par(pdf_pagebox_code) 
#define pdf_inclusion_errorlevel ==int_par(pdf_inclusion_errorlevel_code) 
#define pdf_gamma ==int_par(pdf_gamma_code) 
#define pdf_image_gamma ==int_par(pdf_image_gamma_code) 
#define pdf_image_hicolor ==int_par(pdf_image_hicolor_code) 
#define pdf_image_apply_gamma ==int_par(pdf_image_apply_gamma_code) 
#define pdf_draftmode ==int_par(pdf_draftmode_code) 
#define pdf_inclusion_copy_font ==int_par(pdf_inclusion_copy_font_code) 
#define pdf_suppress_warning_dup_dest ==int_par(pdf_suppress_warning_dup_dest_code) 
#define pdf_suppress_warning_dup_map ==int_par(pdf_suppress_warning_dup_map_code) 
#define pdf_suppress_warning_page_group ==int_par(pdf_suppress_warning_page_group_code) 
#define pdf_info_omit_date ==int_par(pdf_info_omit_date_code) 
#define pdf_suppress_ptex_info ==int_par(pdf_suppress_ptex_info_code) 
#define pdf_omit_charset ==int_par(pdf_omit_charset_code)  \

#define tracing_assigns ==int_par(tracing_assigns_code) 
#define tracing_groups ==int_par(tracing_groups_code) 
#define tracing_ifs ==int_par(tracing_ifs_code) 
#define tracing_scan_tokens ==int_par(tracing_scan_tokens_code) 
#define tracing_nesting ==int_par(tracing_nesting_code) 
#define pre_display_direction ==int_par(pre_display_direction_code) 
#define last_line_fit ==int_par(last_line_fit_code) 
#define saving_vdiscards ==int_par(saving_vdiscards_code) 
#define saving_hyph_codes ==int_par(saving_hyph_codes_code)  \

#define fix_date_and_time ==date_and_time(time,day,month,year)  \

#define par_indent_code = 0{indentation of paragraphs}
#define math_surround_code = 1{space around math in text}
#define line_skip_limit_code = 2{threshold for|line_skip|instead of|baseline_skip|}
#define hsize_code = 3{line width in horizontal mode}
#define vsize_code = 4{page height in vertical mode}
#define max_depth_code = 5{maximum depth of boxes on main pages}
#define split_max_depth_code = 6{maximum depth of boxes on split pages}
#define box_max_depth_code = 7{maximum depth of explicit vboxes}
#define hfuzz_code = 8{tolerance for overfull hbox messages}
#define vfuzz_code = 9{tolerance for overfull vbox messages}
#define delimiter_shortfall_code = 10{maximum amount uncovered by variable delimiters}
#define null_delimiter_space_code = 11{blank space in null delimiters}
#define script_space_code = 12{extra space after subscript or superscript}
#define pre_display_size_code = 13{length of text preceding a display}
#define display_width_code = 14{length of line for displayed equation}
#define display_indent_code = 15{indentation of line for displayed equation}
#define overfull_rule_code = 16{width of rule that identifies overfull hboxes}
#define hang_indent_code = 17{amount of hanging indentation}
#define h_offset_code = 18{amount of horizontal offset when shipping pages out}
#define v_offset_code = 19{amount of vertical offset when shipping pages out}
#define emergency_stretch_code = 20{reduces badnesses on final pass of line-breaking}
#define pdftex_first_dimen_code = 21{first number defined in this section}
#define pdf_h_origin_code = pdftex_first_dimen_code+0{horigin of the PDF output}
#define pdf_v_origin_code = pdftex_first_dimen_code+1{vorigin of the PDF output}
#define pdf_page_width_code = pdftex_first_dimen_code+2{page width of the PDF output}
#define pdf_page_height_code = pdftex_first_dimen_code+3{page height of the PDF output}
#define pdf_link_margin_code = pdftex_first_dimen_code+4{link margin in the PDF output}
#define pdf_dest_margin_code = pdftex_first_dimen_code+5{dest margin in the PDF output}
#define pdf_thread_margin_code = pdftex_first_dimen_code+6{thread margin in the PDF output}
#define pdf_first_line_height_code = pdftex_first_dimen_code+7
#define pdf_last_line_depth_code = pdftex_first_dimen_code+8
#define pdf_each_line_height_code = pdftex_first_dimen_code+9
#define pdf_each_line_depth_code = pdftex_first_dimen_code+10
#define pdf_ignored_dimen_code = pdftex_first_dimen_code+11
#define pdf_px_dimen_code = pdftex_first_dimen_code+12
#define pdftex_last_dimen_code = pdftex_first_dimen_code+12{last number defined in this section}
#define dimen_pars = pdftex_last_dimen_code+1{total number of dimension parameters}
#define scaled_base = dimen_base+dimen_pars \
{table of 256 user-defined\.{\\dimen}registers}
#define eqtb_size = scaled_base+255{largest subscript of|eqtb|} \

#define dimen(#) ==eqtb[scaled_base+#].sc
#define dimen_par(#) ==eqtb[dimen_base+#].sc{a scaled quantity}
#define par_indent ==dimen_par(par_indent_code) 
#define math_surround ==dimen_par(math_surround_code) 
#define line_skip_limit ==dimen_par(line_skip_limit_code) 
#define hsize ==dimen_par(hsize_code) 
#define vsize ==dimen_par(vsize_code) 
#define max_depth ==dimen_par(max_depth_code) 
#define split_max_depth ==dimen_par(split_max_depth_code) 
#define box_max_depth ==dimen_par(box_max_depth_code) 
#define hfuzz ==dimen_par(hfuzz_code) 
#define vfuzz ==dimen_par(vfuzz_code) 
#define delimiter_shortfall ==dimen_par(delimiter_shortfall_code) 
#define null_delimiter_space ==dimen_par(null_delimiter_space_code) 
#define script_space ==dimen_par(script_space_code) 
#define pre_display_size ==dimen_par(pre_display_size_code) 
#define display_width ==dimen_par(display_width_code) 
#define display_indent ==dimen_par(display_indent_code) 
#define overfull_rule ==dimen_par(overfull_rule_code) 
#define hang_indent ==dimen_par(hang_indent_code) 
#define h_offset ==dimen_par(h_offset_code) 
#define v_offset ==dimen_par(v_offset_code) 
#define emergency_stretch ==dimen_par(emergency_stretch_code) 
#define pdf_h_origin ==dimen_par(pdf_h_origin_code) 
#define pdf_v_origin ==dimen_par(pdf_v_origin_code) 
#define pdf_page_width ==dimen_par(pdf_page_width_code) 
#define pdf_page_height ==dimen_par(pdf_page_height_code) 
#define pdf_link_margin ==dimen_par(pdf_link_margin_code) 
#define pdf_dest_margin ==dimen_par(pdf_dest_margin_code) 
#define pdf_thread_margin ==dimen_par(pdf_thread_margin_code) 
#define pdf_first_line_height ==dimen_par(pdf_first_line_height_code) 
#define pdf_last_line_depth ==dimen_par(pdf_last_line_depth_code) 
#define pdf_each_line_height ==dimen_par(pdf_each_line_height_code) 
#define pdf_each_line_depth ==dimen_par(pdf_each_line_depth_code) 
#define pdf_ignored_dimen ==dimen_par(pdf_ignored_dimen_code) 
#define pdf_px_dimen ==dimen_par(pdf_px_dimen_code)  \

#define next(#) ==hash[#].lh{link for coalesced lists}
#define text(#) ==hash[#].rh{string number for control sequence name}
#define hash_is_full ==(hash_used= hash_base) {test if all positions are occupied}
#define font_id_text(#) ==text(font_id_base+#) {a frozen font identifier's name} \

#define prim_prime = 1777{about 85\pct!of|primitive_size|}
#define prim_base = 1
#define prim_next(#) ==prim[#].lh{link for coalesced lists}
#define prim_text(#) ==prim[#].rh{string number for control sequence name,plus one}
#define prim_is_full ==(prim_used= prim_base) {test if all positions are occupied}
#define prim_eq_level_field(#) ==#.hh.b1
#define prim_eq_type_field(#) ==#.hh.b0
#define prim_equiv_field(#) ==#.hh.rh
#define prim_eq_level(#) ==prim_eq_level_field(eqtb[prim_eqtb_base+#]) {level of definition}
#define prim_eq_type(#) ==prim_eq_type_field(eqtb[prim_eqtb_base+#]) {command code for equivalent}
#define prim_equiv(#) ==prim_equiv_field(eqtb[prim_eqtb_base+#]) {equivalent value}
#define undefined_primitive = 0
#define biggest_char = 255{65535 in XeTeX} \

#define save_type(#) ==save_stack[#].hh.b0{classifies a|save_stack|entry}
#define save_level(#) ==save_stack[#].hh.b1 \
{saved level for regions 5 and 6,or group code}
#define save_index(#) ==save_stack[#].hh.rh \
{|eqtb|location or token or|save_stack|location}
#define restore_old_value = 0{|save_type|when a value should be restored later}
#define restore_zero = 1{|save_type|when an undefined entry should be restored}
#define insert_token = 2{|save_type|when a token is being saved for later use}
#define level_boundary = 3{|save_type|corresponding to beginning of group}
#define restore_sa = 4{|save_type|when sparse array entries should be restored} \

#define bottom_level = 0{group code for the outside world}
#define simple_group = 1{group code for local structure only}
#define hbox_group = 2{code for`\.{\\hbox}\grp'}
#define adjusted_hbox_group = 3{code for`\.{\\hbox}\grp' in vertical mode}
#define vbox_group = 4{code for`\.{\\vbox}\grp'}
#define vtop_group = 5{code for`\.{\\vtop}\grp'}
#define align_group = 6{code for`\.{\\halign}\grp', `\.{\\valign}\grp'}
#define no_align_group = 7{code for`\.{\\noalign}\grp'}
#define output_group = 8{code for output routine}
#define math_group = 9{code for,e.g.,`\.{\char'136}\grp'}
#define disc_group = 10{code for`\.{\\discretionary}\grp\grp\grp'}
#define insert_group = 11{code for`\.{\\insert}\grp', `\.{\\vadjust}\grp'}
#define vcenter_group = 12{code for`\.{\\vcenter}\grp'}
#define math_choice_group = 13{code for`\.{\\mathchoice}\grp\grp\grp\grp'}
#define semi_simple_group = 14{code for`\.{\\begingroup...\\endgroup}'}
#define math_shift_group = 15{code for`\.{\$...\$}'}
#define math_left_group = 16{code for`\.{\\left...\\right}'}
#define max_group_code = 16 \

#define check_full_save_stack ==if save_ptr> max_save_stack then \
begin max_save_stack:= save_ptr; \
if max_save_stack> save_size-7 then overflow("save size",save_size) ; \
 \
end \

#define saved(#) ==save_stack[save_ptr+#].int \

#define assign_trace(#) ==stat if tracing_assigns> 0 then restore_trace(#) ; \
tats \

#define cs_token_flag ==55 \
token that stands for a control sequence;is a multiple of~256,less~1}
#define left_brace_token = 48
#define left_brace_limit = 49
#define right_brace_token = 49
#define right_brace_limit = 49
#define math_shift_token = 49
#define tab_token = 50
#define out_param_token = 50
#define space_token = 53
#define letter_token = 53
#define other_token = 54
#define match_token = 54
#define end_match_token = 55
#define protected_token = 55 \

#define chr_cmd(#) ==begin print(#) ;print_ASCII(chr_code) ; \
end \

#define state ==cur_input.state_field{current scanner state}
#define index ==cur_input.index_field{reference for buffer information}
#define start ==cur_input.start_field{starting position in|buffer|}
#define limit ==cur_input.limit_field{end of current line in|buffer|}
#define name ==cur_input.name_field{name of the current file}
#define synctex_tag ==cur_input.synctex_tag_field{{\sl Sync\TeX}tag of the current file} \

#define mid_line = 1{|state|code when scanning a line of characters}
#define skip_blanks = 2+max_char_code{|state|code when ignoring blanks}
#define new_line = 3+max_char_code+max_char_code{|state|code at start of line} \

#define terminal_input ==(name= 0) {are we reading from the terminal?}
#define cur_file ==input_file[index]{the current|alpha_file|variable} \

#define skipping = 1{|scanner_status|when passing conditional text}
#define defining = 2{|scanner_status|when reading a macro definition}
#define matching = 3{|scanner_status|when reading macro arguments}
#define aligning = 4{|scanner_status|when reading an alignment preamble}
#define absorbing = 5{|scanner_status|when reading a balanced text} \

#define token_list = 0{|state|code when scanning a token list}
#define token_type ==index{type of current token list}
#define param_start ==limit{base of macro parameters in|param_stack|}
#define parameter = 0{|token_type|code for parameter}
#define u_template = 1{|token_type|code for\<u_j> template}
#define v_template = 2{|token_type|code for\<v_j> template}
#define backed_up = 3{|token_type|code for text to be reread}
#define inserted = 4{|token_type|code for inserted texts}
#define macro = 5{|token_type|code for defined control sequences}
#define output_text = 6{|token_type|code for output routines}
#define every_par_text = 7{|token_type|code for\.{\\everypar}}
#define every_math_text = 8{|token_type|code for\.{\\everymath}}
#define every_display_text = 9{|token_type|code for\.{\\everydisplay}}
#define every_hbox_text = 10{|token_type|code for\.{\\everyhbox}}
#define every_vbox_text = 11{|token_type|code for\.{\\everyvbox}}
#define every_job_text = 12{|token_type|code for\.{\\everyjob}}
#define every_cr_text = 13{|token_type|code for\.{\\everycr}}
#define mark_text = 14{|token_type|code for\.{\\topmark},etc.} \

#define eTeX_text_offset = output_routine_loc-output_text
#define every_eof_text = every_eof_loc-eTeX_text_offset \
{|token_type|code for\.{\\everyeof}} \

#define write_text = toks_base-eTeX_text_offset{|token_type|code for\.{\\write}} \

#define begin_pseudoprint == \
begin l:= tally;tally:= 0;selector:= pseudo; \
trick_count:= 1000000; \
end
#define set_trick_count == \
begin first_count:= tally; \
trick_count:= tally+1+error_line-half_error_line; \
if trick_count<error_line then trick_count:= error_line; \
end \

#define push_input =={enter a new input level,save the old} \
begin if input_ptr> max_in_stack then \
begin max_in_stack:= input_ptr; \
if input_ptr= stack_size then overflow("input stack size",stack_size) ; \
 \
end; \
input_stack[input_ptr]:= cur_input;{stack the record} \
incr(input_ptr) ; \
end \

#define pop_input =={leave an input level,re-enter the old} \
begin decr(input_ptr) ;cur_input:= input_stack[input_ptr]; \
end \

#define back_list(#) ==begin_token_list(#,backed_up) {backs up a simple token list}
#define ins_list(#) ==begin_token_list(#,inserted) {inserts a simple token list} \

#define switch = 25{a label in|get_next|}
#define start_cs = 26{another} \

#define any_state_plus(#) ==mid_line+#,skip_blanks+#,new_line+# \

#define add_delims_to(#) ==#+math_shift,#+tab_mark,#+mac_param, \
#+sub_mark,#+letter,#+other_char \

#define is_hex(#) ==(((#>="0") and(#<="9") ) or((#>="a") and(#<="f") ) ) 
#define hex_to_cur_chr == \
if c<="9"then cur_chr:= c-"0"else cur_chr:= c-"a"+10; \
if cc<="9"then cur_chr:= 16*cur_chr+cc-"0" \
else cur_chr:= 16*cur_chr+cc-"a"+10 \

#define no_expand_flag = 257{this characterizes a special variant of|relax|} \

#define end_line_char_inactive ==(end_line_char<0) or(end_line_char> 255)  \

#define store_new_token(#) ==begin q:= get_avail;link(p) := q;info(q) := #; \
p:= q;{|link(p) |is|null|} \
end
#define fast_store_new_token(#) ==begin fast_get_avail(q) ;link(p) := q;info(q) := #; \
p:= q;{|link(p) |is|null|} \
end \

#define marks_code ==5{add this for\.{\\topmarks}etc.} \

#define top_mark_code = 0{the mark in effect at the previous page break}
#define first_mark_code = 1{the first mark between|top_mark|and|bot_mark|}
#define bot_mark_code = 2{the mark in effect at the current page break}
#define split_first_mark_code = 3{the first mark found by\.{\\vsplit}}
#define split_bot_mark_code = 4{the last mark found by\.{\\vsplit}}
#define top_mark ==cur_mark[top_mark_code]
#define first_mark ==cur_mark[first_mark_code]
#define bot_mark ==cur_mark[bot_mark_code]
#define split_first_mark ==cur_mark[split_first_mark_code]
#define split_bot_mark ==cur_mark[split_bot_mark_code] \

#define int_val = 0{integer values}
#define dimen_val = 1{dimension values}
#define glue_val = 2{glue specifications}
#define mu_val = 3{math glue specifications}
#define ident_val = 4{font identifier}
#define tok_val = 5{token lists} \

#define scanned_result_end(#) ==cur_val_level:= #;end
#define scanned_result(#) ==begin cur_val:= #;scanned_result_end \

#define last_node_type_code = glue_val+1{code for\.{\\lastnodetype}}
#define input_line_no_code = glue_val+2{code for\.{\\inputlineno}}
#define badness_code = input_line_no_code+1{code for\.{\\badness}} \

#define pdftex_first_rint_code = badness_code+1{base for\pdfTeX's command codes}
#define pdftex_version_code = pdftex_first_rint_code+0{code for\.{\\pdftexversion}}
#define pdf_last_obj_code = pdftex_first_rint_code+1{code for\.{\\pdflastobj}}
#define pdf_last_xform_code = pdftex_first_rint_code+2{code for\.{\\pdflastxform}}
#define pdf_last_ximage_code = pdftex_first_rint_code+3{code for\.{\\pdflastximage}}
#define pdf_last_ximage_pages_code = pdftex_first_rint_code+4{code for\.{\\pdflastximagepages}}
#define pdf_last_annot_code = pdftex_first_rint_code+5{code for\.{\\pdflastannot}}
#define pdf_last_x_pos_code = pdftex_first_rint_code+6{code for\.{\\pdflastxpos}}
#define pdf_last_y_pos_code = pdftex_first_rint_code+7{code for\.{\\pdflastypos}}
#define pdf_retval_code = pdftex_first_rint_code+8{global multi-purpose return value}
#define pdf_last_ximage_colordepth_code = pdftex_first_rint_code+9{code for\.{\\pdflastximagecolordepth}}
#define elapsed_time_code = pdftex_first_rint_code+10{code for\.{\\pdfelapsedtime}}
#define pdf_shell_escape_code = pdftex_first_rint_code+11{code for\.{\\pdfshellescape}}
#define random_seed_code = pdftex_first_rint_code+12{code for\.{\\pdfrandomseed}}
#define pdf_last_link_code = pdftex_first_rint_code+13{code for\.{\\pdflastlink}}
#define pdftex_last_item_codes = pdftex_first_rint_code+13{end of\pdfTeX's command codes} \

#define eTeX_int = pdftex_last_item_codes+1{first of\eTeX\codes for integers}
#define eTeX_dim = eTeX_int+8{first of\eTeX\codes for dimensions}
#define eTeX_glue = eTeX_dim+9{first of\eTeX\codes for glue}
#define eTeX_mu = eTeX_glue+1{first of\eTeX\codes for muglue}
#define eTeX_expr = eTeX_mu+1{first of\eTeX\codes for expressions} \

#define max_dimen ==55 \

#define find_effective_tail_eTeX == \
tx:= tail; \
if not is_char_node(tx) then \
if(type(tx) = math_node) and(subtype(tx) = end_M_code) then \
begin r:= head; \
repeat q:= r;r:= link(q) ; \
until r= tx; \
tx:= q; \
end \

#define find_effective_tail ==find_effective_tail_eTeX \

#define octal_token = other_token+"'"{apostrophe,indicates an octal constant}
#define hex_token = other_token+""""{double quote,indicates a hex constant}
#define alpha_token = other_token+"`"{reverse apostrophe,precedes alpha constants}
#define point_token = other_token+"."{decimal point}
#define continental_point_token = other_token+","{decimal point,Eurostyle} \

#define infinity ==49
#define zero_token = other_token+"0"{zero,the smallest digit}
#define A_token = letter_token+"A"{the smallest special hex digit}
#define other_A_token = other_token+"A"{special hex digit of type|other_char|} \

#define attach_fraction = 88{go here to pack|cur_val|and|f|into|cur_val|}
#define attach_sign = 89{go here when|cur_val|is correct except perhaps for sign}
#define scan_normal_dimen ==scan_dimen(false,false,false)  \

#define set_conversion_end(#) ==denom:= #;end
#define set_conversion(#) ==begin num:= #;set_conversion_end \

#define default_rule = 26214{0.4\thinspace pt} \

#define number_code = 0{command code for\.{\\number}}
#define roman_numeral_code = 1{command code for\.{\\romannumeral}}
#define string_code = 2{command code for\.{\\string}}
#define meaning_code = 3{command code for\.{\\meaning}}
#define font_name_code = 4{command code for\.{\\fontname}}
#define etex_convert_base = 5{base for\eTeX's command codes}
#define eTeX_revision_code = etex_convert_base{command code for\.{\\eTeXrevision}}
#define etex_convert_codes = etex_convert_base+1{end of\eTeX's command codes}
#define expanded_code = etex_convert_codes{command code for\.{\\expanded}}
#define pdftex_first_expand_code = expanded_code+1{base for\pdfTeX's command codes}
#define pdftex_revision_code = pdftex_first_expand_code+0{command code for\.{\\pdftexrevision}}
#define pdftex_banner_code = pdftex_first_expand_code+1{command code for\.{\\pdftexbanner}}
#define pdf_font_name_code = pdftex_first_expand_code+2{command code for\.{\\pdffontname}}
#define pdf_font_objnum_code = pdftex_first_expand_code+3{command code for\.{\\pdffontobjnum}}
#define pdf_font_size_code = pdftex_first_expand_code+4{command code for\.{\\pdffontsize}}
#define pdf_page_ref_code = pdftex_first_expand_code+5{command code for\.{\\pdfpageref}}
#define pdf_xform_name_code = pdftex_first_expand_code+6{command code for\.{\\pdfxformname}}
#define pdf_escape_string_code = pdftex_first_expand_code+7{command code for\.{\\pdfescapestring}}
#define pdf_escape_name_code = pdftex_first_expand_code+8{command code for\.{\\pdfescapename}}
#define left_margin_kern_code = pdftex_first_expand_code+9{command code for\.{\\leftmarginkern}}
#define right_margin_kern_code = pdftex_first_expand_code+10{command code for\.{\\rightmarginkern}}
#define pdf_strcmp_code = pdftex_first_expand_code+11{command code for\.{\\pdfstrcmp}}
#define pdf_colorstack_init_code = pdftex_first_expand_code+12{command code for\.{\\pdfcolorstackinit}}
#define pdf_escape_hex_code = pdftex_first_expand_code+13{command code for\.{\\pdfescapehex}}
#define pdf_unescape_hex_code = pdftex_first_expand_code+14{command code for\.{\\pdfunescapehex}}
#define pdf_creation_date_code = pdftex_first_expand_code+15{command code for\.{\\pdfcreationdate}}
#define pdf_file_mod_date_code = pdftex_first_expand_code+16{command code for\.{\\pdffilemoddate}}
#define pdf_file_size_code = pdftex_first_expand_code+17{command code for\.{\\pdffilesize}}
#define pdf_mdfive_sum_code = pdftex_first_expand_code+18{command code for\.{\\pdfmdfivesum}}
#define pdf_file_dump_code = pdftex_first_expand_code+19{command code for\.{\\pdffiledump}}
#define pdf_match_code = pdftex_first_expand_code+20{command code for\.{\\pdfmatch}}
#define pdf_last_match_code = pdftex_first_expand_code+21{command code for\.{\\pdflastmatch}}
#define uniform_deviate_code = pdftex_first_expand_code+22{end of\pdfTeX's command codes}
#define normal_deviate_code = pdftex_first_expand_code+23{end of\pdfTeX's command codes}
#define pdf_insert_ht_code = pdftex_first_expand_code+24{command code for\.{\\pdfinsertht}}
#define pdf_ximage_bbox_code = pdftex_first_expand_code+25{command code for\.{\\pdfximagebbox}}
#define pdftex_convert_codes = pdftex_first_expand_code+26{end of\pdfTeX's command codes}
#define job_name_code = pdftex_convert_codes{command code for\.{\\jobname}} \

#define save_cur_string ==if str_start[str_ptr]<pool_ptr then u:= make_string
#define restore_cur_string ==if u<> 0 then begin decr(str_ptr) ;u:= 0;end \

#define closed = 2{not open,or at end of file}
#define just_open = 1{newly opened,first line not yet read} \

#define unless_code = 32{amount added for`\.{\\unless}' prefix} \

#define if_char_code = 0{`\.{\\if}' }
#define if_cat_code = 1{`\.{\\ifcat}' }
#define if_int_code = 2{`\.{\\ifnum}' }
#define if_dim_code = 3{`\.{\\ifdim}' }
#define if_odd_code = 4{`\.{\\ifodd}' }
#define if_vmode_code = 5{`\.{\\ifvmode}' }
#define if_hmode_code = 6{`\.{\\ifhmode}' }
#define if_mmode_code = 7{`\.{\\ifmmode}' }
#define if_inner_code = 8{`\.{\\ifinner}' }
#define if_void_code = 9{`\.{\\ifvoid}' }
#define if_hbox_code = 10{`\.{\\ifhbox}' }
#define if_vbox_code = 11{`\.{\\ifvbox}' }
#define ifx_code = 12{`\.{\\ifx}' }
#define if_eof_code = 13{`\.{\\ifeof}' }
#define if_true_code = 14{`\.{\\iftrue}' }
#define if_false_code = 15{`\.{\\iffalse}' }
#define if_case_code = 16{`\.{\\ifcase}' }
#define if_pdfprimitive_code = 21{`\.{\\ifpdfprimitive}' } \

#define if_node_size = 2{number of words in stack entry for conditionals}
#define if_line_field(#) ==mem[#+1].int
#define if_code = 1{code for\.{\\if...}being evaluated}
#define fi_code = 2{code for\.{\\fi}}
#define else_code = 3{code for\.{\\else}}
#define or_code = 4{code for\.{\\or}} \

#define get_x_token_or_active_char == \
begin get_x_token; \
if cur_cmd= relax then if cur_chr= no_expand_flag then \
begin cur_cmd:= active_char; \
cur_chr:= cur_tok-cs_token_flag-active_base; \
end; \
end \

#define check_quoted(#) =={check if string|#|needs quoting} \
if#<> 0 then begin \
j:= str_start[#]; \
while(not must_quote) and(j<str_start[#+1]) do begin \
must_quote:= str_pool[j]= " ";incr(j) ; \
end; \
end \

#define print_quoted(#) =={print string|#|,omitting quotes} \
if#<> 0 then \
for j:= str_start[#]to str_start[#+1]-1 do \
if so(str_pool[j]) <> """"then \
print(so(str_pool[j]) )  \

#define append_to_name(#) ==begin c:= #;if not(c= """") then begin incr(k) ; \
if k<=file_name_size then name_of_file[k]:= xchr[c]; \
end end \

#define format_area_length = 0{length of its area part}
#define format_ext_length = 4{length of its`\.{.fmt}' part}
#define format_extension = ".fmt"{the extension,as a\.{WEB}constant} \

#define pack_cur_name ==pack_file_name(cur_name,cur_area,cur_ext)  \

#define log_name ==texmf_log_name
#define ensure_dvi_open ==if output_file_name= 0 then \
begin if job_name= 0 then open_log_file; \
pack_job_name(".dvi") ; \
while not b_open_out(dvi_file) do \
prompt_file_name("file name for output",".dvi") ; \
output_file_name:= b_make_name_string(dvi_file) ; \
end \

#define no_tag = 0{vanilla character}
#define lig_tag = 1{character has a ligature/kerning program}
#define list_tag = 2{character has a successor in a charlist}
#define ext_tag = 3{character is extensible} \

#define stop_flag ==qi(128) {value indicating`\.{STOP}' in a lig/kern program}
#define kern_flag ==qi(128) {op code for a kern step}
#define skip_byte(#) ==#.b0
#define next_char(#) ==#.b1
#define op_byte(#) ==#.b2
#define rem_byte(#) ==#.b3 \

#define ext_top(#) ==#.b0{|top|piece in a recipe}
#define ext_mid(#) ==#.b1{|mid|piece in a recipe}
#define ext_bot(#) ==#.b2{|bot|piece in a recipe}
#define ext_rep(#) ==#.b3{|rep|piece in a recipe} \

#define slant_code = 1
#define space_code = 2
#define space_stretch_code = 3
#define space_shrink_code = 4
#define x_height_code = 5
#define quad_code = 6
#define extra_space_code = 7 \

#define non_char ==qi(256) {a|halfword|code that can't match a real character}
#define non_address = 0{a spurious|bchar_label|} \

#define char_list_exists(#) ==(char_sub_code(#) > hi(0) ) 
#define char_list_accent(#) ==(ho(char_sub_code(#) ) div 256) 
#define char_list_char(#) ==(ho(char_sub_code(#) ) mod 256)  \

#define char_info_end(#) ==#)].qqqq
#define char_info(#) == \
font_info[char_base[#]+effective_char(true,#,char_info_end \

#define orig_char_info_end(#) ==#].qqqq
#define orig_char_info(#) ==font_info[char_base[#]+orig_char_info_end \

#define char_width_end(#) ==#.b0].sc
#define char_width(#) ==font_info[width_base[#]+char_width_end
#define char_exists(#) ==(#.b0> min_quarterword) 
#define char_italic_end(#) ==(qo(#.b2) ) div 4].sc
#define char_italic(#) ==font_info[italic_base[#]+char_italic_end
#define height_depth(#) ==qo(#.b1) 
#define char_height_end(#) ==(#) div 16].sc
#define char_height(#) ==font_info[height_base[#]+char_height_end
#define char_depth_end(#) ==(#) mod 16].sc
#define char_depth(#) ==font_info[depth_base[#]+char_depth_end
#define char_tag(#) ==((qo(#.b2) ) mod 4)  \

#define char_kern_end(#) ==256*op_byte(#) +rem_byte(#) ].sc
#define char_kern(#) ==font_info[kern_base[#]+char_kern_end
#define kern_base_offset ==256*(128+min_quarterword) 
#define lig_kern_start(#) ==lig_kern_base[#]+rem_byte{beginning of lig/kern program}
#define lig_kern_restart_end(#) ==256*op_byte(#) +rem_byte(#) +32768-kern_base_offset
#define lig_kern_restart(#) ==lig_kern_base[#]+lig_kern_restart_end \

#define param_end(#) ==param_base[#]].sc
#define param(#) ==font_info[#+param_end
#define slant ==param(slant_code) {slant to the right,per unit distance upward}
#define space ==param(space_code) {normal space between words}
#define space_stretch ==param(space_stretch_code) {stretch between words}
#define space_shrink ==param(space_shrink_code) {shrink between words}
#define x_height ==param(x_height_code) {one ex}
#define quad ==param(quad_code) {one em}
#define extra_space ==param(extra_space_code) {additional space at end of sentence} \

#define bad_tfm = 11{label for|read_font_info|}
#define abort ==goto bad_tfm{do this when the\.{TFM}data is wrong} \

#define start_font_error_message ==print_err("Font ") ;sprint_cs(u) ; \
print_char("=") ;print_file_name(nom,aire,"") ; \
if s>=0 then \
begin print(" at ") ;print_scaled(s) ;print("pt") ; \
end \
else if s<> -1000 then \
begin print(" scaled ") ;print_int(-s) ; \
end \

#define fget ==tfm_temp:= getc(tfm_file) 
#define fbyte ==tfm_temp
#define read_sixteen(#) ==begin#:= fbyte; \
if#> 127 then abort; \
fget;#:= #*52 \
end
#define store_four_quarters(#) ==begin fget;a:= fbyte;qw.b0:= qi(a) ; \
fget;b:= fbyte;qw.b1:= qi(b) ; \
fget;c:= fbyte;qw.b2:= qi(c) ; \
fget;d:= fbyte;qw.b3:= qi(d) ; \
#:= qw; \
end \

#define check_byte_range(#) ==begin if(#<bc) or(#> ec) then abort end
#define current_character_being_worked_on ==k+bc-fmem_ptr \

#define store_scaled(#) ==begin fget;a:= fbyte;fget;b:= fbyte; \
fget;c:= fbyte;fget;d:= fbyte; \
sw:= (((((d*z) div 52 400) +(b*z) ) div beta; \
if a= 0 then#:= sw else if a= 255 then#:= sw-alpha else abort; \
end \

#define check_existence(#) == \
begin check_byte_range(#) ; \
qw:= orig_char_info(f) (#) ;{N.B.:not|qi(#) |} \
if not char_exists(qw) then abort; \
end \

#define adjust(#) ==#[f]:= qo(#[f])  \
{correct for the excess|min_quarterword|that was added} \

#define set_char_0 = 0{typeset character 0 and move right}
#define set1 = 128{typeset a character and move right}
#define set_rule = 132{typeset a rule and move right}
#define put_rule = 137{typeset a rule}
#define nop = 138{no operation}
#define bop = 139{beginning of page}
#define eop = 140{ending of page}
#define push = 141{save the current positions}
#define pop = 142{restore previous positions}
#define right1 = 143{move right}
#define w0 = 147{move right by|w|}
#define w1 = 148{move right and set|w|}
#define x0 = 152{move right by|x|}
#define x1 = 153{move right and set|x|}
#define down1 = 157{move down}
#define y0 = 161{move down by|y|}
#define y1 = 162{move down and set|y|}
#define z0 = 166{move down by|z|}
#define z1 = 167{move down and set|z|}
#define fnt_num_0 = 171{set current font to 0}
#define fnt1 = 235{set current font}
#define xxx1 = 239{extension to\.{DVI}primitives}
#define xxx4 = 242{potentially long extension to\.{DVI}primitives}
#define fnt_def1 = 243{define the meaning of a font number}
#define pre = 247{preamble}
#define post = 248{postamble beginning}
#define post_post = 249{postamble ending} \

#define id_byte = 2{identifies the kind of\.{DVI}files described here} \

#define dvi_out(#) ==begin dvi_buf[dvi_ptr]:= #;incr(dvi_ptr) ; \
if dvi_ptr= dvi_limit then dvi_swap; \
end \

#define movement_node_size = 3{number of words per entry in the down and right stacks}
#define location(#) ==mem[#+2].int{\.{DVI}byte number for a movement command} \

#define y_here = 1{|info|when the movement entry points to a|y|command}
#define z_here = 2{|info|when the movement entry points to a|z|command}
#define yz_OK = 3{|info|corresponding to an unconstrained\\{down}command}
#define y_OK = 4{|info|corresponding to a\\{down}that can't become a |z|}
#define z_OK = 5{|info|corresponding to a\\{down}that can't become a |y|}
#define d_fixed = 6{|info|corresponding to a\\{down}that can't change} \

#define none_seen = 0{no|y_here|or|z_here|nodes have been encountered yet}
#define y_seen = 6{we have seen|y_here|but not|z_here|}
#define z_seen = 12{we have seen|z_here|but not|y_here|} \

#define reversed = 1{subtype for an|hlist_node|whose hlist has been reversed}
#define dlist = 2{subtype for an|hlist_node|from display math mode}
#define box_lr(#) ==(qo(subtype(#) ) ) {direction mode of a box}
#define set_box_lr(#) ==subtype(#) := set_box_lr_end
#define set_box_lr_end(#) ==qi(#)  \

#define left_to_right = 0
#define right_to_left = 1
#define reflected ==1-cur_dir{the opposite of|cur_dir|} \

#define synch_h ==if cur_h<> dvi_h then \
begin movement(cur_h-dvi_h,right1) ;dvi_h:= cur_h; \
end
#define synch_v ==if cur_v<> dvi_v then \
begin movement(cur_v-dvi_v,down1) ;dvi_v:= cur_v; \
end \

#define move_past = 13{go to this label when advancing past glue or a rule}
#define fin_rule = 14{go to this label to finish processing a rule}
#define next_p = 15{go to this label when finished with node|p|} \

#define billion ==float_constant(1000000000) 
#define vet_glue(#) ==glue_temp:= #; \
if glue_temp> billion then \
glue_temp:= billion \
else if glue_temp<-billion then \
glue_temp:= -billion \

#define round_glue ==g:= glue_ptr(p) ;rule_wd:= width(g) -cur_g; \
if g_sign<> normal then \
begin if g_sign= stretching then \
begin if stretch_order(g) = g_order then \
begin cur_glue:= cur_glue+stretch(g) ; \
vet_glue(float(glue_set(this_box) ) *cur_glue) ; \
 \
cur_g:= round(glue_temp) ; \
end; \
end \
else if shrink_order(g) = g_order then \
begin cur_glue:= cur_glue-shrink(g) ; \
vet_glue(float(glue_set(this_box) ) *cur_glue) ; \
cur_g:= round(glue_temp) ; \
end; \
end; \
rule_wd:= rule_wd+cur_g \

#define flushable(#) ==(#= str_ptr-1)  \

#define is_valid_char(#) ==((font_bc[f]<=#) and(#<=font_ec[f]) and \
char_exists(orig_char_info(f) (#) ) )  \

#define pdf_offset ==(pdf_gone+pdf_ptr) {the file offset of last byte in PDF \
buffer that|pdf_ptr|points to} \

#define no_zip ==0{no\.{ZIP}compression}
#define zip_writing ==1{\.{ZIP}compression being used}
#define zip_finish ==2{finish\.{ZIP}compression} \

#define pdf_quick_out(#) =={output a byte to PDF buffer without checking of \
overflow} \
begin \
pdf_buf[pdf_ptr]:= #; \
incr(pdf_ptr) ; \
end \

#define pdf_room(#) =={make sure that there are at least|n|bytes free in PDF buffer} \
begin \
if pdf_os_mode and(#+pdf_ptr> pdf_buf_size) then \
pdf_os_get_os_buf(#)  \
else if not pdf_os_mode and(#> pdf_buf_size) then \
overflow("PDF output buffer",pdf_op_buf_size)  \
else if not pdf_os_mode and(#+pdf_ptr> pdf_buf_size) then \
pdf_flush; \
end \

#define pdf_out(#) =={do the same as|pdf_quick_out|and flush the PDF \
buffer if necessary} \
begin \
pdf_room(1) ; \
pdf_quick_out(#) ; \
end \

#define pdf_new_line_char ==10{new-line character for UNIX platforms} \

#define pdf_print_nl =={output a new-line character to PDF buffer} \
pdf_out(pdf_new_line_char)  \

#define pdf_print_ln(#) =={print out a string to PDF buffer followed by \
a new-line character} \
begin \
pdf_print(#) ; \
pdf_print_nl; \
end \

#define pdf_print_int_ln(#) =={print out an integer to PDF buffer followed by \
a new-line character} \
begin \
pdf_print_int(#) ; \
pdf_print_nl; \
end \

#define max_integer ==7FFFFFFF{$2^{31}-1 $}
#define call_func(#) ==begin if#<> 0 then do_nothing end \

#define pdf_x(#) ==((#) -pdf_origin_h) {convert $x$-coordinate from\.{DVI}to \
PDF}
#define pdf_y(#) ==(pdf_origin_v-(#) ) {convert $y$-coordinate from\.{DVI}to \
PDF}
#define dvi_x(#) ==((#) +pdf_origin_h) {convert $x$-coordinate from\.{PDF}to \
DVI}
#define dvi_y(#) ==(pdf_origin_v-(#) ) {convert $y$-coordinate from\.{PDF}to \
DVI} \

#define pdf_print_resname_prefix == \
if pdf_resname_prefix<> 0 then \
pdf_print(pdf_resname_prefix)  \

#define obj_info(#) ==obj_tab[#].int0{information representing identifier of this object}
#define obj_link(#) ==obj_tab[#].int1{link to the next entry in linked list}
#define obj_offset(#) ==obj_tab[#].int2{negative(flags) ,or byte offset for this object in PDF output file,or object stream number for this object}
#define obj_os_idx(#) ==obj_tab[#].int3{index of this object in object stream}
#define obj_aux(#) ==obj_tab[#].int4{auxiliary pointer} \

#define set_obj_fresh(#) ==obj_offset(#) := -2
#define set_obj_scheduled(#) ==if obj_offset(#) = -2 then obj_offset(#) := -1
#define is_obj_scheduled(#) ==(obj_offset(#) > -2) 
#define is_obj_written(#) ==(obj_offset(#) > -1)  \
 \
{types of objects}
#define obj_type_others ==0{objects which are not linked in any list}
#define obj_type_page ==1{index of linked list of Page objects}
#define obj_type_pages ==2{index of linked list of Pages objects}
#define obj_type_font ==3{index of linked list of Fonts objects}
#define obj_type_outline ==4{index of linked list of outline objects}
#define obj_type_dest ==5{index of linked list of destination objects}
#define obj_type_obj ==6{index of linked list of raw objects}
#define obj_type_xform ==7{index of linked list of XObject forms}
#define obj_type_ximage ==8{index of linked list of XObject image}
#define obj_type_thread ==9{index of linked list of num article threads}
#define head_tab_max ==obj_type_thread{max index of|head_tab|} \
 \
{max number of kids for balanced trees}
#define pages_tree_kids_max ==6{max number of kids of Pages tree node}
#define name_tree_kids_max ==6{max number of kids of node of name tree for \
name destinations} \
 \
{when a whatsit node representing annotation is created,words|1. .3|are \
width,height and depth of this annotation;after shipping out words|1. .4| \
are rectangle specification of annotation.For whatsit node representing \
destination|pdf_left|and|pdf_top|are used for some types of destinations} \
 \
{coordinates of destinations/threads/annotations(in whatsit node) }
#define pdf_left(#) ==mem[#+1].sc
#define pdf_top(#) ==mem[#+2].sc
#define pdf_right(#) ==mem[#+3].sc
#define pdf_bottom(#) ==mem[#+4].sc \
 \
{dimension of destinations/threads/annotations(in whatsit node) }
#define pdf_width(#) ==mem[#+1].sc
#define pdf_height(#) ==mem[#+2].sc
#define pdf_depth(#) ==mem[#+3].sc \
 \
{data structure for\.{\\pdfliteral}}
#define pdf_literal_data(#) ==link(#+1) {data}
#define pdf_literal_mode(#) ==info(#+1) {mode of resetting the text matrix \
while writing data to the page stream} \
{modes of setting the current transformation matrix(CTM) }
#define set_origin ==0{end text(ET) if needed,set CTM to current point}
#define direct_page ==1{end text(ET) if needed,but don't change the CTM}
#define direct_always ==2{don't end text, don't change the CTM}
#define scan_special ==3{look into special text} \
 \
{data structure for\.{\\pdfcolorstack}}
#define pdf_colorstack_node_size ==3
#define pdf_colorstack_setter_node_size ==3
#define pdf_colorstack_getter_node_size ==2
#define pdf_colorstack_stack(#) ==link(#+1) {stack number}
#define pdf_colorstack_cmd(#) ==info(#+1) {command:set,push,pop,current}
#define pdf_colorstack_data(#) ==link(#+2) {data} \
 \
{color stack commands}
#define colorstack_set ==0
#define colorstack_push ==1
#define colorstack_data ==1{last value where data field is set}
#define colorstack_pop ==2
#define colorstack_current ==3 \
 \
{data structure for\.{\\pdfsetmatrix}}
#define pdf_setmatrix_node_size ==2
#define pdf_setmatrix_data(#) ==link(#+1) {data} \
 \
{data structure for\.{\\pdfsave}}
#define pdf_save_node_size ==2 \
 \
{data structure for\.{\\pdfrestore}}
#define pdf_restore_node_size ==2 \
 \
{data structure for\.{\\pdfobj}and\.{\\pdfrefobj}}
#define pdf_refobj_node_size ==2{size of whatsit node representing the raw object}
#define pdf_obj_objnum(#) ==info(#+1) {number of the raw object}
#define obj_data_ptr ==obj_aux{pointer to|pdf_mem|}
#define pdfmem_obj_size ==4{size of memory in|pdf_mem|which \
|obj_data_ptr|holds}
#define obj_obj_data(#) ==pdf_mem[obj_data_ptr(#) +0]{object data}
#define obj_obj_is_stream(#) ==pdf_mem[obj_data_ptr(#) +1]{will this object \
be written as a stream instead of a dictionary?}
#define obj_obj_stream_attr(#) ==pdf_mem[obj_data_ptr(#) +2]{additional \
object attributes for streams}
#define obj_obj_is_file(#) ==pdf_mem[obj_data_ptr(#) +3]{data should be \
read from an external file?} \
 \
{data structure for\.{\\pdfxform}and\.{\\pdfrefxform}}
#define pdf_refxform_node_size ==5{size of whatsit node for xform;words 1. .3 are \
form dimensions}
#define pdf_xform_objnum(#) ==info(#+4) {object number}
#define pdfmem_xform_size ==6{size of memory in|pdf_mem|which \
|obj_data_ptr|holds}
#define obj_xform_width(#) ==pdf_mem[obj_data_ptr(#) +0]
#define obj_xform_height(#) ==pdf_mem[obj_data_ptr(#) +1]
#define obj_xform_depth(#) ==pdf_mem[obj_data_ptr(#) +2]
#define obj_xform_box(#) ==pdf_mem[obj_data_ptr(#) +3]{this field holds \
pointer to the corresponding box}
#define obj_xform_attr(#) ==pdf_mem[obj_data_ptr(#) +4]{additional xform \
attributes}
#define obj_xform_resources(#) ==pdf_mem[obj_data_ptr(#) +5]{additional xform \
Resources} \
 \
{data structure for\.{\\pdfximage}and\.{\\pdfrefximage}}
#define pdf_refximage_node_size ==5{size of whatsit node for ximage;words 1. .3 \
are image dimensions}
#define pdf_ximage_objnum(#) ==info(#+4) {object number}
#define pdfmem_ximage_size ==5{size of memory in|pdf_mem|which \
|obj_data_ptr|holds}
#define obj_ximage_width(#) ==pdf_mem[obj_data_ptr(#) +0]
#define obj_ximage_height(#) ==pdf_mem[obj_data_ptr(#) +1]
#define obj_ximage_depth(#) ==pdf_mem[obj_data_ptr(#) +2]
#define obj_ximage_attr(#) ==pdf_mem[obj_data_ptr(#) +3]{additional ximage attributes}
#define obj_ximage_data(#) ==pdf_mem[obj_data_ptr(#) +4]{pointer to image data} \
 \
{data structure of annotations;words 1. .4 represent the coordinates of \
the annotation}
#define obj_annot_ptr ==obj_aux{pointer to corresponding whatsit node}
#define pdf_annot_node_size ==7{size of whatsit node representing annotation}
#define pdf_annot_data(#) ==info(#+5) {raw data of general annotations}
#define pdf_link_attr(#) ==info(#+5) {attributes of link annotations}
#define pdf_link_action(#) ==link(#+5) {pointer to action structure}
#define pdf_annot_objnum(#) ==mem[#+6].int{object number of corresponding object}
#define pdf_link_objnum(#) ==mem[#+6].int{object number of corresponding object} \
 \
{types of actions}
#define pdf_action_page ==0{GoTo action}
#define pdf_action_goto ==1{GoTo action}
#define pdf_action_thread ==2{Thread action}
#define pdf_action_user ==3{user-defined action} \
 \
{data structure of actions}
#define pdf_action_size ==3{size of action structure in|mem|}
#define pdf_action_type ==type{action type}
#define pdf_action_named_id ==subtype{identifier is type of name}
#define pdf_action_id ==link{destination/thread name identifier}
#define pdf_action_file(#) ==info(#+1) {file name for external action}
#define pdf_action_new_window(#) ==link(#+1) {open a new window?}
#define pdf_action_page_tokens(#) ==info(#+2) {specification of GoTo page action}
#define pdf_action_user_tokens(#) ==info(#+2) {user-defined action string}
#define pdf_action_refcount(#) ==link(#+2) {counter of references to this action} \
 \
{data structure of outlines;it's not able to write out outline entries \
before all outline entries are defined,so memory allocated for outline \
entries can't not be deallocated and will stay in memory. For this reason we \
will store data of outline entries in|pdf_mem|instead of|mem|} \

#define pdfmem_outline_size ==8{size of memory in|pdf_mem|which \
|obj_outline_ptr|points to}
#define obj_outline_count ==obj_info{count of all opened children}
#define obj_outline_ptr ==obj_aux{pointer to|pdf_mem|}
#define obj_outline_title(#) ==pdf_mem[obj_outline_ptr(#) ]
#define obj_outline_parent(#) ==pdf_mem[obj_outline_ptr(#) +1]
#define obj_outline_prev(#) ==pdf_mem[obj_outline_ptr(#) +2]
#define obj_outline_next(#) ==pdf_mem[obj_outline_ptr(#) +3]
#define obj_outline_first(#) ==pdf_mem[obj_outline_ptr(#) +4]
#define obj_outline_last(#) ==pdf_mem[obj_outline_ptr(#) +5]
#define obj_outline_action_objnum(#) ==pdf_mem[obj_outline_ptr(#) +6]{object number of \
action}
#define obj_outline_attr(#) ==pdf_mem[obj_outline_ptr(#) +7] \
 \
{types of destinations}
#define pdf_dest_xyz ==0
#define pdf_dest_fit ==1
#define pdf_dest_fith ==2
#define pdf_dest_fitv ==3
#define pdf_dest_fitb ==4
#define pdf_dest_fitbh ==5
#define pdf_dest_fitbv ==6
#define pdf_dest_fitr ==7 \
 \
{data structure of destinations}
#define obj_dest_ptr ==obj_aux{pointer to|pdf_dest_node|}
#define pdf_dest_node_size ==7{size of whatsit node for destination; \
words|1. .4|hold dest dimensions,word|6|identifier type,subtype \
and identifier of destination,word|6|the corresponding object number}
#define pdf_dest_type(#) ==type(#+5) {type of destination}
#define pdf_dest_named_id(#) ==subtype(#+5) {is named identifier?}
#define pdf_dest_id(#) ==link(#+5) {destination identifier}
#define pdf_dest_xyz_zoom(#) ==info(#+6) {zoom factor for|destxyz|destination}
#define pdf_dest_objnum(#) ==link(#+6) {object number of corresponding \
object} \
 \
{data structure of threads;words 1. .4 represent the coordinates of the \
corners}
#define pdf_thread_node_size ==7
#define pdf_thread_named_id(#) ==subtype(#+5) {is a named identifier}
#define pdf_thread_id(#) ==link(#+5) {thread identifier}
#define pdf_thread_attr(#) ==info(#+6) {attributes of thread}
#define obj_thread_first ==obj_aux{pointer to the first bead} \
 \
{data structure of beads}
#define pdfmem_bead_size ==5{size of memory in|pdf_mem|which \
|obj_bead_ptr|points to}
#define obj_bead_ptr ==obj_aux{pointer to|pdf_mem|}
#define obj_bead_rect(#) ==pdf_mem[obj_bead_ptr(#) ]
#define obj_bead_page(#) ==pdf_mem[obj_bead_ptr(#) +1]
#define obj_bead_next(#) ==pdf_mem[obj_bead_ptr(#) +2]
#define obj_bead_prev(#) ==pdf_mem[obj_bead_ptr(#) +3]
#define obj_bead_attr(#) ==pdf_mem[obj_bead_ptr(#) +4]
#define obj_bead_data ==obj_bead_rect{pointer to the corresponding \
whatsit node;|obj_bead_rect|is needed only when the bead rectangle has \
been written out and after that|obj_bead_data|is not needed any more \
so we can use this field for both} \
 \
{data structure of snap node}
#define snap_node_size ==3
#define snap_glue_ptr(#) ==info(#+1) 
#define final_skip(#) ==mem[#+2].sc{the amount to skip} \
{data structure of snap compensation node}
#define snapy_comp_ratio(#) ==mem[#+1].int \

#define pdf_append_list_end(#) ==#:= append_ptr(#,pdf_append_list_arg) ;end
#define pdf_append_list(#) ==begin pdf_append_list_arg:= #;pdf_append_list_end
#define set_ff(#) ==begin \
if pdf_font_num[#]<0 then \
ff:= -pdf_font_num[#] \
else \
ff:= #; \
end \

#define is_hex_char(#) ==(((#>='0') and(#<='9') ) or \
((#>='A') and(#<='F') ) or \
((#>='a') and(#<='f') ) )  \

#define new_font_type = 0{new font(has not been used yet) }
#define virtual_font_type = 1{virtual font}
#define real_font_type = 2{real font}
#define subst_font_type = 3{substituted font} \

#define set_char_and_font(#) == \
if is_char_node(#) then begin \
c:= character(#) ; \
f:= font(#) ; \
end \
else if type(#) = ligature_node then begin \
c:= character(lig_char(#) ) ; \
f:= font(lig_char(#) ) ; \
end \

#define non_existent_path =="///..." \

#define vf_replace_z == \
begin \
vf_alpha:= 16; \
while vf_z>=52 \
vf_z:= vf_z div 2; \
vf_alpha:= vf_alpha+vf_alpha; \
end; \
vf_beta:= 256 div vf_alpha; \
vf_alpha:= vf_alpha*vf_z; \
end \

#define vf_max_packet_length = 10000{max length of character packet in\.{VF}file} \

#define do_char = 70{label to go to typesetting a character of virtual font} \

#define long_char = 242{\.{VF}command for general character packet}
#define vf_id = 202{identifies\.{VF}files}
#define put1 = 133{typeset a character}
#define four_cases(#) ==#,#+1,#+2,#+3 \

#define tmp_b0 ==tmp_w.qqqq.b0
#define tmp_b1 ==tmp_w.qqqq.b1
#define tmp_b2 ==tmp_w.qqqq.b2
#define tmp_b3 ==tmp_w.qqqq.b3
#define tmp_int ==tmp_w.int \

#define bad_vf(#) ==vf_error(font_name[f],#) {quit with an error message telling the vf filename} \

#define output_one_char(#) ==begin \
if pdf_font_type[f]= new_font_type then \
do_vf(f) ; \
if pdf_font_type[f]= virtual_font_type then \
do_vf_packet(f,#)  \
else begin \
pdf_begin_string(f) ; \
pdf_print_char(f,#) ; \
adv_char_width(f,#) ; \
end; \
end \

#define delete_toks(#) ==begin delete_token_ref(#) ;#:= null;end \

#define get_next_char(#) == \
c#:= str_pool[j#]; \
incr(j#) ; \
if(c#= 92) and(j#<e#) then begin \
c#:= str_pool[j#]; \
incr(j#) ; \
if(c#>=48) and(c#<=55) then begin \
c#:= c#-48; \
if(j#<e#) and(str_pool[j#]>=48)  \
and(str_pool[j#]<=55) then begin \
c#:= 8*c#+str_pool[j#]-48; \
incr(j#) ; \
if(j#<e#) and(str_pool[j#]>=48)  \
and(str_pool[j#]<=55)  \
and(c#<32) then begin \
c#:= 8*c#+str_pool[j#]-48; \
incr(j#) ; \
end; \
end; \
end else begin \
case c#of \
98:c#:= 8;{`\.b': backspace} \
102:c#:= 12;{`\.f': form feed} \
110:c#:= 10;{`\.n': line feed} \
114:c#:= 13;{`\.r': carriage return} \
116:c#:= 9;{`\.t': horizontal tab} \
{nothing to do for`\.{\\}', `\.(',`\.) '} \
othercases do_nothing \
endcases; \
end; \
end \

#define exactly = 0{a box dimension is pre-specified}
#define additional = 1{a box dimension is increased from the natural one}
#define natural ==0,additional{shorthand for parameters to|hpack|and|vpack|} \

#define cal_margin_kern_var(#) == \
begin \
character(cp) := character(#) ; \
font(cp) := font(#) ; \
do_subst_font(cp,1000) ; \
if font(cp) <> font(#) then \
margin_kern_stretch:= margin_kern_stretch+left_pw(#) -left_pw(cp) ; \
font(cp) := font(#) ; \
do_subst_font(cp,-1000) ; \
if font(cp) <> font(#) then \
margin_kern_shrink:= margin_kern_shrink+left_pw(cp) -left_pw(#) ; \
end \

#define cal_expand_ratio ==2{calculate amount for font expansion after breaking \
paragraph into lines}
#define subst_ex_font ==3{substitute fonts} \

#define substituted = 3{|subtype|of kern nodes that should be substituted} \

#define left_pw(#) ==char_pw(#,left_side) 
#define right_pw(#) ==char_pw(#,right_side)  \

#define update_adjust_list(#) ==begin \
if#= null then \
confusion("pre vadjust") ; \
link(#) := adjust_ptr(p) ; \
while link(#) <> null do \
#:= link(#) ; \
end \

#define vpack(#) ==vpackage(#,max_dimen) {special case of unconstrained depth} \

#define noad_size = 4{number of words in a normal noad}
#define nucleus(#) ==#+1{the|nucleus|field of a noad}
#define supscr(#) ==#+2{the|supscr|field of a noad}
#define subscr(#) ==#+3{the|subscr|field of a noad}
#define math_type ==link{a|halfword|in|mem|}
#define fam ==font{a|quarterword|in|mem|}
#define math_char = 1{|math_type|when the attribute is simple}
#define sub_box = 2{|math_type|when the attribute is a box}
#define sub_mlist = 3{|math_type|when the attribute is a formula}
#define math_text_char = 4{|math_type|when italic correction is dubious} \

#define ord_noad = unset_node+3{|type|of a noad classified Ord}
#define op_noad = ord_noad+1{|type|of a noad classified Op}
#define bin_noad = ord_noad+2{|type|of a noad classified Bin}
#define rel_noad = ord_noad+3{|type|of a noad classified Rel}
#define open_noad = ord_noad+4{|type|of a noad classified Ope}
#define close_noad = ord_noad+5{|type|of a noad classified Clo}
#define punct_noad = ord_noad+6{|type|of a noad classified Pun}
#define inner_noad = ord_noad+7{|type|of a noad classified Inn}
#define limits = 1{|subtype|of|op_noad|whose scripts are to be above,below}
#define no_limits = 2{|subtype|of|op_noad|whose scripts are to be normal} \

#define left_delimiter(#) ==#+4{first delimiter field of a noad}
#define right_delimiter(#) ==#+5{second delimiter field of a fraction noad}
#define radical_noad = inner_noad+1{|type|of a noad for square roots}
#define radical_noad_size = 5{number of|mem|words in a radical noad}
#define fraction_noad = radical_noad+1{|type|of a noad for generalized fractions}
#define fraction_noad_size = 6{number of|mem|words in a fraction noad}
#define small_fam(#) ==mem[#].qqqq.b0{|fam|for``small''delimiter}
#define small_char(#) ==mem[#].qqqq.b1{|character|for``small''delimiter}
#define large_fam(#) ==mem[#].qqqq.b2{|fam|for``large''delimiter}
#define large_char(#) ==mem[#].qqqq.b3{|character|for``large''delimiter}
#define thickness ==width{|thickness|field in a fraction noad}
#define default_code ==49
#define numerator ==supscr{|numerator|field in a fraction noad}
#define denominator ==subscr{|denominator|field in a fraction noad} \

#define under_noad = fraction_noad+1{|type|of a noad for underlining}
#define over_noad = under_noad+1{|type|of a noad for overlining}
#define accent_noad = over_noad+1{|type|of a noad for accented subformulas}
#define accent_noad_size = 5{number of|mem|words in an accent noad}
#define accent_chr(#) ==#+4{the|accent_chr|field of an accent noad}
#define vcenter_noad = accent_noad+1{|type|of a noad for\.{\\vcenter}}
#define left_noad = vcenter_noad+1{|type|of a noad for\.{\\left}}
#define right_noad = left_noad+1{|type|of a noad for\.{\\right}}
#define delimiter ==nucleus{|delimiter|field in left and right noads}
#define middle_noad ==1{|subtype|of right noad representing\.{\\middle}}
#define scripts_allowed(#) ==(type(#) >=ord_noad) and(type(#) <left_noad)  \

#define style_node = unset_node+1{|type|of a style node}
#define style_node_size = 3{number of words in a style node}
#define display_style = 0{|subtype|for\.{\\displaystyle}}
#define text_style = 2{|subtype|for\.{\\textstyle}}
#define script_style = 4{|subtype|for\.{\\scriptstyle}}
#define script_script_style = 6{|subtype|for\.{\\scriptscriptstyle}}
#define cramped = 1{add this to an uncramped style if you want to cramp it} \

#define choice_node = unset_node+2{|type|of a choice node}
#define display_mlist(#) ==info(#+1) {mlist to be used in display style}
#define text_mlist(#) ==link(#+1) {mlist to be used in text style}
#define script_mlist(#) ==info(#+2) {mlist to be used in script style}
#define script_script_mlist(#) ==link(#+2) {mlist to be used in scriptscript style} \

#define text_size = 0{size code for the largest size in a family}
#define script_size = 16{size code for the medium size in a family}
#define script_script_size = 32{size code for the smallest size in a family} \

#define mathsy_end(#) ==fam_fnt(2+#) ]].sc
#define mathsy(#) ==font_info[#+param_base[mathsy_end
#define math_x_height ==mathsy(5) {height of`\.x'}
#define math_quad ==mathsy(6) {\.{18 mu}}
#define num1 ==mathsy(8) {numerator shift-up in display styles}
#define num2 ==mathsy(9) {numerator shift-up in non-display,non-\.{\\atop}}
#define num3 ==mathsy(10) {numerator shift-up in non-display\.{\\atop}}
#define denom1 ==mathsy(11) {denominator shift-down in display styles}
#define denom2 ==mathsy(12) {denominator shift-down in non-display styles}
#define sup1 ==mathsy(13) {superscript shift-up in uncramped display style}
#define sup2 ==mathsy(14) {superscript shift-up in uncramped non-display}
#define sup3 ==mathsy(15) {superscript shift-up in cramped styles}
#define sub1 ==mathsy(16) {subscript shift-down if superscript is absent}
#define sub2 ==mathsy(17) {subscript shift-down if superscript is present}
#define sup_drop ==mathsy(18) {superscript baseline below top of large box}
#define sub_drop ==mathsy(19) {subscript baseline below bottom of large box}
#define delim1 ==mathsy(20) {size of\.{\\atopwithdelims}delimiters \
in display styles}
#define delim2 ==mathsy(21) {size of\.{\\atopwithdelims}delimiters in non-displays}
#define axis_height ==mathsy(22) {height of fraction lines above the baseline}
#define total_mathsy_params = 22 \

#define mathex(#) ==font_info[#+param_base[fam_fnt(3+cur_size) ]].sc
#define default_rule_thickness ==mathex(8) {thickness of\.{\\over}bars}
#define big_op_spacing1 ==mathex(9) {minimum clearance above a displayed op}
#define big_op_spacing2 ==mathex(10) {minimum clearance below a displayed op}
#define big_op_spacing3 ==mathex(11) {minimum baselineskip above displayed op}
#define big_op_spacing4 ==mathex(12) {minimum baselineskip below displayed op}
#define big_op_spacing5 ==mathex(13) {padding above and below displayed limits}
#define total_mathex_params = 13 \

#define cramped_style(#) ==2*(#div 2) +cramped{cramp the style}
#define sub_style(#) ==2*(#div 4) +script_style+cramped{smaller and cramped}
#define sup_style(#) ==2*(#div 4) +script_style+(#mod 2) {smaller}
#define num_style(#) ==#+2-2*(#div 6) {smaller unless already script-script}
#define denom_style(#) ==2*(#div 2) +cramped+2-2*(#div 6) {smaller,cramped} \

#define mu_mult(#) ==nx_plus_y(n,#,xn_over_d(#,f,50 \

#define new_hlist(#) ==mem[nucleus(#) ].int{the translation of an mlist} \

#define done_with_noad = 80{go here when a noad has been fully translated}
#define done_with_node = 81{go here when a node has been fully converted}
#define check_dimensions = 82{go here to update|max_h|and|max_d|}
#define delete_q = 83{go here to delete|q|and move to the next node} \

#define choose_mlist(#) ==begin p:= #(q) ;#(q) := null;end \

#define math_spacing =  \
 \
"0234000122*4000133**3**344*0400400*000000234000111*1111112341011" \
 \

#define u_part(#) ==mem[#+height_offset].int{pointer to\<u_j> token list}
#define v_part(#) ==mem[#+depth_offset].int{pointer to\<v_j> token list}
#define extra_info(#) ==info(#+list_offset) {info to remember during template} \

#define preamble ==link(align_head) {the current preamble list}
#define align_stack_node_size = 6{number of|mem|words to save alignment states} \

#define span_code = 256{distinct from any character}
#define cr_code = 257{distinct from|span_code|and from any character}
#define cr_cr_code = cr_code+1{this distinguishes\.{\\crcr}from\.{\\cr}}
#define end_template_token ==cs_token_flag+frozen_end_template \

#define span_node_size = 2{number of|mem|words for a span node} \

#define tight_fit = 3{fitness classification for lines shrinking 0.5 to 1.0 of their \
shrinkability}
#define loose_fit = 1{fitness classification for lines stretching 0.5 to 1.0 of their \
stretchability}
#define very_loose_fit = 0{fitness classification for lines stretching more than \
their stretchability}
#define decent_fit = 2{fitness classification for all other lines} \

#define active_node_size_normal = 3{number of words in normal active nodes}
#define fitness ==subtype{|very_loose_fit..tight_fit|on final line for this break}
#define break_node ==rlink{pointer to the corresponding passive node}
#define line_number ==llink{line that begins at this breakpoint}
#define total_demerits(#) ==mem[#+2].int{the quantity that\TeX\minimizes}
#define unhyphenated = 0{the|type|of a normal active break node}
#define hyphenated = 1{the|type|of an active node that breaks at a|disc_node|}
#define last_active ==active{the active list ends where it begins} \

#define passive_node_size = 2{number of words in passive nodes}
#define cur_break ==rlink{in passive node,points to position of this breakpoint}
#define prev_break ==llink{points to passive node that should precede this one}
#define serial ==info{serial number for symbolic identification} \

#define delta_node_size = 9{number of words in a delta node}
#define delta_node = 2{|type|field in a delta node} \

#define do_all_six(#) ==#(1) ;#(2) ;#(3) ;#(4) ;#(5) ;#(6)  \

#define do_seven_eight(#) ==if pdf_adjust_spacing> 1 then begin#(7) ;#(8) ;end
#define do_all_eight(#) ==do_all_six(#) ;do_seven_eight(#) 
#define do_one_seven_eight(#) ==#(1) ;do_seven_eight(#)  \

#define total_font_stretch ==cur_active_width[7]
#define total_font_shrink ==cur_active_width[8] \

#define save_active_width(#) ==prev_active_width[#]:= active_width[#]
#define restore_active_width(#) ==active_width[#]:= prev_active_width[#] \

#define check_shrinkage(#) ==if(shrink_order(#) <> normal) and(shrink(#) <> 0) then \
begin#:= finite_shrink(#) ; \
end \

#define copy_to_cur_active(#) ==cur_active_width[#]:= active_width[#]
#define deactivate = 60{go here when node|r|should be deactivated} \

#define cp_skipable(#) =={skipable nodes at the margins during character protrusion} \
( \
not is_char_node(#) and \
( \
(type(#) = ins_node)  \
or(type(#) = mark_node)  \
or(type(#) = adjust_node)  \
or(type(#) = penalty_node)  \
or((type(#) = whatsit_node) and \
(subtype(#) <> pdf_refximage_node) and \
(subtype(#) <> pdf_refxform_node) ) {reference to an image or XObject form} \
or((type(#) = disc_node) and \
(pre_break(#) = null) and \
(post_break(#) = null) and \
(replace_count(#) = 0) ) {an empty|disc_node|} \
or((type(#) = math_node) and(width(#) = 0) )  \
or((type(#) = kern_node) and \
((width(#) = 0) or(subtype(#) = normal) ) )  \
or((type(#) = glue_node) and(glue_ptr(#) = zero_glue) )  \
or((type(#) = hlist_node) and(width(#) = 0) and(height(#) = 0) and \
(depth(#) = 0) and(list_ptr(#) = null) )  \
)  \
)  \
 \

#define update_width(#) == \
cur_active_width[#]:= cur_active_width[#]+mem[r+#].sc \

#define awful_bad ==55 \

#define set_break_width_to_background(#) ==break_width[#]:= background[#] \

#define reset_disc_width(#) ==disc_width[#]:= 0 \

#define add_disc_width_to_break_width(#) == \
break_width[#]:= break_width[#]+disc_width[#] \

#define add_disc_width_to_active_width(#) == \
active_width[#]:= active_width[#]+disc_width[#] \

#define sub_disc_width_from_active_width(#) == \
active_width[#]:= active_width[#]-disc_width[#] \

#define add_char_stretch_end(#) ==char_stretch(f,#) 
#define add_char_stretch(#) ==#:= #+add_char_stretch_end \

#define add_char_shrink_end(#) ==char_shrink(f,#) 
#define add_char_shrink(#) ==#:= #+add_char_shrink_end \

#define sub_char_stretch_end(#) ==char_stretch(f,#) 
#define sub_char_stretch(#) ==#:= #-sub_char_stretch_end \

#define sub_char_shrink_end(#) ==char_shrink(f,#) 
#define sub_char_shrink(#) ==#:= #-sub_char_shrink_end \

#define add_kern_stretch_end(#) ==kern_stretch(#) 
#define add_kern_stretch(#) ==#:= #+add_kern_stretch_end \

#define add_kern_shrink_end(#) ==kern_shrink(#) 
#define add_kern_shrink(#) ==#:= #+add_kern_shrink_end \

#define sub_kern_stretch_end(#) ==kern_stretch(#) 
#define sub_kern_stretch(#) ==#:= #-sub_kern_stretch_end \

#define sub_kern_shrink_end(#) ==kern_shrink(#) 
#define sub_kern_shrink(#) ==#:= #-sub_kern_shrink_end \

#define convert_to_break_width(#) == \
mem[prev_r+#].sc:= mem[prev_r+#].sc \
-cur_active_width[#]+break_width[#]
#define store_break_width(#) ==active_width[#]:= break_width[#]
#define new_delta_to_break_width(#) == \
mem[q+#].sc:= break_width[#]-cur_active_width[#] \

#define new_delta_from_break_width(#) ==mem[q+#].sc:=  \
cur_active_width[#]-break_width[#] \

#define combine_two_deltas(#) ==mem[prev_r+#].sc:= mem[prev_r+#].sc+mem[r+#].sc
#define downdate_width(#) ==cur_active_width[#]:= cur_active_width[#]- \
mem[prev_r+#].sc \

#define update_active(#) ==active_width[#]:= active_width[#]+mem[r+#].sc \

#define store_background(#) ==active_width[#]:= background[#] \

#define act_width ==active_width[1]{length from first active node to current node}
#define kern_break ==begin if not is_char_node(link(cur_p) ) and auto_breaking then \
if type(link(cur_p) ) = glue_node then try_break(0,unhyphenated) ; \
act_width:= act_width+width(cur_p) ; \
end \

#define next_break ==prev_break{new name for|prev_break|after links are reversed} \

#define append_charnode_to_t(#) ==begin link(t) := get_avail;t:= link(t) ; \
font(t) := hf;character(t) := #; \
end
#define set_cur_r ==begin if j<n then cur_r:= qi(hu[j+1]) else cur_r:= bchar; \
if odd(hyf[j]) then cur_rh:= hchar else cur_rh:= non_char; \
end \

#define wrap_lig(#) ==if ligature_present then \
begin p:= new_ligature(hf,cur_l,link(cur_q) ) ; \
if lft_hit then \
begin subtype(p) := 2;lft_hit:= false; \
end; \
if#then if lig_stack= null then \
begin incr(subtype(p) ) ;rt_hit:= false; \
end; \
link(cur_q) := p;t:= p;ligature_present:= false; \
end
#define pop_lig_stack ==begin if lig_ptr(lig_stack) > null then \
begin link(t) := lig_ptr(lig_stack) ;{this is a charnode for|hu[j+1]|} \
t:= link(t) ;incr(j) ; \
end; \
p:= lig_stack;lig_stack:= link(p) ;free_node(p,small_node_size) ; \
if lig_stack= null then set_cur_r else cur_r:= character(lig_stack) ; \
end{if|lig_stack|isn't |null| we have |cur_rh=non_char|} \

#define advance_major_tail ==begin major_tail:= link(major_tail) ;incr(r_count) ; \
end \

#define trie_link(#) ==trie_trl[#]{``downward''link in a trie}
#define trie_char(#) ==trie_trc[#]{character matched at this trie location}
#define trie_op(#) ==trie_tro[#]{program for hyphenation at this trie location} \

#define set_cur_lang ==if language<=0 then cur_lang:= 0 \
else if language> 255 then cur_lang:= 0 \
else cur_lang:= language \

#define trie_root ==trie_l[0]{root of the linked trie} \

#define trie_ref ==trie_hash{where linked trie families go into|trie|}
#define trie_back(#) ==trie_tro[#]{use the opcode field now for backward links} \

#define clear_trie =={clear|trie[r]|} \
begin trie_link(r) := 0; \
trie_op(r) := min_trie_op; \
trie_char(r) := min_quarterword;{|trie_char:= qi(0) |} \
end \

#define discard_or_move = 60
#define active_height ==active_width{new name for the six distance variables}
#define cur_height ==active_height[1]{the natural height}
#define set_height_zero(#) ==active_height[#]:= 0{initialize the height to zero} \

#define update_heights = 90{go here to record glue in the|active_height|table} \

#define deplorable ==100000{more than|inf_bad|,but less than|awful_bad|} \

#define inserts_only = 1 \
{|page_contents|when an insert node has been contributed,but no boxes}
#define box_there = 2{|page_contents|when a box or rule has been contributed} \

#define page_ins_node_size = 4{number of words for a page insertion node}
#define inserting = 0{an insertion class that has not yet overflowed}
#define split_up = 1{an overflowed insertion class}
#define broken_ptr(#) ==link(#+1)  \
{an insertion for this class will break here if anywhere}
#define broken_ins(#) ==info(#+1) {this insertion might break at|broken_ptr|}
#define last_ins_ptr(#) ==link(#+2) {the most recent insertion for this|subtype|}
#define best_ins_ptr(#) ==info(#+2) {the optimum most recent insertion} \

#define page_goal ==page_so_far[0]{desired height of information on page being built}
#define page_total ==page_so_far[1]{height of the current page}
#define page_shrink ==page_so_far[6]{shrinkability of the current page}
#define page_depth ==page_so_far[7]{depth of the current page} \

#define print_plus_end(#) ==print(#) ;end
#define print_plus(#) ==if page_so_far[#]<> 0 then \
begin print(" plus ") ;print_scaled(page_so_far[#]) ;print_plus_end \

#define set_page_so_far_zero(#) ==page_so_far[#]:= 0 \

#define contribute = 80{go here to link a node into the current page} \

#define contrib_tail ==nest[0].tail_field{tail of the contribution list} \

#define big_switch = 60{go here to branch on the next token of input}
#define main_loop = 70{go here to typeset a string of consecutive characters}
#define main_loop_wrapup = 80{go here to finish a character or ligature}
#define main_loop_move = 90{go here to advance the ligature cursor}
#define main_loop_move_lig = 95{same,when advancing past a generated ligature}
#define main_loop_lookahead = 100{go here to bring in another character,if any}
#define main_lig_loop = 110{go here to check for ligatures or kerning}
#define append_normal_space = 120{go here to append a normal space between words} \

#define adjust_space_factor == \
main_s:= sf_code(cur_chr) ; \
if main_s= 1000 then space_factor:= 1000 \
else if main_s<1000 then \
begin if main_s> 0 then space_factor:= main_s; \
end \
else if space_factor<1000 then space_factor:= 1000 \
else space_factor:= main_s \

#define pack_lig(#) =={the parameter is either|rt_hit|or|false|} \
begin main_p:= new_ligature(main_f,cur_l,link(cur_q) ) ; \
if lft_hit then \
begin subtype(main_p) := 2;lft_hit:= false; \
end; \
if#then if lig_stack= null then \
begin incr(subtype(main_p) ) ;rt_hit:= false; \
end; \
if pdf_prepend_kern> 0 then \
tmp_k2:= get_auto_kern(main_f,non_char,cur_l)  \
else \
tmp_k2:= null; \
if tmp_k2= null then begin \
link(cur_q) := main_p;tail:= main_p;ligature_present:= false; \
end \
else begin \
link(cur_q) := tmp_k2; \
link(tmp_k2) := main_p; \
tail:= main_p; \
ligature_present:= false; \
end \
end \

#define wrapup(#) ==if cur_l<non_char then \
begin if link(cur_q) > null then \
if character(tail) = qi(hyphen_char[main_f]) then ins_disc:= true; \
if ligature_present then pack_lig(#) ; \
if ins_disc then \
begin ins_disc:= false; \
if mode> 0 then tail_append(new_disc) ; \
end; \
end \

#define any_mode(#) ==vmode+#,hmode+#,mmode+#{for mode-independent commands} \

#define non_math(#) ==vmode+#,hmode+# \

#define fil_code = 0{identifies\.{\\hfil}and\.{\\vfil}}
#define fill_code = 1{identifies\.{\\hfill}and\.{\\vfill}}
#define ss_code = 2{identifies\.{\\hss}and\.{\\vss}}
#define fil_neg_code = 3{identifies\.{\\hfilneg}and\.{\\vfilneg}}
#define skip_code = 4{identifies\.{\\hskip}and\.{\\vskip}}
#define mskip_code = 5{identifies\.{\\mskip}} \

#define box_flag ==49}
#define global_box_flag ==49}
#define ship_out_flag ==49}
#define leader_flag ==49}
#define box_code = 0{|chr_code|for`\.{\\box}'}
#define copy_code = 1{|chr_code|for`\.{\\copy}'}
#define last_box_code = 2{|chr_code|for`\.{\\lastbox}'}
#define vsplit_code = 3{|chr_code|for`\.{\\vsplit}'}
#define vtop_code = 4{|chr_code|for`\.{\\vtop}'} \

#define fetch_effective_tail_eTeX(#) =={extract|tx|, \
drop\.{\\beginM}\.{\\endM}pair} \
q:= head;p:= null; \
repeat r:= p;p:= q;fm:= false; \
if not is_char_node(q) then \
if type(q) = disc_node then \
begin for m:= 1 to replace_count(q) do p:= link(p) ; \
if p= tx then#; \
end \
else if(type(q) = math_node) and(subtype(q) = begin_M_code) then fm:= true; \
q:= link(p) ; \
until q= tx;{found|r|$\to$|p|$\to$|q= tx|} \
q:= link(tx) ;link(p) := q;link(tx) := null; \
if q= null then if fm then confusion("tail1")  \
 \
else tail:= p \
else if fm then{|r|$\to$|p= begin_M|$\to$|q= end_M|} \
begin tail:= r;link(r) := null;flush_node_list(p) ;end \

#define check_effective_tail(#) ==find_effective_tail_eTeX
#define fetch_effective_tail ==fetch_effective_tail_eTeX \

#define fam_in_range ==((cur_fam>=0) and(cur_fam<16) )  \

#define above_code = 0{`\.{\\above}' }
#define over_code = 1{`\.{\\over}' }
#define atop_code = 2{`\.{\\atop}' }
#define delimited_code = 3{`\.{\\abovewithdelims}', etc.} \

#define global ==(a>=4) 
#define define(#) ==if global then geq_define(#) else eq_define(#) 
#define word_define(#) ==if global then geq_word_define(#) else eq_word_define(#)  \

#define char_def_code = 0{|shorthand_def|for\.{\\chardef}}
#define math_char_def_code = 1{|shorthand_def|for\.{\\mathchardef}}
#define count_def_code = 2{|shorthand_def|for\.{\\countdef}}
#define dimen_def_code = 3{|shorthand_def|for\.{\\dimendef}}
#define skip_def_code = 4{|shorthand_def|for\.{\\skipdef}}
#define mu_skip_def_code = 5{|shorthand_def|for\.{\\muskipdef}}
#define toks_def_code = 6{|shorthand_def|for\.{\\toksdef}}
#define char_sub_def_code = 7{|shorthand_def|for\.{\\charsubdef}} \

#define show_code = 0{\.{\\show}}
#define show_box_code = 1{\.{\\showbox}}
#define show_the_code = 2{\.{\\showthe}}
#define show_lists = 3{\.{\\showlists}} \

#define bad_fmt = 6666{go here if the format file is unacceptable}
#define too_small(#) ==begin wake_up_terminal; \
wterm_ln('---! Must increase the ',#) ; \
 \
goto bad_fmt; \
end \

#define undump_end_end(#) ==#:= x;end
#define undump_end(#) ==(x> #) then goto bad_fmt else undump_end_end
#define undump(#) ==begin undump_int(x) ;if(x<#) or undump_end
#define format_debug_end(#) == \
write_ln(stderr,' = ',#) ; \
end;
#define format_debug(#) == \
if debug_format_file then begin \
write(stderr,'fmtdebug:',#) ; \
format_debug_end
#define undump_size_end_end(#) == \
too_small(#) else format_debug(#) (x) ;undump_end_end
#define undump_size_end(#) ==if x> #then undump_size_end_end
#define undump_size(#) ==begin undump_int(x) ; \
if x<#then goto bad_fmt;undump_size_end \

#define dump_four_ASCII == \
w.b0:= qi(so(str_pool[k]) ) ;w.b1:= qi(so(str_pool[k+1]) ) ; \
w.b2:= qi(so(str_pool[k+2]) ) ;w.b3:= qi(so(str_pool[k+3]) ) ; \
dump_qqqq(w)  \

#define undump_four_ASCII == \
undump_qqqq(w) ; \
str_pool[k]:= si(qo(w.b0) ) ;str_pool[k+1]:= si(qo(w.b1) ) ; \
str_pool[k+2]:= si(qo(w.b2) ) ;str_pool[k+3]:= si(qo(w.b3) )  \

#define const_chk(#) ==begin if#<inf#then#:= inf#else \
if#> sup#then#:= sup#end \
 \
{|setup_bound_var|stuff duplicated in\.{mf.ch}.}
#define setup_bound_var(#) ==bound_default:= #;setup_bound_var_end
#define setup_bound_var_end(#) ==bound_name:= #;setup_bound_var_end_end
#define setup_bound_var_end_end(#) == \
setup_bound_variable(addressof(#) ,bound_name,bound_default)  \

#define breakpoint = 888{place where a breakpoint is desirable} \

#define write_node_size = 2{number of words in a write/whatsit node}
#define open_node_size = 3{number of words in an open/whatsit node}
#define open_node = 0{|subtype|in whatsits that represent files to\.{\\openout}}
#define write_node = 1{|subtype|in whatsits that represent things to\.{\\write}}
#define close_node = 2{|subtype|in whatsits that represent streams to\.{\\closeout}}
#define special_node = 3{|subtype|in whatsits that represent\.{\\special}things}
#define language_node = 4{|subtype|in whatsits that change the current language}
#define what_lang(#) ==link(#+1) {language number,in the range|0. .255|}
#define what_lhm(#) ==type(#+1) {minimum left fragment,in the range|1. .63|}
#define what_rhm(#) ==subtype(#+1) {minimum right fragment,in the range|1. .63|}
#define write_tokens(#) ==link(#+1) {reference count of token list to write}
#define write_stream(#) ==type(#+1) {stream number(0 to 17) }
#define mubyte_zero ==64
#define write_mubyte(#) ==subtype(#+1) {mubyte value+|mubyte_zero|}
#define open_name(#) ==link(#+1) {string number of file name to open}
#define open_area(#) ==info(#+2) {string number of file area for|open_name|}
#define open_ext(#) ==link(#+2) {string number of file extension for|open_name|} \

#define immediate_code = 4{command modifier for\.{\\immediate}}
#define set_language_code = 5{command modifier for\.{\\setlanguage}}
#define pdftex_first_extension_code = 6
#define pdf_literal_node ==pdftex_first_extension_code+0
#define pdf_obj_code ==pdftex_first_extension_code+1
#define pdf_refobj_node ==pdftex_first_extension_code+2
#define pdf_xform_code ==pdftex_first_extension_code+3
#define pdf_refxform_node ==pdftex_first_extension_code+4
#define pdf_ximage_code ==pdftex_first_extension_code+5
#define pdf_refximage_node ==pdftex_first_extension_code+6
#define pdf_annot_node ==pdftex_first_extension_code+7
#define pdf_start_link_node ==pdftex_first_extension_code+8
#define pdf_end_link_node ==pdftex_first_extension_code+9
#define pdf_outline_code ==pdftex_first_extension_code+10
#define pdf_dest_node ==pdftex_first_extension_code+11
#define pdf_thread_node ==pdftex_first_extension_code+12
#define pdf_start_thread_node ==pdftex_first_extension_code+13
#define pdf_end_thread_node ==pdftex_first_extension_code+14
#define pdf_save_pos_node ==pdftex_first_extension_code+15
#define pdf_info_code ==pdftex_first_extension_code+16
#define pdf_catalog_code ==pdftex_first_extension_code+17
#define pdf_names_code ==pdftex_first_extension_code+18
#define pdf_font_attr_code ==pdftex_first_extension_code+19
#define pdf_include_chars_code ==pdftex_first_extension_code+20
#define pdf_map_file_code ==pdftex_first_extension_code+21
#define pdf_map_line_code ==pdftex_first_extension_code+22
#define pdf_trailer_code ==pdftex_first_extension_code+23
#define pdf_trailer_id_code ==pdftex_first_extension_code+24
#define reset_timer_code ==pdftex_first_extension_code+25
#define pdf_font_expand_code ==pdftex_first_extension_code+26
#define set_random_seed_code ==pdftex_first_extension_code+27
#define pdf_snap_ref_point_node ==pdftex_first_extension_code+28
#define pdf_snapy_node ==pdftex_first_extension_code+29
#define pdf_snapy_comp_node ==pdftex_first_extension_code+30
#define pdf_glyph_to_unicode_code ==pdftex_first_extension_code+31
#define pdf_colorstack_node ==pdftex_first_extension_code+32
#define pdf_setmatrix_node ==pdftex_first_extension_code+33
#define pdf_save_node ==pdftex_first_extension_code+34
#define pdf_restore_node ==pdftex_first_extension_code+35
#define pdf_nobuiltin_tounicode_code ==pdftex_first_extension_code+36
#define pdf_interword_space_on_node ==pdftex_first_extension_code+37
#define pdf_interword_space_off_node ==pdftex_first_extension_code+38
#define pdf_fake_space_node ==pdftex_first_extension_code+39
#define pdf_running_link_off_node ==pdftex_first_extension_code+40
#define pdf_running_link_on_node ==pdftex_first_extension_code+41
#define pdftex_last_extension_code ==pdftex_first_extension_code+41 \

#define add_action_ref(#) ==incr(pdf_action_refcount(#) ) {increase count of \
references to this action} \

#define delete_action_ref(#) =={decrease count of references to this \
action;free it if there is no reference to this action} \
begin \
if pdf_action_refcount(#) = null then begin \
if pdf_action_type(#) = pdf_action_user then \
delete_token_ref(pdf_action_user_tokens(#) )  \
else begin \
if pdf_action_file(#) <> null then \
delete_token_ref(pdf_action_file(#) ) ; \
if pdf_action_type(#) = pdf_action_page then \
delete_token_ref(pdf_action_page_tokens(#) )  \
else if pdf_action_named_id(#) > 0 then \
delete_token_ref(pdf_action_id(#) ) ; \
end; \
free_node(#,pdf_action_size) ; \
end \
else \
decr(pdf_action_refcount(#) ) ; \
end \

#define adv_past(#) ==if subtype(#) = language_node then \
begin cur_lang:= what_lang(#) ;l_hyf:= what_lhm(#) ;r_hyf:= what_rhm(#) ;end \

#define end_write_token ==cs_token_flag+end_write \

#define pdf_link_stack_top ==pdf_link_stack[pdf_link_stack_ptr] \

#define eTeX_state_base = int_base+eTeX_state_code
#define eTeX_state(#) ==eqtb[eTeX_state_base+#].int{an\eTeX\state variable} \

#define eTeX_version_code = eTeX_int{code for\.{\\eTeXversion}} \

#define eTeX_ex ==(eTeX_mode= 1) {is this extended mode?} \

#define every_eof ==equiv(every_eof_loc)  \

#define current_group_level_code = eTeX_int+1{code for\.{\\currentgrouplevel}}
#define current_group_type_code = eTeX_int+2{code for\.{\\currentgrouptype}} \

#define current_if_level_code = eTeX_int+3{code for\.{\\currentiflevel}}
#define current_if_type_code = eTeX_int+4{code for\.{\\currentiftype}}
#define current_if_branch_code = eTeX_int+5{code for\.{\\currentifbranch}} \

#define font_char_wd_code = eTeX_dim{code for\.{\\fontcharwd}}
#define font_char_ht_code = eTeX_dim+1{code for\.{\\fontcharht}}
#define font_char_dp_code = eTeX_dim+2{code for\.{\\fontchardp}}
#define font_char_ic_code = eTeX_dim+3{code for\.{\\fontcharic}} \

#define par_shape_length_code = eTeX_dim+4{code for\.{\\parshapelength}}
#define par_shape_indent_code = eTeX_dim+5{code for\.{\\parshapeindent}}
#define par_shape_dimen_code = eTeX_dim+6{code for\.{\\parshapedimen}} \

#define show_groups = 4{\.{\\showgroups}} \

#define show_tokens = 5{\.{\\showtokens},must be odd!} \

#define show_ifs = 6{\.{\\showifs}} \

#define print_if_line(#) ==if#<> 0 then \
begin print(" entered on line ") ;print_int(#) ; \
end \

#define TeXXeT_state ==eTeX_state(TeXXeT_code) 
#define TeXXeT_en ==(TeXXeT_state> 0) {is\TeXXeT\enabled?} \

#define put_LR(#) ==begin temp_ptr:= get_avail;info(temp_ptr) := #; \
link(temp_ptr) := LR_ptr;LR_ptr:= temp_ptr; \
end \

#define push_LR(#) ==put_LR(end_LR_type(#) )  \

#define pop_LR ==begin temp_ptr:= LR_ptr;LR_ptr:= link(temp_ptr) ; \
free_avail(temp_ptr) ; \
end \

#define LR_dir(#) ==(subtype(#) div R_code) {text direction of a`math node'} \

#define edge_node = style_node{a|style_node|does not occur in hlists}
#define edge_node_size = style_node_size{number of words in an edge node}
#define edge_dist(#) ==depth(#) {new|left_edge|position relative to|cur_h| \
(after|width|has been taken into account) } \

#define cancel_glue(#) ==j:= new_skip_param(#) ;cancel_glue_cont
#define cancel_glue_cont(#) ==link(#) := j;cancel_glue_cont_cont
#define cancel_glue_cont_cont(#) ==link(j) := #;cancel_glue_end
#define cancel_glue_end(#) ==j:= glue_ptr(#) ;cancel_glue_end_end
#define cancel_glue_end_end(#) == \
stretch_order(temp_ptr) := stretch_order(j) ; \
shrink_order(temp_ptr) := shrink_order(j) ;width(temp_ptr) := #-width(j) ; \
stretch(temp_ptr) := -stretch(j) ;shrink(temp_ptr) := -shrink(j)  \

#define if_def_code = 17{`\.{\\ifdefined}' }
#define if_cs_code = 18{`\.{\\ifcsname}' }
#define if_font_char_code = 19{`\.{\\iffontchar}' }
#define if_in_csname_code = 20{`\.{\\ifincsname}' }
#define if_pdfabs_num_code = 22{`\.{\\ifpdfabsnum}' } { 21 = |if_pdfprimitive|}
#define if_pdfabs_dim_code = 23{`\.{\\ifpdfabsdim}' } \

#define expr_none = 0{\.(seen,or\.($\langle\it expr\rangle$\.) seen}
#define expr_add = 1{\.($\langle\it expr\rangle$\.+seen}
#define expr_sub = 2{\.($\langle\it expr\rangle$\.-seen}
#define expr_mult = 3{$\langle\it term\rangle$\.*seen}
#define expr_div = 4{$\langle\it term\rangle$\./seen}
#define expr_scale = 5{$\langle\it term\rangle$\.* \
$\langle\it factor\rangle$\./seen} \

#define expr_node_size = 4{number of words in stack entry for subexpressions}
#define expr_e_field(#) ==mem[#+1].int{saved expression so far}
#define expr_t_field(#) ==mem[#+2].int{saved term so far}
#define expr_n_field(#) ==mem[#+3].int{saved numerator} \

#define num_error(#) =={clear a number or dimension and set|arith_error|} \
begin arith_error:= true;#:= 0; \
end
#define glue_error(#) =={clear a glue spec and set|arith_error|} \
begin arith_error:= true;delete_glue_ref(#) ;#:= new_spec(zero_glue) ; \
end \

#define normalize_glue(#) == \
if stretch(#) = 0 then stretch_order(#) := normal; \
if shrink(#) = 0 then shrink_order(#) := normal \

#define expr_add_sub(#) ==add_or_sub(#,r= expr_sub) 
#define expr_a(#) ==expr_add_sub(#,max_dimen)  \

#define expr_m(#) ==#:= nx_plus_y(#,f,0)  \

#define expr_d(#) ==#:= quotient(#,f)  \

#define expr_s(#) ==#:= fract(#,n,f,max_dimen)  \

#define too_big = 88{go here when the result is too big} \

#define glue_stretch_order_code = eTeX_int+6{code for\.{\\gluestretchorder}}
#define glue_shrink_order_code = eTeX_int+7{code for\.{\\glueshrinkorder}}
#define glue_stretch_code = eTeX_dim+7{code for\.{\\gluestretch}}
#define glue_shrink_code = eTeX_dim+8{code for\.{\\glueshrink}} \

#define mu_to_glue_code = eTeX_glue{code for\.{\\mutoglue}}
#define glue_to_mu_code = eTeX_mu{code for\.{\\gluetomu}} \

#define box_val ==4{the additional box registers}
#define mark_val = 6{the additional mark classes} \

#define dimen_val_limit = 20{$2^4\cdot(|dimen_val|+1) $}
#define mu_val_limit = 40{$2^4\cdot(|mu_val|+1) $}
#define box_val_limit = 50{$2^4\cdot(|box_val|+1) $}
#define tok_val_limit = 60{$2^4\cdot(|tok_val|+1) $} \

#define index_node_size = 9{size of an index node}
#define sa_index ==type{a four-bit address or a type or both}
#define sa_used ==subtype{count of non-null pointers} \

#define sa_mark ==sa_root[mark_val]{root for mark classes} \

#define if_cur_ptr_is_null_then_return_or_goto(#) =={some tree element is missing} \
begin if cur_ptr= null then \
if w then goto#else return; \
end \

#define hex_dig1(#) ==#div 4096{the fourth lowest hexadecimal digit}
#define hex_dig2(#) ==(#div 256) mod 16{the third lowest hexadecimal digit}
#define hex_dig3(#) ==(#div 16) mod 16{the second lowest hexadecimal digit}
#define hex_dig4(#) ==#mod 16{the lowest hexadecimal digit} \

#define get_sa_ptr ==if odd(i) then cur_ptr:= link(q+(i div 2) +1)  \
else cur_ptr:= info(q+(i div 2) +1)  \
{set|cur_ptr|to the pointer indexed by|i|from index node|q|}
#define put_sa_ptr(#) ==if odd(i) then link(q+(i div 2) +1) := # \
else info(q+(i div 2) +1) := # \
{store the pointer indexed by|i|in index node|q|}
#define add_sa_ptr ==begin put_sa_ptr(cur_ptr) ;incr(sa_used(q) ) ; \
end{add|cur_ptr|as the pointer indexed by|i|in index node|q|}
#define delete_sa_ptr ==begin put_sa_ptr(null) ;decr(sa_used(q) ) ; \
end{delete the pointer indexed by|i|in index node|q|} \

#define sa_lev ==sa_used{grouping level for the current value}
#define pointer_node_size = 2{size of an element with a pointer value}
#define sa_type(#) ==(sa_index(#) div 16) {type part of combined type/index}
#define sa_ref(#) ==info(#+1) {reference count of a sparse array element}
#define sa_ptr(#) ==link(#+1) {a pointer value} \

#define word_node_size = 3{size of an element with a word value}
#define sa_num ==sa_ptr{the register number}
#define sa_int(#) ==mem[#+2].int{an integer}
#define sa_dim(#) ==mem[#+2].sc{a dimension(a somewhat esoteric distinction) } \

#define mark_class_node_size = 4{size of an element for a mark class} \

#define fetch_box(#) =={fetch|box(cur_val) |} \
if cur_val<256 then#:= box(cur_val)  \
else begin find_sa_element(box_val,cur_val,false) ; \
if cur_ptr= null then#:= null else#:= sa_ptr(cur_ptr) ; \
end \

#define add_sa_ref(#) ==incr(sa_ref(#) ) {increase reference count} \

#define change_box(#) =={change|box(cur_val) |,the|eq_level|stays the same} \
if cur_val<256 then box(cur_val) := #else set_sa_box(#)  \

#define set_sa_box(#) ==begin find_sa_element(box_val,cur_val,false) ; \
if cur_ptr<> null then \
begin sa_ptr(cur_ptr) := #;add_sa_ref(cur_ptr) ;delete_sa_ref(cur_ptr) ; \
end; \
end \

#define vsplit_init ==0{action code for|vsplit|initialization}
#define fire_up_init ==1{action code for|fire_up|initialization}
#define fire_up_done ==2{action code for|fire_up|completion}
#define destroy_marks ==3{action code for|final_cleanup|} \

#define sa_top_mark(#) ==info(#+1) {\.{\\topmarks}|n|}
#define sa_first_mark(#) ==link(#+1) {\.{\\firstmarks}|n|}
#define sa_bot_mark(#) ==info(#+2) {\.{\\botmarks}|n|}
#define sa_split_first_mark(#) ==link(#+2) {\.{\\splitfirstmarks}|n|}
#define sa_split_bot_mark(#) ==info(#+3) {\.{\\splitbotmarks}|n|} \

#define sa_loc ==sa_ref{location of saved item} \

#define sa_define(#) ==if e then \
if global then gsa_def(#) else sa_def(#)  \
else define \

#define sa_def_box =={assign|cur_box|to|box(cur_val) |} \
begin find_sa_element(box_val,cur_val,true) ; \
if global then gsa_def(cur_ptr,cur_box) else sa_def(cur_ptr,cur_box) ; \
end \

#define sa_word_define(#) ==if e then \
if global then gsa_w_def(#) else sa_w_def(#)  \
else word_define(#)  \

#define active_node_size_extended = 5{number of words in extended active nodes}
#define active_short(#) ==mem[#+3].sc{|shortfall|of this line}
#define active_glue(#) ==mem[#+4].sc{corresponding glue stretch or shrink} \

#define hyph_root ==trie_r[0]{root of the linked trie for|hyph_codes|} \

#define set_hyph_index =={set|hyph_index|for current language} \
if trie_char(hyph_start+cur_lang) <> qi(cur_lang)  \
then hyph_index:= 0{no hyphenation codes for|cur_lang|} \
else hyph_index:= trie_link(hyph_start+cur_lang)  \

#define set_lc_code(#) =={set|hc[0]|to hyphenation or lc code for|#|} \
if hyph_index= 0 then hc[0]:= lc_code(#)  \
else if trie_char(hyph_index+#) <> qi(#) then hc[0]:= 0 \
else hc[0]:= qo(trie_op(hyph_index+#) )  \

#define tail_page_disc ==disc_ptr[copy_code]{last item removed by page builder}
#define page_disc ==disc_ptr[last_box_code]{first item removed by page builder}
#define split_disc ==disc_ptr[vsplit_code]{first item removed by\.{\\vsplit}} \

#define inter_line_penalties_ptr ==equiv(inter_line_penalties_loc) 
#define club_penalties_ptr ==equiv(club_penalties_loc) 
#define widow_penalties_ptr ==equiv(widow_penalties_loc) 
#define display_widow_penalties_ptr ==equiv(display_widow_penalties_loc)  \

#define encTeX_banner ==' encTeX v. Jun. 2004' \

#define new_mubyte_node == \
link(p) := get_avail;p:= link(p) ;info(p) := get_avail;p:= info(p) 
#define subinfo (#) ==subtype(#)  \

/*4:*/
#line 385 "pdftexdir/pdftex.web"
/*9:*/
#line 475 "pdftexdir/pdftex.web"

$C-,A+,D-{no range check,catch arithmetic overflow,no debug overhead}
debug$C+,D+gubed{but turn everything on when debugging}

/*:9*/
#line 385 "pdftexdir/pdftex.web"

#line 47 "pdftex-final.ch"
program TEX;{all file names are defined dynamically}
#line 388 "pdftexdir/pdftex.web"
const/*11:*/
#line 171 "pdftex-final.ch"

hash_offset= 514;{smallest index in hash array,i.e.,|hash_base|}
{Use|hash_offset= 0|for compilers which cannot decrement pointers.}
trie_op_size= 35111;{space for``opcodes''in the hyphenation patterns;
best if relatively prime to 313,361,and 1009.}
neg_trie_op_size= -35111;{for lower|trie_op_hash|array bound;
must be equal to|-trie_op_size|.}
min_trie_op= 0;{first possible trie op code for any language}
max_trie_op= ssup_trie_opcode;{largest possible trie opcode for any language}
pool_name= TEXMF_POOL_NAME;{this is configurable,for the sake of ML-\TeX}
{string of length|file_name_size|;tells where the string pool appears}
engine_name= TEXMF_ENGINE_NAME;{the name of this engine}

inf_mem_bot= 0;
sup_mem_bot= 1;

inf_main_memory= 3000;
sup_main_memory= 256000000;

inf_trie_size= 8000;
sup_trie_size= ssup_trie_size;

inf_max_strings= 3000;
sup_max_strings= ssup_max_strings;
inf_strings_free= 100;
sup_strings_free= sup_max_strings;

inf_buf_size= 500;
sup_buf_size= 30000000;

inf_nest_size= 40;
sup_nest_size= 4000;

inf_max_in_open= 6;
sup_max_in_open= 127;

inf_param_size= 60;
sup_param_size= 32767;

inf_save_size= 600;
sup_save_size= 80000;

inf_stack_size= 200;
sup_stack_size= 30000;

inf_dvi_buf_size= 800;
sup_dvi_buf_size= 65536;

inf_font_mem_size= 20000;
sup_font_mem_size= 147483647;{|integer|-limited,so 2 could be prepended?}

sup_font_max= max_font_max;
inf_font_max= 50;{could be smaller,but why?}

inf_pool_size= 32000;
sup_pool_size= 40000000;
inf_pool_free= 1000;
sup_pool_free= sup_pool_size;
inf_string_vacancies= 8000;
sup_string_vacancies= sup_pool_size-23000;

sup_hash_extra= sup_max_strings;
inf_hash_extra= 0;

sup_hyph_size= ssup_hyph_size;
inf_hyph_size= iinf_hyphen_size;{Must be not less than|hyph_prime|!}

inf_expand_depth= 10;
sup_expand_depth= 10000000;
#line 559 "pdftexdir/pdftex.web"


/*:11*//*675:*/
#line 15256 "pdftexdir/pdftex.web"

inf_pdf_mem_size= 10000;{min size of the|pdf_mem|array}
sup_pdf_mem_size= 10000000;{max size of the|pdf_mem|array}

/*:675*//*679:*/
#line 15298 "pdftexdir/pdftex.web"

pdf_op_buf_size= 16384;{size of the PDF output buffer}
inf_pdf_os_buf_size= 1;{initial value of|pdf_os_buf_size|}
sup_pdf_os_buf_size= 5000000;{arbitrary upper hard limit of|pdf_os_buf_size|}
pdf_os_max_objs= 100;{maximum number of objects in object stream}

/*:679*//*695:*/
#line 16619 "pdftexdir/pdftex.web"

inf_obj_tab_size= 1000;{min size of the cross-reference table for PDF output}
sup_obj_tab_size= 8388607;{max size of the cross-reference table for PDF output}
inf_dest_names_size= 1000;{min size of the destination names table for PDF output}
sup_dest_names_size= 500000;{max size of the destination names table for PDF output}
inf_pk_dpi= 72;{min PK pixel density value from\.{texmf.cnf}}
sup_pk_dpi= 8000;{max PK pixel density value from\.{texmf.cnf}}
pdf_objtype_max= head_tab_max;

/*:695*//*721:*/
#line 18237 "pdftexdir/pdftex.web"

vf_max_recursion= 10;{\.{VF}files shouldn't recurse beyond this level}
vf_stack_size= 100;{\.{DVI}files shouldn't |push| beyond this depth}

/*:721*//*1628:*/
#line 36120 "pdftexdir/pdftex.web"

pdf_max_link_level= 10;{maximum depth of link nesting}

/*:1628*/
#line 388 "pdftexdir/pdftex.web"

mtype/*18:*/
#line 685 "pdftexdir/pdftex.web"

ASCII_code= 0. .255;{eight-bit numbers}

/*:18*//*25:*/
#line 920 "pdftexdir/pdftex.web"

eight_bits= 0. .255;{unsigned one-byte quantity}
alpha_file= packed file of text_char;{files that contain textual data}
byte_file= packed file of eight_bits;{files that contain binary data}

/*:25*//*38:*/
#line 1278 "pdftexdir/pdftex.web"

#line 645 "pdftex-final.ch"
pool_pointer= integer;{for variables that point into|str_pool|}
str_number= 0..ssup_max_strings;{for variables that point into|str_start|}
#line 1281 "pdftexdir/pdftex.web"
packed_ASCII_code= 0. .255;{elements of|str_pool|array}

/*:38*//*101:*/
#line 2312 "pdftexdir/pdftex.web"

scaled= integer;{this type is used for scaled integers}
nonnegative_integer= 0..49
small_number= 0. .63;{this type is self-explanatory}

/*:101*//*109:*/
#line 2504 "pdftexdir/pdftex.web"

#line 2506 "pdftexdir/pdftex.web"

/*:109*//*131:*/
#line 2965 "pdftexdir/pdftex.web"

#line 1067 "pdftex-final.ch"
quarterword= min_quarterword..max_quarterword;
halfword= min_halfword..max_halfword;
two_choices= 1. .2;{used when there are two variants in a record}
four_choices= 1. .4;{used when there are four variants in a record}
#include "texmfmem.h";
#line 1077 "pdftex-final.ch"
word_file= gzFile;
#line 2990 "pdftexdir/pdftex.web"

/*:131*//*168:*/
#line 3688 "pdftexdir/pdftex.web"

glue_ord= normal..filll;{infinity to the 0,1,2,or 3 power}

/*:168*//*230:*/
#line 4951 "pdftexdir/pdftex.web"

list_state_record= record mode_field:-mmode..mmode;
head_field,tail_field:pointer;
eTeX_aux_field:pointer;
pg_field,ml_field:integer;
aux_field:memory_word;
end;

/*:230*//*291:*/
#line 7022 "pdftexdir/pdftex.web"

group_code= 0..max_group_code;{|save_level|for a level boundary}

/*:291*//*322:*/
#line 7644 "pdftexdir/pdftex.web"

#line 1761 "pdftex-final.ch"
in_state_record= record
state_field,index_field:quarterword;
start_field,loc_field,limit_field,name_field:halfword;
synctex_tag_field:integer;{stack the tag of the current file}
end;
#line 7649 "pdftexdir/pdftex.web"

/*:322*//*574:*/
#line 12838 "pdftexdir/pdftex.web"

#line 2705 "pdftex-final.ch"
internal_font_number= integer;{|font|in a|char_node|}
font_index= integer;{index into|font_info|}
nine_bits= min_quarterword..non_char;
#line 12841 "pdftexdir/pdftex.web"

/*:574*//*621:*/
#line 14084 "pdftexdir/pdftex.web"

dvi_index= 0..dvi_buf_size;{an index into the output buffer}

/*:621*//*694:*/
#line 16374 "pdftexdir/pdftex.web"

obj_entry= record
int0,int1:integer;
int2:longinteger;
int3,int4:integer;
end;

/*:694*//*707:*/
#line 17831 "pdftexdir/pdftex.web"

char_used_array= array[0. .31]of eight_bits;
char_map_array= array[0. .32]of eight_bits;{move chars in range 0. .32}
fm_entry_ptr= ^integer;

/*:707*//*722:*/
#line 18241 "pdftexdir/pdftex.web"

vf_stack_index= 0..vf_stack_size;{an index into the stack}
vf_stack_record= record
stack_h,stack_v,stack_w,stack_x,stack_y,stack_z:scaled;
end;

/*:722*//*1095:*/
#line 26563 "pdftexdir/pdftex.web"

#line 3663 "pdftex-final.ch"
trie_pointer= 0..ssup_trie_size;{an index into|trie|}
trie_opcode= 0..ssup_trie_opcode;{a trie opcode}
#line 26565 "pdftexdir/pdftex.web"

#line 3672 "pdftex-final.ch"
/*:1095*//*1100:*/
#line 26629 "pdftexdir/pdftex.web"

#line 3727 "pdftex-final.ch"
hyph_pointer= 0..ssup_hyph_size;{index into hyphen exceptions hash table;
enlarging this requires changing(un)dump code}
#line 26631 "pdftexdir/pdftex.web"

/*:1100*//*1624:*/
#line 35924 "pdftexdir/pdftex.web"

dest_name_entry= record
objname:str_number;{destination name}
objnum:integer;{destination object number}
end;

/*:1624*//*1629:*/
#line 36123 "pdftexdir/pdftex.web"

pdf_link_stack_record= record
nesting_level:integer;
link_node:pointer;{holds a copy of the corresponding|pdf_start_link_node|}
ref_link_node:pointer;{points to original|pdf_start_link_node|,or a
copy of|link_node|created by|append_link|in
case of multi-line link}
end;

/*:1629*//*1675:*/
#line 37135 "pdftexdir/pdftex.web"

save_pointer= 0..save_size;{index into|save_stack|}

/*:1675*/
#line 389 "pdftexdir/pdftex.web"

var/*13:*/
#line 591 "pdftexdir/pdftex.web"

bad:integer;{is some``constant''wrong?}

/*:13*//*20:*/
#line 725 "pdftexdir/pdftex.web"

xord:array[text_char]of ASCII_code;
{specifies conversion of input characters}
#line 278 "pdftex-final.ch"
xchr:array[ASCII_code]of text_char;
{specifies conversion of output characters}
xprn:array[ASCII_code]of ASCII_code;
{non zero iff character is printable}
mubyte_read:array[ASCII_code]of pointer;
{non zero iff character begins the multi byte code}
mubyte_write:array[ASCII_code]of str_number;
{non zero iff character expands to multi bytes in log and write files}
mubyte_cswrite:array[0. .127]of pointer;
{non null iff cs mod 128 expands to multi bytes in log and write files}
mubyte_skip:integer;{the number of bytes to skip in|buffer|}
mubyte_keep:integer;{the number of chars we need to keep unchanged}
mubyte_skeep:integer;{saved|mubyte_keep|}
mubyte_prefix:integer;{the type of mubyte prefix}
mubyte_tablein:boolean;{the input side of table will be updated}
mubyte_tableout:boolean;{the output side of table will be updated}
mubyte_relax:boolean;{the relax prefix is used}
mubyte_start:boolean;{we are making the token at the start of the line}
mubyte_sstart:boolean;{saved|mubyte_start|}
mubyte_token:pointer;{the token returned by|read_buffer|}
mubyte_stoken:pointer;{saved first token in mubyte primitive}
mubyte_sout:integer;{saved value of|mubyte_out|}
mubyte_slog:integer;{saved value of|mubyte_log|}
spec_sout:integer;{saved value of|spec_out|}
no_convert:boolean;{conversion supressed by noconvert primitive}
active_noconvert:boolean;{true if noconvert primitive is active}
write_noexpanding:boolean;{true only if we need not write expansion}
cs_converting:boolean;{true only if we need csname converting}
special_printing:boolean;{true only if we need converting in special}
message_printing:boolean;{true if message or errmessage prints to string}
#line 730 "pdftexdir/pdftex.web"

/*:20*//*26:*/
#line 937 "pdftexdir/pdftex.web"

#line 349 "pdftex-final.ch"
name_of_file:^text_char;
#line 940 "pdftexdir/pdftex.web"
name_length:0..file_name_size;{this many characters are actually
relevant in|name_of_file|(the rest are blank)}

#line 409 "pdftex-final.ch"
/*:26*//*30:*/
#line 1037 "pdftexdir/pdftex.web"

#line 442 "pdftex-final.ch"
buffer:^ASCII_code;{lines of characters being read}
#line 1039 "pdftexdir/pdftex.web"
first:0..buf_size;{the first unused position in|buffer|}
last:0..buf_size;{end of the line just input to|buffer|}
max_buf_stack:0..buf_size;{largest index used in|buffer|}

/*:30*//*32:*/
#line 482 "pdftex-final.ch"

init
ini_version:boolean;{are we\.{INITEX}?}
dump_option:boolean;{was the dump name option used?}
dump_line:boolean;{was a\.{\%\AM format}line seen?}
tini

dump_name:const_cstring;{format name for terminal display}

bound_default:integer;{temporary for setup}
bound_name:const_cstring;{temporary for setup}

mem_bot:integer;{smallest index in the|mem|array dumped by\.{INITEX};
must not be less than|mem_min|}
main_memory:integer;{total memory words allocated in initex}
extra_mem_bot:integer;{|mem_min:= mem_bot-extra_mem_bot|except in\.{INITEX}}
mem_min:integer;{smallest index in\TeX's internal |mem| array;
must be|min_halfword|or more;
must be equal to|mem_bot|in\.{INITEX},otherwise|<=mem_bot|}
mem_top:integer;{largest index in the|mem|array dumped by\.{INITEX};
must be substantially larger than|mem_bot|,
equal to|mem_max|in\.{INITEX},else not greater than|mem_max|}
extra_mem_top:integer;{|mem_max:= mem_top+extra_mem_top|except in\.{INITEX}}
mem_max:integer;{greatest index in\TeX's internal |mem| array;
must be strictly less than|max_halfword|;
must be equal to|mem_top|in\.{INITEX},otherwise|>=mem_top|}
error_line:integer;{width of context lines on terminal error messages}
half_error_line:integer;{width of first lines of contexts in terminal
error messages;should be between 30 and|error_line-15|}
max_print_line:integer;
{width of longest text lines output;should be at least 60}
max_strings:integer;{maximum number of strings;must not exceed|max_halfword|}
strings_free:integer;{strings available after format loaded}
string_vacancies:integer;{the minimum number of characters that should be
available for the user's control sequences and font names,
after\TeX's own error messages are stored}
pool_size:integer;{maximum number of characters in strings,including all
error messages and help texts,and the names of all fonts and
control sequences;must exceed|string_vacancies|by the total
length of\TeX's own strings, which is currently about 23000}
pool_free:integer;{pool space free after format loaded}
font_mem_size:integer;{number of words of|font_info|for all fonts}
font_max:integer;{maximum internal font number;ok to exceed|max_quarterword|
and must be at most|font_base|+|max_font_max|}
font_k:integer;{loop variable for initialization}
hyph_size:integer;{maximum number of hyphen exceptions}
trie_size:integer;{space for hyphenation patterns;should be larger for
\.{INITEX}than it is in production versions of\TeX.50000 is
needed for English,German,and Portuguese.}
buf_size:integer;{maximum number of characters simultaneously present in
current lines of open files and in control sequences between
\.{\\csname}and\.{\\endcsname};must not exceed|max_halfword|}
stack_size:integer;{maximum number of simultaneous input sources}
max_in_open:integer;{maximum number of input files and error insertions that
can be going on simultaneously}
param_size:integer;{maximum number of simultaneous macro parameters}
nest_size:integer;{maximum number of semantic levels simultaneously active}
save_size:integer;{space for saving values outside of current group;must be
at most|max_halfword|}
dvi_buf_size:integer;{size of the output buffer;must be a multiple of 8}
expand_depth:integer;{limits recursive calls to the|expand|procedure}
parse_first_line_p:cinttype;{parse the first line for options}
file_line_error_style_p:cinttype;{format messages as file:line:error}
eight_bit_p:cinttype;{make all characters printable by default}
halt_on_error_p:cinttype;{stop at first error}
quoted_filename:boolean;{current filename is quoted}
{Variables for source specials}
src_specials_p:boolean;{Whether|src_specials|are enabled at all}
insert_src_special_auto:boolean;
insert_src_special_every_par:boolean;
insert_src_special_every_parend:boolean;
insert_src_special_every_cr:boolean;
insert_src_special_every_math:boolean;
insert_src_special_every_hbox:boolean;
insert_src_special_every_vbox:boolean;
insert_src_special_every_display:boolean;
#line 1113 "pdftexdir/pdftex.web"

#line 569 "pdftex-final.ch"
/*:32*//*39:*/
#line 1283 "pdftexdir/pdftex.web"

#line 653 "pdftex-final.ch"
str_pool:^packed_ASCII_code;{the characters}
str_start:^pool_pointer;{the starting pointers}
#line 1286 "pdftexdir/pdftex.web"
pool_ptr:pool_pointer;{first unused position in|str_pool|}
str_ptr:str_number;{number of the current string being created}
init_pool_ptr:pool_pointer;{the starting value of|pool_ptr|}
init_str_ptr:str_number;{the starting value of|str_ptr|}

/*:39*//*50:*/
#line 1459 "pdftexdir/pdftex.web"

init pool_file:alpha_file;{the string-pool file output by\.{TANGLE}}
tini

#line 737 "pdftex-final.ch"
/*:50*//*54:*/
#line 1566 "pdftexdir/pdftex.web"

log_file:alpha_file;{transcript of\TeX\session}
selector:0..max_selector;{where to print a message}
dig:array[0. .22]of 0. .15;{digits in a number being output}
tally:integer;{the number of characters recently printed}
term_offset:0..max_print_line;
{the number of characters on the current terminal line}
file_offset:0..max_print_line;
{the number of characters on the current file line}
#line 754 "pdftex-final.ch"
trick_buf:array[0..ssup_error_line]of ASCII_code;{circular buffer for
#line 1576 "pdftexdir/pdftex.web"
 pseudoprinting}
trick_count:integer;{threshold for pseudoprinting,explained later}
first_count:integer;{another variable for pseudoprinting}

/*:54*//*73:*/
#line 1890 "pdftexdir/pdftex.web"

#line 843 "pdftex-final.ch"
interaction:batch_mode..error_stop_mode;{current level of interaction}
interaction_option:batch_mode..unspecified_mode;{set from command line}
#line 1892 "pdftexdir/pdftex.web"

#line 850 "pdftex-final.ch"
/*:73*//*76:*/
#line 1931 "pdftexdir/pdftex.web"

deletions_allowed:boolean;{is it safe for|error|to call|get_token|?}
set_box_allowed:boolean;{is it safe to do a\.{\\setbox}assignment?}
history:spotless..fatal_error_stop;{has the source input been clean so far?}
error_count:-1. .100;{the number of scrolled errors since the
last paragraph ended}

/*:76*//*79:*/
#line 1987 "pdftexdir/pdftex.web"

help_line:array[0. .5]of str_number;{helps for the next|error|}
help_ptr:0. .6;{the number of help lines present}
use_err_help:boolean;{should the|err_help|list be shown?}

/*:79*//*96:*/
#line 2249 "pdftexdir/pdftex.web"

interrupt:integer;{should\TeX\pause for instructions?}
OK_to_interrupt:boolean;{should interrupts be observed?}

/*:96*//*104:*/
#line 982 "pdftex-final.ch"

#line 2383 "pdftexdir/pdftex.web"
arith_error:boolean;{has arithmetic overflow occurred recently?}
remainder:scaled;{amount subtracted to get an exact division}

/*:104*//*110:*/
#line 2538 "pdftexdir/pdftex.web"

randoms:array[0. .54]of integer;{the last 55 random values generated}
j_random:0. .54;{the number of unused|randoms|}
random_seed:scaled;{the default random seed}

/*:110*//*117:*/
#line 2691 "pdftexdir/pdftex.web"

two_to_the:array[0. .30]of integer;{powers of two}
spec_log:array[1. .28]of integer;{special logarithms}


/*:117*//*133:*/
#line 3025 "pdftexdir/pdftex.web"

temp_ptr:pointer;{a pointer variable for occasional emergency use}

/*:133*//*134:*/
#line 3057 "pdftexdir/pdftex.web"

#line 1083 "pdftex-final.ch"
yzmem:^memory_word;{the big dynamic storage area}
zmem:^memory_word;{the big dynamic storage area}
#line 3059 "pdftexdir/pdftex.web"
lo_mem_max:pointer;{the largest location of variable-size memory in use}
hi_mem_min:pointer;{the smallest location of one-word memory in use}

/*:134*//*135:*/
#line 3068 "pdftexdir/pdftex.web"

var_used,dyn_used:integer;{how much memory is in use}

/*:135*//*136:*/
#line 3084 "pdftexdir/pdftex.web"

avail:pointer;{head of the list of available one-word nodes}
mem_end:pointer;{the last one-word node used in|mem|}

/*:136*//*142:*/
#line 3183 "pdftexdir/pdftex.web"

rover:pointer;{points to some node in the list of empties}

/*:142*//*183:*/
#line 3934 "pdftexdir/pdftex.web"

#line 1210 "pdftex-final.ch"
{The debug memory arrays have not been mallocated yet.}
debug free:packed array[0. .9]of boolean;{free cells}
was_free:packed array[0. .9]of boolean;
#line 3937 "pdftexdir/pdftex.web"
{previously free cells}
was_mem_end,was_lo_max,was_hi_min:pointer;
{previous|mem_end|,|lo_mem_max|,and|hi_mem_min|}
panicking:boolean;{do we want to check memory constantly?}
gubed

/*:183*//*191:*/
#line 4084 "pdftexdir/pdftex.web"

font_in_short_display:integer;{an internal font number}

/*:191*//*199:*/
#line 4239 "pdftexdir/pdftex.web"

depth_threshold:integer;{maximum nesting depth in box displays}
breadth_max:integer;{maximum number of items shown at the same list level}

/*:199*//*231:*/
#line 4974 "pdftexdir/pdftex.web"

#line 1363 "pdftex-final.ch"
nest:^list_state_record;
#line 4976 "pdftexdir/pdftex.web"
nest_ptr:0..nest_size;{first unused location of|nest|}
max_nest_stack:0..nest_size;{maximum of|nest_ptr|when pushing}
cur_list:list_state_record;{the``top''semantic state}
shown_mode:-mmode..mmode;{most recent mode shown by\.{\\tracingcommands}}
save_tail:pointer;{save|tail|so we can examine whether we have an auto
kern before a glue}

/*:231*//*264:*/
#line 6185 "pdftexdir/pdftex.web"

old_setting:0..max_selector;

/*:264*//*271:*/
#line 6417 "pdftexdir/pdftex.web"

#line 1592 "pdftex-final.ch"
zeqtb:^memory_word;
#line 6419 "pdftexdir/pdftex.web"
xeq_level:array[int_base..eqtb_size]of quarterword;

/*:271*//*274:*/
#line 6465 "pdftexdir/pdftex.web"

#line 1600 "pdftex-final.ch"
hash:^two_halves;{the hash table}
yhash:^two_halves;{auxiliary pointer for freeing hash}
hash_used:pointer;{allocation pointer for|hash|}
hash_extra:pointer;{|hash_extra= hash|above|eqtb_size|}
hash_top:pointer;{maximum of the hash array}
eqtb_top:pointer;{maximum of the|eqtb|}
hash_high:pointer;{pointer to next high hash location}
#line 6469 "pdftexdir/pdftex.web"
no_new_control_sequence:boolean;{are new identifiers legal?}
cs_count:integer;{total number of known identifiers}

/*:274*//*275:*/
#line 6488 "pdftexdir/pdftex.web"

prim:array[0..prim_size]of two_halves;{the primitives table}
prim_used:pointer;{allocation pointer for|prim|}

/*:275*//*293:*/
#line 7031 "pdftexdir/pdftex.web"

#line 1739 "pdftex-final.ch"
save_stack:^memory_word;
#line 7033 "pdftexdir/pdftex.web"
save_ptr:0..save_size;{first unused entry on|save_stack|}
max_save_stack:0..save_size;{maximum usage of save stack}
cur_level:quarterword;{current nesting level for groups}
cur_group:group_code;{current group type}
cur_boundary:0..save_size;{where the current level begins}

/*:293*//*308:*/
#line 7294 "pdftexdir/pdftex.web"

mag_set:integer;{if nonzero,this magnification should be used henceforth}

/*:308*//*319:*/
#line 7553 "pdftexdir/pdftex.web"

cur_cmd:eight_bits;{current command set by|get_next|}
cur_chr:halfword;{operand of current command}
cur_cs:pointer;{control sequence found here,zero if none found}
cur_tok:halfword;{packed representative of|cur_cmd|and|cur_chr|}

/*:319*//*323:*/
#line 7650 "pdftexdir/pdftex.web"

#line 1771 "pdftex-final.ch"
input_stack:^in_state_record;
#line 7652 "pdftexdir/pdftex.web"
input_ptr:0..stack_size;{first unused location of|input_stack|}
max_in_stack:0..stack_size;{largest value of|input_ptr|when pushing}
cur_input:in_state_record;
{the``top''input state,according to convention(1)}

/*:323*//*326:*/
#line 7754 "pdftexdir/pdftex.web"

in_open:0..max_in_open;{the number of lines in the buffer,less one}
open_parens:0..max_in_open;{the number of open text files}
#line 1786 "pdftex-final.ch"
input_file:^alpha_file;
line:integer;{current line number in the current source file}
line_stack:^integer;
source_filename_stack:^str_number;
full_source_filename_stack:^str_number;
#line 7760 "pdftexdir/pdftex.web"

/*:326*//*327:*/
#line 7797 "pdftexdir/pdftex.web"

scanner_status:normal..absorbing;{can a subfile end now?}
warning_index:pointer;{identifier relevant to non-|normal|scanner status}
def_ref:pointer;{reference count of token list being defined}

/*:327*//*330:*/
#line 7929 "pdftexdir/pdftex.web"

#line 1825 "pdftex-final.ch"
param_stack:^pointer;
{token list pointers for parameters}
#line 7932 "pdftexdir/pdftex.web"
param_ptr:0..param_size;{first unused entry in|param_stack|}
max_param_stack:integer;
{largest value of|param_ptr|,will be|<=param_size+9|}

/*:330*//*331:*/
#line 7946 "pdftexdir/pdftex.web"

align_state:integer;{group level with respect to current alignment}

/*:331*//*332:*/
#line 7957 "pdftexdir/pdftex.web"

base_ptr:0..stack_size;{shallowest level shown by|show_context|}

/*:332*//*355:*/
#line 8351 "pdftexdir/pdftex.web"

par_loc:pointer;{location of`\.{\\par}' in |eqtb|}
par_token:halfword;{token representing`\.{\\par}'}

/*:355*//*383:*/
#line 8778 "pdftexdir/pdftex.web"

force_eof:boolean;{should the next\.{\\input}be aborted early?}

/*:383*//*389:*/
#line 8923 "pdftexdir/pdftex.web"

is_in_csname:boolean;

/*:389*//*408:*/
#line 9198 "pdftexdir/pdftex.web"

cur_mark:array[top_mark_code..split_bot_mark_code]of pointer;
{token lists for marks}

/*:408*//*413:*/
#line 9252 "pdftexdir/pdftex.web"

long_state:call..long_outer_call;{governs the acceptance of\.{\\par}}

/*:413*//*414:*/
#line 9263 "pdftexdir/pdftex.web"

pstack:array[0. .8]of pointer;{arguments supplied to a macro}

/*:414*//*436:*/
#line 9653 "pdftexdir/pdftex.web"

cur_val:integer;{value returned by numeric scanners}
cur_val_level:int_val..tok_val;{the``level''of this value}

/*:436*//*464:*/
#line 10197 "pdftexdir/pdftex.web"

radix:small_number;{|scan_int|sets this to 8,10,16,or zero}

/*:464*//*473:*/
#line 10335 "pdftexdir/pdftex.web"

cur_order:glue_ord;{order of infinity found by|scan_dimen|}

/*:473*//*506:*/
#line 11533 "pdftexdir/pdftex.web"

read_file:array[0. .15]of alpha_file;{used for\.{\\read}}
read_open:array[0. .16]of normal..closed;{state of|read_file[n]|}

/*:506*//*515:*/
#line 11730 "pdftexdir/pdftex.web"

cond_ptr:pointer;{top of the condition stack}
if_limit:normal..or_code;{upper bound on|fi_or_else|codes}
cur_if:small_number;{type of conditional being worked on}
if_line:integer;{line where that conditional began}

/*:515*//*519:*/
#line 11756 "pdftexdir/pdftex.web"

skip_line:integer;{skipping began here}

/*:519*//*538:*/
#line 12109 "pdftexdir/pdftex.web"

cur_name:str_number;{name of file just scanned}
cur_area:str_number;{file area just scanned,or\.{""}}
cur_ext:str_number;{file extension just scanned,or\.{""}}

#line 2110 "pdftex-final.ch"
/*:538*//*539:*/
#line 12125 "pdftexdir/pdftex.web"

#line 2123 "pdftex-final.ch"
area_delimiter:pool_pointer;{the most recent`\./', if any}
ext_delimiter:pool_pointer;{the most recent`\..', if any}
#line 12128 "pdftexdir/pdftex.web"

/*:539*//*546:*/
#line 12228 "pdftexdir/pdftex.web"

#line 2364 "pdftex-final.ch"
format_default_length:integer;
TEX_format_default:cstring;

/*:546*//*553:*/
#line 12362 "pdftexdir/pdftex.web"

name_in_progress:boolean;{is a file name being scanned?}
job_name:str_number;{principal file name}
log_opened:boolean;{has the transcript file been opened?}

/*:553*//*558:*/
#line 12434 "pdftexdir/pdftex.web"

dvi_file:byte_file;{the device-independent output goes here}
output_file_name:str_number;{full name of the output file}
log_name:str_number;{full name of the log file}

/*:558*//*565:*/
#line 12561 "pdftexdir/pdftex.web"

tfm_file:byte_file;

/*:565*//*575:*/
#line 12847 "pdftexdir/pdftex.web"

#line 2742 "pdftex-final.ch"
font_info:^fmemory_word;
{the big collection of font data}
fmem_ptr:font_index;{first unused word of|font_info|}
font_ptr:internal_font_number;{largest internal font number in use}
font_check:^four_quarters;{check sum}
font_size:^scaled;{``at''size}
font_dsize:^scaled;{``design''size}
font_params:^font_index;{how many font
parameters are present}
font_name:^str_number;{name of the font}
font_area:^str_number;{area of the font}
font_bc:^eight_bits;
{beginning(smallest)character code}
font_ec:^eight_bits;
{ending(largest)character code}
font_glue:^pointer;
{glue specification for interword space,|null|if not allocated}
font_used:^boolean;
{has a character from this font actually appeared in the output?}
hyphen_char:^integer;
{current\.{\\hyphenchar}values}
skew_char:^integer;
{current\.{\\skewchar}values}
bchar_label:^font_index;
{start of|lig_kern|program for left boundary character,
|non_address|if there is none}
font_bchar:^nine_bits;
{right boundary character,|non_char|if there is none}
font_false_bchar:^nine_bits;
{|font_bchar|if it doesn't exist in the font, otherwise |non_char|}
#line 12878 "pdftexdir/pdftex.web"

/*:575*//*576:*/
#line 12888 "pdftexdir/pdftex.web"

#line 2794 "pdftex-final.ch"
char_base:^integer;
{base addresses for|char_info|}
width_base:^integer;
{base addresses for widths}
height_base:^integer;
{base addresses for heights}
depth_base:^integer;
{base addresses for depths}
italic_base:^integer;
{base addresses for italic corrections}
lig_kern_base:^integer;
{base addresses for ligature/kerning programs}
kern_base:^integer;
{base addresses for kerns}
exten_base:^integer;
{base addresses for extensible recipes}
param_base:^integer;
{base addresses for font parameters}
#line 12907 "pdftexdir/pdftex.web"

/*:576*//*581:*/
#line 12982 "pdftexdir/pdftex.web"

null_character:four_quarters;{nonexistent character information}

/*:581*//*619:*/
#line 14043 "pdftexdir/pdftex.web"

total_pages:integer;{the number of pages that have been shipped out}
max_v:scaled;{maximum height-plus-depth of pages shipped so far}
max_h:scaled;{maximum width of pages shipped so far}
max_push:integer;{deepest nesting of|push|commands encountered so far}
last_bop:integer;{location of previous|bop|in the\.{DVI}output}
dead_cycles:integer;{recent outputs that didn't ship anything out}
doing_leaders:boolean;{are we inside a leader box?}

#line 3035 "pdftex-final.ch"
{character and font in current|char_node|}
c:quarterword;
f:internal_font_number;
#line 14053 "pdftexdir/pdftex.web"
rule_ht,rule_dp,rule_wd:scaled;{size of current rule being output}
g:pointer;{current glue specification}
lq,lr:integer;{quantities used in calculations for leaders}

/*:619*//*622:*/
#line 14091 "pdftexdir/pdftex.web"

#line 3046 "pdftex-final.ch"
dvi_buf:^eight_bits;{buffer for\.{DVI}output}
half_buf:integer;{half of|dvi_buf_size|}
dvi_limit:integer;{end of the current half buffer}
dvi_ptr:integer;{the next available buffer address}
#line 14096 "pdftexdir/pdftex.web"
dvi_offset:integer;{|dvi_buf_size|times the number of times the
output buffer has been fully emptied}
dvi_gone:integer;{the number of bytes already output to|dvi_file|}

/*:622*//*632:*/
#line 14256 "pdftexdir/pdftex.web"

down_ptr,right_ptr:pointer;{heads of the down and right stacks}

/*:632*//*643:*/
#line 14506 "pdftexdir/pdftex.web"

dvi_h,dvi_v:scaled;{a\.{DVI}reader program thinks we are here}
cur_h,cur_v:scaled;{\TeX\thinks we are here}
dvi_f:internal_font_number;{the current font}
cur_s:integer;{current depth of output box nesting,initially $-1 $}

/*:643*//*676:*/
#line 15260 "pdftexdir/pdftex.web"

pdf_mem_size:integer;
pdf_mem:^integer;
pdf_mem_ptr:integer;

/*:676*//*680:*/
#line 15337 "pdftexdir/pdftex.web"

pdf_file:byte_file;{the PDF output file}
pdf_buf:^eight_bits;{pointer to the PDF output buffer or PDF object stream buffer}
pdf_buf_size:integer;{end of PDF output buffer or PDF object stream buffer}
pdf_ptr:integer;{pointer to the first unused byte in the PDF buffer or object stream buffer}
pdf_op_buf:^eight_bits;{the PDF output buffer}
pdf_os_buf:^eight_bits;{the PDF object stream buffer}
pdf_os_buf_size:integer;{current size of the PDF object stream buffer,grows dynamically}
pdf_os_objnum:^integer;{array of object numbers within object stream}
pdf_os_objoff:^integer;{array of object offsets within object stream}
pdf_os_objidx:pointer;{pointer into|pdf_os_objnum|and|pdf_os_objoff|}
pdf_os_cntr:integer;{counter for object stream objects}
pdf_op_ptr:integer;{store for PDF buffer|pdf_ptr|while inside object streams}
pdf_os_ptr:integer;{store for object stream|pdf_ptr|while outside object streams}
pdf_os_mode:boolean;{true if producing object stream}
pdf_os_enable:boolean;{true if object streams are globally enabled}
pdf_os_cur_objnum:integer;{number of current object stream object}
pdf_gone:longinteger;{number of bytes that were flushed to output}
pdf_save_offset:longinteger;{to save|pdf_offset|}
zip_write_state:integer;{which state of compression we are in}
fixed_pdf_major_version:integer;{fixed major part of the PDF version}
fixed_pdf_minor_version:integer;{fixed minor part of the PDF version}
fixed_pdf_objcompresslevel:integer;{fixed level for activating PDF object streams}
pdf_version_written:boolean;{flag if the PDF version has been written}
fixed_pdfoutput:integer;{fixed output format}
fixed_pdfoutput_set:boolean;{|fixed_pdfoutput|has been set?}
fixed_gamma:integer;
fixed_image_gamma:integer;
fixed_image_hicolor:boolean;
fixed_image_apply_gamma:integer;
epochseconds:integer;
microseconds:integer;
fixed_pdf_draftmode:integer;{fixed\\pdfdraftmode}
fixed_pdf_draftmode_set:boolean;{|fixed_pdf_draftmode|has been set?}
pdf_page_group_val:integer;

/*:680*//*687:*/
#line 15745 "pdftexdir/pdftex.web"

one_bp:scaled;{scaled value corresponds to 1 bp}
one_hundred_bp:scaled;{scaled value corresponds to 100 bp}
one_hundred_inch:scaled;{scaled value corresponds to 100 in}
ten_pow:array[0. .9]of integer;{$10^0. .10^9 $}
scaled_out:integer;{amount of|scaled|that was taken out in
|divide_scaled|}
init_pdf_output:boolean;

/*:687*//*691:*/
#line 15910 "pdftexdir/pdftex.web"

pdf_f:internal_font_number;{the current font in PDF output page}
pdf_h:scaled;{current horizontal coordinate in PDF output page}
pdf_v:scaled;{current vertical coordinate in PDF output page}
pdf_tj_start_h:scaled;{horizontal coordinate in PDF output page just before\.{TJ}array start}
cur_delta_h:scaled;{horizontal|cur_h|offset from|pdf_tj_start_h|}
pdf_delta_h:scaled;{horizontal offset from|pdf_tj_start_h|}
pdf_origin_h:scaled;{current horizontal origin in PDF output page}
pdf_origin_v:scaled;{current vertical origin in PDF output page}
pdf_doing_string:boolean;{we are writing string to PDF file?}
pdf_doing_text:boolean;{we are writing text section to PDF file?}
min_bp_val:scaled;
min_font_val:scaled;{(TJ array system)}
fixed_pk_resolution:integer;
fixed_decimal_digits:integer;
fixed_gen_tounicode:integer;
fixed_inclusion_copy_font:integer;
pk_scale_factor:integer;
pdf_output_option:integer;
pdf_output_value:integer;
pdf_draftmode_option:integer;
pdf_draftmode_value:integer;
pdf_cur_Tm_a:integer;{|a|value of the current text matrix,i.e.,the current
horizontal scaling factor}
pdf_last_f:internal_font_number;{last font in PDF output page}
pdf_last_fs:internal_font_number;{last font size in PDF output page}
pdf_dummy_font:internal_font_number;{font used to insert artificial interword spaces}


/*:691*//*696:*/
#line 16628 "pdftexdir/pdftex.web"

obj_tab_size:integer;
obj_tab:^obj_entry;
head_tab:array[1..head_tab_max]of integer;
pages_tail:integer;
obj_ptr:integer;{user objects counter}
sys_obj_ptr:integer;{system objects counter,including object streams}
pdf_last_pages:integer;{pointer to most recently generated pages object}
pdf_last_page:integer;{pointer to most recently generated page object}
pdf_last_stream:integer;{pointer to most recently generated stream}
pdf_stream_length:longinteger;{length of most recently generated stream}
pdf_stream_length_offset:longinteger;{file offset of the last stream length}
pdf_seek_write_length:boolean;{flag whether to seek back and write\.{/Length}}
pdf_last_byte:eight_bits;{byte most recently written to PDF file;for\.{endstream}in new line}
pdf_append_list_arg:integer;{for use with|pdf_append_list|}
ff:integer;{for use with|set_ff|}
pdf_box_spec_media:integer;
pdf_box_spec_crop:integer;
pdf_box_spec_bleed:integer;
pdf_box_spec_trim:integer;
pdf_box_spec_art:integer;

/*:696*//*701:*/
#line 16946 "pdftexdir/pdftex.web"

pdf_image_procset:integer;{collection of image types used in current page/form}
pdf_text_procset:boolean;{mask of used ProcSet's in the current page/form}

/*:701*//*704:*/
#line 17104 "pdftexdir/pdftex.web"

pdf_font_type:^eight_bits;{the type of font}
pdf_font_attr:^str_number;{pointer to additional attributes}
pdf_font_nobuiltin_tounicode:^boolean;{disable generating ToUnicode for this font?}

/*:704*//*708:*/
#line 17836 "pdftexdir/pdftex.web"

pdf_char_used:^char_used_array;{to mark used chars}
pdf_font_size:^scaled;{used size of font in PDF file}
pdf_font_num:^integer;{mapping between internal font number in\TeX\and
font name defined in resources in PDF file}
pdf_font_map:^fm_entry_ptr;{pointer into AVL tree of font mappings}
pdf_font_list:pointer;{list of used fonts in current page}
pdf_resname_prefix:str_number;{global prefix of resources name}
last_tokens_string:str_number;{the number of the most recently string
created by|tokens_to_string|}

/*:708*//*710:*/
#line 17870 "pdftexdir/pdftex.web"

vf_packet_base:^integer;{base addresses of character packets from virtual fonts}
vf_default_font:^internal_font_number;{default font in a\.{VF}file}
vf_local_font_num:^internal_font_number;{number of local fonts in a\.{VF}file}
vf_packet_length:integer;{length of the current packet}
vf_file:byte_file;
vf_nf:internal_font_number;{the local fonts counter}
vf_e_fnts:^integer;{external font numbers}
vf_i_fnts:^internal_font_number;{corresponding internal font numbers}
tmp_w:memory_word;{accumulator}

/*:710*//*723:*/
#line 18247 "pdftexdir/pdftex.web"

vf_cur_s:0..vf_max_recursion;{current recursion level}
vf_stack:array[vf_stack_index]of vf_stack_record;
vf_stack_ptr:vf_stack_index;{pointer into|vf_stack|}

/*:723*//*774:*/
#line 19370 "pdftexdir/pdftex.web"

saved_pdf_cur_form:integer;

/*:774*//*809:*/
#line 20203 "pdftexdir/pdftex.web"

pdftex_banner:str_number;{the complete banner}

/*:809*//*816:*/
#line 20392 "pdftexdir/pdftex.web"

total_stretch,total_shrink:array[glue_ord]of scaled;
{glue found by|hpack|or|vpack|}
last_badness:integer;{badness of the most recently packaged box}

/*:816*//*817:*/
#line 20402 "pdftexdir/pdftex.web"

adjust_tail:pointer;{tail of adjustment list}

/*:817*//*819:*/
#line 20407 "pdftexdir/pdftex.web"

pdf_font_blink:^internal_font_number;{link to base font(used for expanded fonts only)}
pdf_font_elink:^internal_font_number;{link to expanded fonts(used for base fonts only)}
pdf_font_stretch:^integer;{link to font expanded by stretch limi}
pdf_font_shrink:^integer;{link to font expanded by shrink limit}
pdf_font_step:^integer;{amount of one step of expansion}
pdf_font_expand_ratio:^integer;{expansion ratio of a particular font}
pdf_font_auto_expand:^boolean;{this font is auto-expanded?}
pdf_font_lp_base:^integer;{base of left-protruding factor}
pdf_font_rp_base:^integer;{base of right-protruding factor}
pdf_font_ef_base:^integer;{base of font expansion factor}
pdf_font_kn_bs_base:^integer;{base of kern before space}
pdf_font_st_bs_base:^integer;{base of stretch before space}
pdf_font_sh_bs_base:^integer;{base of shrink before space}
pdf_font_kn_bc_base:^integer;{base of kern before character}
pdf_font_kn_ac_base:^integer;{base of kern after character}
font_expand_ratio:integer;{current expansion ratio}
last_leftmost_char:pointer;
last_rightmost_char:pointer;
hlist_stack:array[0..max_hlist_stack]of pointer;{stack for|find_protchar_left()|and|find_protchar_right()|}
hlist_stack_level:0..max_hlist_stack;{fill level for|hlist_stack|}

/*:819*//*827:*/
#line 20899 "pdftexdir/pdftex.web"

pre_adjust_tail:pointer;

/*:827*//*835:*/
#line 21001 "pdftexdir/pdftex.web"

pack_begin_line:integer;{source file line where the current paragraph
or alignment began;a negative value denotes alignment}

/*:835*//*858:*/
#line 21425 "pdftexdir/pdftex.web"

empty_field:two_halves;
null_delimiter:four_quarters;

/*:858*//*893:*/
#line 22085 "pdftexdir/pdftex.web"

cur_mlist:pointer;{beginning of mlist to be translated}
cur_style:small_number;{style code at current place in the list}
cur_size:small_number;{size code corresponding to|cur_style|}
cur_mu:scaled;{the math unit width corresponding to|cur_size|}
mlist_penalties:boolean;{should|mlist_to_hlist|insert penalties?}

/*:893*//*898:*/
#line 22175 "pdftexdir/pdftex.web"

cur_f:internal_font_number;{the|font|field of a|math_char|}
cur_c:quarterword;{the|character|field of a|math_char|}
cur_i:four_quarters;{the|char_info|of a|math_char|,
or a lig/kern instruction}

/*:898*//*938:*/
#line 23000 "pdftexdir/pdftex.web"

magic_offset:integer;{used to find inter-element spacing}

/*:938*//*944:*/
#line 23201 "pdftexdir/pdftex.web"

cur_align:pointer;{current position in preamble list}
cur_span:pointer;{start of currently spanned columns in preamble list}
cur_loop:pointer;{place to copy when extending a periodic preamble}
align_ptr:pointer;{most recently pushed-down alignment stack node}
cur_head,cur_tail:pointer;{adjustment list pointers}
cur_pre_head,cur_pre_tail:pointer;{pre-adjustment list pointers}

/*:944*//*988:*/
#line 23995 "pdftexdir/pdftex.web"

just_box:pointer;{the|hlist_node|for the last line of the new paragraph}

/*:988*//*995:*/
#line 24141 "pdftexdir/pdftex.web"

passive:pointer;{most recent node on passive list}
printed_node:pointer;{most recent node that has been printed}
pass_number:halfword;{the number of passive nodes allocated on this pass}

/*:995*//*997:*/
#line 24190 "pdftexdir/pdftex.web"

active_width:array[1. .8]of scaled;
{distance from first active node to~|cur_p|}
cur_active_width:array[1. .8]of scaled;{distance from current active node}
background:array[1. .8]of scaled;{length of an``empty''line}
break_width:array[1. .8]of scaled;{length being computed after current break}

auto_breaking:boolean;{make|auto_breaking|accessible out of|line_break|}
prev_p:pointer;{make|prev_p|accessible out of|line_break|}
first_p:pointer;{to access the first node of the paragraph}
prev_char_p:pointer;{pointer to the previous char of an implicit kern}
next_char_p:pointer;{pointer to the next char of an implicit kern}

try_prev_break:boolean;{force break at the previous legal breakpoint?}
prev_legal:pointer;{the previous legal breakpoint}
prev_prev_legal:pointer;{to save|prev_p|corresponding to|prev_legal|}
prev_auto_breaking:boolean;{to save|auto_breaking|corresponding to|prev_legal|}
prev_active_width:array[1. .8]of scaled;{to save|active_width|corresponding to|prev_legal|}
rejected_cur_p:pointer;{the last|cur_p|that has been rejected}
before_rejected_cur_p:boolean;{|cur_p|is still before|rejected_cur_p|?}

max_stretch_ratio:integer;{maximal stretch ratio of expanded fonts}
max_shrink_ratio:integer;{maximal shrink ratio of expanded fonts}
cur_font_step:integer;{the current step of expanded fonts}

/*:997*//*999:*/
#line 24265 "pdftexdir/pdftex.web"

no_shrink_error_yet:boolean;{have we complained about infinite shrinkage?}

/*:999*//*1002:*/
#line 24326 "pdftexdir/pdftex.web"

cur_p:pointer;{the current breakpoint under consideration}
second_pass:boolean;{is this our second attempt to break this paragraph?}
final_pass:boolean;{is this our final attempt to break this paragraph?}
threshold:integer;{maximum badness on feasible lines}

/*:1002*//*1007:*/
#line 24587 "pdftexdir/pdftex.web"

minimal_demerits:array[very_loose_fit..tight_fit]of integer;{best total
demerits known for current line class and position,given the fitness}
minimum_demerits:integer;{best total demerits known for current line class
and position}
best_place:array[very_loose_fit..tight_fit]of pointer;{how to achieve
|minimal_demerits|}
best_pl_line:array[very_loose_fit..tight_fit]of halfword;{corresponding
line number}

/*:1007*//*1013:*/
#line 24742 "pdftexdir/pdftex.web"

disc_width:array[1. .8]of scaled;{the length of discretionary material preceding a break}

/*:1013*//*1021:*/
#line 24914 "pdftexdir/pdftex.web"

easy_line:halfword;{line numbers|> easy_line|are equivalent in break nodes}
last_special_line:halfword;{line numbers|> last_special_line|all have
the same width}
first_width:scaled;{the width of all lines|<=last_special_line|,if
no\.{\\parshape}has been specified}
second_width:scaled;{the width of all lines|> last_special_line|}
first_indent:scaled;{left margin to go with|first_width|}
second_indent:scaled;{left margin to go with|second_width|}

/*:1021*//*1046:*/
#line 25515 "pdftexdir/pdftex.web"

best_bet:pointer;{use this passive node and its predecessors}
fewest_demerits:integer;{the demerits associated with|best_bet|}
best_line:halfword;{line number following the last line of the new paragraph}
actual_looseness:integer;{the difference between|line_number(best_bet)|
and the optimum|best_line|}
line_diff:integer;{the difference between the current line number and
the optimum|best_line|}

/*:1046*//*1067:*/
#line 25959 "pdftexdir/pdftex.web"

hc:array[0. .65]of 0. .256;{word to be hyphenated}
hn:small_number;{the number of positions occupied in|hc|}
ha,hb:pointer;{nodes|ha..hb|should be replaced by the hyphenated result}
hf:internal_font_number;{font number of the letters in|hc|}
hu:array[0. .63]of 0. .256;{like|hc|,before conversion to lowercase}
hyf_char:integer;{hyphen character of the relevant font}
cur_lang,init_cur_lang:ASCII_code;{current hyphenation table of interest}
l_hyf,r_hyf,init_l_hyf,init_r_hyf:integer;{limits on fragment sizes}
hyf_bchar:halfword;{boundary character after $c_n$}

/*:1067*//*1075:*/
#line 26099 "pdftexdir/pdftex.web"

hyf:array[0. .64]of 0. .9;{odd values indicate discretionary hyphens}
init_list:pointer;{list of punctuation characters preceding the word}
init_lig:boolean;{does|init_list|represent a ligature?}
init_lft:boolean;{if so,did the ligature involve a left boundary?}

/*:1075*//*1080:*/
#line 26223 "pdftexdir/pdftex.web"

hyphen_passed:small_number;{first hyphen in a ligature,if any}

/*:1080*//*1082:*/
#line 26264 "pdftexdir/pdftex.web"

cur_l,cur_r:halfword;{characters before and after the cursor}
cur_q:pointer;{where a ligature should be detached}
lig_stack:pointer;{unfinished business to the right of the cursor}
ligature_present:boolean;{should a ligature node be made for|cur_l|?}
lft_hit,rt_hit:boolean;{did we hit a ligature with a boundary character?}

/*:1082*//*1096:*/
#line 26570 "pdftexdir/pdftex.web"

#line 3686 "pdftex-final.ch"
{We will dynamically allocate these arrays.}
trie_trl:^trie_pointer;{|trie_link|}
trie_tro:^trie_pointer;{|trie_op|}
trie_trc:^quarterword;{|trie_char|}
#line 26572 "pdftexdir/pdftex.web"
hyf_distance:array[1..trie_op_size]of small_number;{position|k-j|of $n_j$}
hyf_num:array[1..trie_op_size]of small_number;{value of $n_j$}
#line 3695 "pdftex-final.ch"
hyf_next:array[1..trie_op_size]of trie_opcode;{continuation code}
#line 26575 "pdftexdir/pdftex.web"
op_start:array[ASCII_code]of 0..trie_op_size;{offset for current language}

/*:1096*//*1101:*/
#line 26632 "pdftexdir/pdftex.web"

#line 3736 "pdftex-final.ch"
hyph_word:^str_number;{exception words}
hyph_list:^pointer;{lists of hyphen positions}
hyph_link:^hyph_pointer;{link array for hyphen exceptions hash table}
hyph_count:integer;{the number of words in the exception dictionary}
hyph_next:integer;{next free slot in hyphen exceptions hash table}
#line 26636 "pdftexdir/pdftex.web"

/*:1101*//*1118:*/
#line 26848 "pdftexdir/pdftex.web"

#line 3891 "pdftex-final.ch"
init trie_op_hash:array[neg_trie_op_size..trie_op_size]of 0..trie_op_size;
#line 26850 "pdftexdir/pdftex.web"
{trie op codes for quadruples}
#line 3897 "pdftex-final.ch"
trie_used:array[ASCII_code]of trie_opcode;
#line 26852 "pdftexdir/pdftex.web"
{largest opcode used so far for this language}
trie_op_lang:array[1..trie_op_size]of ASCII_code;
{language part of a hashed quadruple}
#line 3903 "pdftex-final.ch"
trie_op_val:array[1..trie_op_size]of trie_opcode;
#line 26856 "pdftexdir/pdftex.web"
{opcode corresponding to a hashed quadruple}
trie_op_ptr:0..trie_op_size;{number of stored ops so far}
#line 3909 "pdftex-final.ch"
tini
max_op_used:trie_opcode;{largest opcode used for any language}
small_op:boolean;{flag used while dumping or undumping}
#line 26859 "pdftexdir/pdftex.web"

/*:1118*//*1122:*/
#line 26940 "pdftexdir/pdftex.web"

#line 3986 "pdftex-final.ch"
init trie_c:^packed_ASCII_code;
{characters to match}
trie_o:^trie_opcode;
{operations to perform}
trie_l:^trie_pointer;
{left subtrie links}
trie_r:^trie_pointer;
{right subtrie links}
trie_ptr:trie_pointer;{the number of nodes in the trie}
trie_hash:^trie_pointer;
{used to identify equivalent subtries}
tini
#line 26953 "pdftexdir/pdftex.web"

/*:1122*//*1125:*/
#line 27026 "pdftexdir/pdftex.web"

#line 4015 "pdftex-final.ch"
init trie_taken:^boolean;
{does a family start here?}
trie_min:array[ASCII_code]of trie_pointer;
{the first possible slot for each character}
trie_max:trie_pointer;{largest location used in|trie|}
trie_not_ready:boolean;{is the trie still in linked form?}
tini
#line 27034 "pdftexdir/pdftex.web"

/*:1125*//*1146:*/
#line 27419 "pdftexdir/pdftex.web"

best_height_plus_depth:scaled;{height of the best box,without stretching or
shrinking}

/*:1146*//*1155:*/
#line 27634 "pdftexdir/pdftex.web"

page_tail:pointer;{the final node on the current page}
page_contents:empty..box_there;{what is on the current page so far?}
page_max_depth:scaled;{maximum box depth on page being built}
best_page_break:pointer;{break here to get the best page known so far}
least_page_cost:integer;{the score for this currently best page}
best_size:scaled;{its|page_goal|}

/*:1155*//*1157:*/
#line 27717 "pdftexdir/pdftex.web"

page_so_far:array[0. .7]of scaled;{height and glue of the current page}
last_glue:pointer;{used to implement\.{\\lastskip}}
last_penalty:integer;{used to implement\.{\\lastpenalty}}
last_kern:scaled;{used to implement\.{\\lastkern}}
last_node_type:integer;{used to implement\.{\\lastnodetype}}
insert_penalties:integer;{sum of the penalties for held-over insertions}

/*:1157*//*1164:*/
#line 27849 "pdftexdir/pdftex.web"

output_active:boolean;{are we in the midst of an output routine?}

/*:1164*//*1207:*/
#line 28605 "pdftexdir/pdftex.web"

main_f:internal_font_number;{the current font}
main_i:four_quarters;{character information bytes for|cur_l|}
main_j:four_quarters;{ligature/kern command}
main_k:font_index;{index into|font_info|}
main_p:pointer;{temporary register for list manipulation}
main_s:integer;{space factor value}
bchar:halfword;{right boundary character of current font,or|non_char|}
false_bchar:halfword;{nonexistent character matching|bchar|,or|non_char|}
cancel_boundary:boolean;{should the left boundary be ignored?}
ins_disc:boolean;{should we insert a discretionary node?}

/*:1207*//*1250:*/
#line 29430 "pdftexdir/pdftex.web"

cur_box:pointer;{box to be placed into its context}

/*:1250*//*1442:*/
#line 32239 "pdftexdir/pdftex.web"

after_token:halfword;{zero,or a saved token}

/*:1442*//*1457:*/
#line 32342 "pdftexdir/pdftex.web"

long_help_seen:boolean;{has the long\.{\\errmessage}help been used?}

/*:1457*//*1475:*/
#line 32537 "pdftexdir/pdftex.web"

format_ident:str_number;

/*:1475*//*1481:*/
#line 32621 "pdftexdir/pdftex.web"

fmt_file:word_file;{for input or output of format information}

/*:1481*//*1509:*/
#line 33140 "pdftexdir/pdftex.web"

ready_already:integer;{a sacrifice of purity for economy}

/*:1509*//*1520:*/
#line 33516 "pdftexdir/pdftex.web"

write_file:array[0. .15]of alpha_file;
write_open:array[0. .17]of boolean;

/*:1520*//*1523:*/
#line 33675 "pdftexdir/pdftex.web"

write_loc:pointer;{|eqtb|address of\.{\\write}}

/*:1523*//*1541:*/
#line 34039 "pdftexdir/pdftex.web"

pdf_last_obj:integer;

/*:1541*//*1545:*/
#line 34131 "pdftexdir/pdftex.web"

pdf_last_xform:integer;

/*:1545*//*1548:*/
#line 34181 "pdftexdir/pdftex.web"

pdf_last_ximage:integer;
pdf_last_ximage_pages:integer;
pdf_last_ximage_colordepth:integer;
alt_rule:pointer;
warn_pdfpagebox:boolean;

/*:1548*//*1555:*/
#line 34583 "pdftexdir/pdftex.web"

pdf_last_annot:integer;

/*:1555*//*1557:*/
#line 34610 "pdftexdir/pdftex.web"

pdf_last_link:integer;

/*:1557*//*1568:*/
#line 34863 "pdftexdir/pdftex.web"

pdf_last_x_pos:integer;
pdf_last_y_pos:integer;
pdf_snapx_refpos:integer;
pdf_snapy_refpos:integer;
count_do_snapy:integer;

/*:1568*//*1581:*/
#line 34986 "pdftexdir/pdftex.web"

pdf_retval:integer;{global multi-purpose return value}

/*:1581*//*1625:*/
#line 35930 "pdftexdir/pdftex.web"

cur_page_width:scaled;{width of page being shipped}
cur_page_height:scaled;{height of page being shipped}
cur_h_offset:scaled;{horizontal offset of page being shipped}
cur_v_offset:scaled;{vertical offset of page being shipped}
pdf_obj_list:pointer;{list of objects in the current page}
pdf_xform_list:pointer;{list of forms in the current page}
pdf_ximage_list:pointer;{list of images in the current page}
last_thread:pointer;{pointer to the last thread}
pdf_thread_ht,pdf_thread_dp,pdf_thread_wd:scaled;{dimensions of the last
thread}
pdf_last_thread_id:halfword;{identifier of the last thread}
pdf_last_thread_named_id:boolean;{is identifier of the last thread named}
pdf_thread_level:integer;{depth of nesting of box containing the last thread}
pdf_annot_list:pointer;{list of annotations in the current page}
pdf_link_list:pointer;{list of link annotations in the current page}
pdf_dest_list:pointer;{list of destinations in the current page}
pdf_bead_list:pointer;{list of thread beads in the current page}
pdf_obj_count:integer;{counter of objects}
pdf_xform_count:integer;{counter of forms}
pdf_ximage_count:integer;{counter of images}
pdf_cur_form:integer;{the form being output}
pdf_first_outline,pdf_last_outline,pdf_parent_outline:integer;
pdf_xform_width,
pdf_xform_height,
pdf_xform_depth:scaled;{dimension of the current form}
pdf_info_toks:pointer;{additional keys of Info dictionary}
pdf_catalog_toks:pointer;{additional keys of Catalog dictionary}
pdf_catalog_openaction:integer;
pdf_names_toks:pointer;{additional keys of Names dictionary}
pdf_dest_names_ptr:integer;{first unused position in|dest_names|}
dest_names_size:integer;{maximum number of names in name tree of PDF output file}
dest_names:^dest_name_entry;
pk_dpi:integer;{PK pixel density value from\.{texmf.cnf}}
image_orig_x,image_orig_y:integer;{origin of cropped PDF images}
pdf_trailer_toks:pointer;{additional keys of Trailer dictionary}
pdf_trailer_id_toks:pointer;{custom Trailer ID}
gen_faked_interword_space:boolean;{flag to turn on/off faked interword spaces}
gen_running_link:boolean;{flag to turn on/off running link}

/*:1625*//*1630:*/
#line 36132 "pdftexdir/pdftex.web"

pdf_link_stack:array[1..pdf_max_link_level]of pdf_link_stack_record;
pdf_link_stack_ptr:small_number;

/*:1630*//*1637:*/
#line 36691 "pdftexdir/pdftex.web"

is_shipping_page:boolean;{set to|shipping_page|when|pdf_ship_out|starts}

/*:1637*//*1649:*/
#line 36852 "pdftexdir/pdftex.web"

#line 5827 "pdftex-final.ch"
eTeX_mode:0. .1;{identifies compatibility and extended mode}
etex_p:boolean;{was the-etex option specified}
#line 36854 "pdftexdir/pdftex.web"

/*:1649*//*1657:*/
#line 36930 "pdftexdir/pdftex.web"

#line 5834 "pdftex-final.ch"
eof_seen:^boolean;{has eof been seen?}
#line 36932 "pdftexdir/pdftex.web"

/*:1657*//*1702:*/
#line 37537 "pdftexdir/pdftex.web"

LR_ptr:pointer;{stack of LR codes for|hpack|,|ship_out|,and|init_math|}
LR_problems:integer;{counts missing begins and ends}
cur_dir:small_number;{current text direction}

/*:1702*//*1747:*/
#line 38118 "pdftexdir/pdftex.web"

pseudo_files:pointer;{stack of pseudo files}

/*:1747*//*1770:*/
#line 38415 "pdftexdir/pdftex.web"

#line 5981 "pdftex-final.ch"
grp_stack:^save_pointer;{initial|cur_boundary|}
if_stack:^pointer;{initial|cond_ptr|}
#line 38418 "pdftexdir/pdftex.web"

/*:1770*//*1811:*/
#line 39059 "pdftexdir/pdftex.web"

max_reg_num:halfword;{largest allowed register number}
max_reg_help_line:str_number;{first line of help message}

/*:1811*//*1813:*/
#line 39126 "pdftexdir/pdftex.web"

sa_root:array[int_val..mark_val]of pointer;{roots of sparse arrays}
cur_ptr:pointer;{value returned by|new_index|and|find_sa_element|}
sa_null:memory_word;{two|null|pointers}

/*:1813*//*1832:*/
#line 39519 "pdftexdir/pdftex.web"

sa_chain:pointer;{chain of saved sparse array entries}
sa_level:quarterword;{group level for|sa_chain|}

/*:1832*//*1839:*/
#line 39668 "pdftexdir/pdftex.web"

last_line_fill:pointer;{the|par_fill_skip|glue node of the new paragraph}
do_last_line_fit:boolean;{special algorithm for last line of paragraph?}
active_node_size:small_number;{number of words in active nodes}
fill_width:array[0. .2]of scaled;{infinite stretch components of
|par_fill_skip|}
best_pl_short:array[very_loose_fit..tight_fit]of scaled;{|shortfall|
corresponding to|minimal_demerits|}
best_pl_glue:array[very_loose_fit..tight_fit]of scaled;{corresponding
glue stretch or shrink}

/*:1839*//*1855:*/
#line 39868 "pdftexdir/pdftex.web"

hyph_start:trie_pointer;{root of the packed trie for|hyph_codes|}
hyph_index:trie_pointer;{pointer to hyphenation codes for|cur_lang|}

/*:1855*//*1856:*/
#line 39880 "pdftexdir/pdftex.web"

disc_ptr:array[copy_code..vsplit_code]of pointer;{list pointers}

/*:1856*//*1864:*/
#line 6008 "pdftex-final.ch"

edit_name_start:pool_pointer;{where the filename to switch to starts}
edit_name_length,edit_line:integer;{what line to start editing at}
ipc_on:cinttype;{level of IPC action,0 for none[default]}
stop_at_space:boolean;{whether|more_name|returns false for space}

/*:1864*//*1866:*/
#line 6024 "pdftex-final.ch"

save_str_ptr:str_number;
save_pool_ptr:pool_pointer;
shellenabledp:cinttype;
restrictedshell:cinttype;
output_comment:^char;
k,l:0. .255;{used by`Make the first 256 strings', etc.}

/*:1866*//*1868:*/
#line 6056 "pdftex-final.ch"

debug_format_file:boolean;


/*:1868*//*1875:*/
#line 6191 "pdftex-final.ch"

expand_depth_count:integer;

/*:1875*//*1878:*/
#line 6252 "pdftex-final.ch"

mltex_p:boolean;

/*:1878*//*1879:*/
#line 6261 "pdftex-final.ch"

mltex_enabled_p:boolean;{enable character substitution}


/*:1879*//*1885:*/
#line 6399 "pdftex-final.ch"

accent_c,base_c,replace_c:integer;
ia_c,ib_c:four_quarters;{accent and base character information}
base_slant,accent_slant:real;{amount of slant}
base_x_height:scaled;{accent is designed for characters of this height}
base_width,base_height:scaled;{height and width for base character}
accent_width,accent_height:scaled;{height and width for accent}
delta:scaled;{amount of right shift}


/*:1885*//*1893:*/
#line 6575 "pdftex-final.ch"

enctex_p:boolean;


/*:1893*//*1894:*/
#line 6584 "pdftex-final.ch"

enctex_enabled_p:boolean;{enable encTeX}


/*:1894*//*1903:*/
#line 6897 "pdftex-final.ch"

synctexoption:integer;

/*:1903*//*1908:*/
#line 6920 "pdftex-final.ch"

synctexoffset:integer;{holds the true value of|synctex_code|}

/*:1908*/
#line 390 "pdftexdir/pdftex.web"


procedure initialize;{this procedure gets things started properly}
var/*19:*/
#line 718 "pdftexdir/pdftex.web"

i:integer;

/*:19*//*181:*/
#line 3893 "pdftexdir/pdftex.web"

k:integer;{index into|mem|,|eqtb|,etc.}

/*:181*//*1102:*/
#line 26637 "pdftexdir/pdftex.web"

z:hyph_pointer;{runs through the exception dictionary}

/*:1102*/
#line 393 "pdftexdir/pdftex.web"

begin/*8:*/
#line 460 "pdftexdir/pdftex.web"

/*21:*/
#line 740 "pdftexdir/pdftex.web"

xchr[52';
xchr[52!';
xchr[52"';
xchr[52#';
xchr[52 $';
xchr[52%';
xchr[52&';
xchr[52''';@/
xchr[53(';
xchr[53)';
xchr[53*';
xchr[53+';
xchr[53,';
xchr[53-';
xchr[53.';
xchr[53/';@/
xchr[54 0';
xchr[54 1';
xchr[54 2';
xchr[54 3';
xchr[54 4';
xchr[54 5';
xchr[54 6';
xchr[54 7';@/
xchr[55 8';
xchr[55 9';
xchr[55:';
xchr[55;';
xchr[55<';
xchr[55= ';
xchr[55> ';
xchr[55?';@/
xchr[49@';
xchr[49 A';
xchr[49 B';
xchr[49 C';
xchr[49 D';
xchr[49 E';
xchr[49 F';
xchr[49 G';@/
xchr[49 H';
xchr[49 I';
xchr[49 J';
xchr[49 K';
xchr[49L';
xchr[49 M';
xchr[49 N';
xchr[49 O';@/
xchr[49 P';
xchr[49 Q';
xchr[49 R';
xchr[49 S';
xchr[49 T';
xchr[49U';
xchr[49 V';
xchr[49 W';@/
xchr[49 X';
xchr[49 Y';
xchr[49 Z';
xchr[49[';
xchr[49\';
xchr[49]';
xchr[49^';
xchr[49 _';@/
xchr[49`';
xchr[49 a';
xchr[49 b';
xchr[49 c';
xchr[49 d';
xchr[49 e';
xchr[49 f';
xchr[49 g';@/
xchr[49 h';
xchr[49 i';
xchr[49 j';
xchr[49 k';
xchr[49 l';
xchr[49 m';
xchr[49 n';
xchr[49 o';@/
xchr[49 p';
xchr[49 q';
xchr[49 r';
xchr[49 s';
xchr[49 t';
xchr[49u';
xchr[49 v';
xchr[49 w';@/
xchr[49 x';
xchr[49 y';
xchr[49 z';
xchr[49{';
xchr[49|';
xchr[49}';
xchr[49~';@/

/*:21*//*23:*/
#line 871 "pdftexdir/pdftex.web"

#line 314 "pdftex-final.ch"
{Initialize|xchr|to the identity mapping.}
for i:= 0 to 51
for i:= 49 377 do xchr[i]:= i;
{Initialize enc\TeX\data.}
for i:= 0 to 255 do mubyte_read[i]:= null;
for i:= 0 to 255 do mubyte_write[i]:= 0;
for i:= 0 to 127 do mubyte_cswrite[i]:= null;
mubyte_keep:= 0;mubyte_start:= false;
write_noexpanding:= false;cs_converting:= false;
special_printing:= false;message_printing:= false;
no_convert:= false;active_noconvert:= false;
#line 874 "pdftexdir/pdftex.web"

/*:23*//*24:*/
#line 881 "pdftexdir/pdftex.web"

for i:= first_text_char to last_text_char do xord[chr(i)]:= invalid_code;
for i:= 50 377 do xord[xchr[i]]:= i;
#line 330 "pdftex-final.ch"
for i:= 0 to 49
{Set|xprn|for printable ASCII,unless|eight_bit_p|is set.}
for i:= 0 to 255 do xprn[i]:= (eight_bit_p or((i>=" ")and(i<="~")));

{The idea for this dynamic translation comes from the patch by
Libor Skarvada\.{<libor@informatics.muni.cz> }
and Petr Sojka\.{<sojka@informatics.muni.cz> }.I didn't use any of the
actual code,though,preferring a more general approach.}

{This updates the|xchr|,|xord|,and|xprn|arrays from the provided
|translate_filename|.See the function definition in\.{texmfmp.c}for
more comments.}
if translate_filename then read_tcx_file;
#line 885 "pdftexdir/pdftex.web"

/*:24*//*74:*/
#line 850 "pdftex-final.ch"
if interaction_option= unspecified_mode then
interaction:= error_stop_mode
else
interaction:= interaction_option;
#line 1894 "pdftexdir/pdftex.web"

/*:74*//*77:*/
#line 1941 "pdftexdir/pdftex.web"

deletions_allowed:= true;set_box_allowed:= true;
error_count:= 0;{|history|is initialized elsewhere}

/*:77*//*80:*/
#line 1992 "pdftexdir/pdftex.web"

help_ptr:= 0;use_err_help:= false;

#line 872 "pdftex-final.ch"
/*:80*//*97:*/
#line 2253 "pdftexdir/pdftex.web"

interrupt:= 0;OK_to_interrupt:= true;

/*:97*//*118:*/
#line 2696 "pdftexdir/pdftex.web"

two_to_the[0]:= 1;
for k:= 1 to 30 do two_to_the[k]:= 2*two_to_the[k-1];
spec_log[1]:= 93032640;
spec_log[2]:= 38612034;
spec_log[3]:= 17922280;
spec_log[4]:= 8662214;
spec_log[5]:= 4261238;
spec_log[6]:= 2113709;
spec_log[7]:= 1052693;
spec_log[8]:= 525315;
spec_log[9]:= 262400;
spec_log[10]:= 131136;
spec_log[11]:= 65552;
spec_log[12]:= 32772;
spec_log[13]:= 16385;
for k:= 14 to 27 do spec_log[k]:= two_to_the[27-k];
spec_log[28]:= 1;

/*:118*//*184:*/
#line 3943 "pdftexdir/pdftex.web"

debug was_mem_end:= mem_min;{indicate that everything was previously free}
was_lo_max:= mem_min;was_hi_min:= mem_max;
panicking:= false;
gubed

/*:184*//*233:*/
#line 4996 "pdftexdir/pdftex.web"

nest_ptr:= 0;max_nest_stack:= 0;
mode:= vmode;head:= contrib_head;tail:= contrib_head;
eTeX_aux:= null;save_tail:= null;
prev_depth:= ignore_depth;mode_line:= 0;
#line 1370 "pdftex-final.ch"
prev_graf:= 0;shown_mode:= 0;
{The following piece of code is a copy of module 991:}
page_contents:= empty;page_tail:= page_head;{|link(page_head):= null;|}
last_glue:= max_halfword;last_penalty:= 0;last_kern:= 0;
last_node_type:= -1;
page_depth:= 0;page_max_depth:= 0;
#line 5003 "pdftexdir/pdftex.web"

/*:233*//*272:*/
#line 6421 "pdftexdir/pdftex.web"

for k:= int_base to eqtb_size do xeq_level[k]:= level_one;

/*:272*//*276:*/
#line 6492 "pdftexdir/pdftex.web"

no_new_control_sequence:= true;{new identifiers are usually forbidden}
prim_next(0):= 0;prim_text(0):= 0;
for k:= 1 to prim_size do prim[k]:= prim[0];
#line 6498 "pdftexdir/pdftex.web"

/*:276*//*294:*/
#line 7044 "pdftexdir/pdftex.web"

save_ptr:= 0;cur_level:= level_one;cur_group:= bottom_level;cur_boundary:= 0;
max_save_stack:= 0;

/*:294*//*309:*/
#line 7297 "pdftexdir/pdftex.web"

mag_set:= 0;

/*:309*//*390:*/
#line 8926 "pdftexdir/pdftex.web"

is_in_csname:= false;

/*:390*//*409:*/
#line 9202 "pdftexdir/pdftex.web"

top_mark:= null;first_mark:= null;bot_mark:= null;
split_first_mark:= null;split_bot_mark:= null;

/*:409*//*465:*/
#line 10204 "pdftexdir/pdftex.web"

cur_val:= 0;cur_val_level:= int_val;radix:= 0;cur_order:= normal;

/*:465*//*507:*/
#line 11537 "pdftexdir/pdftex.web"

for k:= 0 to 16 do read_open[k]:= closed;

/*:507*//*516:*/
#line 11736 "pdftexdir/pdftex.web"

cond_ptr:= null;if_limit:= normal;cur_if:= 0;if_line:= 0;

/*:516*//*577:*/
#line 12908 "pdftexdir/pdftex.web"

#line 12910 "pdftexdir/pdftex.web"

/*:577*//*582:*/
#line 12985 "pdftexdir/pdftex.web"

null_character.b0:= min_quarterword;null_character.b1:= min_quarterword;
null_character.b2:= min_quarterword;null_character.b3:= min_quarterword;

/*:582*//*620:*/
#line 14057 "pdftexdir/pdftex.web"

total_pages:= 0;max_v:= 0;max_h:= 0;max_push:= 0;last_bop:= -1;
doing_leaders:= false;dead_cycles:= 0;cur_s:= -1;

/*:620*//*623:*/
#line 14103 "pdftexdir/pdftex.web"

half_buf:= dvi_buf_size div 2;dvi_limit:= dvi_buf_size;dvi_ptr:= 0;
dvi_offset:= 0;dvi_gone:= 0;

/*:623*//*633:*/
#line 14259 "pdftexdir/pdftex.web"

down_ptr:= null;right_ptr:= null;

/*:633*//*677:*/
#line 15265 "pdftexdir/pdftex.web"

pdf_mem_ptr:= 1;{the first word is not used so we can use zero as a value for testing
whether a pointer to|pdf_mem|is valid}
pdf_mem_size:= inf_pdf_mem_size;{allocated size of|pdf_mem|array}

/*:677*//*681:*/
#line 15373 "pdftexdir/pdftex.web"

pdf_gone:= 0;
pdf_os_mode:= false;
pdf_ptr:= 0;
pdf_op_ptr:= 0;
pdf_os_ptr:= 0;
pdf_os_cur_objnum:= 0;
pdf_os_cntr:= 0;
pdf_buf_size:= pdf_op_buf_size;
pdf_os_buf_size:= inf_pdf_os_buf_size;
pdf_buf:= pdf_op_buf;
pdf_seek_write_length:= false;
zip_write_state:= no_zip;
pdf_version_written:= false;
fixed_pdfoutput_set:= false;
fixed_pdf_draftmode_set:= false;


/*:681*//*688:*/
#line 15754 "pdftexdir/pdftex.web"

one_bp:= 65782;{65781.76}
one_hundred_bp:= 6578176;
one_hundred_inch:= 473628672;
ten_pow[0]:= 1;
for i:= 1 to 9 do
ten_pow[i]:= 10*ten_pow[i-1];
init_pdf_output:= false;


/*:688*//*697:*/
#line 16650 "pdftexdir/pdftex.web"

obj_ptr:= 0;
sys_obj_ptr:= 0;
obj_tab_size:= inf_obj_tab_size;{allocated size of|obj_tab|array}
dest_names_size:= inf_dest_names_size;{allocated size of|dest_names|array}
for k:= 1 to head_tab_max do
head_tab[k]:= 0;
pdf_box_spec_media:= 1;
pdf_box_spec_crop:= 2;
pdf_box_spec_bleed:= 3;
pdf_box_spec_trim:= 4;
pdf_box_spec_art:= 5;
pdf_dummy_font:= null_font;

/*:697*//*709:*/
#line 17847 "pdftexdir/pdftex.web"

pdf_resname_prefix:= 0;
last_tokens_string:= 0;

/*:709*//*711:*/
#line 17881 "pdftexdir/pdftex.web"

vf_nf:= 0;

/*:711*//*724:*/
#line 18252 "pdftexdir/pdftex.web"

vf_cur_s:= 0;
vf_stack_ptr:= 0;

/*:724*//*818:*/
#line 20405 "pdftexdir/pdftex.web"
adjust_tail:= null;last_badness:= 0;

/*:818*//*828:*/
#line 20902 "pdftexdir/pdftex.web"

pre_adjust_tail:= null;

/*:828*//*836:*/
#line 21005 "pdftexdir/pdftex.web"

pack_begin_line:= 0;

/*:836*//*859:*/
#line 21429 "pdftexdir/pdftex.web"

empty_field.rh:= empty;empty_field.lh:= null;
null_delimiter.b0:= 0;null_delimiter.b1:= min_quarterword;
null_delimiter.b2:= 0;null_delimiter.b3:= min_quarterword;

/*:859*//*945:*/
#line 23211 "pdftexdir/pdftex.web"

align_ptr:= null;cur_align:= null;cur_span:= null;cur_loop:= null;
cur_head:= null;cur_tail:= null;
cur_pre_head:= null;cur_pre_tail:= null;

/*:945*//*1103:*/
#line 26640 "pdftexdir/pdftex.web"

#line 3749 "pdftex-final.ch"
for z:= 0 to hyph_size do
begin hyph_word[z]:= 0;hyph_list[z]:= null;hyph_link[z]:= 0;
end;
hyph_count:= 0;
hyph_next:= hyph_prime+1;if hyph_next> hyph_size then hyph_next:= hyph_prime;
#line 26645 "pdftexdir/pdftex.web"

/*:1103*//*1165:*/
#line 27852 "pdftexdir/pdftex.web"

output_active:= false;insert_penalties:= 0;

/*:1165*//*1208:*/
#line 28621 "pdftexdir/pdftex.web"

ligature_present:= false;cancel_boundary:= false;lft_hit:= false;rt_hit:= false;
ins_disc:= false;

/*:1208*//*1443:*/
#line 32242 "pdftexdir/pdftex.web"

after_token:= 0;

/*:1443*//*1458:*/
#line 32345 "pdftexdir/pdftex.web"
long_help_seen:= false;

/*:1458*//*1476:*/
#line 32540 "pdftexdir/pdftex.web"

format_ident:= 0;

/*:1476*//*1521:*/
#line 33520 "pdftexdir/pdftex.web"

for k:= 0 to 17 do write_open[k]:= false;

/*:1521*//*1549:*/
#line 34188 "pdftexdir/pdftex.web"

alt_rule:= null;
warn_pdfpagebox:= true;

/*:1549*//*1569:*/
#line 34870 "pdftexdir/pdftex.web"

count_do_snapy:= 0;

/*:1569*//*1582:*/
#line 34989 "pdftexdir/pdftex.web"

seconds_and_micros(epochseconds,microseconds);
init_start_time;

/*:1582*//*1626:*/
#line 35970 "pdftexdir/pdftex.web"

pdf_first_outline:= 0;
pdf_last_outline:= 0;
pdf_parent_outline:= 0;
pdf_obj_count:= 0;
pdf_xform_count:= 0;
pdf_ximage_count:= 0;
pdf_dest_names_ptr:= 0;
pdf_info_toks:= null;
pdf_catalog_toks:= null;
pdf_names_toks:= null;
pdf_catalog_openaction:= 0;
pdf_trailer_toks:= null;
pdf_trailer_id_toks:= null;
gen_faked_interword_space:= false;
gen_running_link:= true;

/*:1626*//*1631:*/
#line 36136 "pdftexdir/pdftex.web"

pdf_link_stack_ptr:= 0;

/*:1631*//*1703:*/
#line 37542 "pdftexdir/pdftex.web"

LR_ptr:= null;LR_problems:= 0;cur_dir:= left_to_right;

/*:1703*//*1748:*/
#line 38121 "pdftexdir/pdftex.web"

pseudo_files:= null;

/*:1748*//*1814:*/
#line 39131 "pdftexdir/pdftex.web"

sa_mark:= null;sa_null.hh.lh:= null;sa_null.hh.rh:= null;

/*:1814*//*1833:*/
#line 39523 "pdftexdir/pdftex.web"

sa_chain:= null;sa_level:= level_zero;

/*:1833*//*1857:*/
#line 39883 "pdftexdir/pdftex.web"

page_disc:= null;split_disc:= null;

/*:1857*//*1865:*/
#line 6017 "pdftex-final.ch"

edit_name_start:= 0;
stop_at_space:= true;

/*:1865*//*1876:*/
#line 6194 "pdftex-final.ch"

expand_depth_count:= 0;

/*:1876*//*1880:*/
#line 6265 "pdftex-final.ch"

mltex_enabled_p:= false;


/*:1880*//*1895:*/
#line 6588 "pdftex-final.ch"

enctex_enabled_p:= false;


/*:1895*/
#line 461 "pdftexdir/pdftex.web"

#line 109 "pdftex-final.ch"
Init/*182:*/
#line 3896 "pdftexdir/pdftex.web"

for k:= mem_bot+1 to lo_mem_stat_max do mem[k].sc:= 0;
{all glue dimensions are zeroed}

k:= mem_bot;while k<=lo_mem_stat_max do
{set first words of glue specifications}
begin glue_ref_count(k):= null+1;
stretch_order(k):= normal;shrink_order(k):= normal;
k:= k+glue_spec_size;
end;
stretch(fil_glue):= unity;stretch_order(fil_glue):= fil;
stretch(fill_glue):= unity;stretch_order(fill_glue):= fill;
stretch(ss_glue):= unity;stretch_order(ss_glue):= fil;
shrink(ss_glue):= unity;shrink_order(ss_glue):= fil;
stretch(fil_neg_glue):= -unity;stretch_order(fil_neg_glue):= fil;
rover:= lo_mem_stat_max+1;
link(rover):= empty_flag;{now initialize the dynamic memory}
node_size(rover):= 1000;{which is a 1000-word available node}
llink(rover):= rover;rlink(rover):= rover;
lo_mem_max:= rover+1000;link(lo_mem_max):= null;info(lo_mem_max):= null;
for k:= hi_mem_stat_min to mem_top do
mem[k]:= mem[lo_mem_max];{clear list heads}
/*964:*/
#line 23530 "pdftexdir/pdftex.web"

info(omit_template):= end_template_token;{|link(omit_template)= null|}

/*:964*//*971:*/
#line 23640 "pdftexdir/pdftex.web"

link(end_span):= max_quarterword+1;info(end_span):= null;

/*:971*//*994:*/
#line 24111 "pdftexdir/pdftex.web"

type(last_active):= hyphenated;line_number(last_active):= max_halfword;
subtype(last_active):= 0;{the|subtype|is never examined by the algorithm}

/*:994*//*1156:*/
#line 27687 "pdftexdir/pdftex.web"

subtype(page_ins_head):= qi(255);
type(page_ins_head):= split_up;link(page_ins_head):= page_ins_head;

/*:1156*//*1163:*/
#line 4089 "pdftex-final.ch"

type(page_head):= glue_node;subtype(page_head):= normal;
{{\sl Sync\TeX}watch point:box(|page_head|)size>=|glue_node|size}
#line 27845 "pdftexdir/pdftex.web"

/*:1163*/
#line 3918 "pdftexdir/pdftex.web"
;
avail:= null;mem_end:= mem_top;
hi_mem_min:= hi_mem_stat_min;{initialize the one-word memory}
var_used:= lo_mem_stat_max+1-mem_bot;dyn_used:= hi_mem_stat_usage;
{initialize statistics}

/*:182*//*240:*/
#line 5191 "pdftexdir/pdftex.web"

eq_type(undefined_control_sequence):= undefined_cs;
equiv(undefined_control_sequence):= null;
eq_level(undefined_control_sequence):= level_zero;
#line 1419 "pdftex-final.ch"
for k:= active_base to eqtb_top do
eqtb[k]:= eqtb[undefined_control_sequence];
#line 5197 "pdftexdir/pdftex.web"

/*:240*//*246:*/
#line 5346 "pdftexdir/pdftex.web"

equiv(glue_base):= zero_glue;eq_level(glue_base):= level_one;
eq_type(glue_base):= glue_ref;
for k:= glue_base+1 to local_base-1 do eqtb[k]:= eqtb[glue_base];
glue_ref_count(zero_glue):= glue_ref_count(zero_glue)+local_base-glue_base;

/*:246*//*250:*/
#line 5503 "pdftexdir/pdftex.web"

par_shape_ptr:= null;eq_type(par_shape_loc):= shape_ref;
eq_level(par_shape_loc):= level_one;
for k:= etex_pen_base to etex_pens-1 do
eqtb[k]:= eqtb[par_shape_loc];
for k:= output_routine_loc to toks_base+255 do
eqtb[k]:= eqtb[undefined_control_sequence];
box(0):= null;eq_type(box_base):= box_ref;eq_level(box_base):= level_one;
for k:= box_base+1 to box_base+255 do eqtb[k]:= eqtb[box_base];
cur_font:= null_font;eq_type(cur_font_loc):= data;
eq_level(cur_font_loc):= level_one;
for k:= math_font_base to math_font_base+47 do eqtb[k]:= eqtb[cur_font_loc];
equiv(cat_code_base):= 0;eq_type(cat_code_base):= data;
eq_level(cat_code_base):= level_one;
for k:= cat_code_base+1 to int_base-1 do eqtb[k]:= eqtb[cat_code_base];
for k:= 0 to 255 do
begin cat_code(k):= other_char;math_code(k):= hi(k);sf_code(k):= 1000;
end;
cat_code(carriage_return):= car_ret;cat_code(" "):= spacer;
cat_code("\"):=escape; cat_code("%"):=comment;
cat_code(invalid_code):= invalid_char;cat_code(null_code):= ignore;
for k:= "0"to"9"do math_code(k):= hi(k+var_code);
for k:= "A"to"Z"do
begin cat_code(k):= letter;cat_code(k+"a"-"A"):= letter;
math_code(k):= hi(k+var_code+100);
math_code(k+"a"-"A"):= hi(k+"a"-"A"+var_code+100);
lc_code(k):= k+"a"-"A";lc_code(k+"a"-"A"):= k+"a"-"A";
uc_code(k):= k;uc_code(k+"a"-"A"):= k;
sf_code(k):= 999;
end;

/*:250*//*258:*/
#line 6128 "pdftexdir/pdftex.web"

#line 1549 "pdftex-final.ch"
for k:= int_base to del_code_base-1 do eqtb[k].int:= 0;
char_sub_def_min:= 256;char_sub_def_max:= -1;
{allow\.{\\charsubdef}for char 0}
{|tracing_char_sub_def:= 0|is already done}
#line 6130 "pdftexdir/pdftex.web"
mag:= 1000;tolerance:= 10000;hang_after:= 1;max_dead_cycles:= 25;
escape_char:= "\"; end_line_char:=carriage_return;
for k:= 0 to 255 do del_code(k):= -1;
del_code("."):= 0;{this null delimiter is used in error recovery}

#line 1570 "pdftex-final.ch"
/*:258*//*268:*/
#line 6387 "pdftexdir/pdftex.web"

for k:= dimen_base to eqtb_size do eqtb[k].sc:= 0;

/*:268*//*277:*/
#line 6499 "pdftexdir/pdftex.web"

prim_used:= prim_size;{nothing is used}
#line 1618 "pdftex-final.ch"
hash_used:= frozen_control_sequence;{nothing is used}
hash_high:= 0;
#line 6502 "pdftexdir/pdftex.web"
cs_count:= 0;
eq_type(frozen_dont_expand):= dont_expand;
text(frozen_dont_expand):= "notexpanded:";


eq_type(frozen_primitive):= ignore_spaces;
equiv(frozen_primitive):= 1;
eq_level(frozen_primitive):= level_one;
text(frozen_primitive):= "pdfprimitive";
/*:277*//*578:*/
#line 12914 "pdftexdir/pdftex.web"

#line 12929 "pdftexdir/pdftex.web"

/*:578*//*672:*/
#line 15077 "pdftexdir/pdftex.web"

pdf_h_origin:= (one_hundred_inch+50)div 100;
pdf_v_origin:= (one_hundred_inch+50)div 100;
pdf_compress_level:= 9;
pdf_objcompresslevel:= 0;
pdf_decimal_digits:= 3;
pdf_image_resolution:= 72;
pdf_major_version:= 1;
pdf_minor_version:= 4;
pdf_gamma:= 1000;
pdf_image_gamma:= 2200;
pdf_image_hicolor:= 1;
pdf_image_apply_gamma:= 0;
pdf_px_dimen:= one_bp;
pdf_draftmode:= 0;

/*:672*//*1062:*/
#line 25805 "pdftexdir/pdftex.web"

pdf_ignored_dimen:= ignore_depth;
pdf_each_line_height:= pdf_ignored_dimen;
pdf_each_line_depth:= pdf_ignored_dimen;
pdf_first_line_height:= pdf_ignored_dimen;
pdf_last_line_depth:= pdf_ignored_dimen;

/*:1062*//*1121:*/
#line 26917 "pdftexdir/pdftex.web"

for k:= -trie_op_size to trie_op_size do trie_op_hash[k]:= 0;
#line 3962 "pdftex-final.ch"
for k:= 0 to 255 do trie_used[k]:= min_trie_op;
#line 3968 "pdftex-final.ch"
max_op_used:= min_trie_op;
trie_op_ptr:= 0;
#line 26921 "pdftexdir/pdftex.web"

/*:1121*//*1126:*/
#line 27041 "pdftexdir/pdftex.web"

#line 4027 "pdftex-final.ch"
trie_not_ready:= true;
#line 27043 "pdftexdir/pdftex.web"

/*:1126*//*1392:*/
#line 31480 "pdftexdir/pdftex.web"

text(frozen_protection):= "inaccessible";

/*:1392*//*1477:*/
#line 32543 "pdftexdir/pdftex.web"

#line 4498 "pdftex-final.ch"
if ini_version then format_ident:= " (INITEX)";
#line 32545 "pdftexdir/pdftex.web"

/*:1477*//*1613:*/
#line 35744 "pdftexdir/pdftex.web"

text(end_write):= "endwrite";eq_level(end_write):= level_one;
eq_type(end_write):= outer_call;equiv(end_write):= null;

/*:1613*//*1650:*/
#line 36855 "pdftexdir/pdftex.web"

eTeX_mode:= 0;{initially we are in compatibility mode}
/*1809:*/
#line 39051 "pdftexdir/pdftex.web"

max_reg_num:= 255;
max_reg_help_line:= "A register number must be between 0 and 255.";

/*:1809*/
#line 36857 "pdftexdir/pdftex.web"


/*:1650*//*1815:*/
#line 39134 "pdftexdir/pdftex.web"

for i:= int_val to tok_val do sa_root[i]:= null;

/*:1815*//*1851:*/
#line 39814 "pdftexdir/pdftex.web"

#line 39816 "pdftexdir/pdftex.web"

/*:1851*/
#line 109 "pdftex-final.ch"
Tini
#line 463 "pdftexdir/pdftex.web"

/*:8*//*1909:*/
#line 6923 "pdftex-final.ch"

synctexoffset:= int_base+synctex_code;

/*:1909*/
#line 394 "pdftexdir/pdftex.web"

end;
/*57:*/
#line 1598 "pdftexdir/pdftex.web"

procedure print_ln;{prints an end-of-line}
begin case selector of
term_and_log:begin wterm_cr;wlog_cr;
term_offset:= 0;file_offset:= 0;
end;
log_only:begin wlog_cr;file_offset:= 0;
end;
term_only:begin wterm_cr;term_offset:= 0;
end;
no_print,pseudo,new_string:do_nothing;
othercases write_ln(write_file[selector])
endcases;
end;{|tally|is not affected}

/*:57*//*58:*/
#line 1617 "pdftexdir/pdftex.web"

procedure print_char(s:ASCII_code);{prints a single character}
label exit;
begin if/*262:*/
#line 6161 "pdftexdir/pdftex.web"
 s= new_line_char

/*:262*/
#line 1620 "pdftexdir/pdftex.web"
then
if selector<pseudo then
begin print_ln;return;
end;
case selector of
term_and_log:begin wterm(xchr[s]);wlog(xchr[s]);
incr(term_offset);incr(file_offset);
if term_offset= max_print_line then
begin wterm_cr;term_offset:= 0;
end;
if file_offset= max_print_line then
begin wlog_cr;file_offset:= 0;
end;
end;
log_only:begin wlog(xchr[s]);incr(file_offset);
if file_offset= max_print_line then print_ln;
end;
term_only:begin wterm(xchr[s]);incr(term_offset);
if term_offset= max_print_line then print_ln;
end;
no_print:do_nothing;
pseudo:if tally<trick_count then trick_buf[tally mod error_line]:= s;
new_string:begin if pool_ptr<pool_size then append_char(s);
end;{we drop characters if the string space is full}
othercases write(write_file[selector],xchr[s])
endcases;
incr(tally);
exit:end;

/*:58*//*59:*/
#line 1657 "pdftexdir/pdftex.web"

procedure print(s:integer);{prints string|s|}
label exit;
var j:pool_pointer;{current character code position}
nl:integer;{new-line character to restore}
begin if s>=str_ptr then s:= "???"{this can't happen}

else if s<256 then
if s<0 then s:= "???"{can't happen}
#line 766 "pdftex-final.ch"
else begin if(selector> pseudo)and(not special_printing)
and(not message_printing)then
begin print_char(s);return;{internal strings are not expanded}
end;
if(/*262:*/
#line 6161 "pdftexdir/pdftex.web"
s= new_line_char

/*:262*/
#line 770 "pdftex-final.ch"
)then
if selector<pseudo then
begin print_ln;no_convert:= false;return;
end
else if message_printing then
begin print_char(s);no_convert:= false;return;
end;
if(mubyte_log> 0)and(not no_convert)and(mubyte_write[s]> 0)then
s:= mubyte_write[s]
else if xprn[s]or special_printing then
begin print_char(s);no_convert:= false;return;end;
no_convert:= false;
#line 1673 "pdftexdir/pdftex.web"
nl:= new_line_char;new_line_char:= -1;
{temporarily disable new-line character}
j:= str_start[s];
while j<str_start[s+1]do
begin print_char(so(str_pool[j]));incr(j);
end;
new_line_char:= nl;return;
end;
j:= str_start[s];
while j<str_start[s+1]do
begin print_char(so(str_pool[j]));incr(j);
end;
exit:end;

/*:59*//*60:*/
#line 1691 "pdftexdir/pdftex.web"

procedure slow_print(s:integer);{prints string|s|}
var j:pool_pointer;{current character code position}
begin if(s>=str_ptr)or(s<256)then print(s)
else begin j:= str_start[s];
while j<str_start[s+1]do
begin print(so(str_pool[j]));incr(j);
end;
end;
end;

/*:60*//*62:*/
#line 1718 "pdftexdir/pdftex.web"

procedure print_nl(s:str_number);{prints string|s|at beginning of line}
begin if((term_offset> 0)and(odd(selector)))or
((file_offset> 0)and(selector>=log_only))then print_ln;
print(s);
end;

/*:62*//*63:*/
#line 1728 "pdftexdir/pdftex.web"

procedure print_esc(s:str_number);{prints escape character,then|s|}
var c:integer;{the escape character code}
begin/*261:*/
#line 6159 "pdftexdir/pdftex.web"
 c:= escape_char

/*:261*/
#line 1731 "pdftexdir/pdftex.web"
;
if c>=0 then if c<256 then print(c);
slow_print(s);
end;

/*:63*//*64:*/
#line 1738 "pdftexdir/pdftex.web"

procedure print_the_digs(k:eight_bits);
{prints|dig[k-1]|$\,\ldots\,$|dig[0]|}
begin while k> 0 do
begin decr(k);
if dig[k]<10 then print_char("0"+dig[k])
else print_char("A"-10+dig[k]);
end;
end;

/*:64*//*65:*/
#line 1754 "pdftexdir/pdftex.web"

procedure print_int(n:longinteger);{prints an integer in decimal form}
var k:0. .23;{index to current digit;we assume that $|n|<10^{23}$}
m:longinteger;{used to negate|n|in possibly dangerous cases}
begin k:= 0;
if n<0 then
begin print_char("-");
if n> -100000000 then negate(n)
else begin m:= -1-n;n:= m div 10;m:= (m mod 10)+1;k:= 1;
if m<10 then dig[0]:= m
else begin dig[0]:= 0;incr(n);
end;
end;
end;
repeat dig[k]:= n mod 10;n:= n div 10;incr(k);
until n= 0;
print_the_digs(k);
end;

/*:65*//*284:*/
#line 1667 "pdftex-final.ch"

procedure print_cs(p:integer);{prints a purported control sequence}
var q:pointer;
s:str_number;
begin
if active_noconvert and(not no_convert)and
(eq_type(p)= let)and(equiv(p)= normal+11)then{noconvert}
begin
no_convert:= true;
return;
end;
s:= 0;
if cs_converting and(not no_convert)then
begin
q:= mubyte_cswrite[p mod 128];
while q<> null do
if info(q)= p then
begin
s:= info(link(q));q:= null;
end else q:= link(link(q));
end;
no_convert:= false;
if s> 0 then print(s)
else if p<hash_base then{single character}
#line 6642 "pdftexdir/pdftex.web"
if p>=single_base then
if p= null_cs then
begin print_esc("csname");print_esc("endcsname");print_char(" ");
end
else begin print_esc(p-single_base);
if cat_code(p-single_base)= letter then print_char(" ");
end
else if p<active_base then print_esc("IMPOSSIBLE.")

else print(p-active_base)
#line 1696 "pdftex-final.ch"
else if((p>=undefined_control_sequence)and(p<=eqtb_size))or(p> eqtb_top)then
print_esc("IMPOSSIBLE.")
#line 1703 "pdftex-final.ch"
else if(text(p)>=str_ptr)then print_esc("NONEXISTENT.")
#line 6654 "pdftexdir/pdftex.web"

else begin
if(p>=prim_eqtb_base)and(p<frozen_null_font)then
print_esc(prim_text(p-prim_eqtb_base)-1)else print_esc(text(p));
#line 1711 "pdftex-final.ch"
print_char(" ");
end;
exit:end;
#line 6661 "pdftexdir/pdftex.web"

/*:284*//*285:*/
#line 6665 "pdftexdir/pdftex.web"

procedure sprint_cs(p:pointer);{prints a control sequence}
begin if p<hash_base then
if p<single_base then print(p-active_base)
else if p<null_cs then print_esc(p-single_base)
else begin print_esc("csname");print_esc("endcsname");
end
else if(p>=prim_eqtb_base)and(p<frozen_null_font)then
print_esc(prim_text(p-prim_eqtb_base)-1)
else print_esc(text(p));
end;

/*:285*//*544:*/
#line 12190 "pdftexdir/pdftex.web"

procedure print_file_name(n,a,e:integer);
#line 2305 "pdftex-final.ch"
var must_quote:boolean;{whether to quote the filename}
j:pool_pointer;{index into|str_pool|}
begin
must_quote:= false;
check_quoted(a);check_quoted(n);check_quoted(e);
{FIXME:Alternative is to assume that any filename that has to be quoted has
at least one quoted component...if we pick this,a number of insertions
of|print_file_name|should go away.
|must_quote|:= ((|a|<> 0)and(|str_pool|[|str_start|[|a|]]= """"))or
((|n|<> 0)and(|str_pool|[|str_start|[|n|]]= """"))or
((|e|<> 0)and(|str_pool|[|str_start|[|e|]]= """"));}
if must_quote then print_char("""");
print_quoted(a);print_quoted(n);print_quoted(e);
if must_quote then print_char("""");
#line 12193 "pdftexdir/pdftex.web"
end;

/*:544*//*873:*/
#line 21726 "pdftexdir/pdftex.web"

procedure print_size(s:integer);
begin if s= text_size then print_esc("textfont")
else if s= script_size then print_esc("scriptfont")
else print_esc("scriptscriptfont");
end;

/*:873*//*1599:*/
#line 35226 "pdftexdir/pdftex.web"

procedure print_write_whatsit(s:str_number;p:pointer);
begin print_esc(s);
if write_stream(p)<16 then print_int(write_stream(p))
else if write_stream(p)= 16 then print_char("*")

#line 5624 "pdftex-final.ch"
else print_char("-");
if(s= "write")and(write_mubyte(p)<> mubyte_zero)then
begin
print_char("<");print_int(write_mubyte(p)-mubyte_zero);print_char(">");
end;
#line 35233 "pdftexdir/pdftex.web"
end;

/*:1599*//*1819:*/
#line 39302 "pdftexdir/pdftex.web"

procedure print_sa_num(q:pointer);{print register number}
var n:halfword;{the register number}
begin if sa_index(q)<dimen_val_limit then n:= sa_num(q){the easy case}
else begin n:= hex_dig4(sa_index(q));q:= link(q);n:= n+16*sa_index(q);
q:= link(q);n:= n+256*(sa_index(q)+16*sa_index(link(q)));
end;
print_int(n);
end;

/*:1819*//*1867:*/
#line 6038 "pdftex-final.ch"

procedure print_csnames(hstart:integer;hfinish:integer);
var c,h:integer;
begin
write_ln(stderr,'fmtdebug:csnames from ',hstart,' to ',hfinish,':');
for h:= hstart to hfinish do begin
if text(h)> 0 then begin{if have anything at this position}
for c:= str_start[text(h)]to str_start[text(h)+1]-1
do begin
put_byte(str_pool[c],stderr);{print the characters}
end;
write_ln(stderr,'|');
end;
end;
end;

/*:1867*//*1869:*/
#line 6064 "pdftex-final.ch"

procedure print_file_line;
var level:0..max_in_open;
begin
level:= in_open;
while(level> 0)and(full_source_filename_stack[level]= 0)do
decr(level);
if level= 0 then
print_nl("! ")
else begin
print_nl("");print(full_source_filename_stack[level]);print(":");
if level= in_open then print_int(line)
else print_int(line_stack[level+1]);
print(": ");
end;
end;

/*:1869*//*1896:*/
#line 6621 "pdftex-final.ch"

{read|buffer|[|i|]and convert multibyte.|i|should have been
of type 0..|buf_size|,but web2c doesn't like that construct in
argument lists.}
function read_buffer(var i:integer):ASCII_code;
var p:pointer;
last_found:integer;
last_type:integer;
begin
mubyte_skip:= 0;mubyte_token:= 0;
read_buffer:= buffer[i];
if mubyte_in= 0 then
begin
if mubyte_keep> 0 then mubyte_keep:= 0;
return;
end;
last_found:= -2;
if(i= start)and(not mubyte_start)then
begin
mubyte_keep:= 0;
if(end_line_char>=0)and(end_line_char<256)then
if mubyte_read[end_line_char]<> null then
begin
mubyte_start:= true;mubyte_skip:= -1;
p:= mubyte_read[end_line_char];
goto continue;
end;
end;
restart:
mubyte_start:= false;
if(mubyte_read[buffer[i]]= null)or(mubyte_keep> 0)then
begin
if mubyte_keep> 0 then decr(mubyte_keep);
return;
end;
p:= mubyte_read[buffer[i]];
continue:
if type(p)>=64 then
begin
last_type:= type(p)-64;
p:= link(p);
mubyte_token:= info(p);last_found:= mubyte_skip;
end else if type(p)> 0 then
begin
last_type:= type(p);
mubyte_token:= link(p);
goto found;
end;
incr(mubyte_skip);
if i+mubyte_skip> limit then
begin
mubyte_skip:= 0;
if mubyte_start then goto restart;
return;
end;
repeat
p:= link(p);
if subinfo(info(p))= buffer[i+mubyte_skip]then
begin
p:= info(p);goto continue;
end;
until link(p)= null;
mubyte_skip:= 0;
if mubyte_start then goto restart;
if last_found= -2 then return;{no found}
mubyte_skip:= last_found;
found:
if mubyte_token<256 then{multibyte to one byte}
begin
read_buffer:= mubyte_token;mubyte_token:= 0;
i:= i+mubyte_skip;
if mubyte_start and(i>=start)then mubyte_start:= false;
return;
end else begin{multibyte to control sequence}
read_buffer:= 0;
if last_type= 60 then{normal conversion}
i:= i+mubyte_skip
else begin{insert control sequence}
decr(i);mubyte_keep:= last_type;
if i<start then mubyte_start:= true;
if last_type= 52 then mubyte_keep:= 10000;
if last_type= 51 then mubyte_keep:= mubyte_skip+1;
mubyte_skip:= -1;
end;
if mubyte_start and(i>=start)then mubyte_start:= false;
return;
end;
exit:end;

/*:1896*//*1898:*/
#line 6819 "pdftex-final.ch"

{print one char from|buffer|[|i|].|i|should have been of type
0..|buf_size|,but web2c doesn't like that construct in argument lists. }
procedure print_buffer(var i:integer);
var c:ASCII_code;
begin
if mubyte_in= 0 then print(buffer[i]){normal TeX}
else if mubyte_log> 0 then print_char(buffer[i])
else begin
c:= read_buffer(i);
if mubyte_token> 0 then print_cs(mubyte_token-cs_token_flag)
else print(c);
end;
incr(i);
end;

/*:1898*/
#line 396 "pdftexdir/pdftex.web"

/*78:*/
#line 1956 "pdftexdir/pdftex.web"

procedure normalize_selector;forward;
procedure get_token;forward;
procedure term_input;forward;
procedure show_context;forward;
procedure begin_file_reading;forward;
procedure open_log_file;forward;
procedure close_files_and_terminate;forward;
procedure clear_for_error_prompt;forward;
procedure give_err_help;forward;
debug procedure debug_help;
forward;gubed

/*:78*//*81:*/
#line 889 "pdftex-final.ch"

noreturn procedure jump_out;
begin
close_files_and_terminate;
do_final_end;
end;
#line 2009 "pdftexdir/pdftex.web"

/*:81*//*82:*/
#line 2012 "pdftexdir/pdftex.web"

procedure error;{completes the job of error reporting}
label continue,exit;
var c:ASCII_code;{what the user types}
s1,s2,s3,s4:integer;
{used to save global variables when deleting tokens}
begin if history<error_message_issued then history:= error_message_issued;
#line 900 "pdftex-final.ch"
print_char(".");show_context;
if(halt_on_error_p)then begin
history:= fatal_error_stop;jump_out;
end;
#line 2020 "pdftexdir/pdftex.web"
if interaction= error_stop_mode then/*83:*/
#line 2030 "pdftexdir/pdftex.web"

#line 909 "pdftex-final.ch"
 loop begin continue:
if interaction<> error_stop_mode then return;
clear_for_error_prompt;prompt_input("? ");
#line 2032 "pdftexdir/pdftex.web"

if last= first then return;
c:= buffer[first];
if c>="a"then c:= c+"A"-"a";{convert to uppercase}
/*84:*/
#line 2051 "pdftexdir/pdftex.web"

case c of
"0","1","2","3","4","5","6","7","8","9":if deletions_allowed then
/*88:*/
#line 2121 "pdftexdir/pdftex.web"

begin s1:= cur_tok;s2:= cur_cmd;s3:= cur_chr;s4:= align_state;
align_state:= 1000000;OK_to_interrupt:= false;
if(last> first+1)and(buffer[first+1]>="0")and(buffer[first+1]<="9")then
c:= c*10+buffer[first+1]-"0"*11
else c:= c-"0";
while c> 0 do
begin get_token;{one-level recursive call of|error|is possible}
decr(c);
end;
cur_tok:= s1;cur_cmd:= s2;cur_chr:= s3;align_state:= s4;OK_to_interrupt:= true;
help2("I have just deleted some text, as you asked.")
("You can now delete more, or insert, or whatever.");
show_context;goto continue;
end

/*:88*/
#line 2054 "pdftexdir/pdftex.web"
;
debug"D":begin debug_help;goto continue;end;gubed
#line 947 "pdftex-final.ch"
"E":if base_ptr> 0 then
begin edit_name_start:= str_start[edit_file.name_field];
edit_name_length:= str_start[edit_file.name_field+1]-
str_start[edit_file.name_field];
edit_line:= line;
jump_out;
#line 2062 "pdftexdir/pdftex.web"
end;
"H":/*89:*/
#line 2137 "pdftexdir/pdftex.web"

begin if use_err_help then
begin give_err_help;use_err_help:= false;
end
else begin if help_ptr= 0 then
help2("Sorry, I don't know how to help in this situation.")
("Maybe you should try asking a human?");
repeat decr(help_ptr);print(help_line[help_ptr]);print_ln;
until help_ptr= 0;
end;
help4("Sorry, I already gave what help I could...")
("Maybe you should try asking a human?")
("An error might have occurred before I noticed any problems.")
("``If all else fails, read the instructions.''");
goto continue;
end

/*:89*/
#line 2063 "pdftexdir/pdftex.web"
;
"I":/*87:*/
#line 2105 "pdftexdir/pdftex.web"

begin begin_file_reading;{enter a new syntactic level for terminal input}
{now|state= mid_line|,so an initial blank space will count as a blank}
if last> first+1 then
begin loc:= first+1;buffer[first]:= " ";
end
else begin prompt_input("insert>");loc:= first;

end;
first:= last;
cur_input.limit_field:= last-1;{no|end_line_char|ends this line}
return;
end

/*:87*/
#line 2064 "pdftexdir/pdftex.web"
;
"Q","R","S":/*86:*/
#line 2088 "pdftexdir/pdftex.web"

begin error_count:= 0;interaction:= batch_mode+c-"Q";
print("OK, entering ");
case c of
"Q":begin print_esc("batchmode");decr(selector);
end;
"R":print_esc("nonstopmode");
"S":print_esc("scrollmode");
end;{there are no other cases}
print("...");print_ln;update_terminal;return;
end

/*:86*/
#line 2065 "pdftexdir/pdftex.web"
;
"X":begin interaction:= scroll_mode;jump_out;
end;
othercases do_nothing
endcases;
/*85:*/
#line 2072 "pdftexdir/pdftex.web"

begin print("Type <return> to proceed, S to scroll future error messages,");

print_nl("R to run without stopping, Q to run quietly,");
print_nl("I to insert something, ");
if base_ptr> 0 then print("E to edit your file,");
if deletions_allowed then
print_nl("1 or ... or 9 to ignore the next 1 to 9 tokens of input,");
print_nl("H for help, X to quit.");
end

/*:85*/
#line 2070 "pdftexdir/pdftex.web"


/*:84*/
#line 2036 "pdftexdir/pdftex.web"
;
end

/*:83*/
#line 2020 "pdftexdir/pdftex.web"
;
incr(error_count);
if error_count= 100 then
begin print_nl("(That makes 100 errors; please try again.)");

history:= fatal_error_stop;jump_out;
end;
/*90:*/
#line 2154 "pdftexdir/pdftex.web"

if interaction> batch_mode then decr(selector);{avoid terminal output}
if use_err_help then
begin print_ln;give_err_help;
end
else while help_ptr> 0 do
begin decr(help_ptr);print_nl(help_line[help_ptr]);
end;
print_ln;
if interaction> batch_mode then incr(selector);{re-enable terminal output}
print_ln

/*:90*/
#line 2027 "pdftexdir/pdftex.web"
;
exit:end;

/*:82*//*93:*/
#line 2193 "pdftexdir/pdftex.web"

#line 958 "pdftex-final.ch"
noreturn procedure fatal_error(s:str_number);{prints|s|,and that's it}
#line 2195 "pdftexdir/pdftex.web"
begin normalize_selector;
print_err("Emergency stop");help1(s);succumb;

end;

/*:93*//*94:*/
#line 2202 "pdftexdir/pdftex.web"

#line 964 "pdftex-final.ch"
noreturn procedure overflow(s:str_number;n:integer);{stop due to finiteness}
#line 2204 "pdftexdir/pdftex.web"
begin normalize_selector;
print_err("TeX capacity exceeded, sorry [");

print(s);print_char("=");print_int(n);print_char("]");
help2("If you really absolutely need more capacity,")
("you can ask a wizard to enlarge me.");
succumb;
end;

/*:94*//*95:*/
#line 2221 "pdftexdir/pdftex.web"

#line 970 "pdftex-final.ch"
noreturn procedure confusion(s:str_number);
#line 2223 "pdftexdir/pdftex.web"
{consistency check violated;|s|tells where}
begin normalize_selector;
if history<error_message_issued then
begin print_err("This can't happen (");print(s);print_char(")");

help1("I'm broken. Please show this to someone who can fix can fix");
end
else begin print_err("I can't go on meeting you like this");

help2("One of your faux pas seems to have wounded me deeply...")
("in fact, I'm barely conscious. Please fix it and try again.");
end;
succumb;
end;

/*:95*/
#line 397 "pdftexdir/pdftex.web"


/*:4*//*31:*/
#line 471 "pdftex-final.ch"
/*35:*/
#line 603 "pdftex-final.ch"

begin cur_input.loc_field:= first;cur_input.limit_field:= last-1;
#line 1175 "pdftexdir/pdftex.web"
overflow("buffer size",buf_size);

end

/*:35*/
#line 471 "pdftex-final.ch"

#line 1103 "pdftexdir/pdftex.web"

/*:31*//*37:*/
#line 623 "pdftex-final.ch"
function init_terminal:boolean;{gets the terminal input started}
label exit;
begin t_open_in;
if last> first then
begin loc:= first;
while(loc<last)and(buffer[loc]= ' ')do incr(loc);
if loc<last then
begin init_terminal:= true;goto exit;
end;
end;
#line 1216 "pdftexdir/pdftex.web"
loop begin wake_up_terminal;write(term_out,'**');update_terminal;

if not input_ln(term_in,true)then{this shouldn't happen}
begin write_ln(term_out);
#line 638 "pdftex-final.ch"
write_ln(term_out,'! End of file on the terminal... why?');
#line 1221 "pdftexdir/pdftex.web"

init_terminal:= false;return;
end;
loc:= first;
while(loc<last)and(buffer[loc]= " ")do incr(loc);
if loc<last then
begin init_terminal:= true;
return;{return unless the line was all blank}
end;
write_ln(term_out,'Please type the name of your input file.');
end;
exit:end;

/*:37*//*43:*/
#line 1330 "pdftexdir/pdftex.web"
function make_string:str_number;{current string enters the pool}
begin if str_ptr= max_strings then
overflow("number of strings",max_strings-init_str_ptr);

incr(str_ptr);str_start[str_ptr]:= pool_ptr;
make_string:= str_ptr-1;
end;

/*:43*//*45:*/
#line 1349 "pdftexdir/pdftex.web"
function str_eq_buf(s:str_number;k:integer):boolean;
{test equality of strings}
label not_found;{loop exit}
var j:pool_pointer;{running index}
result:boolean;{result of comparison}
begin j:= str_start[s];
while j<str_start[s+1]do
begin if so(str_pool[j])<> buffer[k]then
begin result:= false;goto not_found;
end;
incr(j);incr(k);
end;
result:= true;
not_found:str_eq_buf:= result;
end;

/*:45*//*46:*/
#line 1368 "pdftexdir/pdftex.web"
function str_eq_str(s,t:str_number):boolean;
{test equality of strings}
label not_found;{loop exit}
var j,k:pool_pointer;{running indices}
result:boolean;{result of comparison}
begin result:= false;
if length(s)<> length(t)then goto not_found;
j:= str_start[s];k:= str_start[t];
while j<str_start[s+1]do
begin if str_pool[j]<> str_pool[k]then goto not_found;
incr(j);incr(k);
end;
result:= true;
not_found:str_eq_str:= result;
end;

/*:46*//*47:*/
#line 660 "pdftex-final.ch"
/*1873:*/
#line 6136 "pdftex-final.ch"

function search_string(search:str_number):str_number;
label found;
var result:str_number;
s:str_number;{running index}
len:integer;{length of searched string}
begin result:= 0;len:= length(search);
if len= 0 then{trivial case}
begin result:= "";goto found;
end
else begin s:= search-1;{start search with newest string below|s|;|search> 1|!}
while s> 255 do{first 256 strings depend on implementation!!}
begin if length(s)= len then
if str_eq_str(s,search)then
begin result:= s;goto found;
end;
decr(s);
end;
end;
found:search_string:= result;
end;

/*:1873*//*1874:*/
#line 6164 "pdftex-final.ch"

function slow_make_string:str_number;
label exit;
var s:str_number;{result of|search_string|}
t:str_number;{new string}
begin t:= make_string;s:= search_string(t);
if s> 0 then
begin flush_string;slow_make_string:= s;return;
end;
slow_make_string:= t;
exit:end;


/*:1874*/
#line 660 "pdftex-final.ch"


init function get_strings_started:boolean;{initializes the string pool,
#line 1391 "pdftexdir/pdftex.web"
but returns|false|if something goes wrong}
label done,exit;
var k,l:0. .255;{small indices or counters}
#line 671 "pdftex-final.ch"
g:str_number;{garbage}
#line 1398 "pdftexdir/pdftex.web"
begin pool_ptr:= 0;str_ptr:= 0;str_start[0]:= 0;
/*48:*/
#line 1408 "pdftexdir/pdftex.web"

for k:= 0 to 255 do
begin if(/*49:*/
#line 1448 "pdftexdir/pdftex.web"

(k<" ")or(k> "~")

/*:49*/
#line 1410 "pdftexdir/pdftex.web"
)then
begin append_char("^");append_char("^");
if k<49 100)
else if k<50 100)
else begin app_lc_hex(k div 16);app_lc_hex(k mod 16);
end;
end
else append_char(k);
g:= make_string;
end

/*:48*/
#line 1399 "pdftexdir/pdftex.web"
;
/*51:*/
#line 737 "pdftex-final.ch"

g:= loadpoolstrings((pool_size-string_vacancies));
if g= 0 then begin
wake_up_terminal;write_ln(term_out,'! You have to increase POOLSIZE.');
get_strings_started:= false;
return;
end;
get_strings_started:= true;

/*:51*/
#line 1401 "pdftexdir/pdftex.web"
;
exit:end;
tini

/*:47*//*66:*/
#line 1776 "pdftexdir/pdftex.web"
procedure print_two(n:integer);{prints two least significant digits}
begin n:= abs(n)mod 100;print_char("0"+(n div 10));
print_char("0"+(n mod 10));
end;

/*:66*//*67:*/
#line 1783 "pdftexdir/pdftex.web"
procedure print_hex(n:integer);
{prints a positive integer in hexadecimal form}
var k:0. .22;{index to current digit;we assume that $0\L n<16^{22}$}
begin k:= 0;print_char("""");
repeat dig[k]:= n mod 16;n:= n div 16;incr(k);
until n= 0;
print_the_digs(k);
end;

/*:67*//*69:*/
#line 1803 "pdftexdir/pdftex.web"
procedure print_roman_int(n:integer);
label exit;
var j,k:pool_pointer;{mysterious indices into|str_pool|}
u,v:nonnegative_integer;{mysterious numbers}
begin j:= str_start["m2d5c2l5x2v5i"];v:= 1000;
loop begin while n>=v do
begin print_char(so(str_pool[j]));n:= n-v;
end;
if n<=0 then return;{nonpositive input produces no output}
k:= j+2;u:= v div(so(str_pool[k-1])-"0");
if str_pool[k-1]= si("2")then
begin k:= k+2;u:= u div(so(str_pool[k-1])-"0");
end;
if n+u>=v then
begin print_char(so(str_pool[k]));n:= n+u;
end
else begin j:= j+2;v:= v div(so(str_pool[j-1])-"0");
end;
end;
exit:end;

/*:69*//*70:*/
#line 1827 "pdftexdir/pdftex.web"
procedure print_current_string;{prints a yet-unmade string}
var j:pool_pointer;{points to current character code}
begin j:= str_start[str_ptr];
while j<pool_ptr do
begin print_char(so(str_pool[j]));incr(j);
end;
end;

/*:70*//*71:*/
#line 1845 "pdftexdir/pdftex.web"
procedure term_input;{gets a line from the terminal}
var k:0..buf_size;{index into|buffer|}
begin update_terminal;{now the user sees the prompt for sure}
if not input_ln(term_in,true)then fatal_error("End of file on the terminal!");

term_offset:= 0;{the user's line ended with \<\rm return>}
decr(selector);{prepare to echo the input}
#line 822 "pdftex-final.ch"
k:= first;while k<last do begin print_buffer(k)end;
#line 1853 "pdftexdir/pdftex.web"
print_ln;incr(selector);{restore previous status}
end;

/*:71*//*91:*/
#line 2169 "pdftexdir/pdftex.web"
procedure int_error(n:integer);
begin print(" (");print_int(n);print_char(")");error;
end;

/*:91*//*92:*/
#line 2177 "pdftexdir/pdftex.web"
procedure normalize_selector;
begin if log_opened then selector:= term_and_log
else selector:= term_only;
if job_name= 0 then open_log_file;
if interaction= batch_mode then decr(selector);
end;

/*:92*//*98:*/
#line 2261 "pdftexdir/pdftex.web"
procedure pause_for_instructions;
begin if OK_to_interrupt then
begin interaction:= error_stop_mode;
if(selector= log_only)or(selector= no_print)then
incr(selector);
print_err("Interruption");

help3("You rang?")
("Try to insert some instructions for me (e.g.,`I\showlists'),")
("unless you just want to quit by typing `X'.");
deletions_allowed:= false;error;deletions_allowed:= true;
interrupt:= 0;
end;
end;

/*:98*//*100:*/
#line 2300 "pdftexdir/pdftex.web"
function half(x:integer):integer;
begin if odd(x)then half:= (x+1)div 2
else half:= x div 2;
end;

/*:100*//*102:*/
#line 2321 "pdftexdir/pdftex.web"
function round_decimals(k:small_number):scaled;
{converts a decimal fraction}
var a:integer;{the accumulator}
begin a:= 0;
while k> 0 do
begin decr(k);a:= (a+dig[k]*two)div 10;
end;
round_decimals:= (a+1)div 2;
end;

/*:102*//*103:*/
#line 2343 "pdftexdir/pdftex.web"
procedure print_scaled(s:scaled);{prints scaled real,rounded to five
digits}
var delta:scaled;{amount of allowable inaccuracy}
begin if s<0 then
begin print_char("-");negate(s);{print the sign,if negative}
end;
print_int(s div unity);{print the integer part}
print_char(".");
s:= 10*(s mod unity)+5;delta:= 10;
repeat if delta> unity then s:= s+49
print_char("0"+(s div unity));s:= 10*(s mod unity);delta:= delta*10;
until s<=delta;
end;

/*:103*//*105:*/
#line 2393 "pdftexdir/pdftex.web"
function mult_and_add(n:integer;x,y,max_answer:scaled):scaled;
begin if n<0 then
begin negate(x);negate(n);
end;
if n= 0 then mult_and_add:= y
else if((x<=(max_answer-y)div n)and(-x<=(max_answer+y)div n))then
mult_and_add:= n*x+y
else begin arith_error:= true;mult_and_add:= 0;
end;
end;

/*:105*//*106:*/
#line 2406 "pdftexdir/pdftex.web"
function x_over_n(x:scaled;n:integer):scaled;
var negative:boolean;{should|remainder|be negated?}
begin negative:= false;
if n= 0 then
begin arith_error:= true;x_over_n:= 0;remainder:= x;
end
else begin if n<0 then
begin negate(x);negate(n);negative:= true;
end;
if x>=0 then
begin x_over_n:= x div n;remainder:= x mod n;
end
else begin x_over_n:= -((-x)div n);remainder:= -((-x)mod n);
end;
end;
if negative then negate(remainder);
end;

/*:106*//*107:*/
#line 2431 "pdftexdir/pdftex.web"
function xn_over_d(x:scaled;n,d:integer):scaled;
var positive:boolean;{was|x>=0|?}
t,u,v:nonnegative_integer;{intermediate quantities}
begin if x>=0 then positive:= true
else begin negate(x);positive:= false;
end;
t:= (x mod 49
u:= (x div 49 100000);
v:= (u mod d)*49 100000);
if u div d>=49
else u:= 49
if positive then
begin xn_over_d:= u;remainder:= v mod d;
end
else begin xn_over_d:= -u;remainder:= -(v mod d);
end;
end;

/*:107*//*108:*/
#line 2469 "pdftexdir/pdftex.web"
function badness(t,s:scaled):halfword;{compute badness,given|t>=0|}
var r:integer;{approximation to $\alpha t/s$,where $\alpha^3\approx
100\cdot2^{18}$}
begin if t= 0 then badness:= 0
else if s<=0 then badness:= inf_bad
else begin if t<=7230584 then r:= (t*297)div s{$297^3= 99.94\times2^{18}$}
else if s>=1663497 then r:= t div(s div 297)
else r:= t;
if r> 1290 then badness:= inf_bad{$1290^3<2^{31}<1291^3 $}
else badness:= (r*r*r+52 1000000;
end;{that was $r^3/2^{18}$,rounded to the nearest integer}
end;

/*:108*//*112:*/
#line 2590 "pdftexdir/pdftex.web"
function make_frac(p,q:integer):integer;
var f:integer;{the fraction bits,with a leading 1 bit}
n:integer;{the integer part of $\vert p/q\vert$}
negative:boolean;{should the result be negated?}
be_careful:integer;{disables certain compiler optimizations}
begin if p>=0 then negative:= false
else begin negate(p);negative:= true;
end;
if q<=0 then
begin debug if q= 0 then confusion("/");gubed

negate(q);negative:= not negative;
end;
n:= p div q;p:= p mod q;
if n>=8 then
begin arith_error:= true;
if negative then make_frac:= -el_gordo else make_frac:= el_gordo;
end
else begin n:= (n-1)*fraction_one;
/*113:*/
#line 2627 "pdftexdir/pdftex.web"

f:= 1;
repeat be_careful:= p-q;p:= be_careful+p;
if p>=0 then f:= f+f+1
else begin double(f);p:= p+q;
end;
until f>=fraction_one;
be_careful:= p-q;
if be_careful+p>=0 then incr(f)

/*:113*/
#line 2609 "pdftexdir/pdftex.web"
;
if negative then make_frac:= -(f+n)else make_frac:= f+n;
end;
end;

/*:112*//*114:*/
#line 2639 "pdftexdir/pdftex.web"
function take_frac(q:integer;f:integer):integer;
var p:integer;{the fraction so far}
negative:boolean;{should the result be negated?}
n:integer;{additional multiple of $q$}
be_careful:integer;{disables certain compiler optimizations}
begin/*115:*/
#line 2661 "pdftexdir/pdftex.web"

if f>=0 then negative:= false
else begin negate(f);negative:= true;
end;
if q<0 then
begin negate(q);negative:= not negative;
end;

/*:115*/
#line 2644 "pdftexdir/pdftex.web"
;
if f<fraction_one then n:= 0
else begin n:= f div fraction_one;f:= f mod fraction_one;
if q<=el_gordo div n then n:= n*q
else begin arith_error:= true;n:= el_gordo;
end;
end;
f:= f+fraction_one;
/*116:*/
#line 2674 "pdftexdir/pdftex.web"

p:= fraction_half;{that's $2^{27}$; the invariants hold now with $k=28$}
if q<fraction_four then
repeat if odd(f)then p:= halfp(p+q)else p:= halfp(p);
f:= halfp(f);
until f= 1
else repeat if odd(f)then p:= p+halfp(q-p)else p:= halfp(p);
f:= halfp(f);
until f= 1

/*:116*/
#line 2652 "pdftexdir/pdftex.web"
;
be_careful:= n-el_gordo;
if be_careful+p> 0 then
begin arith_error:= true;n:= el_gordo-p;
end;
if negative then take_frac:= -(n+p)
else take_frac:= n+p;
end;

/*:114*//*119:*/
#line 2717 "pdftexdir/pdftex.web"
function m_log(x:integer):integer;
var y,z:integer;{auxiliary registers}
k:integer;{iteration counter}
begin if x<=0 then/*121:*/
#line 2743 "pdftexdir/pdftex.web"

begin print_err("Logarithm of ");

print_scaled(x);print(" has been replaced by 0");
help2("Since I don't take logs of non-positive numbers,")
("I'm zeroing this one. Proceed, with fingers crossed.");
error;m_log:= 0;
end

/*:121*/
#line 2720 "pdftexdir/pdftex.web"

else begin y:= 1302456956+4-100;{$14\times2^{27}\ln2\approx1302456956 .421063 $}
z:= 27595+6553600;{and $2^{16}\times .421063\approx 27595 $}
while x<fraction_four do
begin double(x);y:= y-93032639;z:= z-48782;
end;{$2^{27}\ln2\approx 93032639.74436163 $
and $2^{16}\times .74436163\approx 48782 $}
y:= y+(z div unity);k:= 2;
while x> fraction_four+4 do
/*120:*/
#line 2735 "pdftexdir/pdftex.web"

begin z:= ((x-1)div two_to_the[k])+1;{$z= \lceil x/2^k\rceil$}
while x<fraction_four+z do
begin z:= halfp(z+1);k:= k+1;
end;
y:= y+spec_log[k];x:= x-z;
end

/*:120*/
#line 2730 "pdftexdir/pdftex.web"
;
m_log:= y div 8;
end;
end;

/*:119*//*122:*/
#line 2760 "pdftexdir/pdftex.web"
function ab_vs_cd(a,b,c,d:integer):integer;
label exit;
var q,r:integer;{temporary registers}
begin/*123:*/
#line 2775 "pdftexdir/pdftex.web"

if a<0 then
begin negate(a);negate(b);
end;
if c<0 then
begin negate(c);negate(d);
end;
if d<=0 then
begin if b>=0 then
if((a= 0)or(b= 0))and((c= 0)or(d= 0))then return_sign(0)
else return_sign(1);
if d= 0 then
if a= 0 then return_sign(0)else return_sign(-1);
q:= a;a:= c;c:= q;q:= -b;b:= -d;d:= q;
end
else if b<=0 then
begin if b<0 then if a> 0 then return_sign(-1);
if c= 0 then return_sign(0)else return_sign(-1);
end

/*:123*/
#line 2763 "pdftexdir/pdftex.web"
;
loop begin q:= a div d;r:= c div b;
if q<> r then
if q> r then return_sign(1)else return_sign(-1);
q:= a mod d;r:= c mod b;
if r= 0 then
if q= 0 then return_sign(0)else return_sign(1);
if q= 0 then return_sign(-1);
a:= b;b:= q;c:= d;d:= r;
end;{now|a> d> 0|and|c> b> 0|}
exit:end;

/*:122*//*124:*/
#line 2801 "pdftexdir/pdftex.web"
procedure new_randoms;
var k:0. .54;{index into|randoms|}
x:integer;{accumulator}
begin for k:= 0 to 23 do
begin x:= randoms[k]-randoms[k+31];
if x<0 then x:= x+fraction_one;
randoms[k]:= x;
end;
for k:= 24 to 54 do
begin x:= randoms[k]-randoms[k-24];
if x<0 then x:= x+fraction_one;
randoms[k]:= x;
end;
j_random:= 54;
end;

/*:124*//*125:*/
#line 2819 "pdftexdir/pdftex.web"
procedure init_randoms(seed:integer);
var j,jj,k:integer;{more or less random integers}
i:0. .54;{index into|randoms|}
begin j:= abs(seed);
while j>=fraction_one do j:= halfp(j);
k:= 1;
for i:= 0 to 54 do
begin jj:= k;k:= j-k;j:= jj;
if k<0 then k:= k+fraction_one;
randoms[(i*21)mod 55]:= j;
end;
new_randoms;new_randoms;new_randoms;{``warm up''the array}
end;

/*:125*//*126:*/
#line 2840 "pdftexdir/pdftex.web"
function unif_rand(x:integer):integer;
var y:integer;{trial value}
begin next_random;y:= take_frac(abs(x),randoms[j_random]);
if y= abs(x)then unif_rand:= 0
else if x> 0 then unif_rand:= y
else unif_rand:= -y;
end;

/*:126*//*127:*/
#line 2852 "pdftexdir/pdftex.web"
function norm_rand:integer;
var x,u,l:integer;{what the book would call $2^{16}X$,$2^{28}U$,
and $-2^{24}\ln U$}
begin repeat
repeat next_random;
x:= take_frac(112429,randoms[j_random]-fraction_half);
{$2^{16}\sqrt{8/e}\approx 112428.82793 $}
next_random;u:= randoms[j_random];
until abs(x)<u;
x:= make_frac(x,u);
l:= 139548960-m_log(u);{$2^{24}\cdot12\ln2\approx139548959 .6165 $}
until ab_vs_cd(1024,l,x,x)>=0;
norm_rand:= x;
end;

/*:127*//*132:*/
#line 2995 "pdftexdir/pdftex.web"
debug procedure print_word(w:memory_word);
{prints|w|in all ways}
begin print_int(w.int);print_char(" ");
print_scaled(w.sc);print_char(" ");
print_scaled(round(unity*float(w.gr)));print_ln;

print_int(w.hh.lh);print_char("=");print_int(w.hh.b0);print_char(":");
print_int(w.hh.b1);print_char(";");print_int(w.hh.rh);print_char(" ");
print_int(w.qqqq.b0);print_char(":");print_int(w.qqqq.b1);print_char(":");
print_int(w.qqqq.b2);print_char(":");print_int(w.qqqq.b3);
end;
gubed

/*:132*//*137:*/
#line 3092 "pdftexdir/pdftex.web"
/*314:*/
#line 7432 "pdftexdir/pdftex.web"

procedure show_token_list(p,q:integer;l:integer);
label exit;
var m,c:integer;{pieces of a token}
match_chr:ASCII_code;{character used in a`|match|'}
n:ASCII_code;{the highest parameter number,as an ASCII digit}
begin match_chr:= "#";n:= "0";tally:= 0;
while(p<> null)and(tally<l)do
begin if p= q then/*342:*/
#line 8146 "pdftexdir/pdftex.web"
 set_trick_count

/*:342*/
#line 7440 "pdftexdir/pdftex.web"
;
/*315:*/
#line 7449 "pdftexdir/pdftex.web"

if(p<hi_mem_min)or(p> mem_end)then
begin print_esc("CLOBBERED.");return;

end;
if info(p)>=cs_token_flag then print_cs(info(p)-cs_token_flag)
else begin m:= info(p)div 52 400;
if info(p)<0 then print_esc("BAD.")

else/*316:*/
#line 7465 "pdftexdir/pdftex.web"

case m of
left_brace,right_brace,math_shift,tab_mark,sup_mark,sub_mark,spacer,
letter,other_char:print(c);
mac_param:begin print(c);print(c);
end;
out_param:begin print(match_chr);
if c<=9 then print_char(c+"0")
else begin print_char("!");return;
end;
end;
match:begin match_chr:= c;print(c);incr(n);print_char(n);
if n> "9"then return;
end;
end_match:if c= 0 then print("->");

othercases print_esc("BAD.")

endcases

/*:316*/
#line 7458 "pdftexdir/pdftex.web"
;
end

/*:315*/
#line 7441 "pdftexdir/pdftex.web"
;
p:= link(p);
end;
if p<> null then print_esc("ETC.");

exit:
end;

/*:314*/
#line 3092 "pdftexdir/pdftex.web"

/*328:*/
#line 7805 "pdftexdir/pdftex.web"

procedure runaway;
var p:pointer;{head of runaway list}
begin if scanner_status> skipping then
#line 1807 "pdftex-final.ch"
 begin

case scanner_status of
defining:begin print_nl("Runaway definition");p:= def_ref;
end;
matching:begin print_nl("Runaway argument");p:= temp_head;
end;
aligning:begin print_nl("Runaway preamble");p:= hold_head;
end;
absorbing:begin print_nl("Runaway text");p:= def_ref;
end;
end;{there are no other cases}
#line 7821 "pdftexdir/pdftex.web"
print_char("?");print_ln;show_token_list(link(p),null,error_line-10);
end;
end;

/*:328*/
#line 3093 "pdftexdir/pdftex.web"


/*:137*//*138:*/
#line 3104 "pdftexdir/pdftex.web"
function get_avail:pointer;{single-word node allocation}
var p:pointer;{the new node being got}
begin p:= avail;{get top location in the|avail|stack}
if p<> null then avail:= link(avail){and pop it off}
else if mem_end<mem_max then{or go into virgin territory}
begin incr(mem_end);p:= mem_end;
end
else begin decr(hi_mem_min);p:= hi_mem_min;
if hi_mem_min<=lo_mem_max then
begin runaway;{if memory is exhausted,display possible runaway text}
overflow("main memory size",mem_max+1-mem_min);
{quit;all one-word nodes are busy}

end;
end;
link(p):= null;{provide an oft-desired initialization of the new node}
stat incr(dyn_used);tats{maintain statistics}
get_avail:= p;
end;

/*:138*//*141:*/
#line 3150 "pdftexdir/pdftex.web"
procedure flush_list(p:pointer);{makes list of single-word nodes
available}
var q,r:pointer;{list traversers}
begin if p<> null then
begin r:= p;
repeat q:= r;r:= link(r);stat decr(dyn_used);tats
until r= null;{now|q|is the last node on the list}
link(q):= avail;avail:= p;
end;
end;

/*:141*//*143:*/
#line 1090 "pdftex-final.ch"
function get_node(s:integer):pointer;{variable-size node allocation}
#line 3195 "pdftexdir/pdftex.web"
label found,exit,restart;
var p:pointer;{the node currently under inspection}
q:pointer;{the node physically after node|p|}
r:integer;{the newly allocated node,or a candidate for this honor}
t:integer;{temporary register}
begin restart:p:= rover;{start at some free node in the ring}
repeat/*145:*/
#line 3242 "pdftexdir/pdftex.web"

q:= p+node_size(p);{find the physical successor}

while is_empty(q)do{merge node|p|with node|q|}
begin t:= rlink(q);
if q= rover then rover:= t;
llink(t):= llink(q);rlink(llink(q)):= t;
q:= q+node_size(q);
end;
r:= q-s;
if r> p+1 then/*146:*/
#line 3257 "pdftexdir/pdftex.web"

begin node_size(p):= r-p;{store the remaining size}

rover:= p;{start searching here next time}
goto found;
end

/*:146*/
#line 3252 "pdftexdir/pdftex.web"
;
if r= p then if rlink(p)<> p then
/*147:*/
#line 3266 "pdftexdir/pdftex.web"

begin rover:= rlink(p);t:= llink(p);
llink(rover):= t;rlink(t):= rover;
goto found;
end

/*:147*/
#line 3254 "pdftexdir/pdftex.web"
;
node_size(p):= q-p{reset the size in case it grew}

/*:145*/
#line 3202 "pdftexdir/pdftex.web"
;

p:= rlink(p);{move to the next node in the ring}
until p= rover;{repeat until the whole list has been traversed}
if s= 49
begin get_node:= max_halfword;return;
end;
if lo_mem_max+2<hi_mem_min then if lo_mem_max+2<=mem_bot+max_halfword then
/*144:*/
#line 3227 "pdftexdir/pdftex.web"

begin if hi_mem_min-lo_mem_max>=1998 then t:= lo_mem_max+1000
else t:= lo_mem_max+1+(hi_mem_min-lo_mem_max)div 2;
{|lo_mem_max+2<=t<hi_mem_min|}
p:= llink(rover);q:= lo_mem_max;rlink(p):= q;llink(rover):= q;
if t> mem_bot+max_halfword then t:= mem_bot+max_halfword;
rlink(q):= rover;llink(q):= p;link(q):= empty_flag;node_size(q):= t-lo_mem_max;
lo_mem_max:= t;link(lo_mem_max):= null;info(lo_mem_max):= null;
rover:= q;goto restart;
end

/*:144*/
#line 3210 "pdftexdir/pdftex.web"
;
overflow("main memory size",mem_max+1-mem_min);
{sorry,nothing satisfactory is left}

found:link(r):= null;{this node is now nonempty}
stat var_used:= var_used+s;{maintain usage statistics}
tats
#line 1096 "pdftex-final.ch"
/*1913:*/
#line 6981 "pdftex-final.ch"

if s>=medium_node_size then
begin
sync_tag(r+s):= synctex_tag;
sync_line(r+s):= line;
end;

/*:1913*/
#line 1096 "pdftex-final.ch"
;
get_node:= r;
#line 3218 "pdftexdir/pdftex.web"
exit:end;

/*:143*//*148:*/
#line 3277 "pdftexdir/pdftex.web"
procedure free_node(p:pointer;s:halfword);{variable-size node
liberation}
var q:pointer;{|llink(rover)|}
begin node_size(p):= s;link(p):= empty_flag;
q:= llink(rover);llink(p):= q;rlink(p):= rover;{set both links}
llink(rover):= p;rlink(q):= p;{insert|p|into the ring}
stat var_used:= var_used-s;tats{maintain statistics}
end;

/*:148*//*149:*/
#line 3291 "pdftexdir/pdftex.web"
init procedure sort_avail;{sorts the available variable-size nodes
by location}
var p,q,r:pointer;{indices into|mem|}
old_rover:pointer;{initial|rover|setting}
begin p:= get_node(49
p:= rlink(rover);rlink(rover):= max_halfword;old_rover:= rover;
while p<> old_rover do/*150:*/
#line 3311 "pdftexdir/pdftex.web"

if p<rover then
begin q:= p;p:= rlink(q);rlink(q):= rover;rover:= q;
end
else begin q:= rover;
while rlink(q)<p do q:= rlink(q);
r:= rlink(p);rlink(p):= rlink(q);rlink(q):= p;p:= r;
end

/*:150*/
#line 3298 "pdftexdir/pdftex.web"
;
p:= rover;
while rlink(p)<> max_halfword do
begin llink(rlink(p)):= p;p:= rlink(p);
end;
rlink(p):= rover;llink(rover):= p;
end;
tini

/*:149*//*154:*/
#line 3421 "pdftexdir/pdftex.web"
function new_null_box:pointer;{creates a new box node}
var p:pointer;{the new node}
begin p:= get_node(box_node_size);type(p):= hlist_node;
subtype(p):= min_quarterword;
width(p):= 0;depth(p):= 0;height(p):= 0;shift_amount(p):= 0;list_ptr(p):= null;
glue_sign(p):= normal;glue_order(p):= normal;set_glue_ratio_zero(glue_set(p));
new_null_box:= p;
end;

/*:154*//*157:*/
#line 3451 "pdftexdir/pdftex.web"
function new_rule:pointer;
var p:pointer;{the new node}
begin p:= get_node(rule_node_size);type(p):= rule_node;
subtype(p):= 0;{the|subtype|is not used}
width(p):= null_flag;depth(p):= null_flag;height(p):= null_flag;
new_rule:= p;
end;

/*:157*//*162:*/
#line 1134 "pdftex-final.ch"
function new_ligature(f:internal_font_number;c:quarterword;
q:pointer):pointer;
#line 3526 "pdftexdir/pdftex.web"
var p:pointer;{the new node}
begin p:= get_node(small_node_size);type(p):= ligature_node;
font(lig_char(p)):= f;character(lig_char(p)):= c;lig_ptr(p):= q;
subtype(p):= 0;new_ligature:= p;
end;

function new_lig_item(c:quarterword):pointer;
var p:pointer;{the new node}
begin p:= get_node(small_node_size);character(p):= c;lig_ptr(p):= null;
new_lig_item:= p;
end;

/*:162*//*163:*/
#line 3560 "pdftexdir/pdftex.web"
function new_disc:pointer;{creates an empty|disc_node|}
var p:pointer;{the new node}
begin p:= get_node(small_node_size);type(p):= disc_node;
replace_count(p):= 0;pre_break(p):= null;post_break(p):= null;
new_disc:= p;
end;

/*:163*//*165:*/
#line 1141 "pdftex-final.ch"
function new_math(w:scaled;s:small_number):pointer;
#line 3614 "pdftexdir/pdftex.web"
var p:pointer;{the new node}
#line 1147 "pdftex-final.ch"
begin p:= get_node(medium_node_size);type(p):= math_node;
#line 3616 "pdftexdir/pdftex.web"
subtype(p):= s;width(p):= w;new_math:= p;
end;

/*:165*//*169:*/
#line 3695 "pdftexdir/pdftex.web"
function new_spec(p:pointer):pointer;{duplicates a glue specification}
var q:pointer;{the new spec}
begin q:= get_node(glue_spec_size);
mem[q]:= mem[p];glue_ref_count(q):= null;
width(q):= width(p);stretch(q):= stretch(p);shrink(q):= shrink(p);
new_spec:= q;
end;

/*:169*//*170:*/
#line 1153 "pdftex-final.ch"
function new_param_glue(n:small_number):pointer;
#line 3709 "pdftexdir/pdftex.web"
var p:pointer;{the new node}
q:pointer;{the glue specification}
#line 1159 "pdftex-final.ch"
begin p:= get_node(medium_node_size);type(p):= glue_node;subtype(p):= n+1;
#line 3712 "pdftexdir/pdftex.web"
leader_ptr(p):= null;
q:= /*242:*/
#line 5260 "pdftexdir/pdftex.web"
glue_par(n)

/*:242*/
#line 3713 "pdftexdir/pdftex.web"
;
glue_ptr(p):= q;incr(glue_ref_count(q));
new_param_glue:= p;
end;

/*:170*//*171:*/
#line 1165 "pdftex-final.ch"
function new_glue(q:pointer):pointer;
#line 3722 "pdftexdir/pdftex.web"
var p:pointer;{the new node}
#line 1171 "pdftex-final.ch"
begin p:= get_node(medium_node_size);type(p):= glue_node;subtype(p):= normal;
#line 3724 "pdftexdir/pdftex.web"
leader_ptr(p):= null;glue_ptr(p):= q;incr(glue_ref_count(q));
new_glue:= p;
end;

/*:171*//*172:*/
#line 3735 "pdftexdir/pdftex.web"
function new_skip_param(n:small_number):pointer;
var p:pointer;{the new node}
begin temp_ptr:= new_spec(/*242:*/
#line 5260 "pdftexdir/pdftex.web"
glue_par(n)

/*:242*/
#line 3737 "pdftexdir/pdftex.web"
);
p:= new_glue(temp_ptr);glue_ref_count(temp_ptr):= null;subtype(p):= n+1;
new_skip_param:= p;
end;

/*:172*//*174:*/
#line 1177 "pdftex-final.ch"
function new_kern(w:scaled):pointer;
#line 3789 "pdftexdir/pdftex.web"
var p:pointer;{the new node}
#line 1183 "pdftex-final.ch"
begin p:= get_node(medium_node_size);type(p):= kern_node;
#line 3791 "pdftexdir/pdftex.web"
subtype(p):= normal;
width(p):= w;
new_kern:= p;
end;

/*:174*//*176:*/
#line 1189 "pdftex-final.ch"
function new_penalty(m:integer):pointer;
#line 3812 "pdftexdir/pdftex.web"
var p:pointer;{the new node}
#line 1195 "pdftex-final.ch"
begin p:= get_node(medium_node_size);type(p):= penalty_node;
#line 3814 "pdftexdir/pdftex.web"
subtype(p):= 0;{the|subtype|is not used}
penalty(p):= m;new_penalty:= p;
end;

/*:176*//*185:*/
#line 3953 "pdftexdir/pdftex.web"
debug procedure check_mem(print_locs:boolean);
label done1,done2;{loop exits}
var p,q:pointer;{current locations of interest in|mem|}
clobbered:boolean;{is something amiss?}
begin for p:= mem_min to lo_mem_max do free[p]:= false;{you can probably
do this faster}
for p:= hi_mem_min to mem_end do free[p]:= false;{ditto}
/*186:*/
#line 3971 "pdftexdir/pdftex.web"

p:= avail;q:= null;clobbered:= false;
while p<> null do
begin if(p> mem_end)or(p<hi_mem_min)then clobbered:= true
else if free[p]then clobbered:= true;
if clobbered then
begin print_nl("AVAIL list clobbered at ");

print_int(q);goto done1;
end;
free[p]:= true;q:= p;p:= link(q);
end;
done1:

/*:186*/
#line 3960 "pdftexdir/pdftex.web"
;
/*187:*/
#line 3985 "pdftexdir/pdftex.web"

p:= rover;q:= null;clobbered:= false;
repeat if(p>=lo_mem_max)or(p<mem_min)then clobbered:= true
else if(rlink(p)>=lo_mem_max)or(rlink(p)<mem_min)then clobbered:= true
else if not(is_empty(p))or(node_size(p)<2)or
(p+node_size(p)> lo_mem_max)or(llink(rlink(p))<> p)then clobbered:= true;
if clobbered then
begin print_nl("Double-AVAIL list clobbered at ");
print_int(q);goto done2;
end;
for q:= p to p+node_size(p)-1 do{mark all locations free}
begin if free[q]then
begin print_nl("Doubly free location at ");

print_int(q);goto done2;
end;
free[q]:= true;
end;
q:= p;p:= rlink(p);
until p= rover;
done2:

/*:187*/
#line 3961 "pdftexdir/pdftex.web"
;
/*188:*/
#line 4007 "pdftexdir/pdftex.web"

p:= mem_min;
while p<=lo_mem_max do{node|p|should not be empty}
begin if is_empty(p)then
begin print_nl("Bad flag at ");print_int(p);

end;
while(p<=lo_mem_max)and not free[p]do incr(p);
while(p<=lo_mem_max)and free[p]do incr(p);
end

/*:188*/
#line 3962 "pdftexdir/pdftex.web"
;
if print_locs then/*189:*/
#line 4018 "pdftexdir/pdftex.web"

begin print_nl("New busy locs:");
for p:= mem_min to lo_mem_max do
if not free[p]and((p> was_lo_max)or was_free[p])then
begin print_char(" ");print_int(p);
end;
for p:= hi_mem_min to mem_end do
if not free[p]and
((p<was_hi_min)or(p> was_mem_end)or was_free[p])then
begin print_char(" ");print_int(p);
end;
end

/*:189*/
#line 3963 "pdftexdir/pdftex.web"
;
for p:= mem_min to lo_mem_max do was_free[p]:= free[p];
for p:= hi_mem_min to mem_end do was_free[p]:= free[p];
{|was_free:= free|might be faster}
was_mem_end:= mem_end;was_lo_max:= lo_mem_max;was_hi_min:= hi_mem_min;
end;
gubed

/*:185*//*190:*/
#line 4040 "pdftexdir/pdftex.web"
debug procedure search_mem(p:pointer);{look for pointers to|p|}
var q:integer;{current position being searched}
begin for q:= mem_min to lo_mem_max do
begin if link(q)= p then
begin print_nl("LINK(");print_int(q);print_char(")");
end;
if info(q)= p then
begin print_nl("INFO(");print_int(q);print_char(")");
end;
end;
for q:= hi_mem_min to mem_end do
begin if link(q)= p then
begin print_nl("LINK(");print_int(q);print_char(")");
end;
if info(q)= p then
begin print_nl("INFO(");print_int(q);print_char(")");
end;
end;
/*273:*/
#line 6428 "pdftexdir/pdftex.web"

for q:= active_base to box_base+255 do
begin if equiv(q)= p then
begin print_nl("EQUIV(");print_int(q);print_char(")");
end;
end

/*:273*/
#line 4058 "pdftexdir/pdftex.web"
;
/*307:*/
#line 7281 "pdftexdir/pdftex.web"

if save_ptr> 0 then for q:= 0 to save_ptr-1 do
begin if equiv_field(save_stack[q])= p then
begin print_nl("SAVE(");print_int(q);print_char(")");
end;
end

/*:307*/
#line 4059 "pdftexdir/pdftex.web"
;
/*1108:*/
#line 26688 "pdftexdir/pdftex.web"

for q:= 0 to hyph_size do
begin if hyph_list[q]= p then
begin print_nl("HYPH(");print_int(q);print_char(")");
end;
end

/*:1108*/
#line 4060 "pdftexdir/pdftex.web"
;
end;
gubed

/*686:*/
#line 15575 "pdftexdir/pdftex.web"

procedure pdf_error(t,p:str_number);
begin
normalize_selector;
print_err("pdfTeX error");
if t<> 0 then begin
print(" (");
print(t);
print(")");
end;
print(": ");print(p);
succumb;
end;

procedure pdf_warning(t,p:str_number;prepend_nl,append_nl:boolean);
begin
if interaction= error_stop_mode then
wake_up_terminal;
if prepend_nl then
print_ln;
print("pdfTeX warning");
if t<> 0 then begin
print(" (");
print(t);
print(")");
end;
print(": ");print(p);
if append_nl then
print_ln;
if history= spotless then history:= warning_issued;
end;

procedure pdf_os_get_os_buf(s:integer);{check that|s|bytes more
fit into|pdf_os_buf|;increase it if required}
var a:integer;
begin
if s> sup_pdf_os_buf_size-pdf_ptr then
overflow("PDF object stream buffer",pdf_os_buf_size);
if pdf_ptr+s> pdf_os_buf_size then begin
a:= 0.2*pdf_os_buf_size;
if pdf_ptr+s> pdf_os_buf_size+a then
pdf_os_buf_size:= pdf_ptr+s
else if pdf_os_buf_size<sup_pdf_os_buf_size-a then
pdf_os_buf_size:= pdf_os_buf_size+a
else
pdf_os_buf_size:= sup_pdf_os_buf_size;
pdf_os_buf:= xrealloc_array(pdf_os_buf,eight_bits,pdf_os_buf_size);
pdf_buf:= pdf_os_buf;
pdf_buf_size:= pdf_os_buf_size;
end;
end;

procedure remove_last_space;
begin
if(pdf_ptr> 0)and(pdf_buf[pdf_ptr-1]= 32)then
decr(pdf_ptr);
end;

procedure pdf_print_octal(n:integer);{prints an integer in octal form to
PDF buffer}
var k:0. .23;{index to current digit;we assume that $|n|<10^{23}$}
begin
k:= 0;
repeat dig[k]:= n mod 8;n:= n div 8;incr(k);
until n= 0;
if k= 1 then begin
pdf_out("0");
pdf_out("0");
end;
if k= 2 then
pdf_out("0");
while k> 0 do begin
decr(k);
pdf_out("0"+dig[k]);
end;
end;

procedure pdf_print_char(f:internal_font_number;c:integer);
{print out a character to PDF buffer;the character will be printed in octal
form in the following cases:chars<=32,backslash(92),left parenthesis
(40)and right parenthesis(41)}
begin
pdf_mark_char(f,c);
if(c<=32)or(c= 92)or(c= 40)or(c= 41)or(c> 127)then begin
pdf_out(92);{output a backslash}
pdf_print_octal(c);
end
else
pdf_out(c);
end;

procedure pdf_print(s:str_number);{print out a string to PDF buffer}
var j:pool_pointer;{current character code position}
c:integer;
begin
j:= str_start[s];
while j<str_start[s+1]do begin
c:= str_pool[j];
pdf_out(c);
incr(j);
end;
end;

function str_in_str(s,r:str_number;i:integer):boolean;
{test equality of strings}
label not_found;{loop exit}
var j,k:pool_pointer;{running indices}
begin
str_in_str:= false;
if length(s)<i+length(r)then
return;
j:= i+str_start[s];
k:= str_start[r];
while(j<str_start[s+1])and(k<str_start[r+1])do begin
if str_pool[j]<> str_pool[k]then
return;
incr(j);
incr(k);
end;
str_in_str:= true;
end;

procedure pdf_print_int(n:longinteger);{print out a integer to PDF buffer}
var k:integer;{index to current digit($0\le k\le23$);we assume that $|n|<10^{23}$}
m:longinteger;{used to negate|n|in possibly dangerous cases}
begin
k:= 0;
if n<0 then
begin pdf_out("-");
if n> -100000000 then negate(n)
else begin m:= -1-n;n:= m div 10;m:= (m mod 10)+1;k:= 1;
if m<10 then dig[0]:= m
else begin dig[0]:= 0;incr(n);
end;
end;
end;
repeat dig[k]:= n mod 10;n:= n div 10;incr(k);
until n= 0;
pdf_room(k);
while k> 0 do begin
decr(k);
pdf_quick_out("0"+dig[k]);
end;
end;

procedure pdf_print_two(n:integer);{prints two least significant digits in
decimal form to PDF buffer}
begin n:= abs(n)mod 100;pdf_out("0"+(n div 10));
pdf_out("0"+(n mod 10));
end;

function tokens_to_string(p:pointer):str_number;{return a string from tokens
list}
begin
if selector= new_string then
pdf_error("tokens","tokens_to_string() called while selector = new_string");
old_setting:= selector;selector:= new_string;
show_token_list(link(p),null,pool_size-pool_ptr);
selector:= old_setting;
last_tokens_string:= make_string;
tokens_to_string:= last_tokens_string;
end;


/*:686*//*689:*/
#line 15766 "pdftexdir/pdftex.web"

function divide_scaled(s,m:scaled;dd:integer):scaled;
var q,r:scaled;
sign,i:integer;
begin
sign:= 1;
if s<0 then begin
sign:= -sign;
s:= -s;
end;
if m<0 then begin
sign:= -sign;
m:= -m;
end;
if m= 0 then
pdf_error("arithmetic","divided by zero")
else if m>=(max_integer div 10)then
pdf_error("arithmetic","number too big");
q:= s div m;
r:= s mod m;
for i:= 1 to dd do begin
q:= 10*q+(10*r)div m;
r:= (10*r)mod m;
end;
if 2*r>=m then begin
incr(q);
r:= r-m;
end;
scaled_out:= sign*(s-(r div ten_pow[dd]));
divide_scaled:= sign*q;
end;

function round_xn_over_d(x:scaled;n,d:integer):scaled;
var positive:boolean;{was|x>=0|?}
t,u,v:nonnegative_integer;{intermediate quantities}
begin if x>=0 then positive:= true
else begin negate(x);positive:= false;
end;
t:= (x mod 49
u:= (x div 49 100000);
v:= (u mod d)*49 100000);
if u div d>=49
else u:= 49
v:= v mod d;
if 2*v>=d then
incr(u);
if positive then
round_xn_over_d:= u
else
round_xn_over_d:= -u;
end;

/*:689*//*698:*/
#line 16677 "pdftexdir/pdftex.web"

procedure append_dest_name(s:str_number;n:integer);
var a:integer;
begin
if pdf_dest_names_ptr= sup_dest_names_size then
overflow("number of destination names (dest_names_size)",dest_names_size);
if pdf_dest_names_ptr= dest_names_size then begin
a:= 0.2*dest_names_size;
if dest_names_size<sup_dest_names_size-a then
dest_names_size:= dest_names_size+a
else
dest_names_size:= sup_dest_names_size;
dest_names:= xrealloc_array(dest_names,dest_name_entry,dest_names_size);
end;
dest_names[pdf_dest_names_ptr].objname:= s;
dest_names[pdf_dest_names_ptr].objnum:= n;
incr(pdf_dest_names_ptr);
end;

procedure pdf_create_obj(t,i:integer);{create an object with type|t|and
identifier|i|}
label done;
var a,p,q:integer;
begin
if sys_obj_ptr= sup_obj_tab_size then
overflow("indirect objects table size",obj_tab_size);
if sys_obj_ptr= obj_tab_size then begin
a:= 0.2*obj_tab_size;
if obj_tab_size<sup_obj_tab_size-a then
obj_tab_size:= obj_tab_size+a
else
obj_tab_size:= sup_obj_tab_size;
obj_tab:= xrealloc_array(obj_tab,obj_entry,obj_tab_size);
end;
incr(sys_obj_ptr);
obj_ptr:= sys_obj_ptr;
obj_info(obj_ptr):= i;
set_obj_fresh(obj_ptr);
obj_aux(obj_ptr):= 0;
avl_put_obj(obj_ptr,t);
if t= obj_type_page then begin
p:= head_tab[t];
{find the right position to insert newly created object}
if(p= 0)or(obj_info(p)<i)then begin
obj_link(obj_ptr):= p;
head_tab[t]:= obj_ptr;
end
else begin
while p<> 0 do begin
if obj_info(p)<i then
goto done;
q:= p;
p:= obj_link(p);
end;
done:
obj_link(q):= obj_ptr;
obj_link(obj_ptr):= p;
end;
end
else if t<> obj_type_others then begin
obj_link(obj_ptr):= head_tab[t];
head_tab[t]:= obj_ptr;
if(t= obj_type_dest)and(i<0)then
append_dest_name(-obj_info(obj_ptr),obj_ptr);
end;
end;

function pdf_new_objnum:integer;{create a new object and return its number}
begin
pdf_create_obj(obj_type_others,0);
pdf_new_objnum:= obj_ptr;
end;

procedure pdf_os_switch(pdf_os:boolean);{switch between PDF stream and object stream mode}
begin
if pdf_os and pdf_os_enable then begin
if not pdf_os_mode then begin{back up PDF stream variables}
pdf_op_ptr:= pdf_ptr;
pdf_ptr:= pdf_os_ptr;
pdf_buf:= pdf_os_buf;
pdf_buf_size:= pdf_os_buf_size;
pdf_os_mode:= true;{switch to object stream}
end;
end else begin
if pdf_os_mode then begin{back up object stream variables}
pdf_os_ptr:= pdf_ptr;
pdf_ptr:= pdf_op_ptr;
pdf_buf:= pdf_op_buf;
pdf_buf_size:= pdf_op_buf_size;
pdf_os_mode:= false;{switch to PDF stream}
end;
end;
end;

procedure pdf_os_prepare_obj(i:integer;pdf_os_level:integer);{create new\.{/ObjStm}object
if required,and set up cross reference info}
begin
pdf_os_switch((pdf_os_level> 0)and(fixed_pdf_objcompresslevel>=pdf_os_level));
if pdf_os_mode then begin
if pdf_os_cur_objnum= 0 then begin
pdf_os_cur_objnum:= pdf_new_objnum;
decr(obj_ptr);{object stream is not accessible to user}
incr(pdf_os_cntr);{only for statistics}
pdf_os_objidx:= 0;
pdf_ptr:= 0;{start fresh object stream}
end else
incr(pdf_os_objidx);
obj_os_idx(i):= pdf_os_objidx;
obj_offset(i):= pdf_os_cur_objnum;
pdf_os_objnum[pdf_os_objidx]:= i;
pdf_os_objoff[pdf_os_objidx]:= pdf_ptr;
end else begin
obj_offset(i):= pdf_offset;
obj_os_idx(i):= -1;{mark it as not included in object stream}
end;
end;

procedure pdf_begin_obj(i:integer;pdf_os_level:integer);{begin a PDF object}
begin
check_pdfversion;
pdf_os_prepare_obj(i,pdf_os_level);
if not pdf_os_mode then begin
pdf_print_int(i);
pdf_print_ln(" 0 obj");
end else if pdf_compress_level= 0 then begin
pdf_print("% ");{debugging help}
pdf_print_int(i);
pdf_print_ln(" 0 obj");
end;
end;

procedure pdf_new_obj(t,i:integer;pdf_os:integer);{begin a new PDF object}
begin
pdf_create_obj(t,i);
pdf_begin_obj(obj_ptr,pdf_os);
end;

procedure pdf_end_obj;{end a PDF object}
begin
if pdf_os_mode then begin
if pdf_os_objidx= pdf_os_max_objs-1 then
pdf_os_write_objstream;
end else
pdf_print_ln("endobj");{end a PDF object}
end;

procedure pdf_begin_dict(i:integer;pdf_os_level:integer);{begin a PDF dictionary object}
begin
check_pdfversion;
pdf_os_prepare_obj(i,pdf_os_level);
if not pdf_os_mode then begin
pdf_print_int(i);
pdf_print_ln(" 0 obj");
end else if pdf_compress_level= 0 then begin
pdf_print("% ");{debugging help}
pdf_print_int(i);
pdf_print_ln(" 0 obj");
end;
pdf_print_ln("<<");
end;

procedure pdf_new_dict(t,i:integer;pdf_os:integer);{begin a new PDF dictionary object}
begin
pdf_create_obj(t,i);
pdf_begin_dict(obj_ptr,pdf_os);
end;

procedure pdf_end_dict;{end a PDF dictionary object}
begin
if pdf_os_mode then begin
pdf_print_ln(">>");
if pdf_os_objidx= pdf_os_max_objs-1 then
pdf_os_write_objstream;
end else begin
pdf_print_ln(">>");
pdf_print_ln("endobj");
end;
end;

/*:698*//*699:*/
#line 16864 "pdftexdir/pdftex.web"

procedure pdf_os_write_objstream;
var i,j,p,q:pointer;
begin
if pdf_os_cur_objnum= 0 then{no object stream started}
return;
p:= pdf_ptr;
i:= 0;
j:= 0;
while i<=pdf_os_objidx do begin{assemble object number and byte offset pairs}
pdf_print_int(pdf_os_objnum[i]);
pdf_print(" ");
pdf_print_int(pdf_os_objoff[i]);
if j= 9 then begin{print out in groups of ten for better readability}
pdf_out(pdf_new_line_char);
j:= 0;
end else begin
pdf_print(" ");
incr(j);
end;
incr(i);
end;
pdf_buf[pdf_ptr-1]:= pdf_new_line_char;{no risk of flush,as we are in|pdf_os_mode|}
q:= pdf_ptr;
pdf_begin_dict(pdf_os_cur_objnum,0);{switch to PDF stream writing}
pdf_print_ln("/Type /ObjStm");
pdf_print("/N ");
pdf_print_int_ln(pdf_os_objidx+1);
pdf_print("/First ");
pdf_print_int_ln(q-p);
pdf_begin_stream;
pdf_room(q-p);{should always fit into the PDF output buffer}
i:= p;
while i<q do begin{write object number and byte offset pairs}
pdf_quick_out(pdf_os_buf[i]);
incr(i);
end;
i:= 0;
while i<p do begin
q:= i+pdf_buf_size;
if q> p then q:= p;
pdf_room(q-i);
while i<q do begin{write the buffered objects}
pdf_quick_out(pdf_os_buf[i]);
incr(i);
end;
end;
pdf_end_stream;
pdf_os_cur_objnum:= 0;{to force object stream generation next time}
end;

/*:699*//*700:*/
#line 16915 "pdftexdir/pdftex.web"

function append_ptr(p:pointer;i:integer):pointer;{appends a pointer with
info|i|to the end of linked list with head|p|}
var q:pointer;
begin
append_ptr:= p;
fast_get_avail(q);
info(q):= i;
link(q):= null;
if p= null then begin
append_ptr:= q;
return;
end;
while link(p)<> null do
p:= link(p);
link(p):= q;
end;

function pdf_lookup_list(p:pointer;i:integer):pointer;{looks up for pointer
with info|i|in list|p|}
begin
pdf_lookup_list:= null;
while p<> null do begin
if info(p)= i then begin
pdf_lookup_list:= p;
return;
end;
p:= link(p);
end;
end;

/*:700*//*703:*/
#line 17099 "pdftexdir/pdftex.web"

procedure pdf_check_vf_cur_val;forward;
procedure pdf_init_font_cur_val;forward;
procedure scan_pdf_ext_toks;forward;

/*:703*//*1543:*/
#line 34091 "pdftexdir/pdftex.web"

function prev_rightmost(s,e:pointer):pointer;
{finds the node preceding the rightmost node|e|;|s|is some node
before|e|}
var p:pointer;
begin
prev_rightmost:= null;
p:= s;
if p= null then
return;
while link(p)<> e do begin
p:= link(p);
if p= null then
return;
end;
prev_rightmost:= p;
end;

procedure pdf_check_obj(t,n:integer);
var k:integer;
begin
k:= head_tab[t];
while(k<> 0)and(k<> n)do
k:= obj_link(k);
if k= 0 then
pdf_error("ext1","cannot find referenced object");
end;

/*:1543*//*1553:*/
#line 34433 "pdftexdir/pdftex.web"

function find_obj(t,i:integer;byname:boolean):integer;
begin
find_obj:= avl_find_obj(t,i,byname);
end;

procedure flush_str(s:str_number);{flush a string if possible}
begin
if flushable(s)then
flush_string;
end;

function get_obj(t,i:integer;byname:boolean):integer;
var r:integer;
s:str_number;
begin
if byname> 0 then begin
s:= tokens_to_string(i);
r:= find_obj(t,s,true);
end
else begin
s:= 0;
r:= find_obj(t,i,false);
end;
if r= 0 then begin
if byname> 0 then begin
pdf_create_obj(t,-s);
s:= 0;
end
else
pdf_create_obj(t,i);
r:= obj_ptr;
if t= obj_type_dest then
obj_dest_ptr(r):= null;
end;
if s<> 0 then
flush_str(s);
get_obj:= r;
end;

function get_microinterval:integer;
var s,m:integer;{seconds and microseconds}
begin
seconds_and_micros(s,m);
if(s-epochseconds)> 32767 then
get_microinterval:= max_integer
else if(microseconds> m)then
get_microinterval:= ((s-1-epochseconds)*65536)+(((m+1000000-microseconds)/100)*65536)/10000
else
get_microinterval:= ((s-epochseconds)*65536)+(((m-microseconds)/100)*65536)/10000;
end;


/*:1553*/
#line 4064 "pdftexdir/pdftex.web"


/*:190*//*192:*/
#line 4090 "pdftexdir/pdftex.web"

procedure print_font_identifier(f:internal_font_number);
begin
if pdf_font_blink[f]= null_font then
print_esc(font_id_text(f))
else
print_esc(font_id_text(pdf_font_blink[f]));
if pdf_tracing_fonts> 0 then begin
print(" (");
print(font_name[f]);
if font_size[f]<> font_dsize[f]then begin
print("@");
print_scaled(font_size[f]);
print("pt");
end;
print(")");
end else
if pdf_font_expand_ratio[f]<> 0 then begin
print(" (");
if pdf_font_expand_ratio[f]> 0 then
print("+");
print_int(pdf_font_expand_ratio[f]);
print(")");
end;
end;

procedure short_display(p:integer);{prints highlights of list|p|}
var n:integer;{for replacement counts}
begin while p> mem_min do
begin if is_char_node(p)then
begin if p<=mem_end then
begin if font(p)<> font_in_short_display then
#line 1218 "pdftex-final.ch"
 begin if(font(p)> font_max)then
#line 4123 "pdftexdir/pdftex.web"
 print_char("*")

else print_font_identifier(font(p));
print_char(" ");font_in_short_display:= font(p);
end;
print_ASCII(qo(character(p)));
end;
end
else/*193:*/
#line 4136 "pdftexdir/pdftex.web"

case type(p)of
hlist_node,vlist_node,ins_node,whatsit_node,mark_node,adjust_node,
unset_node:print("[]");
rule_node:print_char("|");
glue_node:if glue_ptr(p)<> zero_glue then print_char(" ");
math_node:if subtype(p)>=L_code then print("[]")
else print_char("$");
ligature_node:short_display(lig_ptr(p));
disc_node:begin short_display(pre_break(p));
short_display(post_break(p));
n:= replace_count(p);
while n> 0 do
begin if link(p)<> null then p:= link(p);
decr(n);
end;
end;
othercases do_nothing
endcases

/*:193*/
#line 4131 "pdftexdir/pdftex.web"
;
p:= link(p);
end;
end;

/*:192*//*194:*/
#line 1226 "pdftex-final.ch"
procedure print_font_and_char(p:integer);{prints|char_node|data}
begin if p> mem_end then print_esc("CLOBBERED.")
else begin if(font(p)> font_max)then print_char("*")
#line 4163 "pdftexdir/pdftex.web"

else print_font_identifier(font(p));
print_char(" ");print_ASCII(qo(character(p)));
end;
end;

procedure print_mark(p:integer);{prints token list data in braces}
begin print_char("{");
if(p<hi_mem_min)or(p> mem_end)then print_esc("CLOBBERED.")
else show_token_list(link(p),null,max_print_line-10);
print_char("}");
end;

procedure print_rule_dimen(d:scaled);{prints dimension in rule node}
begin if is_running(d)then print_char("*")else print_scaled(d);

end;

/*:194*//*195:*/
#line 4184 "pdftexdir/pdftex.web"
procedure print_glue(d:scaled;order:integer;s:str_number);
{prints a glue component}
begin print_scaled(d);
if(order<normal)or(order> filll)then print("foul")
else if order> normal then
begin print("fil");
while order> fil do
begin print_char("l");decr(order);
end;
end
else if s<> 0 then print(s);
end;

/*:195*//*196:*/
#line 4199 "pdftexdir/pdftex.web"
procedure print_spec(p:integer;s:str_number);
{prints a glue specification}
begin if(p<mem_min)or(p>=lo_mem_max)then print_char("*")

else begin print_scaled(width(p));
if s<> 0 then print(s);
if stretch(p)<> 0 then
begin print(" plus ");print_glue(stretch(p),stretch_order(p),s);
end;
if shrink(p)<> 0 then
begin print(" minus ");print_glue(shrink(p),shrink_order(p),s);
end;
end;
end;

/*:196*//*197:*/
#line 4217 "pdftexdir/pdftex.web"
/*865:*/
#line 21550 "pdftexdir/pdftex.web"

procedure print_fam_and_char(p:pointer);{prints family and character}
begin print_esc("fam");print_int(fam(p));print_char(" ");
print_ASCII(qo(character(p)));
end;

procedure print_delimiter(p:pointer);{prints a delimiter as 24-bit hex value}
var a:integer;{accumulator}
begin a:= small_fam(p)*256+qo(small_char(p));
a:= a*1000+large_fam(p)*256+qo(large_char(p));
if a<0 then print_int(a){this should never happen}
else print_hex(a);
end;

/*:865*//*866:*/
#line 21571 "pdftexdir/pdftex.web"

procedure show_info;forward;{|show_node_list(info(temp_ptr))|}
procedure print_subsidiary_data(p:pointer;c:ASCII_code);
{display a noad field}
begin if cur_length>=depth_threshold then
begin if math_type(p)<> empty then print(" []");
end
else begin append_char(c);{include|c|in the recursion history}
temp_ptr:= p;{prepare for|show_info|if recursion is needed}
case math_type(p)of
math_char:begin print_ln;print_current_string;print_fam_and_char(p);
end;
sub_box:show_info;{recursive call}
sub_mlist:if info(p)= null then
begin print_ln;print_current_string;print("{}");
end
else show_info;{recursive call}
othercases do_nothing{|empty|}
endcases;
flush_char;{remove|c|from the recursion history}
end;
end;

/*:866*//*868:*/
#line 21608 "pdftexdir/pdftex.web"

procedure print_style(c:integer);
begin case c div 2 of
0:print_esc("displaystyle");{|display_style= 0|}
1:print_esc("textstyle");{|text_style= 2|}
2:print_esc("scriptstyle");{|script_style= 4|}
3:print_esc("scriptscriptstyle");{|script_script_style= 6|}
othercases print("Unknown style!")
endcases;
end;

/*:868*/
#line 4217 "pdftexdir/pdftex.web"

/*243:*/
#line 5266 "pdftexdir/pdftex.web"

procedure print_skip_param(n:integer);
begin case n of
line_skip_code:print_esc("lineskip");
baseline_skip_code:print_esc("baselineskip");
par_skip_code:print_esc("parskip");
above_display_skip_code:print_esc("abovedisplayskip");
below_display_skip_code:print_esc("belowdisplayskip");
above_display_short_skip_code:print_esc("abovedisplayshortskip");
below_display_short_skip_code:print_esc("belowdisplayshortskip");
left_skip_code:print_esc("leftskip");
right_skip_code:print_esc("rightskip");
top_skip_code:print_esc("topskip");
split_top_skip_code:print_esc("splittopskip");
tab_skip_code:print_esc("tabskip");
space_skip_code:print_esc("spaceskip");
xspace_skip_code:print_esc("xspaceskip");
par_fill_skip_code:print_esc("parfillskip");
thin_mu_skip_code:print_esc("thinmuskip");
med_mu_skip_code:print_esc("medmuskip");
thick_mu_skip_code:print_esc("thickmuskip");
othercases print("[unknown glue parameter!]")
endcases;
end;

/*:243*/
#line 4218 "pdftexdir/pdftex.web"


/*:197*//*200:*/
#line 4255 "pdftexdir/pdftex.web"
procedure show_node_list(p:integer);{prints a node list symbolically}
label exit;
var n:integer;{the number of items already printed at this level}
g:real;{a glue ratio,as a floating point number}
begin if cur_length> depth_threshold then
begin if p> null then print(" []");
{indicate that there's been some truncation}
return;
end;
n:= 0;
while p> mem_min do
begin print_ln;print_current_string;{display the nesting history}
if p> mem_end then{pointer out of range}
begin print("Bad link, display aborted.");return;

end;
incr(n);if n> breadth_max then{time to stop}
begin print("etc.");return;

end;
/*201:*/
#line 4281 "pdftexdir/pdftex.web"

if is_char_node(p)then print_font_and_char(p)
else case type(p)of
hlist_node,vlist_node,unset_node:/*202:*/
#line 4308 "pdftexdir/pdftex.web"

begin if type(p)= hlist_node then print_esc("h")
else if type(p)= vlist_node then print_esc("v")
else print_esc("unset");
print("box(");print_scaled(height(p));print_char("+");
print_scaled(depth(p));print(")x");print_scaled(width(p));
if type(p)= unset_node then
/*203:*/
#line 4325 "pdftexdir/pdftex.web"

begin if span_count(p)<> min_quarterword then
begin print(" (");print_int(qo(span_count(p))+1);
print(" columns)");
end;
if glue_stretch(p)<> 0 then
begin print(", stretch ");print_glue(glue_stretch(p),glue_order(p),0);
end;
if glue_shrink(p)<> 0 then
begin print(", shrink ");print_glue(glue_shrink(p),glue_sign(p),0);
end;
end

/*:203*/
#line 4315 "pdftexdir/pdftex.web"

else begin/*204:*/
#line 4348 "pdftexdir/pdftex.web"

g:= float(glue_set(p));
if(g<> float_constant(0))and(glue_sign(p)<> normal)then
begin print(", glue set ");
if glue_sign(p)= shrinking then print("- ");
#line 1235 "pdftex-final.ch"
{The Unix|pc|folks removed this restriction with a remark that
invalid bit patterns were vanishingly improbable,so we follow
their example without really understanding it.
|if abs(mem[p+glue_offset].int)<52?.?')|
|else|}
if fabs(g)> float_constant(20000)then
#line 4355 "pdftexdir/pdftex.web"
 begin if g> float_constant(0)then print_char(">")
else print("< -");
print_glue(20000*unity,glue_order(p),0);
end
else print_glue(round(unity*g),glue_order(p),0);

end

/*:204*/
#line 4316 "pdftexdir/pdftex.web"
;
if shift_amount(p)<> 0 then
begin print(", shifted ");print_scaled(shift_amount(p));
end;
if eTeX_ex then/*1701:*/
#line 37516 "pdftexdir/pdftex.web"

if(type(p)= hlist_node)and(box_lr(p)= dlist)then print(", display")

/*:1701*/
#line 4320 "pdftexdir/pdftex.web"
;
end;
node_list_display(list_ptr(p));{recursive call}
end

/*:202*/
#line 4284 "pdftexdir/pdftex.web"
;
rule_node:/*205:*/
#line 4363 "pdftexdir/pdftex.web"

begin print_esc("rule(");print_rule_dimen(height(p));print_char("+");
print_rule_dimen(depth(p));print(")x");print_rule_dimen(width(p));
end

/*:205*/
#line 4285 "pdftexdir/pdftex.web"
;
ins_node:/*206:*/
#line 4368 "pdftexdir/pdftex.web"

begin print_esc("insert");print_int(qo(subtype(p)));
print(", natural size ");print_scaled(height(p));
print("; split(");print_spec(split_top_ptr(p),0);
print_char(",");print_scaled(depth(p));
print("); float cost ");print_int(float_cost(p));
node_list_display(ins_ptr(p));{recursive call}
end

/*:206*/
#line 4286 "pdftexdir/pdftex.web"
;
whatsit_node:/*1600:*/
#line 35235 "pdftexdir/pdftex.web"

case subtype(p)of
open_node:begin print_write_whatsit("openout",p);
print_char("=");print_file_name(open_name(p),open_area(p),open_ext(p));
end;
write_node:begin print_write_whatsit("write",p);
print_mark(write_tokens(p));
end;
close_node:print_write_whatsit("closeout",p);
#line 5634 "pdftex-final.ch"
special_node:begin print_esc("special");
if write_stream(p)<> mubyte_zero then
begin
print_char("<");print_int(write_stream(p)-mubyte_zero);
if(write_stream(p)-mubyte_zero= 2)or
(write_stream(p)-mubyte_zero= 3)then
begin
print_char(":");print_int(write_mubyte(p)-mubyte_zero);
end;
print_char(">");
end;
#line 35245 "pdftexdir/pdftex.web"
print_mark(write_tokens(p));
end;
language_node:begin print_esc("setlanguage");
print_int(what_lang(p));print(" (hyphenmin ");
print_int(what_lhm(p));print_char(",");
print_int(what_rhm(p));print_char(")");
end;
pdf_literal_node:begin
print_esc("pdfliteral");
case pdf_literal_mode(p)of
set_origin:
do_nothing;
direct_page:
print(" page");
direct_always:
print(" direct");
othercases confusion("literal2")
endcases;
print_mark(pdf_literal_data(p));
end;
pdf_colorstack_node:begin
print_esc("pdfcolorstack ");
print_int(pdf_colorstack_stack(p));
case pdf_colorstack_cmd(p)of
colorstack_set:
print(" set ");
colorstack_push:
print(" push ");
colorstack_pop:
print(" pop");
colorstack_current:
print(" current");
othercases confusion("pdfcolorstack")
endcases;
if pdf_colorstack_cmd(p)<=colorstack_data then
print_mark(pdf_colorstack_data(p));
end;
pdf_setmatrix_node:begin
print_esc("pdfsetmatrix");
print_mark(pdf_setmatrix_data(p));
end;
pdf_save_node:begin
print_esc("pdfsave");
end;
pdf_restore_node:begin
print_esc("pdfrestore");
end;
pdf_refobj_node:begin
print_esc("pdfrefobj");
if obj_obj_is_stream(pdf_obj_objnum(p))> 0 then begin
if obj_obj_stream_attr(pdf_obj_objnum(p))<> null then begin
print(" attr");
print_mark(obj_obj_stream_attr(pdf_obj_objnum(p)));
end;
print(" stream");
end;
if obj_obj_is_file(pdf_obj_objnum(p))> 0 then
print(" file");
print_mark(obj_obj_data(pdf_obj_objnum(p)));
end;
pdf_refxform_node:begin
print_esc("pdfrefxform");
print("(");
print_scaled(obj_xform_height(pdf_xform_objnum(p)));
print_char("+");
print_scaled(obj_xform_depth(pdf_xform_objnum(p)));
print(")x");
print_scaled(obj_xform_width(pdf_xform_objnum(p)));
end;
pdf_refximage_node:begin
print_esc("pdfrefximage");
print("(");
print_scaled(obj_ximage_height(pdf_ximage_objnum(p)));
print_char("+");
print_scaled(obj_ximage_depth(pdf_ximage_objnum(p)));
print(")x");
print_scaled(obj_ximage_width(pdf_ximage_objnum(p)));
end;
pdf_annot_node:begin
print_esc("pdfannot");
/*1598:*/
#line 35213 "pdftexdir/pdftex.web"

print("(");
print_rule_dimen(pdf_height(p));
print_char("+");
print_rule_dimen(pdf_depth(p));
print(")x");
print_rule_dimen(pdf_width(p))

/*:1598*/
#line 35325 "pdftexdir/pdftex.web"
;
print_mark(pdf_annot_data(p));
end;
pdf_start_link_node:begin
print_esc("pdfstartlink");
/*1598:*/
#line 35213 "pdftexdir/pdftex.web"

print("(");
print_rule_dimen(pdf_height(p));
print_char("+");
print_rule_dimen(pdf_depth(p));
print(")x");
print_rule_dimen(pdf_width(p))

/*:1598*/
#line 35330 "pdftexdir/pdftex.web"
;
if pdf_link_attr(p)<> null then begin
print(" attr");
print_mark(pdf_link_attr(p));
end;
print(" action");
if pdf_action_type(pdf_link_action(p))= pdf_action_user then begin
print(" user");
print_mark(pdf_action_user_tokens(pdf_link_action(p)));
end
else begin
if pdf_action_file(pdf_link_action(p))<> null then begin
print(" file");
print_mark(pdf_action_file(pdf_link_action(p)));
end;
case pdf_action_type(pdf_link_action(p))of
pdf_action_goto:begin
if pdf_action_named_id(pdf_link_action(p))> 0 then begin
print(" goto name");
print_mark(pdf_action_id(pdf_link_action(p)));
end
else begin
print(" goto num");
print_int(pdf_action_id(pdf_link_action(p)))
end;
end;
pdf_action_page:begin
print(" page");
print_int(pdf_action_id(pdf_link_action(p)));
print_mark(pdf_action_page_tokens(pdf_link_action(p)));
end;
pdf_action_thread:begin
if pdf_action_named_id(pdf_link_action(p))> 0 then begin
print(" thread name");
print_mark(pdf_action_id(pdf_link_action(p)));
end
else begin
print(" thread num");
print_int(pdf_action_id(pdf_link_action(p)));
end;
end;
othercases pdf_error("displaying","unknown action type");
endcases;
end
end;
pdf_end_link_node:print_esc("pdfendlink");
pdf_dest_node:begin
print_esc("pdfdest");
if pdf_dest_named_id(p)> 0 then begin
print(" name");
print_mark(pdf_dest_id(p));
end
else begin
print(" num");
print_int(pdf_dest_id(p));
end;
print(" ");
case pdf_dest_type(p)of
pdf_dest_xyz:begin
print("xyz");
if pdf_dest_xyz_zoom(p)<> null then begin
print(" zoom");
print_int(pdf_dest_xyz_zoom(p));
end;
end;
pdf_dest_fitbh:print("fitbh");
pdf_dest_fitbv:print("fitbv");
pdf_dest_fitb:print("fitb");
pdf_dest_fith:print("fith");
pdf_dest_fitv:print("fitv");
pdf_dest_fitr:begin
print("fitr");
/*1598:*/
#line 35213 "pdftexdir/pdftex.web"

print("(");
print_rule_dimen(pdf_height(p));
print_char("+");
print_rule_dimen(pdf_depth(p));
print(")x");
print_rule_dimen(pdf_width(p))

/*:1598*/
#line 35402 "pdftexdir/pdftex.web"
;
end;
pdf_dest_fit:print("fit");
othercases print("unknown!");
endcases;
end;
pdf_thread_node,
pdf_start_thread_node:begin
if subtype(p)= pdf_thread_node then
print_esc("pdfthread")
else
print_esc("pdfstartthread");
print("(");print_rule_dimen(pdf_height(p));print_char("+");
print_rule_dimen(pdf_depth(p));print(")x");
print_rule_dimen(pdf_width(p));
if pdf_thread_attr(p)<> null then begin
print(" attr");
print_mark(pdf_thread_attr(p));
end;
if pdf_thread_named_id(p)> 0 then begin
print(" name");
print_mark(pdf_thread_id(p));
end
else begin
print(" num");
print_int(pdf_thread_id(p));
end;
end;
pdf_end_thread_node:print_esc("pdfendthread");
pdf_save_pos_node:print_esc("pdfsavepos");
pdf_snap_ref_point_node:print_esc("pdfsnaprefpoint");
pdf_snapy_node:begin
print_esc("pdfsnapy");
print_char(" ");
print_spec(snap_glue_ptr(p),0);
print_char(" ");
print_spec(final_skip(p),0);
end;
pdf_snapy_comp_node:begin
print_esc("pdfsnapycomp");
print_char(" ");
print_int(snapy_comp_ratio(p));
end;
pdf_interword_space_on_node:print_esc("pdfinterwordspaceon");
pdf_interword_space_off_node:print_esc("pdfinterwordspaceoff");
pdf_fake_space_node:print_esc("pdffakespace");
pdf_running_link_off_node:print_esc("pdfrunninglinkoff");
pdf_running_link_on_node:print_esc("pdfrunninglinkon");
othercases print("whatsit?")
endcases

/*:1600*/
#line 4287 "pdftexdir/pdftex.web"
;
glue_node:/*207:*/
#line 4377 "pdftexdir/pdftex.web"

if subtype(p)>=a_leaders then/*208:*/
#line 4395 "pdftexdir/pdftex.web"

begin print_esc("");
if subtype(p)= c_leaders then print_char("c")
else if subtype(p)= x_leaders then print_char("x");
print("leaders ");print_spec(glue_ptr(p),0);
node_list_display(leader_ptr(p));{recursive call}
end

/*:208*/
#line 4378 "pdftexdir/pdftex.web"

else begin print_esc("glue");
if subtype(p)<> normal then
begin print_char("(");
if subtype(p)<cond_math_glue then
print_skip_param(subtype(p)-1)
else if subtype(p)= cond_math_glue then print_esc("nonscript")
else print_esc("mskip");
print_char(")");
end;
if subtype(p)<> cond_math_glue then
begin print_char(" ");
if subtype(p)<cond_math_glue then print_spec(glue_ptr(p),0)
else print_spec(glue_ptr(p),"mu");
end;
end

/*:207*/
#line 4288 "pdftexdir/pdftex.web"
;
margin_kern_node:begin
print_esc("kern");
print_scaled(width(p));
if subtype(p)= left_side then
print(" (left margin)")
else
print(" (right margin)");
end;
kern_node:/*209:*/
#line 4405 "pdftexdir/pdftex.web"

if subtype(p)<> mu_glue then
begin print_esc("kern");
if subtype(p)<> normal then print_char(" ");
print_scaled(width(p));
if subtype(p)= acc_kern then print(" (for accent)");

if subtype(p)= auto_kern then print(" (for \pdfprependkern/\pdfappendkern)");
end
else begin print_esc("mkern");print_scaled(width(p));print("mu");
end

/*:209*/
#line 4297 "pdftexdir/pdftex.web"
;
math_node:/*210:*/
#line 4417 "pdftexdir/pdftex.web"

if subtype(p)> after then
begin if end_LR(p)then print_esc("end")
else print_esc("begin");
if subtype(p)> R_code then print_char("R")
else if subtype(p)> L_code then print_char("L")
else print_char("M");
end else
begin print_esc("math");
if subtype(p)= before then print("on")
else print("off");
if width(p)<> 0 then
begin print(", surrounded ");print_scaled(width(p));
end;
end

/*:210*/
#line 4298 "pdftexdir/pdftex.web"
;
ligature_node:/*211:*/
#line 4433 "pdftexdir/pdftex.web"

begin print_font_and_char(lig_char(p));print(" (ligature ");
if subtype(p)> 1 then print_char("|");
font_in_short_display:= font(lig_char(p));short_display(lig_ptr(p));
if odd(subtype(p))then print_char("|");
print_char(")");
end

/*:211*/
#line 4299 "pdftexdir/pdftex.web"
;
penalty_node:/*212:*/
#line 4441 "pdftexdir/pdftex.web"

begin print_esc("penalty ");print_int(penalty(p));
end

/*:212*/
#line 4300 "pdftexdir/pdftex.web"
;
disc_node:/*213:*/
#line 4448 "pdftexdir/pdftex.web"

begin print_esc("discretionary");
if replace_count(p)> 0 then
begin print(" replacing ");print_int(replace_count(p));
end;
node_list_display(pre_break(p));{recursive call}
append_char("|");show_node_list(post_break(p));flush_char;{recursive call}
end

/*:213*/
#line 4301 "pdftexdir/pdftex.web"
;
mark_node:/*214:*/
#line 4457 "pdftexdir/pdftex.web"

begin print_esc("mark");
if mark_class(p)<> 0 then
begin print_char("s");print_int(mark_class(p));
end;
print_mark(mark_ptr(p));
end

/*:214*/
#line 4302 "pdftexdir/pdftex.web"
;
adjust_node:/*215:*/
#line 4465 "pdftexdir/pdftex.web"

begin print_esc("vadjust");if adjust_pre(p)<> 0 then print(" pre ");
node_list_display(adjust_ptr(p));{recursive call}
end

/*:215*/
#line 4303 "pdftexdir/pdftex.web"
;
/*864:*/
#line 21540 "pdftexdir/pdftex.web"

style_node:print_style(subtype(p));
choice_node:/*869:*/
#line 21619 "pdftexdir/pdftex.web"

begin print_esc("mathchoice");
append_char("D");show_node_list(display_mlist(p));flush_char;
append_char("T");show_node_list(text_mlist(p));flush_char;
append_char("S");show_node_list(script_mlist(p));flush_char;
append_char("s");show_node_list(script_script_mlist(p));flush_char;
end

/*:869*/
#line 21542 "pdftexdir/pdftex.web"
;
ord_noad,op_noad,bin_noad,rel_noad,open_noad,close_noad,punct_noad,inner_noad,
radical_noad,over_noad,under_noad,vcenter_noad,accent_noad,
left_noad,right_noad:/*870:*/
#line 21627 "pdftexdir/pdftex.web"

begin case type(p)of
ord_noad:print_esc("mathord");
op_noad:print_esc("mathop");
bin_noad:print_esc("mathbin");
rel_noad:print_esc("mathrel");
open_noad:print_esc("mathopen");
close_noad:print_esc("mathclose");
punct_noad:print_esc("mathpunct");
inner_noad:print_esc("mathinner");
over_noad:print_esc("overline");
under_noad:print_esc("underline");
vcenter_noad:print_esc("vcenter");
radical_noad:begin print_esc("radical");print_delimiter(left_delimiter(p));
end;
accent_noad:begin print_esc("accent");print_fam_and_char(accent_chr(p));
end;
left_noad:begin print_esc("left");print_delimiter(delimiter(p));
end;
right_noad:begin if subtype(p)= normal then print_esc("right")
else print_esc("middle");
print_delimiter(delimiter(p));
end;
end;
if type(p)<left_noad then
begin if subtype(p)<> normal then
if subtype(p)= limits then print_esc("limits")
else print_esc("nolimits");
print_subsidiary_data(nucleus(p),".");
end;
print_subsidiary_data(supscr(p),"^");
print_subsidiary_data(subscr(p),"_");
end

/*:870*/
#line 21545 "pdftexdir/pdftex.web"
;
fraction_noad:/*871:*/
#line 21661 "pdftexdir/pdftex.web"

begin print_esc("fraction, thickness ");
if thickness(p)= default_code then print("= default")
else print_scaled(thickness(p));
if(small_fam(left_delimiter(p))<> 0)or
(small_char(left_delimiter(p))<> min_quarterword)or
(large_fam(left_delimiter(p))<> 0)or
(large_char(left_delimiter(p))<> min_quarterword)then
begin print(", left-delimiter ");print_delimiter(left_delimiter(p));
end;
if(small_fam(right_delimiter(p))<> 0)or
(small_char(right_delimiter(p))<> min_quarterword)or
(large_fam(right_delimiter(p))<> 0)or
(large_char(right_delimiter(p))<> min_quarterword)then
begin print(", right-delimiter ");print_delimiter(right_delimiter(p));
end;
print_subsidiary_data(numerator(p),"\");
print_subsidiary_data(denominator(p),"/");
end

/*:871*/
#line 21546 "pdftexdir/pdftex.web"
;

/*:864*/
#line 4304 "pdftexdir/pdftex.web"

othercases print("Unknown node type!")
endcases

/*:201*/
#line 4275 "pdftexdir/pdftex.web"
;
p:= link(p);
end;
exit:
end;

/*:200*//*216:*/
#line 4473 "pdftexdir/pdftex.web"
procedure show_box(p:pointer);
begin/*254:*/
#line 5822 "pdftexdir/pdftex.web"

depth_threshold:= show_box_depth;
breadth_max:= show_box_breadth

/*:254*/
#line 4475 "pdftexdir/pdftex.web"
;
if breadth_max<=0 then breadth_max:= 5;
if pool_ptr+depth_threshold>=pool_size then
depth_threshold:= pool_size-pool_ptr-1;
{now there's enough room for prefix string}
show_node_list(p);{the show starts at|p|}
print_ln;
end;

/*:216*//*218:*/
#line 4498 "pdftexdir/pdftex.web"
procedure delete_token_ref(p:pointer);{|p|points to the reference count
of a token list that is losing one reference}
begin if token_ref_count(p)= null then flush_list(p)
else decr(token_ref_count(p));
end;

/*:218*//*219:*/
#line 4512 "pdftexdir/pdftex.web"
procedure delete_glue_ref(p:pointer);{|p|points to a glue specification}
fast_delete_glue_ref(p);

/*:219*//*220:*/
#line 1246 "pdftex-final.ch"
procedure flush_node_list(p:pointer);{erase list of nodes starting at|p|}
#line 4521 "pdftexdir/pdftex.web"
label done;{go here when node|p|has been freed}
var q:pointer;{successor to node|p|}
begin while p<> null do

begin q:= link(p);
if is_char_node(p)then free_avail(p)
else begin case type(p)of
hlist_node,vlist_node,unset_node:begin flush_node_list(list_ptr(p));
free_node(p,box_node_size);goto done;
end;
rule_node:begin free_node(p,rule_node_size);goto done;
end;
ins_node:begin flush_node_list(ins_ptr(p));
delete_glue_ref(split_top_ptr(p));
free_node(p,ins_node_size);goto done;
end;
whatsit_node:/*1602:*/
#line 35565 "pdftexdir/pdftex.web"

begin case subtype(p)of
open_node:free_node(p,open_node_size);
write_node,special_node:begin delete_token_ref(write_tokens(p));
free_node(p,write_node_size);goto done;
end;
close_node,language_node:free_node(p,small_node_size);
pdf_literal_node:begin
delete_token_ref(pdf_literal_data(p));
free_node(p,write_node_size);
end;
pdf_colorstack_node:begin
if pdf_colorstack_cmd(p)<=colorstack_data then begin
delete_token_ref(pdf_colorstack_data(p));
free_node(p,pdf_colorstack_setter_node_size);
end
else
free_node(p,pdf_colorstack_getter_node_size);
end;
pdf_setmatrix_node:begin
delete_token_ref(pdf_setmatrix_data(p));
free_node(p,pdf_setmatrix_node_size);
end;
pdf_save_node:begin
free_node(p,pdf_save_node_size);
end;
pdf_restore_node:begin
free_node(p,pdf_restore_node_size);
end;
pdf_refobj_node:
free_node(p,pdf_refobj_node_size);
pdf_refxform_node:
free_node(p,pdf_refxform_node_size);
pdf_refximage_node:
free_node(p,pdf_refximage_node_size);
pdf_annot_node:begin
delete_token_ref(pdf_annot_data(p));
free_node(p,pdf_annot_node_size);
end;
pdf_start_link_node:begin
if pdf_link_attr(p)<> null then
delete_token_ref(pdf_link_attr(p));
delete_action_ref(pdf_link_action(p));
free_node(p,pdf_annot_node_size);
end;
pdf_end_link_node:
free_node(p,small_node_size);
pdf_dest_node:begin
if pdf_dest_named_id(p)> 0 then
delete_token_ref(pdf_dest_id(p));
free_node(p,pdf_dest_node_size);
end;
pdf_thread_node,
pdf_start_thread_node:begin
if pdf_thread_named_id(p)> 0 then
delete_token_ref(pdf_thread_id(p));
if pdf_thread_attr(p)<> null then
delete_token_ref(pdf_thread_attr(p));
free_node(p,pdf_thread_node_size);
end;
pdf_end_thread_node:
free_node(p,small_node_size);
pdf_save_pos_node:
free_node(p,small_node_size);
pdf_snap_ref_point_node:
free_node(p,small_node_size);
pdf_snapy_node:begin
delete_glue_ref(snap_glue_ptr(p));
free_node(p,snap_node_size);
end;
pdf_snapy_comp_node:
free_node(p,small_node_size);
pdf_interword_space_on_node:
free_node(p,small_node_size);
pdf_interword_space_off_node:
free_node(p,small_node_size);
pdf_fake_space_node:
free_node(p,small_node_size);
pdf_running_link_off_node:
free_node(p,small_node_size);
pdf_running_link_on_node:
free_node(p,small_node_size);
othercases confusion("ext3")

endcases;
goto done;
end

/*:1602*/
#line 4537 "pdftexdir/pdftex.web"
;
#line 1254 "pdftex-final.ch"
glue_node:begin fast_delete_glue_ref(glue_ptr(p));
if leader_ptr(p)<> null then flush_node_list(leader_ptr(p));
free_node(p,medium_node_size);
goto done;
end;
#line 1264 "pdftex-final.ch"
kern_node,math_node,penalty_node:begin
free_node(p,medium_node_size);
goto done;
end;
#line 4542 "pdftexdir/pdftex.web"
margin_kern_node:begin
free_avail(margin_char(p));
free_node(p,margin_kern_node_size);
goto done;
end;
ligature_node:flush_node_list(lig_ptr(p));
mark_node:delete_token_ref(mark_ptr(p));
disc_node:begin flush_node_list(pre_break(p));
flush_node_list(post_break(p));
end;
adjust_node:flush_node_list(adjust_ptr(p));
/*872:*/
#line 21683 "pdftexdir/pdftex.web"

style_node:begin free_node(p,style_node_size);goto done;
end;
choice_node:begin flush_node_list(display_mlist(p));
flush_node_list(text_mlist(p));
flush_node_list(script_mlist(p));
flush_node_list(script_script_mlist(p));
free_node(p,style_node_size);goto done;
end;
ord_noad,op_noad,bin_noad,rel_noad,open_noad,close_noad,punct_noad,inner_noad,
radical_noad,over_noad,under_noad,vcenter_noad,accent_noad:
begin if math_type(nucleus(p))>=sub_box then
flush_node_list(info(nucleus(p)));
if math_type(supscr(p))>=sub_box then
flush_node_list(info(supscr(p)));
if math_type(subscr(p))>=sub_box then
flush_node_list(info(subscr(p)));
if type(p)= radical_noad then free_node(p,radical_noad_size)
else if type(p)= accent_noad then free_node(p,accent_noad_size)
else free_node(p,noad_size);
goto done;
end;
left_noad,right_noad:begin free_node(p,noad_size);goto done;
end;
fraction_noad:begin flush_node_list(info(numerator(p)));
flush_node_list(info(denominator(p)));
free_node(p,fraction_noad_size);goto done;
end;

/*:872*/
#line 4553 "pdftexdir/pdftex.web"

othercases confusion("flushing")

endcases;
free_node(p,small_node_size);
done:end;
p:= q;
end;
end;

/*:220*//*222:*/
#line 4587 "pdftexdir/pdftex.web"
function copy_node_list(p:pointer):pointer;{makes a duplicate of the
node list that starts at|p|and returns a pointer to the new list}
var h:pointer;{temporary head of copied list}
q:pointer;{previous position in new list}
r:pointer;{current node being fabricated for new list}
words:0. .5;{number of words remaining to be copied}
begin h:= get_avail;q:= h;
while p<> null do
begin/*223:*/
#line 4602 "pdftexdir/pdftex.web"

words:= 1;{this setting occurs in more branches than any other}
if is_char_node(p)then r:= get_avail
else/*224:*/
#line 1273 "pdftex-final.ch"

#line 4612 "pdftexdir/pdftex.web"
 case type(p)of
#line 1279 "pdftex-final.ch"
 hlist_node,vlist_node,unset_node:begin r:= get_node(box_node_size);
/*1932:*/
#line 7065 "pdftex-final.ch"

sync_tag(r+box_node_size):= sync_tag(p+box_node_size);
sync_line(r+box_node_size):= sync_line(p+box_node_size);

/*:1932*/
#line 1280 "pdftex-final.ch"
;
#line 4614 "pdftexdir/pdftex.web"
mem[r+6]:= mem[p+6];mem[r+5]:= mem[p+5];{copy the last two words}
list_ptr(r):= copy_node_list(list_ptr(p));{this affects|mem[r+5]|}
words:= 5;
end;
#line 1286 "pdftex-final.ch"
rule_node:begin r:= get_node(rule_node_size);words:= rule_node_size-synctex_field_size;{{\sl Sync\TeX}:do not let\TeX\copy the{\sl Sync\TeX}information}
/*1933:*/
#line 7069 "pdftex-final.ch"

{|sync_tag(r+rule_node_size):= sync_tag(p+rule_node_size);|
|sync_line(r+rule_node_size):= sync_line(p+rule_node_size);|}

/*:1933*/
#line 1287 "pdftex-final.ch"
;
#line 4619 "pdftexdir/pdftex.web"
end;
ins_node:begin r:= get_node(ins_node_size);mem[r+4]:= mem[p+4];
add_glue_ref(split_top_ptr(p));
ins_ptr(r):= copy_node_list(ins_ptr(p));{this affects|mem[r+4]|}
words:= ins_node_size-1;
end;
whatsit_node:/*1601:*/
#line 35453 "pdftexdir/pdftex.web"

case subtype(p)of
open_node:begin r:= get_node(open_node_size);words:= open_node_size;
end;
write_node,special_node:begin r:= get_node(write_node_size);
add_token_ref(write_tokens(p));words:= write_node_size;
end;
close_node,language_node:begin r:= get_node(small_node_size);
words:= small_node_size;
end;
pdf_literal_node:begin
r:= get_node(write_node_size);
add_token_ref(pdf_literal_data(p));
words:= write_node_size;
end;
pdf_colorstack_node:begin
if pdf_colorstack_cmd(p)<=colorstack_data then begin
r:= get_node(pdf_colorstack_setter_node_size);
add_token_ref(pdf_colorstack_data(p));
words:= pdf_colorstack_setter_node_size;
end
else begin
r:= get_node(pdf_colorstack_getter_node_size);
words:= pdf_colorstack_getter_node_size;
end;
end;
pdf_setmatrix_node:begin
r:= get_node(pdf_setmatrix_node_size);
add_token_ref(pdf_setmatrix_data(p));
words:= pdf_setmatrix_node_size;
end;
pdf_save_node:begin
r:= get_node(pdf_save_node_size);
words:= pdf_save_node_size;
end;
pdf_restore_node:begin
r:= get_node(pdf_restore_node_size);
words:= pdf_restore_node_size;
end;
pdf_refobj_node:begin
r:= get_node(pdf_refobj_node_size);
words:= pdf_refobj_node_size;
end;
pdf_refxform_node:begin
r:= get_node(pdf_refxform_node_size);
words:= pdf_refxform_node_size;
end;
pdf_refximage_node:begin
r:= get_node(pdf_refximage_node_size);
words:= pdf_refximage_node_size;
end;
pdf_annot_node:begin
r:= get_node(pdf_annot_node_size);
add_token_ref(pdf_annot_data(p));
words:= pdf_annot_node_size;
end;
pdf_start_link_node:begin
r:= get_node(pdf_annot_node_size);
pdf_height(r):= pdf_height(p);
pdf_depth(r):= pdf_depth(p);
pdf_width(r):= pdf_width(p);
pdf_link_attr(r):= pdf_link_attr(p);
if pdf_link_attr(r)<> null then
add_token_ref(pdf_link_attr(r));
pdf_link_action(r):= pdf_link_action(p);
add_action_ref(pdf_link_action(r));
pdf_link_objnum(r):= pdf_link_objnum(p);
end;
pdf_end_link_node:
r:= get_node(small_node_size);
pdf_dest_node:begin
r:= get_node(pdf_dest_node_size);
if pdf_dest_named_id(p)> 0 then
add_token_ref(pdf_dest_id(p));
words:= pdf_dest_node_size;
end;
pdf_thread_node,
pdf_start_thread_node:begin
r:= get_node(pdf_thread_node_size);
if pdf_thread_named_id(p)> 0 then
add_token_ref(pdf_thread_id(p));
if pdf_thread_attr(p)<> null then
add_token_ref(pdf_thread_attr(p));
words:= pdf_thread_node_size;
end;
pdf_end_thread_node:
r:= get_node(small_node_size);
pdf_save_pos_node:
r:= get_node(small_node_size);
pdf_snap_ref_point_node:
r:= get_node(small_node_size);
pdf_snapy_node:begin
add_glue_ref(snap_glue_ptr(p));
r:= get_node(snap_node_size);
words:= snap_node_size;
end;
pdf_snapy_comp_node:
r:= get_node(small_node_size);
pdf_interword_space_on_node:
r:= get_node(small_node_size);
pdf_interword_space_off_node:
r:= get_node(small_node_size);
pdf_fake_space_node:
r:= get_node(small_node_size);
pdf_running_link_off_node:
r:= get_node(small_node_size);
pdf_running_link_on_node:
r:= get_node(small_node_size);
othercases confusion("ext2")

endcases

/*:1601*/
#line 4626 "pdftexdir/pdftex.web"
;
#line 1293 "pdftex-final.ch"
glue_node:begin r:= get_node(medium_node_size);add_glue_ref(glue_ptr(p));
/*1934:*/
#line 7073 "pdftex-final.ch"

sync_tag(r+medium_node_size):= sync_tag(p+medium_node_size);
sync_line(r+medium_node_size):= sync_line(p+medium_node_size);

/*:1934*/
#line 1294 "pdftex-final.ch"
;
#line 4628 "pdftexdir/pdftex.web"
glue_ptr(r):= glue_ptr(p);leader_ptr(r):= copy_node_list(leader_ptr(p));
end;
#line 1302 "pdftex-final.ch"
kern_node,math_node,penalty_node:begin r:= get_node(medium_node_size);
words:= medium_node_size;
end;
#line 4633 "pdftexdir/pdftex.web"
margin_kern_node:begin
r:= get_node(margin_kern_node_size);
fast_get_avail(margin_char(r));
font(margin_char(r)):= font(margin_char(p));
character(margin_char(r)):= character(margin_char(p));
words:= small_node_size;
end;
ligature_node:begin r:= get_node(small_node_size);
mem[lig_char(r)]:= mem[lig_char(p)];{copy|font|and|character|}
lig_ptr(r):= copy_node_list(lig_ptr(p));
end;
disc_node:begin r:= get_node(small_node_size);
pre_break(r):= copy_node_list(pre_break(p));
post_break(r):= copy_node_list(post_break(p));
end;
mark_node:begin r:= get_node(small_node_size);add_token_ref(mark_ptr(p));
words:= small_node_size;
end;
adjust_node:begin r:= get_node(small_node_size);
adjust_ptr(r):= copy_node_list(adjust_ptr(p));
end;{|words= 1= small_node_size-1|}
othercases confusion("copying")

endcases

/*:224*/
#line 4606 "pdftexdir/pdftex.web"
;
while words> 0 do
begin decr(words);mem[r+words]:= mem[p+words];
end

#line 1273 "pdftex-final.ch"
/*:223*/
#line 4595 "pdftexdir/pdftex.web"
;
link(q):= r;q:= r;p:= link(p);
end;
link(q):= null;q:= link(h);free_avail(h);
copy_node_list:= q;
end;

/*:222*//*229:*/
#line 4879 "pdftexdir/pdftex.web"
procedure print_mode(m:integer);{prints the mode represented by|m|}
#line 1330 "pdftex-final.ch"
begin if m> 0 then
case m div(max_command+1)of
0:print("vertical mode");
1:print("horizontal mode");
2:print("display math mode");
end
else if m= 0 then print("no mode")
else case(-m)div(max_command+1)of
0:print("internal vertical mode");
1:print("restricted horizontal mode");
2:print("math mode");
end;
end;

procedure print_in_mode(m:integer);{prints the mode represented by|m|}
begin if m> 0 then
case m div(max_command+1)of
0:print("' in vertical mode");
1:print("' in horizontal mode");
2:print("' in display math mode");
end
else if m= 0 then print("' in no mode")
else case(-m)div(max_command+1)of
0:print("' in internal vertical mode");
1:print("' in restricted horizontal mode");
2:print("' in math mode");
end;
end;
#line 4894 "pdftexdir/pdftex.web"

/*:229*//*234:*/
#line 5008 "pdftexdir/pdftex.web"
procedure push_nest;{enter a new semantic level,save the old}
begin if nest_ptr> max_nest_stack then
begin max_nest_stack:= nest_ptr;
if nest_ptr= nest_size then overflow("semantic nest size",nest_size);

end;
nest[nest_ptr]:= cur_list;{stack the record}
incr(nest_ptr);head:= get_avail;tail:= head;prev_graf:= 0;mode_line:= line;
eTeX_aux:= null;
end;

/*:234*//*235:*/
#line 5024 "pdftexdir/pdftex.web"
procedure pop_nest;{leave a semantic level,re-enter the old}
begin free_avail(head);decr(nest_ptr);cur_list:= nest[nest_ptr];
end;

/*:235*//*236:*/
#line 5030 "pdftexdir/pdftex.web"
procedure print_totals;forward;
procedure show_activities;
var p:0..nest_size;{index into|nest|}
m:-mmode..mmode;{mode}
a:memory_word;{auxiliary}
q,r:pointer;{for showing the current page}
t:integer;{ditto}
begin nest[nest_ptr]:= cur_list;{put the top level into the array}
print_nl("");print_ln;
for p:= nest_ptr downto 0 do
begin m:= nest[p].mode_field;a:= nest[p].aux_field;
print_nl("### ");print_mode(m);
print(" entered at line ");print_int(abs(nest[p].ml_field));
if m= hmode then if nest[p].pg_field<> 52
begin print(" (language");print_int(nest[p].pg_field mod 50
print(":hyphenmin");print_int(nest[p].pg_field div 50
print_char(",");print_int((nest[p].pg_field div 50 100);
print_char(")");
end;
if nest[p].ml_field<0 then print(" (\output routine)");
if p= 0 then
begin/*1161:*/
#line 27770 "pdftexdir/pdftex.web"

if page_head<> page_tail then
begin print_nl("### current page:");
if output_active then print(" (held over for next output)");

show_box(link(page_head));
if page_contents> empty then
begin print_nl("total height ");print_totals;

print_nl(" goal height ");print_scaled(page_goal);

r:= link(page_ins_head);
while r<> page_ins_head do
begin print_ln;print_esc("insert");t:= qo(subtype(r));
print_int(t);print(" adds ");
if count(t)= 1000 then t:= height(r)
else t:= x_over_n(height(r),1000)*count(t);
print_scaled(t);
if type(r)= split_up then
begin q:= page_head;t:= 0;
repeat q:= link(q);
if(type(q)= ins_node)and(subtype(q)= subtype(r))then incr(t);
until q= broken_ins(r);
print(", #");print_int(t);print(" might split");
end;
r:= link(r);
end;
end;
end

/*:1161*/
#line 5051 "pdftexdir/pdftex.web"
;
if link(contrib_head)<> null then
print_nl("### recent contributions:");
end;
show_box(link(nest[p].head_field));
/*237:*/
#line 5060 "pdftexdir/pdftex.web"

case abs(m)div(max_command+1)of
0:begin print_nl("prevdepth ");
if a.sc<=pdf_ignored_dimen then print("ignored")
else print_scaled(a.sc);
if nest[p].pg_field<> 0 then
begin print(", prevgraf ");
#line 1382 "pdftex-final.ch"
print_int(nest[p].pg_field);
if nest[p].pg_field<> 1 then print(" lines")
else print(" line");
#line 5069 "pdftexdir/pdftex.web"
end;
end;
1:begin print_nl("spacefactor ");print_int(a.hh.lh);
if m> 0 then if a.hh.rh> 0 then
begin print(", current language ");print_int(a.hh.rh);
end;
end;
2:if a.int<> null then
begin print("this will be denominator of:");show_box(a.int);
end;
end{there are no other cases}

/*:237*/
#line 5056 "pdftexdir/pdftex.web"
;
end;
end;

/*:236*//*255:*/
#line 5828 "pdftexdir/pdftex.web"
procedure print_param(n:integer);
begin case n of
pretolerance_code:print_esc("pretolerance");
tolerance_code:print_esc("tolerance");
line_penalty_code:print_esc("linepenalty");
hyphen_penalty_code:print_esc("hyphenpenalty");
ex_hyphen_penalty_code:print_esc("exhyphenpenalty");
club_penalty_code:print_esc("clubpenalty");
widow_penalty_code:print_esc("widowpenalty");
display_widow_penalty_code:print_esc("displaywidowpenalty");
broken_penalty_code:print_esc("brokenpenalty");
bin_op_penalty_code:print_esc("binoppenalty");
rel_penalty_code:print_esc("relpenalty");
pre_display_penalty_code:print_esc("predisplaypenalty");
post_display_penalty_code:print_esc("postdisplaypenalty");
inter_line_penalty_code:print_esc("interlinepenalty");
double_hyphen_demerits_code:print_esc("doublehyphendemerits");
final_hyphen_demerits_code:print_esc("finalhyphendemerits");
adj_demerits_code:print_esc("adjdemerits");
mag_code:print_esc("mag");
delimiter_factor_code:print_esc("delimiterfactor");
looseness_code:print_esc("looseness");
time_code:print_esc("time");
day_code:print_esc("day");
month_code:print_esc("month");
year_code:print_esc("year");
show_box_breadth_code:print_esc("showboxbreadth");
show_box_depth_code:print_esc("showboxdepth");
hbadness_code:print_esc("hbadness");
vbadness_code:print_esc("vbadness");
pausing_code:print_esc("pausing");
tracing_online_code:print_esc("tracingonline");
tracing_macros_code:print_esc("tracingmacros");
tracing_stats_code:print_esc("tracingstats");
tracing_paragraphs_code:print_esc("tracingparagraphs");
tracing_pages_code:print_esc("tracingpages");
tracing_output_code:print_esc("tracingoutput");
tracing_lost_chars_code:print_esc("tracinglostchars");
tracing_commands_code:print_esc("tracingcommands");
tracing_restores_code:print_esc("tracingrestores");
uc_hyph_code:print_esc("uchyph");
output_penalty_code:print_esc("outputpenalty");
max_dead_cycles_code:print_esc("maxdeadcycles");
hang_after_code:print_esc("hangafter");
floating_penalty_code:print_esc("floatingpenalty");
global_defs_code:print_esc("globaldefs");
cur_fam_code:print_esc("fam");
escape_char_code:print_esc("escapechar");
default_hyphen_char_code:print_esc("defaulthyphenchar");
default_skew_char_code:print_esc("defaultskewchar");
end_line_char_code:print_esc("endlinechar");
new_line_char_code:print_esc("newlinechar");
language_code:print_esc("language");
left_hyphen_min_code:print_esc("lefthyphenmin");
right_hyphen_min_code:print_esc("righthyphenmin");
holding_inserts_code:print_esc("holdinginserts");
#line 1500 "pdftex-final.ch"
error_context_lines_code:print_esc("errorcontextlines");
char_sub_def_min_code:print_esc("charsubdefmin");
char_sub_def_max_code:print_esc("charsubdefmax");
tracing_char_sub_def_code:print_esc("tracingcharsubdef");
mubyte_in_code:print_esc("mubytein");
mubyte_out_code:print_esc("mubyteout");
mubyte_log_code:print_esc("mubytelog");
spec_out_code:print_esc("specialout");
#line 5885 "pdftexdir/pdftex.web"

pdf_output_code:print_esc("pdfoutput");
pdf_compress_level_code:print_esc("pdfcompresslevel");
pdf_objcompresslevel_code:print_esc("pdfobjcompresslevel");
pdf_decimal_digits_code:print_esc("pdfdecimaldigits");
pdf_move_chars_code:print_esc("pdfmovechars");
pdf_image_resolution_code:print_esc("pdfimageresolution");
pdf_pk_resolution_code:print_esc("pdfpkresolution");
pdf_unique_resname_code:print_esc("pdfuniqueresname");
pdf_option_always_use_pdfpagebox_code:print_esc("pdfoptionalwaysusepdfpagebox");
pdf_option_pdf_inclusion_errorlevel_code:print_esc("pdfoptionpdfinclusionerrorlevel");
pdf_major_version_code:print_esc("pdfmajorversion");
pdf_minor_version_code:print_esc("pdfminorversion");
pdf_force_pagebox_code:print_esc("pdfforcepagebox");
pdf_pagebox_code:print_esc("pdfpagebox");
pdf_inclusion_errorlevel_code:print_esc("pdfinclusionerrorlevel");
pdf_gamma_code:print_esc("pdfgamma");
pdf_image_gamma_code:print_esc("pdfimagegamma");
pdf_image_hicolor_code:print_esc("pdfimagehicolor");
pdf_image_apply_gamma_code:print_esc("pdfimageapplygamma");
pdf_adjust_spacing_code:print_esc("pdfadjustspacing");
pdf_protrude_chars_code:print_esc("pdfprotrudechars");
pdf_tracing_fonts_code:print_esc("pdftracingfonts");
pdf_adjust_interword_glue_code:print_esc("pdfadjustinterwordglue");
pdf_prepend_kern_code:print_esc("pdfprependkern");
pdf_append_kern_code:print_esc("pdfappendkern");
pdf_gen_tounicode_code:print_esc("pdfgentounicode");
pdf_draftmode_code:print_esc("pdfdraftmode");
pdf_inclusion_copy_font_code:print_esc("pdfinclusioncopyfonts");
pdf_suppress_warning_dup_dest_code:print_esc("pdfsuppresswarningdupdest");
pdf_suppress_warning_dup_map_code:print_esc("pdfsuppresswarningdupmap");
pdf_suppress_warning_page_group_code:print_esc("pdfsuppresswarningpagegroup");
pdf_info_omit_date_code:print_esc("pdfinfoomitdate");
pdf_suppress_ptex_info_code:print_esc("pdfsuppressptexinfo");
pdf_omit_charset_code:print_esc("pdfomitcharset");
#line 1514 "pdftex-final.ch"
/*1906:*/
#line 6911 "pdftex-final.ch"

synctex_code:print_esc("synctex");

/*:1906*/
#line 1514 "pdftex-final.ch"

/*1656:*/
#line 36916 "pdftexdir/pdftex.web"

tracing_assigns_code:print_esc("tracingassigns");
tracing_groups_code:print_esc("tracinggroups");
tracing_ifs_code:print_esc("tracingifs");
tracing_scan_tokens_code:print_esc("tracingscantokens");
tracing_nesting_code:print_esc("tracingnesting");
pre_display_direction_code:print_esc("predisplaydirection");
last_line_fit_code:print_esc("lastlinefit");
saving_vdiscards_code:print_esc("savingvdiscards");
saving_hyph_codes_code:print_esc("savinghyphcodes");

/*:1656*//*1697:*/
#line 37479 "pdftexdir/pdftex.web"

eTeX_state_code+TeXXeT_code:print_esc("TeXXeTstate");

/*:1697*/
#line 1515 "pdftex-final.ch"

othercases print("[unknown integer parameter!]")
#line 5922 "pdftexdir/pdftex.web"
endcases;
end;

/*:255*//*263:*/
#line 6167 "pdftexdir/pdftex.web"
procedure begin_diagnostic;{prepare to do some tracing}
begin old_setting:= selector;
if(tracing_online<=0)and(selector= term_and_log)then
begin decr(selector);
if history= spotless then history:= warning_issued;
end;
end;

procedure end_diagnostic(blank_line:boolean);
{restore proper conditions after tracing}
begin print_nl("");
if blank_line then print_ln;
selector:= old_setting;
end;

/*:263*//*265:*/
#line 6269 "pdftexdir/pdftex.web"
procedure print_length_param(n:integer);
begin case n of
par_indent_code:print_esc("parindent");
math_surround_code:print_esc("mathsurround");
line_skip_limit_code:print_esc("lineskiplimit");
hsize_code:print_esc("hsize");
vsize_code:print_esc("vsize");
max_depth_code:print_esc("maxdepth");
split_max_depth_code:print_esc("splitmaxdepth");
box_max_depth_code:print_esc("boxmaxdepth");
hfuzz_code:print_esc("hfuzz");
vfuzz_code:print_esc("vfuzz");
delimiter_shortfall_code:print_esc("delimitershortfall");
null_delimiter_space_code:print_esc("nulldelimiterspace");
script_space_code:print_esc("scriptspace");
pre_display_size_code:print_esc("predisplaysize");
display_width_code:print_esc("displaywidth");
display_indent_code:print_esc("displayindent");
overfull_rule_code:print_esc("overfullrule");
hang_indent_code:print_esc("hangindent");
h_offset_code:print_esc("hoffset");
v_offset_code:print_esc("voffset");
emergency_stretch_code:print_esc("emergencystretch");
pdf_h_origin_code:print_esc("pdfhorigin");
pdf_v_origin_code:print_esc("pdfvorigin");
pdf_page_width_code:print_esc("pdfpagewidth");
pdf_page_height_code:print_esc("pdfpageheight");
pdf_link_margin_code:print_esc("pdflinkmargin");
pdf_dest_margin_code:print_esc("pdfdestmargin");
pdf_thread_margin_code:print_esc("pdfthreadmargin");
pdf_first_line_height_code:print_esc("pdffirstlineheight");
pdf_last_line_depth_code:print_esc("pdflastlinedepth");
pdf_each_line_height_code:print_esc("pdfeachlineheight");
pdf_each_line_depth_code:print_esc("pdfeachlinedepth");
pdf_ignored_dimen_code:print_esc("pdfignoreddimen");
pdf_px_dimen_code:print_esc("pdfpxdimen");
othercases print("[unknown dimen parameter!]")
endcases;
end;

/*:265*//*270:*/
#line 6400 "pdftexdir/pdftex.web"
/*320:*/
#line 7573 "pdftexdir/pdftex.web"

procedure print_cmd_chr(cmd:quarterword;chr_code:halfword);
var n:integer;{temp variable}
begin case cmd of
left_brace:chr_cmd("begin-group character ");
right_brace:chr_cmd("end-group character ");
math_shift:chr_cmd("math shift character ");
mac_param:chr_cmd("macro parameter character ");
sup_mark:chr_cmd("superscript character ");
sub_mark:chr_cmd("subscript character ");
endv:print("end of alignment template");
spacer:chr_cmd("blank space ");
letter:chr_cmd("the letter ");
other_char:chr_cmd("the character ");
/*245:*/
#line 5335 "pdftexdir/pdftex.web"

assign_glue,assign_mu_glue:if chr_code<skip_base then
print_skip_param(chr_code-glue_base)
else if chr_code<mu_skip_base then
begin print_esc("skip");print_int(chr_code-skip_base);
end
else begin print_esc("muskip");print_int(chr_code-mu_skip_base);
end;

/*:245*//*249:*/
#line 5469 "pdftexdir/pdftex.web"

assign_toks:if chr_code>=toks_base then
begin print_esc("toks");print_int(chr_code-toks_base);
end
else case chr_code of
output_routine_loc:print_esc("output");
every_par_loc:print_esc("everypar");
every_math_loc:print_esc("everymath");
every_display_loc:print_esc("everydisplay");
every_hbox_loc:print_esc("everyhbox");
every_vbox_loc:print_esc("everyvbox");
every_job_loc:print_esc("everyjob");
every_cr_loc:print_esc("everycr");
/*1655:*/
#line 36913 "pdftexdir/pdftex.web"

every_eof_loc:print_esc("everyeof");

/*:1655*/
#line 5482 "pdftexdir/pdftex.web"

pdf_pages_attr_loc:print_esc("pdfpagesattr");
pdf_page_attr_loc:print_esc("pdfpageattr");
pdf_page_resources_loc:print_esc("pdfpageresources");
pdf_pk_mode_loc:print_esc("pdfpkmode");
othercases print_esc("errhelp")
endcases;

/*:249*//*257:*/
#line 6118 "pdftexdir/pdftex.web"

assign_int:if chr_code<count_base then print_param(chr_code-int_base)
else begin print_esc("count");print_int(chr_code-count_base);
end;

/*:257*//*267:*/
#line 6381 "pdftexdir/pdftex.web"

assign_dimen:if chr_code<scaled_base then
print_length_param(chr_code-dimen_base)
else begin print_esc("dimen");print_int(chr_code-scaled_base);
end;

/*:267*//*288:*/
#line 6866 "pdftexdir/pdftex.web"

accent:print_esc("accent");
advance:print_esc("advance");
after_assignment:print_esc("afterassignment");
after_group:print_esc("aftergroup");
assign_font_dimen:print_esc("fontdimen");
begin_group:print_esc("begingroup");
break_penalty:print_esc("penalty");
char_num:print_esc("char");
cs_name:print_esc("csname");
def_font:print_esc("font");
letterspace_font:print_esc("letterspacefont");
pdf_copy_font:print_esc("pdfcopyfont");
delim_num:print_esc("delimiter");
divide:print_esc("divide");
#line 1732 "pdftex-final.ch"
end_cs_name:if chr_code= 10 then print_esc("endmubyte")
else print_esc("endcsname");
#line 6882 "pdftexdir/pdftex.web"
end_group:print_esc("endgroup");
ex_space:print_esc(" ");
expand_after:if chr_code= 0 then print_esc("expandafter")
/*1760:*/
#line 38276 "pdftexdir/pdftex.web"

else print_esc("unless")

/*:1760*/
#line 6885 "pdftexdir/pdftex.web"
;
halign:print_esc("halign");
hrule:print_esc("hrule");
ignore_spaces:if chr_code= 0 then print_esc("ignorespaces")else print_esc("pdfprimitive");
insert:print_esc("insert");
ital_corr:print_esc("/");
mark:begin print_esc("mark");
if chr_code> 0 then print_char("s");
end;
math_accent:print_esc("mathaccent");
math_char_num:print_esc("mathchar");
math_choice:print_esc("mathchoice");
multiply:print_esc("multiply");
no_align:print_esc("noalign");
no_boundary:print_esc("noboundary");
no_expand:if chr_code= 0 then print_esc("noexpand")
else print_esc("pdfprimitive");
non_script:print_esc("nonscript");
omit:print_esc("omit");
radical:print_esc("radical");
read_to_cs:if chr_code= 0 then print_esc("read")
/*1757:*/
#line 38236 "pdftexdir/pdftex.web"

else print_esc("readline")

/*:1757*/
#line 6906 "pdftexdir/pdftex.web"
;
relax:print_esc("relax");
set_box:print_esc("setbox");
set_prev_graf:print_esc("prevgraf");
set_shape:case chr_code of
par_shape_loc:print_esc("parshape");
/*1862:*/
#line 39926 "pdftexdir/pdftex.web"

inter_line_penalties_loc:print_esc("interlinepenalties");
club_penalties_loc:print_esc("clubpenalties");
widow_penalties_loc:print_esc("widowpenalties");
display_widow_penalties_loc:print_esc("displaywidowpenalties");

/*:1862*/
#line 6912 "pdftexdir/pdftex.web"

end;{there are no other cases}
the:if chr_code= 0 then print_esc("the")
/*1684:*/
#line 37316 "pdftexdir/pdftex.web"

else if chr_code= 1 then print_esc("unexpanded")
else print_esc("detokenize")

/*:1684*/
#line 6915 "pdftexdir/pdftex.web"
;
toks_register:/*1830:*/
#line 39500 "pdftexdir/pdftex.web"

begin print_esc("toks");
if chr_code<> mem_bot then print_sa_num(chr_code);
end

/*:1830*/
#line 6916 "pdftexdir/pdftex.web"
;
vadjust:print_esc("vadjust");
valign:if chr_code= 0 then print_esc("valign")
/*1699:*/
#line 37494 "pdftexdir/pdftex.web"

else case chr_code of
begin_L_code:print_esc("beginL");
end_L_code:print_esc("endL");
begin_R_code:print_esc("beginR");
othercases print_esc("endR")
endcases

/*:1699*/
#line 6919 "pdftexdir/pdftex.web"
;
vcenter:print_esc("vcenter");
vrule:print_esc("vrule");

/*:288*//*357:*/
#line 8360 "pdftexdir/pdftex.web"

par_end:print_esc("par");

/*:357*//*403:*/
#line 9122 "pdftexdir/pdftex.web"

input:if chr_code= 0 then print_esc("input")
/*1745:*/
#line 38106 "pdftexdir/pdftex.web"

else if chr_code= 2 then print_esc("scantokens")

/*:1745*/
#line 9124 "pdftexdir/pdftex.web"

else print_esc("endinput");

/*:403*//*411:*/
#line 9218 "pdftexdir/pdftex.web"

top_bot_mark:begin case(chr_code mod marks_code)of
first_mark_code:print_esc("firstmark");
bot_mark_code:print_esc("botmark");
split_first_mark_code:print_esc("splitfirstmark");
split_bot_mark_code:print_esc("splitbotmark");
othercases print_esc("topmark")
endcases;
if chr_code>=marks_code then print_char("s");
end;

/*:411*//*438:*/
#line 9673 "pdftexdir/pdftex.web"

register:/*1829:*/
#line 39484 "pdftexdir/pdftex.web"

begin if(chr_code<mem_bot)or(chr_code> lo_mem_stat_max)then
cmd:= sa_type(chr_code)
else begin cmd:= chr_code-mem_bot;chr_code:= null;
end;
if cmd= int_val then print_esc("count")
else if cmd= dimen_val then print_esc("dimen")
else if cmd= glue_val then print_esc("skip")
else print_esc("muskip");
if chr_code<> null then print_sa_num(chr_code);
end

/*:1829*/
#line 9674 "pdftexdir/pdftex.web"
;

/*:438*//*443:*/
#line 9850 "pdftexdir/pdftex.web"

set_aux:if chr_code= vmode then print_esc("prevdepth")
else print_esc("spacefactor");
set_page_int:if chr_code= 0 then print_esc("deadcycles")
/*1690:*/
#line 37372 "pdftexdir/pdftex.web"

else if chr_code= 2 then print_esc("interactionmode")

/*:1690*/
#line 9854 "pdftexdir/pdftex.web"

else print_esc("insertpenalties");
set_box_dimen:if chr_code= width_offset then print_esc("wd")
else if chr_code= height_offset then print_esc("ht")
else print_esc("dp");
last_item:case chr_code of
int_val:print_esc("lastpenalty");
dimen_val:print_esc("lastkern");
glue_val:print_esc("lastskip");
input_line_no_code:print_esc("inputlineno");
/*1647:*/
#line 36843 "pdftexdir/pdftex.web"

last_node_type_code:print_esc("lastnodetype");
eTeX_version_code:print_esc("eTeXversion");

/*:1647*//*1661:*/
#line 36999 "pdftexdir/pdftex.web"

current_group_level_code:print_esc("currentgrouplevel");
current_group_type_code:print_esc("currentgrouptype");

/*:1661*//*1664:*/
#line 37023 "pdftexdir/pdftex.web"

current_if_level_code:print_esc("currentiflevel");
current_if_type_code:print_esc("currentiftype");
current_if_branch_code:print_esc("currentifbranch");

/*:1664*//*1667:*/
#line 37061 "pdftexdir/pdftex.web"

font_char_wd_code:print_esc("fontcharwd");
font_char_ht_code:print_esc("fontcharht");
font_char_dp_code:print_esc("fontchardp");
font_char_ic_code:print_esc("fontcharic");

/*:1667*//*1670:*/
#line 37100 "pdftexdir/pdftex.web"

par_shape_length_code:print_esc("parshapelength");
par_shape_indent_code:print_esc("parshapeindent");
par_shape_dimen_code:print_esc("parshapedimen");

/*:1670*//*1776:*/
#line 38531 "pdftexdir/pdftex.web"

eTeX_expr-int_val+int_val:print_esc("numexpr");
eTeX_expr-int_val+dimen_val:print_esc("dimexpr");
eTeX_expr-int_val+glue_val:print_esc("glueexpr");
eTeX_expr-int_val+mu_val:print_esc("muexpr");

/*:1776*//*1799:*/
#line 38953 "pdftexdir/pdftex.web"

glue_stretch_order_code:print_esc("gluestretchorder");
glue_shrink_order_code:print_esc("glueshrinkorder");
glue_stretch_code:print_esc("gluestretch");
glue_shrink_code:print_esc("glueshrink");

/*:1799*//*1803:*/
#line 38988 "pdftexdir/pdftex.web"

mu_to_glue_code:print_esc("mutoglue");
glue_to_mu_code:print_esc("gluetomu");

/*:1803*/
#line 9864 "pdftexdir/pdftex.web"

pdftex_version_code:print_esc("pdftexversion");
pdf_last_obj_code:print_esc("pdflastobj");
pdf_last_xform_code:print_esc("pdflastxform");
pdf_last_ximage_code:print_esc("pdflastximage");
pdf_last_ximage_pages_code:print_esc("pdflastximagepages");
pdf_last_annot_code:print_esc("pdflastannot");
pdf_last_x_pos_code:print_esc("pdflastxpos");
pdf_last_y_pos_code:print_esc("pdflastypos");
pdf_retval_code:print_esc("pdfretval");
pdf_last_ximage_colordepth_code:print_esc("pdflastximagecolordepth");
elapsed_time_code:print_esc("pdfelapsedtime");
pdf_shell_escape_code:print_esc("pdfshellescape");
random_seed_code:print_esc("pdfrandomseed");
pdf_last_link_code:print_esc("pdflastlink");
othercases print_esc("badness")
endcases;

/*:443*//*495:*/
#line 10867 "pdftexdir/pdftex.web"

convert:case chr_code of
number_code:print_esc("number");
roman_numeral_code:print_esc("romannumeral");
string_code:print_esc("string");
meaning_code:print_esc("meaning");
font_name_code:print_esc("fontname");
eTeX_revision_code:print_esc("eTeXrevision");
expanded_code:print_esc("expanded");
pdftex_revision_code:print_esc("pdftexrevision");
pdftex_banner_code:print_esc("pdftexbanner");
pdf_font_name_code:print_esc("pdffontname");
pdf_font_objnum_code:print_esc("pdffontobjnum");
pdf_font_size_code:print_esc("pdffontsize");
pdf_page_ref_code:print_esc("pdfpageref");
left_margin_kern_code:print_esc("leftmarginkern");
right_margin_kern_code:print_esc("rightmarginkern");
pdf_xform_name_code:print_esc("pdfxformname");
pdf_escape_string_code:print_esc("pdfescapestring");
pdf_escape_name_code:print_esc("pdfescapename");
pdf_escape_hex_code:print_esc("pdfescapehex");
pdf_unescape_hex_code:print_esc("pdfunescapehex");
pdf_creation_date_code:print_esc("pdfcreationdate");
pdf_file_mod_date_code:print_esc("pdffilemoddate");
pdf_file_size_code:print_esc("pdffilesize");
pdf_mdfive_sum_code:print_esc("pdfmdfivesum");
pdf_file_dump_code:print_esc("pdffiledump");
pdf_match_code:print_esc("pdfmatch");
pdf_last_match_code:print_esc("pdflastmatch");
pdf_strcmp_code:print_esc("pdfstrcmp");
pdf_colorstack_init_code:print_esc("pdfcolorstackinit");
uniform_deviate_code:print_esc("pdfuniformdeviate");
normal_deviate_code:print_esc("pdfnormaldeviate");
pdf_insert_ht_code:print_esc("pdfinsertht");
pdf_ximage_bbox_code:print_esc("pdfximagebbox");
othercases print_esc("jobname")
endcases;

/*:495*//*514:*/
#line 11682 "pdftexdir/pdftex.web"

if_test:begin if chr_code>=unless_code then print_esc("unless");
case chr_code mod unless_code of
if_cat_code:print_esc("ifcat");
if_int_code:print_esc("ifnum");
if_dim_code:print_esc("ifdim");
if_odd_code:print_esc("ifodd");
if_vmode_code:print_esc("ifvmode");
if_hmode_code:print_esc("ifhmode");
if_mmode_code:print_esc("ifmmode");
if_inner_code:print_esc("ifinner");
if_void_code:print_esc("ifvoid");
if_hbox_code:print_esc("ifhbox");
if_vbox_code:print_esc("ifvbox");
ifx_code:print_esc("ifx");
if_eof_code:print_esc("ifeof");
if_true_code:print_esc("iftrue");
if_false_code:print_esc("iffalse");
if_case_code:print_esc("ifcase");
if_pdfprimitive_code:print_esc("ifpdfprimitive");
/*1761:*/
#line 38279 "pdftexdir/pdftex.web"

if_def_code:print_esc("ifdefined");
if_cs_code:print_esc("ifcsname");
if_font_char_code:print_esc("iffontchar");
if_in_csname_code:print_esc("ifincsname");
if_pdfabs_num_code:print_esc("ifpdfabsnum");
if_pdfabs_dim_code:print_esc("ifpdfabsdim");

/*:1761*/
#line 11702 "pdftexdir/pdftex.web"

othercases print_esc("if")
endcases;
end;

/*:514*//*518:*/
#line 11748 "pdftexdir/pdftex.web"

fi_or_else:if chr_code= fi_code then print_esc("fi")
else if chr_code= or_code then print_esc("or")
else print_esc("else");

/*:518*//*955:*/
#line 23362 "pdftexdir/pdftex.web"

tab_mark:if chr_code= span_code then print_esc("span")
else chr_cmd("alignment tab character ");
car_ret:if chr_code= cr_code then print_esc("cr")
else print_esc("crcr");

/*:955*//*1159:*/
#line 27743 "pdftexdir/pdftex.web"

set_page_dimen:case chr_code of
0:print_esc("pagegoal");
1:print_esc("pagetotal");
2:print_esc("pagestretch");
3:print_esc("pagefilstretch");
4:print_esc("pagefillstretch");
5:print_esc("pagefilllstretch");
6:print_esc("pageshrink");
othercases print_esc("pagedepth")
endcases;

/*:1159*//*1229:*/
#line 29031 "pdftexdir/pdftex.web"

stop:if chr_code= 1 then print_esc("dump")else print_esc("end");

/*:1229*//*1235:*/
#line 29129 "pdftexdir/pdftex.web"

hskip:case chr_code of
skip_code:print_esc("hskip");
fil_code:print_esc("hfil");
fill_code:print_esc("hfill");
ss_code:print_esc("hss");
othercases print_esc("hfilneg")
endcases;
vskip:case chr_code of
skip_code:print_esc("vskip");
fil_code:print_esc("vfil");
fill_code:print_esc("vfill");
ss_code:print_esc("vss");
othercases print_esc("vfilneg")
endcases;
mskip:print_esc("mskip");
kern:print_esc("kern");
mkern:print_esc("mkern");

/*:1235*//*1248:*/
#line 29396 "pdftexdir/pdftex.web"

hmove:if chr_code= 1 then print_esc("moveleft")else print_esc("moveright");
vmove:if chr_code= 1 then print_esc("raise")else print_esc("lower");
make_box:case chr_code of
box_code:print_esc("box");
copy_code:print_esc("copy");
last_box_code:print_esc("lastbox");
vsplit_code:print_esc("vsplit");
vtop_code:print_esc("vtop");
vtop_code+vmode:print_esc("vbox");
othercases print_esc("hbox")
endcases;
leader_ship:if chr_code= a_leaders then print_esc("leaders")
else if chr_code= c_leaders then print_esc("cleaders")
else if chr_code= x_leaders then print_esc("xleaders")
else print_esc("shipout");

/*:1248*//*1265:*/
#line 29696 "pdftexdir/pdftex.web"

start_par:if chr_code= 0 then print_esc("noindent")else if chr_code= 1 then print_esc("indent")else print_esc("quitvmode");

/*:1265*//*1284:*/
#line 29925 "pdftexdir/pdftex.web"

remove_item:if chr_code= glue_node then print_esc("unskip")
else if chr_code= kern_node then print_esc("unkern")
else print_esc("unpenalty");
un_hbox:if chr_code= copy_code then print_esc("unhcopy")
else print_esc("unhbox");
un_vbox:if chr_code= copy_code then print_esc("unvcopy")
/*1859:*/
#line 39898 "pdftexdir/pdftex.web"

else if chr_code= last_box_code then print_esc("pagediscards")
else if chr_code= vsplit_code then print_esc("splitdiscards")

/*:1859*/
#line 29932 "pdftexdir/pdftex.web"

else print_esc("unvbox");

/*:1284*//*1291:*/
#line 30008 "pdftexdir/pdftex.web"

discretionary:if chr_code= 1 then
print_esc("-")else print_esc("discretionary");

/*:1291*//*1319:*/
#line 30373 "pdftexdir/pdftex.web"

eq_no:if chr_code= 1 then print_esc("leqno")else print_esc("eqno");

/*:1319*//*1333:*/
#line 30627 "pdftexdir/pdftex.web"

math_comp:case chr_code of
ord_noad:print_esc("mathord");
op_noad:print_esc("mathop");
bin_noad:print_esc("mathbin");
rel_noad:print_esc("mathrel");
open_noad:print_esc("mathopen");
close_noad:print_esc("mathclose");
punct_noad:print_esc("mathpunct");
inner_noad:print_esc("mathinner");
under_noad:print_esc("underline");
othercases print_esc("overline")
endcases;
limit_switch:if chr_code= limits then print_esc("limits")
else if chr_code= no_limits then print_esc("nolimits")
else print_esc("displaylimits");

/*:1333*//*1346:*/
#line 30763 "pdftexdir/pdftex.web"

math_style:print_style(chr_code);

/*:1346*//*1355:*/
#line 30866 "pdftexdir/pdftex.web"

above:case chr_code of
over_code:print_esc("over");
atop_code:print_esc("atop");
delimited_code+above_code:print_esc("abovewithdelims");
delimited_code+over_code:print_esc("overwithdelims");
delimited_code+atop_code:print_esc("atopwithdelims");
othercases print_esc("above")
endcases;

/*:1355*//*1365:*/
#line 30987 "pdftexdir/pdftex.web"

left_right:if chr_code= left_noad then print_esc("left")
/*1695:*/
#line 37401 "pdftexdir/pdftex.web"

else if chr_code= middle_noad then print_esc("middle")

/*:1695*/
#line 30989 "pdftexdir/pdftex.web"

else print_esc("right");

/*:1365*//*1385:*/
#line 31331 "pdftexdir/pdftex.web"

prefix:if chr_code= 1 then print_esc("long")
else if chr_code= 2 then print_esc("outer")
/*1768:*/
#line 38390 "pdftexdir/pdftex.web"

else if chr_code= 8 then print_esc("protected")

/*:1768*/
#line 31334 "pdftexdir/pdftex.web"

else print_esc("global");
def:if chr_code= 0 then print_esc("def")
else if chr_code= 1 then print_esc("gdef")
else if chr_code= 2 then print_esc("edef")
else print_esc("xdef");

/*:1385*//*1396:*/
#line 31512 "pdftexdir/pdftex.web"

#line 4209 "pdftex-final.ch"
let:if chr_code<> normal then
if chr_code= normal+10 then print_esc("mubyte")
else if chr_code= normal+11 then print_esc("noconvert")
else print_esc("futurelet")
else print_esc("let");
#line 31514 "pdftexdir/pdftex.web"

/*:1396*//*1399:*/
#line 31567 "pdftexdir/pdftex.web"

shorthand_def:case chr_code of
char_def_code:print_esc("chardef");
math_char_def_code:print_esc("mathchardef");
count_def_code:print_esc("countdef");
dimen_def_code:print_esc("dimendef");
skip_def_code:print_esc("skipdef");
mu_skip_def_code:print_esc("muskipdef");
#line 4338 "pdftex-final.ch"
char_sub_def_code:print_esc("charsubdef");
othercases print_esc("toksdef")
#line 31576 "pdftexdir/pdftex.web"
endcases;
char_given:begin print_esc("char");print_hex(chr_code);
end;
math_given:begin print_esc("mathchar");print_hex(chr_code);
end;

/*:1399*//*1407:*/
#line 31733 "pdftexdir/pdftex.web"

#line 4385 "pdftex-final.ch"
def_code:if chr_code= xord_code_base then print_esc("xordcode")
else if chr_code= xchr_code_base then print_esc("xchrcode")
else if chr_code= xprn_code_base then print_esc("xprncode")
else if chr_code= cat_code_base then print_esc("catcode")
#line 31735 "pdftexdir/pdftex.web"
else if chr_code= math_code_base then print_esc("mathcode")
else if chr_code= lc_code_base then print_esc("lccode")
else if chr_code= uc_code_base then print_esc("uccode")
else if chr_code= sf_code_base then print_esc("sfcode")
else print_esc("delcode");
def_family:print_size(chr_code-math_font_base);

/*:1407*//*1427:*/
#line 32027 "pdftexdir/pdftex.web"

hyph_data:if chr_code= 1 then print_esc("patterns")
else print_esc("hyphenation");

/*:1427*//*1431:*/
#line 32099 "pdftexdir/pdftex.web"

assign_font_int:case chr_code of
0:print_esc("hyphenchar");
1:print_esc("skewchar");
lp_code_base:print_esc("lpcode");
rp_code_base:print_esc("rpcode");
ef_code_base:print_esc("efcode");
tag_code:print_esc("tagcode");
kn_bs_code_base:print_esc("knbscode");
st_bs_code_base:print_esc("stbscode");
sh_bs_code_base:print_esc("shbscode");
kn_bc_code_base:print_esc("knbccode");
kn_ac_code_base:print_esc("knaccode");
no_lig_code:print_esc("pdfnoligatures");
endcases;

/*:1431*//*1437:*/
#line 32198 "pdftexdir/pdftex.web"

set_font:begin print("select font ");slow_print(font_name[chr_code]);
if font_size[chr_code]<> font_dsize[chr_code]then
begin print(" at ");print_scaled(font_size[chr_code]);
print("pt");
end;
end;

/*:1437*//*1439:*/
#line 32216 "pdftexdir/pdftex.web"

set_interaction:case chr_code of
batch_mode:print_esc("batchmode");
nonstop_mode:print_esc("nonstopmode");
scroll_mode:print_esc("scrollmode");
othercases print_esc("errorstopmode")
endcases;

/*:1439*//*1449:*/
#line 32278 "pdftexdir/pdftex.web"

in_stream:if chr_code= 0 then print_esc("closein")
else print_esc("openin");

/*:1449*//*1454:*/
#line 32313 "pdftexdir/pdftex.web"

message:if chr_code= 0 then print_esc("message")
else print_esc("errmessage");

/*:1454*//*1463:*/
#line 32380 "pdftexdir/pdftex.web"

case_shift:if chr_code= lc_code_base then print_esc("lowercase")
else print_esc("uppercase");

/*:1463*//*1468:*/
#line 32431 "pdftexdir/pdftex.web"

xray:case chr_code of
show_box_code:print_esc("showbox");
show_the_code:print_esc("showthe");
show_lists:print_esc("showlists");
/*1673:*/
#line 37128 "pdftexdir/pdftex.web"

show_groups:print_esc("showgroups");

/*:1673*//*1682:*/
#line 37299 "pdftexdir/pdftex.web"

show_tokens:print_esc("showtokens");

/*:1682*//*1687:*/
#line 37340 "pdftexdir/pdftex.web"

show_ifs:print_esc("showifs");

/*:1687*/
#line 32436 "pdftexdir/pdftex.web"

othercases print_esc("show")
endcases;

/*:1468*//*1471:*/
#line 32487 "pdftexdir/pdftex.web"

undefined_cs:print("undefined");
call,long_call,outer_call,long_outer_call:begin n:= cmd-call;
if info(link(chr_code))= protected_token then n:= n+4;
if odd(n div 4)then print_esc("protected");
if odd(n)then print_esc("long");
if odd(n div 2)then print_esc("outer");
if n> 0 then print_char(" ");
print("macro");
end;
end_template:print_esc("outer endtemplate");

/*:1471*//*1524:*/
#line 33678 "pdftexdir/pdftex.web"

extension:case chr_code of
open_node:print_esc("openout");
write_node:print_esc("write");
close_node:print_esc("closeout");
special_node:print_esc("special");
immediate_code:print_esc("immediate");
set_language_code:print_esc("setlanguage");
pdf_annot_node:print_esc("pdfannot");
pdf_catalog_code:print_esc("pdfcatalog");
pdf_dest_node:print_esc("pdfdest");
pdf_end_link_node:print_esc("pdfendlink");
pdf_end_thread_node:print_esc("pdfendthread");
pdf_font_attr_code:print_esc("pdffontattr");
pdf_font_expand_code:print_esc("pdffontexpand");
pdf_include_chars_code:print_esc("pdfincludechars");
pdf_info_code:print_esc("pdfinfo");
pdf_literal_node:print_esc("pdfliteral");
pdf_colorstack_node:print_esc("pdfcolorstack");
pdf_setmatrix_node:print_esc("pdfsetmatrix");
pdf_save_node:print_esc("pdfsave");
pdf_restore_node:print_esc("pdfrestore");
pdf_map_file_code:print_esc("pdfmapfile");
pdf_map_line_code:print_esc("pdfmapline");
pdf_names_code:print_esc("pdfnames");
pdf_obj_code:print_esc("pdfobj");
pdf_outline_code:print_esc("pdfoutline");
pdf_refobj_node:print_esc("pdfrefobj");
pdf_refxform_node:print_esc("pdfrefxform");
pdf_refximage_node:print_esc("pdfrefximage");
pdf_save_pos_node:print_esc("pdfsavepos");
pdf_snap_ref_point_node:print_esc("pdfsnaprefpoint");
pdf_snapy_comp_node:print_esc("pdfsnapycomp");
pdf_snapy_node:print_esc("pdfsnapy");
pdf_start_link_node:print_esc("pdfstartlink");
pdf_start_thread_node:print_esc("pdfstartthread");
pdf_thread_node:print_esc("pdfthread");
pdf_trailer_code:print_esc("pdftrailer");
pdf_trailer_id_code:print_esc("pdftrailerid");
pdf_xform_code:print_esc("pdfxform");
pdf_ximage_code:print_esc("pdfximage");
reset_timer_code:print_esc("pdfresettimer");
set_random_seed_code:print_esc("pdfsetrandomseed");
pdf_nobuiltin_tounicode_code:print_esc("pdfnobuiltintounicode");
pdf_glyph_to_unicode_code:print_esc("pdfglyphtounicode");
pdf_interword_space_on_node:print_esc("pdfinterwordspaceon");
pdf_interword_space_off_node:print_esc("pdfinterwordspaceoff");
pdf_fake_space_node:print_esc("pdffakespace");
pdf_running_link_off_node:print_esc("pdfrunninglinkoff");
pdf_running_link_on_node:print_esc("pdfrunninglinkon");
othercases print("[unknown extension!]")
endcases;

/*:1524*/
#line 7587 "pdftexdir/pdftex.web"

othercases print("[unknown command code!]")
endcases;
end;

/*:320*/
#line 6400 "pdftexdir/pdftex.web"

stat procedure show_eqtb(n:pointer);
begin if n<active_base then print_char("?"){this can't happen}
#line 1585 "pdftex-final.ch"
else if(n<glue_base)or((n> eqtb_size)and(n<=eqtb_top))then
/*241:*/
#line 5202 "pdftexdir/pdftex.web"

begin sprint_cs(n);print_char("=");print_cmd_chr(eq_type(n),equiv(n));
if eq_type(n)>=call then
begin print_char(":");show_token_list(link(equiv(n)),null,32);
end;
end

/*:241*/
#line 1586 "pdftex-final.ch"

#line 6404 "pdftexdir/pdftex.web"
else if n<local_base then/*247:*/
#line 5352 "pdftexdir/pdftex.web"

if n<skip_base then
begin print_skip_param(n-glue_base);print_char("=");
if n<glue_base+thin_mu_skip_code then print_spec(equiv(n),"pt")
else print_spec(equiv(n),"mu");
end
else if n<mu_skip_base then
begin print_esc("skip");print_int(n-skip_base);print_char("=");
print_spec(equiv(n),"pt");
end
else begin print_esc("muskip");print_int(n-mu_skip_base);print_char("=");
print_spec(equiv(n),"mu");
end

/*:247*/
#line 6404 "pdftexdir/pdftex.web"

else if n<int_base then/*251:*/
#line 5534 "pdftexdir/pdftex.web"

if(n= par_shape_loc)or((n>=etex_pen_base)and(n<etex_pens))then
begin print_cmd_chr(set_shape,n);print_char("=");
if equiv(n)= null then print_char("0")
else if n> par_shape_loc then
begin print_int(penalty(equiv(n)));print_char(" ");
print_int(penalty(equiv(n)+1));
if penalty(equiv(n))> 1 then print_esc("ETC.");
end
else print_int(info(par_shape_ptr));
end
else if n<toks_base then
begin print_cmd_chr(assign_toks,n);print_char("=");
if equiv(n)<> null then show_token_list(link(equiv(n)),null,32);
end
else if n<box_base then
begin print_esc("toks");print_int(n-toks_base);print_char("=");
if equiv(n)<> null then show_token_list(link(equiv(n)),null,32);
end
else if n<cur_font_loc then
begin print_esc("box");print_int(n-box_base);print_char("=");
if equiv(n)= null then print("void")
else begin depth_threshold:= 0;breadth_max:= 1;show_node_list(equiv(n));
end;
end
else if n<cat_code_base then/*252:*/
#line 5562 "pdftexdir/pdftex.web"

begin if n= cur_font_loc then print("current font")
else if n<math_font_base+16 then
begin print_esc("textfont");print_int(n-math_font_base);
end
else if n<math_font_base+32 then
begin print_esc("scriptfont");print_int(n-math_font_base-16);
end
else begin print_esc("scriptscriptfont");print_int(n-math_font_base-32);
end;
print_char("=");
print_esc(hash[font_id_base+equiv(n)].rh);
{that's |font_id_text(equiv(n))|}
end

/*:252*/
#line 5559 "pdftexdir/pdftex.web"

else/*253:*/
#line 5577 "pdftexdir/pdftex.web"

if n<math_code_base then
begin if n<lc_code_base then
begin print_esc("catcode");print_int(n-cat_code_base);
end
else if n<uc_code_base then
begin print_esc("lccode");print_int(n-lc_code_base);
end
else if n<sf_code_base then
begin print_esc("uccode");print_int(n-uc_code_base);
end
else begin print_esc("sfcode");print_int(n-sf_code_base);
end;
print_char("=");print_int(equiv(n));
end
else begin print_esc("mathcode");print_int(n-math_code_base);
print_char("=");print_int(ho(equiv(n)));
end

/*:253*/
#line 5560 "pdftexdir/pdftex.web"


/*:251*/
#line 6405 "pdftexdir/pdftex.web"

else if n<dimen_base then/*260:*/
#line 6149 "pdftexdir/pdftex.web"

begin if n<count_base then print_param(n-int_base)
else if n<del_code_base then
begin print_esc("count");print_int(n-count_base);
end
else begin print_esc("delcode");print_int(n-del_code_base);
end;
print_char("=");print_int(eqtb[n].int);
end

/*:260*/
#line 6406 "pdftexdir/pdftex.web"

else if n<=eqtb_size then/*269:*/
#line 6390 "pdftexdir/pdftex.web"

begin if n<scaled_base then print_length_param(n-dimen_base)
else begin print_esc("dimen");print_int(n-scaled_base);
end;
print_char("=");print_scaled(eqtb[n].sc);print("pt");
end

/*:269*/
#line 6407 "pdftexdir/pdftex.web"

else print_char("?");{this can't happen either}
end;
tats

/*:270*//*278:*/
#line 6519 "pdftexdir/pdftex.web"
function id_lookup(j,l:integer):pointer;{search the hash table}
label found;{go here if you found it}
var h:integer;{hash code}
d:integer;{number of characters in incomplete current string}
p:pointer;{index in|hash|array}
k:pointer;{index in|buffer|array}
begin/*280:*/
#line 6564 "pdftexdir/pdftex.web"

h:= buffer[j];
for k:= j+1 to j+l-1 do
begin h:= h+h+buffer[k];
while h>=hash_prime do h:= h-hash_prime;
end

/*:280*/
#line 6525 "pdftexdir/pdftex.web"
;
p:= h+hash_base;{we start searching here;note that|0<=h<hash_prime|}
loop begin if text(p)> 0 then if length(text(p))= l then
if str_eq_buf(text(p),j)then goto found;
if next(p)= 0 then
begin if no_new_control_sequence then
p:= undefined_control_sequence
else/*279:*/
#line 1632 "pdftex-final.ch"

begin if text(p)> 0 then
begin if hash_high<hash_extra then
begin incr(hash_high);
next(p):= hash_high+eqtb_size;p:= hash_high+eqtb_size;
end
else begin
repeat if hash_is_full then overflow("hash size",hash_size+hash_extra);

decr(hash_used);
until text(hash_used)= 0;{search for an empty location in|hash|}
next(p):= hash_used;p:= hash_used;
end;
end;
#line 6549 "pdftexdir/pdftex.web"
str_room(l);d:= cur_length;
while pool_ptr> str_start[str_ptr]do
begin decr(pool_ptr);str_pool[pool_ptr+l]:= str_pool[pool_ptr];
end;{move current string up to make room for another}
for k:= j to j+l-1 do append_char(buffer[k]);
text(p):= make_string;pool_ptr:= pool_ptr+d;
stat incr(cs_count);tats
end

/*:279*/
#line 6533 "pdftexdir/pdftex.web"
;
goto found;
end;
p:= next(p);
end;
found:id_lookup:= p;
end;

#line 1632 "pdftex-final.ch"
/*:278*//*281:*/
#line 6573 "pdftexdir/pdftex.web"
function prim_lookup(s:str_number):pointer;{search the primitives table}
label found;{go here if you found it}
var h:integer;{hash code}
p:pointer;{index in|hash|array}
k:pointer;{index in string pool}
j,l:integer;
begin
if s<=biggest_char then begin
if s<0 then begin p:= undefined_primitive;goto found;end
else p:= (s mod prim_prime)+prim_base;{we start searching here}
end
else begin
j:= str_start[s];
if s= str_ptr then l:= cur_length else l:= length(s);
/*283:*/
#line 6622 "pdftexdir/pdftex.web"

h:= str_pool[j];
for k:= j+1 to j+l-1 do
begin h:= h+h+str_pool[k];
while h>=prim_prime do h:= h-prim_prime;
end


/*:283*/
#line 6587 "pdftexdir/pdftex.web"
;
p:= h+prim_base;{we start searching here;note that|0<=h<prim_prime|}
end;
loop begin
if prim_text(p)> 1+biggest_char then{|p|points a multi-letter primitive}
begin if length(prim_text(p)-1)= l then
if str_eq_str(prim_text(p)-1,s)then goto found;
end
else if prim_text(p)= 1+s then goto found;{|p|points a single-letter primitive}
if prim_next(p)= 0 then
begin if no_new_control_sequence then
p:= undefined_primitive
else/*282:*/
#line 6608 "pdftexdir/pdftex.web"

begin if prim_text(p)> 0 then
begin repeat if prim_is_full then overflow("primitive size",prim_size);

decr(prim_used);
until prim_text(prim_used)= 0;{search for an empty location in|prim|}
prim_next(p):= prim_used;p:= prim_used;
end;
prim_text(p):= s+1;
end

/*:282*/
#line 6600 "pdftexdir/pdftex.web"
;
goto found;
end;
p:= prim_next(p);
end;
found:prim_lookup:= p;
end;

/*:281*//*286:*/
#line 6734 "pdftexdir/pdftex.web"
init procedure primitive(s:str_number;c:quarterword;o:halfword);
var k:pool_pointer;{index into|str_pool|}
j:0..buf_size;{index into|buffer|}
l:small_number;{length of the string}
prim_val:integer;{needed to fill|prim_eqtb|}
begin if s<256 then begin
cur_val:= s+single_base;
prim_val:= prim_lookup(s);
end
else begin k:= str_start[s];l:= str_start[s+1]-k;
{we will move|s|into the(possibly non-empty)|buffer|}
if first+l> buf_size+1 then
overflow("buffer size",buf_size);

for j:= 0 to l-1 do buffer[first+j]:= so(str_pool[k+j]);
cur_val:= id_lookup(first,l);{|no_new_control_sequence|is|false|}
flush_string;text(cur_val):= s;{we don't want to have the string twice}
prim_val:= prim_lookup(s);
end;
eq_level(cur_val):= level_one;eq_type(cur_val):= c;equiv(cur_val):= o;
prim_eq_level(prim_val):= level_one;
prim_eq_type(prim_val):= c;
prim_equiv(prim_val):= o;
end;
tini

/*:286*//*290:*/
#line 6990 "pdftexdir/pdftex.web"
/*306:*/
#line 7265 "pdftexdir/pdftex.web"

stat procedure restore_trace(p:pointer;s:str_number);
{|eqtb[p]|has just been restored or retained}
begin begin_diagnostic;print_char("{");print(s);print_char(" ");
show_eqtb(p);print_char("}");
end_diagnostic(false);
end;
tats

/*:306*//*1658:*/
#line 36936 "pdftexdir/pdftex.web"

procedure print_group(e:boolean);
label exit;
begin case cur_group of
bottom_level:begin print("bottom level");return;
end;
simple_group,semi_simple_group:
begin if cur_group= semi_simple_group then print("semi ");
print("simple");
end;
hbox_group,adjusted_hbox_group:
begin if cur_group= adjusted_hbox_group then print("adjusted ");
print("hbox");
end;
vbox_group:print("vbox");
vtop_group:print("vtop");
align_group,no_align_group:
begin if cur_group= no_align_group then print("no ");
print("align");
end;
output_group:print("output");
disc_group:print("disc");
insert_group:print("insert");
vcenter_group:print("vcenter");
math_group,math_choice_group,math_shift_group,math_left_group:
begin print("math");
if cur_group= math_choice_group then print(" choice")
else if cur_group= math_shift_group then print(" shift")
else if cur_group= math_left_group then print(" left");
end;
end;{there are no other cases}
print(" group (level ");print_int(qo(cur_level));print_char(")");
if saved(-1)<> 0 then
begin if e then print(" entered at line ")else print(" at line ");
print_int(saved(-1));
end;
exit:end;

/*:1658*//*1659:*/
#line 36978 "pdftexdir/pdftex.web"

stat procedure group_trace(e:boolean);
begin begin_diagnostic;print_char("{");
if e then print("leaving ")else print("entering ");
print_group(e);print_char("}");end_diagnostic(false);
end;
tats

/*:1659*//*1753:*/
#line 38191 "pdftexdir/pdftex.web"

function pseudo_input:boolean;{inputs the next line or returns|false|}
var p:pointer;{current line from pseudo file}
sz:integer;{size of node|p|}
w:four_quarters;{four ASCII codes}
r:pointer;{loop index}
begin last:= first;{cf.\Matthew 19\thinspace:\thinspace30}
p:= info(pseudo_files);
if p= null then pseudo_input:= false
else begin info(pseudo_files):= link(p);sz:= ho(info(p));
if 4*sz-3>=buf_size-last then
/*35:*/
#line 603 "pdftex-final.ch"

begin cur_input.loc_field:= first;cur_input.limit_field:= last-1;
#line 1175 "pdftexdir/pdftex.web"
overflow("buffer size",buf_size);

end

/*:35*/
#line 38202 "pdftexdir/pdftex.web"
;
last:= first;
for r:= p+1 to p+sz-1 do
begin w:= mem[r].qqqq;
buffer[last]:= w.b0;buffer[last+1]:= w.b1;
buffer[last+2]:= w.b2;buffer[last+3]:= w.b3;
last:= last+4;
end;
if last>=max_buf_stack then max_buf_stack:= last+1;
while(last> first)and(buffer[last-1]= " ")do decr(last);
free_node(p,sz);
pseudo_input:= true;
end;
end;

/*:1753*//*1754:*/
#line 38219 "pdftexdir/pdftex.web"

procedure pseudo_close;{close the top level pseudo file}
var p,q:pointer;
begin p:= link(pseudo_files);q:= info(pseudo_files);
free_avail(pseudo_files);pseudo_files:= p;
while q<> null do
begin p:= q;q:= link(p);free_node(p,ho(info(p)));
end;
end;

/*:1754*//*1771:*/
#line 38429 "pdftexdir/pdftex.web"

procedure group_warning;
var i:0..max_in_open;{index into|grp_stack|}
w:boolean;{do we need a warning?}
begin base_ptr:= input_ptr;input_stack[base_ptr]:= cur_input;
{store current state}
i:= in_open;w:= false;
while(grp_stack[i]= cur_boundary)and(i> 0)do
begin/*1772:*/
#line 38452 "pdftexdir/pdftex.web"

if tracing_nesting> 0 then
begin while(input_stack[base_ptr].state_field= token_list)or
(input_stack[base_ptr].index_field> i)do decr(base_ptr);
if input_stack[base_ptr].name_field> 17 then w:= true;
end

/*:1772*/
#line 38437 "pdftexdir/pdftex.web"
;
grp_stack[i]:= save_index(save_ptr);decr(i);
end;
if w then
begin print_nl("Warning: end of ");print_group(true);

print(" of a different file");print_ln;
if tracing_nesting> 1 then show_context;
if history= spotless then history:= warning_issued;
end;
end;

/*:1771*//*1773:*/
#line 38464 "pdftexdir/pdftex.web"

procedure if_warning;
var i:0..max_in_open;{index into|if_stack|}
w:boolean;{do we need a warning?}
begin base_ptr:= input_ptr;input_stack[base_ptr]:= cur_input;
{store current state}
i:= in_open;w:= false;
while if_stack[i]= cond_ptr do
begin/*1772:*/
#line 38452 "pdftexdir/pdftex.web"

if tracing_nesting> 0 then
begin while(input_stack[base_ptr].state_field= token_list)or
(input_stack[base_ptr].index_field> i)do decr(base_ptr);
if input_stack[base_ptr].name_field> 17 then w:= true;
end

/*:1772*/
#line 38472 "pdftexdir/pdftex.web"
;
if_stack[i]:= link(cond_ptr);decr(i);
end;
if w then
begin print_nl("Warning: end of ");print_cmd_chr(if_test,cur_if);

print_if_line(if_line);print(" of a different file");print_ln;
if tracing_nesting> 1 then show_context;
if history= spotless then history:= warning_issued;
end;
end;

/*:1773*//*1774:*/
#line 38488 "pdftexdir/pdftex.web"

procedure file_warning;
var p:pointer;{saved value of|save_ptr|or|cond_ptr|}
l:quarterword;{saved value of|cur_level|or|if_limit|}
c:quarterword;{saved value of|cur_group|or|cur_if|}
i:integer;{saved value of|if_line|}
begin p:= save_ptr;l:= cur_level;c:= cur_group;save_ptr:= cur_boundary;
while grp_stack[in_open]<> save_ptr do
begin decr(cur_level);
print_nl("Warning: end of file when ");

print_group(true);print(" is incomplete");
cur_group:= save_level(save_ptr);save_ptr:= save_index(save_ptr)
end;
save_ptr:= p;cur_level:= l;cur_group:= c;{restore old values}
p:= cond_ptr;l:= if_limit;c:= cur_if;i:= if_line;
while if_stack[in_open]<> cond_ptr do
begin print_nl("Warning: end of file when ");

print_cmd_chr(if_test,cur_if);
if if_limit= fi_code then print_esc("else");
print_if_line(if_line);print(" is incomplete");
if_line:= if_line_field(cond_ptr);cur_if:= subtype(cond_ptr);
if_limit:= type(cond_ptr);cond_ptr:= link(cond_ptr);
end;
cond_ptr:= p;if_limit:= l;cur_if:= c;if_line:= i;{restore old values}
print_ln;
if tracing_nesting> 1 then show_context;
if history= spotless then history:= warning_issued;
end;

/*:1774*//*1818:*/
#line 39274 "pdftexdir/pdftex.web"

procedure delete_sa_ref(q:pointer);{reduce reference count}
label exit;
var p:pointer;{for list manipulations}
i:small_number;{a four bit index}
s:small_number;{size of a node}
begin decr(sa_ref(q));
if sa_ref(q)<> null then return;
if sa_index(q)<dimen_val_limit then
if sa_int(q)= 0 then s:= word_node_size
else return
else begin if sa_index(q)<mu_val_limit then
if sa_ptr(q)= zero_glue then delete_glue_ref(zero_glue)
else return
else if sa_ptr(q)<> null then return;
s:= pointer_node_size;
end;
repeat i:= hex_dig4(sa_index(q));p:= q;q:= link(p);free_node(p,s);
if q= null then{the whole tree has been freed}
begin sa_root[i]:= null;return;
end;
delete_sa_ptr;s:= index_node_size;{node|q|is an index node}
until sa_used(q)> 0;
exit:end;

/*:1818*//*1820:*/
#line 39317 "pdftexdir/pdftex.web"

stat procedure show_sa(p:pointer;s:str_number);
var t:small_number;{the type of element}
begin begin_diagnostic;print_char("{");print(s);print_char(" ");
if p= null then print_char("?"){this can't happen}
else begin t:= sa_type(p);
if t<box_val then print_cmd_chr(register,p)
else if t= box_val then
begin print_esc("box");print_sa_num(p);
end
else if t= tok_val then print_cmd_chr(toks_register,p)
else print_char("?");{this can't happen either}
print_char("=");
if t= int_val then print_int(sa_int(p))
else if t= dimen_val then
begin print_scaled(sa_dim(p));print("pt");
end
else begin p:= sa_ptr(p);
if t= glue_val then print_spec(p,"pt")
else if t= mu_val then print_spec(p,"mu")
else if t= box_val then
if p= null then print("void")
else begin depth_threshold:= 0;breadth_max:= 1;show_node_list(p);
end
else if t= tok_val then
begin if p<> null then show_token_list(link(p),null,32);
end
else print_char("?");{this can't happen either}
end;
end;
print_char("}");end_diagnostic(false);
end;
tats

/*:1820*//*1834:*/
#line 39533 "pdftexdir/pdftex.web"

procedure sa_save(p:pointer);{saves value of|p|}
var q:pointer;{the new save node}
i:quarterword;{index field of node}
begin if cur_level<> sa_level then
begin check_full_save_stack;save_type(save_ptr):= restore_sa;
save_level(save_ptr):= sa_level;save_index(save_ptr):= sa_chain;
incr(save_ptr);sa_chain:= null;sa_level:= cur_level;
end;
i:= sa_index(p);
if i<dimen_val_limit then
begin if sa_int(p)= 0 then
begin q:= get_node(pointer_node_size);i:= tok_val_limit;
end
else begin q:= get_node(word_node_size);sa_int(q):= sa_int(p);
end;
sa_ptr(q):= null;
end
else begin q:= get_node(pointer_node_size);sa_ptr(q):= sa_ptr(p);
end;
sa_loc(q):= p;sa_index(q):= i;sa_lev(q):= sa_lev(p);
link(q):= sa_chain;sa_chain:= q;add_sa_ref(p);
end;

/*:1834*//*1835:*/
#line 39557 "pdftexdir/pdftex.web"

procedure sa_destroy(p:pointer);{destroy value of|p|}
begin if sa_index(p)<mu_val_limit then delete_glue_ref(sa_ptr(p))
else if sa_ptr(p)<> null then
if sa_index(p)<box_val_limit then flush_node_list(sa_ptr(p))
else delete_token_ref(sa_ptr(p));
end;

/*:1835*//*1836:*/
#line 39583 "pdftexdir/pdftex.web"

procedure sa_def(p:pointer;e:halfword);
{new data for sparse array elements}
begin add_sa_ref(p);
if sa_ptr(p)= e then
begin stat if tracing_assigns> 0 then show_sa(p,"reassigning");tats
sa_destroy(p);
end
else begin stat if tracing_assigns> 0 then show_sa(p,"changing");tats
if sa_lev(p)= cur_level then sa_destroy(p)else sa_save(p);
sa_lev(p):= cur_level;sa_ptr(p):= e;
stat if tracing_assigns> 0 then show_sa(p,"into");tats
end;
delete_sa_ref(p);
end;

procedure sa_w_def(p:pointer;w:integer);
begin add_sa_ref(p);
if sa_int(p)= w then
begin stat if tracing_assigns> 0 then show_sa(p,"reassigning");tats
end
else begin stat if tracing_assigns> 0 then show_sa(p,"changing");tats
if sa_lev(p)<> cur_level then sa_save(p);
sa_lev(p):= cur_level;sa_int(p):= w;
stat if tracing_assigns> 0 then show_sa(p,"into");tats
end;
delete_sa_ref(p);
end;

/*:1836*//*1837:*/
#line 39617 "pdftexdir/pdftex.web"

procedure gsa_def(p:pointer;e:halfword);{global|sa_def|}
begin add_sa_ref(p);
stat if tracing_assigns> 0 then show_sa(p,"globally changing");tats
sa_destroy(p);sa_lev(p):= level_one;sa_ptr(p):= e;
stat if tracing_assigns> 0 then show_sa(p,"into");tats
delete_sa_ref(p);
end;

procedure gsa_w_def(p:pointer;w:integer);{global|sa_w_def|}
begin add_sa_ref(p);
stat if tracing_assigns> 0 then show_sa(p,"globally changing");tats
sa_lev(p):= level_one;sa_int(p):= w;
stat if tracing_assigns> 0 then show_sa(p,"into");tats
delete_sa_ref(p);
end;

/*:1837*//*1838:*/
#line 39637 "pdftexdir/pdftex.web"

procedure sa_restore;
var p:pointer;{sparse array element}
begin repeat p:= sa_loc(sa_chain);
if sa_lev(p)= level_one then
begin if sa_index(p)>=dimen_val_limit then sa_destroy(sa_chain);
stat if tracing_restores> 0 then show_sa(p,"retaining");tats
end
else begin if sa_index(p)<dimen_val_limit then
if sa_index(sa_chain)<dimen_val_limit then sa_int(p):= sa_int(sa_chain)
else sa_int(p):= 0
else begin sa_destroy(p);sa_ptr(p):= sa_ptr(sa_chain);
end;
sa_lev(p):= sa_lev(sa_chain);
stat if tracing_restores> 0 then show_sa(p,"restoring");tats
end;
delete_sa_ref(p);
p:= sa_chain;sa_chain:= link(p);
if sa_index(p)<dimen_val_limit then free_node(p,word_node_size)
else free_node(p,pointer_node_size);
until sa_chain= null;
end;

/*:1838*/
#line 6990 "pdftexdir/pdftex.web"


/*:290*//*296:*/
#line 7075 "pdftexdir/pdftex.web"
procedure new_save_level(c:group_code);{begin a new level of grouping}
begin check_full_save_stack;
if eTeX_ex then
begin saved(0):= line;incr(save_ptr);
end;
save_type(save_ptr):= level_boundary;save_level(save_ptr):= cur_group;
save_index(save_ptr):= cur_boundary;
if cur_level= max_quarterword then overflow("grouping levels",

max_quarterword-min_quarterword);
{quit if|(cur_level+1)|is too big to be stored in|eqtb|}
cur_boundary:= save_ptr;cur_group:= c;
stat if tracing_groups> 0 then group_trace(false);tats
incr(cur_level);incr(save_ptr);
end;

/*:296*//*297:*/
#line 7097 "pdftexdir/pdftex.web"
procedure eq_destroy(w:memory_word);{gets ready to forget|w|}
var q:pointer;{|equiv|field of|w|}
begin case eq_type_field(w)of
call,long_call,outer_call,long_outer_call:delete_token_ref(equiv_field(w));
glue_ref:delete_glue_ref(equiv_field(w));
shape_ref:begin q:= equiv_field(w);{we need to free a\.{\\parshape}block}
if q<> null then free_node(q,info(q)+info(q)+1);
end;{such a block is|2 n+1|words long,where|n= info(q)|}
box_ref:flush_node_list(equiv_field(w));
/*1831:*/
#line 39508 "pdftexdir/pdftex.web"

toks_register,register:
if(equiv_field(w)<mem_bot)or(equiv_field(w)> lo_mem_stat_max)then
delete_sa_ref(equiv_field(w));

/*:1831*/
#line 7106 "pdftexdir/pdftex.web"

othercases do_nothing
endcases;
end;

/*:297*//*298:*/
#line 7114 "pdftexdir/pdftex.web"
procedure eq_save(p:pointer;l:quarterword);{saves|eqtb[p]|}
begin check_full_save_stack;
if l= level_zero then save_type(save_ptr):= restore_zero
else begin save_stack[save_ptr]:= eqtb[p];incr(save_ptr);
save_type(save_ptr):= restore_old_value;
end;
save_level(save_ptr):= l;save_index(save_ptr):= p;incr(save_ptr);
end;

/*:298*//*299:*/
#line 7134 "pdftexdir/pdftex.web"
procedure eq_define(p:pointer;t:quarterword;e:halfword);
{new data for|eqtb|}
label exit;
begin if eTeX_ex and(eq_type(p)= t)and(equiv(p)= e)then
begin assign_trace(p,"reassigning")
eq_destroy(eqtb[p]);return;
end;
assign_trace(p,"changing")
if eq_level(p)= cur_level then eq_destroy(eqtb[p])
else if cur_level> level_one then eq_save(p,eq_level(p));
eq_level(p):= cur_level;eq_type(p):= t;equiv(p):= e;
assign_trace(p,"into")
exit:end;

/*:299*//*300:*/
#line 7152 "pdftexdir/pdftex.web"
procedure eq_word_define(p:pointer;w:integer);
label exit;
begin if eTeX_ex and(eqtb[p].int= w)then
begin assign_trace(p,"reassigning")
return;
end;
assign_trace(p,"changing")
if xeq_level[p]<> cur_level then
begin eq_save(p,xeq_level[p]);xeq_level[p]:= cur_level;
end;
eqtb[p].int:= w;
assign_trace(p,"into")
exit:end;

/*:300*//*301:*/
#line 7171 "pdftexdir/pdftex.web"
procedure geq_define(p:pointer;t:quarterword;e:halfword);
{global|eq_define|}
begin assign_trace(p,"globally changing")
begin eq_destroy(eqtb[p]);
eq_level(p):= level_one;eq_type(p):= t;equiv(p):= e;
end;
assign_trace(p,"into")
end;

procedure geq_word_define(p:pointer;w:integer);{global|eq_word_define|}
begin assign_trace(p,"globally changing")
begin eqtb[p].int:= w;xeq_level[p]:= level_one;
end;
assign_trace(p,"into")
end;

/*:301*//*302:*/
#line 7189 "pdftexdir/pdftex.web"
procedure save_for_after(t:halfword);
begin if cur_level> level_one then
begin check_full_save_stack;
save_type(save_ptr):= insert_token;save_level(save_ptr):= level_zero;
save_index(save_ptr):= t;incr(save_ptr);
end;
end;

/*:302*//*303:*/
#line 7201 "pdftexdir/pdftex.web"

procedure back_input;forward;
procedure unsave;{pops the top level off the save stack}
label done;
var p:pointer;{position to be restored}
l:quarterword;{saved level,if in fullword regions of|eqtb|}
t:halfword;{saved value of|cur_tok|}
a:boolean;{have we already processed an\.{\\aftergroup}?}
begin a:= false;
if cur_level> level_one then
begin decr(cur_level);
/*304:*/
#line 7218 "pdftexdir/pdftex.web"

loop begin decr(save_ptr);
if save_type(save_ptr)= level_boundary then goto done;
p:= save_index(save_ptr);
if save_type(save_ptr)= insert_token then
/*348:*/
#line 8241 "pdftexdir/pdftex.web"

begin t:= cur_tok;cur_tok:= p;
if a then
begin p:= get_avail;info(p):= cur_tok;link(p):= loc;loc:= p;start:= p;
if cur_tok<right_brace_limit then
if cur_tok<left_brace_limit then decr(align_state)
else incr(align_state);
end
else begin back_input;a:= eTeX_ex;
end;
cur_tok:= t;
end

/*:348*/
#line 7223 "pdftexdir/pdftex.web"

else if save_type(save_ptr)= restore_sa then
begin sa_restore;sa_chain:= p;sa_level:= save_level(save_ptr);
end
else begin if save_type(save_ptr)= restore_old_value then
begin l:= save_level(save_ptr);decr(save_ptr);
end
else save_stack[save_ptr]:= eqtb[undefined_control_sequence];
/*305:*/
#line 7247 "pdftexdir/pdftex.web"

#line 1745 "pdftex-final.ch"
if(p<int_base)or(p> eqtb_size)then
#line 7249 "pdftexdir/pdftex.web"
 if eq_level(p)= level_one then
begin eq_destroy(save_stack[save_ptr]);{destroy the saved value}
stat if tracing_restores> 0 then restore_trace(p,"retaining");tats
end
else begin eq_destroy(eqtb[p]);{destroy the current value}
eqtb[p]:= save_stack[save_ptr];{restore the saved value}
stat if tracing_restores> 0 then restore_trace(p,"restoring");tats
end
else if xeq_level[p]<> level_one then
begin eqtb[p]:= save_stack[save_ptr];xeq_level[p]:= l;
stat if tracing_restores> 0 then restore_trace(p,"restoring");tats
end
else begin
stat if tracing_restores> 0 then restore_trace(p,"retaining");tats
end

/*:305*/
#line 7232 "pdftexdir/pdftex.web"
;
end;
end;
done:stat if tracing_groups> 0 then group_trace(true);tats
if grp_stack[in_open]= cur_boundary then group_warning;
{groups possibly not properly nested with files}
cur_group:= save_level(save_ptr);cur_boundary:= save_index(save_ptr);
if eTeX_ex then decr(save_ptr)

/*:304*/
#line 7212 "pdftexdir/pdftex.web"
;
end
else confusion("curlevel");{|unsave|is not used when|cur_group= bottom_level|}

end;

/*:303*//*310:*/
#line 7303 "pdftexdir/pdftex.web"
procedure prepare_mag;
begin if(mag_set> 0)and(mag<> mag_set)then
begin print_err("Incompatible magnification (");print_int(mag);

print(");");print_nl(" the previous value will be retained");
help2("I can handle only one magnification ratio per job. So I've")
("reverted to the magnification you used earlier on this run.");
int_error(mag_set);
geq_word_define(int_base+mag_code,mag_set);{|mag:= mag_set|}
end;
if(mag<=0)or(mag> 32768)then
begin print_err("Illegal magnification has been changed to 1000");

help1("The magnification ratio must be between 1 and 32768.");
int_error(mag);geq_word_define(int_base+mag_code,1000);
end;
mag_set:= mag;
end;

/*:310*//*317:*/
#line 7488 "pdftexdir/pdftex.web"
procedure token_show(p:pointer);
begin if p<> null then show_token_list(link(p),null,10000000);
end;

/*:317*//*318:*/
#line 7495 "pdftexdir/pdftex.web"
procedure print_meaning;
begin print_cmd_chr(cur_cmd,cur_chr);
if cur_cmd>=call then
begin print_char(":");print_ln;token_show(cur_chr);
end
else if(cur_cmd= top_bot_mark)and(cur_chr<marks_code)then
begin print_char(":");print_ln;
token_show(cur_mark[cur_chr]);
end;
end;

/*:318*//*321:*/
#line 7594 "pdftexdir/pdftex.web"
procedure show_cur_cmd_chr;
var n:integer;{level of\.{\\if...\\fi}nesting}
l:integer;{line where\.{\\if}started}
p:pointer;
begin begin_diagnostic;print_nl("{");
if mode<> shown_mode then
begin print_mode(mode);print(": ");shown_mode:= mode;
end;
print_cmd_chr(cur_cmd,cur_chr);
if tracing_ifs> 0 then
if cur_cmd>=if_test then if cur_cmd<=fi_or_else then
begin print(": ");
if cur_cmd= fi_or_else then
begin print_cmd_chr(if_test,cur_if);print_char(" ");
n:= 0;l:= if_line;
end
else begin n:= 1;l:= line;
end;
p:= cond_ptr;
while p<> null do
begin incr(n);p:= link(p);
end;
print("(level ");print_int(n);print_char(")");print_if_line(l);
end;
print_char("}");
end_diagnostic(false);
end;

/*:321*//*333:*/
#line 7967 "pdftexdir/pdftex.web"
procedure show_context;{prints where the scanner is}
label done;
var old_setting:0..max_selector;{saved|selector|setting}
nn:integer;{number of contexts shown so far,less one}
bottom_line:boolean;{have we reached the final context to be shown?}
/*337:*/
#line 8083 "pdftexdir/pdftex.web"

i:0..buf_size;{index into|buffer|}
j:0..buf_size;{end of current line in|buffer|}
l:0..half_error_line;{length of descriptive information on line 1}
m:integer;{context information gathered for line 2}
n:0..error_line;{length of line 1}
p:integer;{starting or ending place in|trick_buf|}
q:integer;{temporary index}

/*:337*/
#line 7972 "pdftexdir/pdftex.web"

begin base_ptr:= input_ptr;input_stack[base_ptr]:= cur_input;
{store current state}
nn:= -1;bottom_line:= false;
loop begin cur_input:= input_stack[base_ptr];{enter into the context}
if(state<> token_list)then
if(name> 19)or(base_ptr= 0)then bottom_line:= true;
if(base_ptr= input_ptr)or bottom_line or(nn<error_context_lines)then
/*334:*/
#line 7990 "pdftexdir/pdftex.web"

begin if(base_ptr= input_ptr)or(state<> token_list)or
(token_type<> backed_up)or(loc<> null)then
{we omit backed-up token lists that have already been read}
begin tally:= 0;{get ready to count characters}
old_setting:= selector;
if state<> token_list then
begin/*335:*/
#line 8014 "pdftexdir/pdftex.web"

if name<=17 then
if terminal_input then
if base_ptr= 0 then print_nl("<*>")else print_nl("<insert> ")
else begin print_nl("<read ");
if name= 17 then print_char("*")else print_int(name-1);

print_char(">");
end
else if index<> in_open then{input from a pseudo file}
begin print_nl("l.");print_int(line_stack[index+1]);
end
else begin print_nl("l.");print_int(line);
end;
print_char(" ")

/*:335*/
#line 7997 "pdftexdir/pdftex.web"
;
/*340:*/
#line 8129 "pdftexdir/pdftex.web"

begin_pseudoprint;
if buffer[limit]= end_line_char then j:= limit
else j:= limit+1;{determine the effective end of the line}
#line 1835 "pdftex-final.ch"
i:= start;mubyte_skeep:= mubyte_keep;
mubyte_sstart:= mubyte_start;mubyte_start:= false;
if j> 0 then while i<j do
begin
if i= loc then set_trick_count;
print_buffer(i);
end;
mubyte_keep:= mubyte_skeep;mubyte_start:= mubyte_sstart
#line 8137 "pdftexdir/pdftex.web"

/*:340*/
#line 7998 "pdftexdir/pdftex.web"
;
end
else begin/*336:*/
#line 8030 "pdftexdir/pdftex.web"

case token_type of
parameter:print_nl("<argument> ");
u_template,v_template:print_nl("<template> ");
backed_up:if loc= null then print_nl("<recently read> ")
else print_nl("<to be read again> ");
inserted:print_nl("<inserted text> ");
macro:begin print_ln;print_cs(name);
end;
output_text:print_nl("<output> ");
every_par_text:print_nl("<everypar> ");
every_math_text:print_nl("<everymath> ");
every_display_text:print_nl("<everydisplay> ");
every_hbox_text:print_nl("<everyhbox> ");
every_vbox_text:print_nl("<everyvbox> ");
every_job_text:print_nl("<everyjob> ");
every_cr_text:print_nl("<everycr> ");
mark_text:print_nl("<mark> ");
every_eof_text:print_nl("<everyeof> ");
write_text:print_nl("<write> ");
othercases print_nl("?"){this should never happen}
endcases

/*:336*/
#line 8000 "pdftexdir/pdftex.web"
;
/*341:*/
#line 8138 "pdftexdir/pdftex.web"

begin_pseudoprint;
if token_type<macro then show_token_list(start,loc,100000)
else show_token_list(link(start),loc,100000){avoid reference count}

/*:341*/
#line 8001 "pdftexdir/pdftex.web"
;
end;
selector:= old_setting;{stop pseudoprinting}
/*339:*/
#line 8107 "pdftexdir/pdftex.web"

if trick_count= 1000000 then set_trick_count;
{|set_trick_count|must be performed}
if tally<trick_count then m:= tally-first_count
else m:= trick_count-first_count;{context on line 2}
if l+first_count<=half_error_line then
begin p:= 0;n:= l+first_count;
end
else begin print("...");p:= l+first_count-half_error_line+3;
n:= half_error_line;
end;
for q:= p to first_count-1 do print_char(trick_buf[q mod error_line]);
print_ln;
for q:= 1 to n do print_char(" ");{print|n|spaces to begin line~2}
if m+n<=error_line then p:= first_count+m else p:= first_count+(error_line-n-3);
for q:= first_count to p-1 do print_char(trick_buf[q mod error_line]);
if m+n> error_line then print("...")

/*:339*/
#line 8004 "pdftexdir/pdftex.web"
;
incr(nn);
end;
end

/*:334*/
#line 7980 "pdftexdir/pdftex.web"

else if nn= error_context_lines then
begin print_nl("...");incr(nn);{omitted if|error_context_lines<0|}
end;
if bottom_line then goto done;
decr(base_ptr);
end;
done:cur_input:= input_stack[input_ptr];{restore original state}
end;

/*:333*//*345:*/
#line 8177 "pdftexdir/pdftex.web"
procedure begin_token_list(p:pointer;t:quarterword);
begin push_input;state:= token_list;start:= p;token_type:= t;
if t>=macro then{the token list starts with a reference count}
begin add_token_ref(p);
if t= macro then param_start:= param_ptr
else begin loc:= link(p);
if tracing_macros> 1 then
begin begin_diagnostic;print_nl("");
case t of
mark_text:print_esc("mark");
write_text:print_esc("write");
othercases print_cmd_chr(assign_toks,t-output_text+output_routine_loc)
endcases;
print("->");token_show(p);end_diagnostic(false);
end;
end;
end
else loc:= p;
end;

/*:345*//*346:*/
#line 8202 "pdftexdir/pdftex.web"
procedure end_token_list;{leave a token-list input level}
begin if token_type>=backed_up then{token list to be deleted}
begin if token_type<=inserted then flush_list(start)
else begin delete_token_ref(start);{update reference count}
if token_type= macro then{parameters must be flushed}
while param_ptr> param_start do
begin decr(param_ptr);
flush_list(param_stack[param_ptr]);
end;
end;
end
else if token_type= u_template then
if align_state> 500000 then align_state:= 0
else fatal_error("(interwoven alignment preambles are not allowed)");

pop_input;
check_interrupt;
end;

/*:346*//*347:*/
#line 8229 "pdftexdir/pdftex.web"
procedure back_input;{undoes one token of input}
var p:pointer;{a token list of length one}
begin while(state= token_list)and(loc= null)and(token_type<> v_template)do
end_token_list;{conserve stack space}
p:= get_avail;info(p):= cur_tok;
if cur_tok<right_brace_limit then
if cur_tok<left_brace_limit then decr(align_state)
else incr(align_state);
push_input;state:= token_list;start:= p;token_type:= backed_up;
loc:= p;{that was|back_list(p)|,without procedure overhead}
end;

/*:347*//*349:*/
#line 8259 "pdftexdir/pdftex.web"
procedure back_error;{back up one token and call|error|}
begin OK_to_interrupt:= false;back_input;OK_to_interrupt:= true;error;
end;

procedure ins_error;{back up one inserted token and call|error|}
begin OK_to_interrupt:= false;back_input;token_type:= inserted;
OK_to_interrupt:= true;error;
end;

/*:349*//*350:*/
#line 1848 "pdftex-final.ch"
procedure begin_file_reading;
#line 8275 "pdftexdir/pdftex.web"
begin if in_open= max_in_open then overflow("text input levels",max_in_open);

if first= buf_size then overflow("buffer size",buf_size);

#line 1854 "pdftex-final.ch"
incr(in_open);push_input;index:= in_open;
source_filename_stack[index]:= 0;full_source_filename_stack[index]:= 0;
#line 8280 "pdftexdir/pdftex.web"
eof_seen[index]:= false;
grp_stack[index]:= cur_boundary;if_stack[index]:= cond_ptr;
line_stack[index]:= line;start:= first;state:= mid_line;
#line 1861 "pdftex-final.ch"
name:= 0;{|terminal_input|is now|true|}
/*1916:*/
#line 7000 "pdftex-final.ch"

synctex_tag:= 0;

/*:1916*/
#line 1862 "pdftex-final.ch"
;
#line 8284 "pdftexdir/pdftex.web"
end;

/*:350*//*351:*/
#line 8289 "pdftexdir/pdftex.web"
procedure end_file_reading;
begin first:= start;line:= line_stack[index];
if(name= 18)or(name= 19)then pseudo_close else
if name> 17 then a_close(cur_file);{forget it}
pop_input;decr(in_open);
end;

/*:351*//*352:*/
#line 8300 "pdftexdir/pdftex.web"
procedure clear_for_error_prompt;
begin while(state<> token_list)and terminal_input and
(input_ptr> 0)and(loc> limit)do end_file_reading;
print_ln;clear_terminal;
end;

/*:352*//*354:*/
#line 1882 "pdftex-final.ch"
/*1897:*/
#line 6710 "pdftex-final.ch"

procedure mubyte_update;{saves new string to mubyte tree}
var j:pool_pointer;
p:pointer;
q:pointer;
in_mutree:integer;
begin
j:= str_start[str_ptr];
if mubyte_read[so(str_pool[j])]= null then
begin
in_mutree:= 0;
p:= get_avail;
mubyte_read[so(str_pool[j])]:= p;
subinfo(p):= so(str_pool[j]);type(p):= 0;
end else begin
in_mutree:= 1;
p:= mubyte_read[so(str_pool[j])];
end;
incr(j);
while j<pool_ptr do
begin
if in_mutree= 0 then
begin
new_mubyte_node;subinfo(p):= so(str_pool[j]);type(p):= 0;
end else{|in_mutree|= 1}
if(type(p)> 0)and(type(p)<64)then
begin
type(p):= type(p)+64;
q:= link(p);link(p):= get_avail;p:= link(p);
info(p):= q;
new_mubyte_node;subinfo(p):= so(str_pool[j]);type(p):= 0;
in_mutree:= 0;
end else begin
if type(p)>=64 then p:= link(p);
repeat
p:= link(p);
if subinfo(info(p))= so(str_pool[j])then
begin
p:= info(p);
goto continue;
end;
until link(p)= null;
new_mubyte_node;subinfo(p):= so(str_pool[j]);type(p):= 0;
in_mutree:= 0;
end;
continue:
incr(j);
end;
if in_mutree= 1 then
begin
if type(p)= 0 then
begin
type(p):= mubyte_prefix+64;
q:= link(p);link(p):= get_avail;p:= link(p);
link(p):= q;info(p):= mubyte_stoken;
return;
end;
if type(p)>=64 then
begin
type(p):= mubyte_prefix+64;
p:= link(p);info(p):= mubyte_stoken;
return;
end;
end;
type(p):= mubyte_prefix;
link(p):= mubyte_stoken;
exit:end;

procedure dispose_munode(p:pointer);{frees a mu subtree recursivelly}
var q:pointer;
begin
if(type(p)> 0)and(type(p)<64)then free_avail(p)
else begin
if type(p)>=64 then
begin
q:= link(p);free_avail(p);p:= q;
end;
q:= link(p);free_avail(p);p:= q;
while p<> null do
begin
dispose_munode(info(p));
q:= link(p);
free_avail(p);
p:= q;
end;
end;
end;

procedure dispose_mutableout(cs:pointer);{frees record from out table}
var p,q,r:pointer;
begin
p:= mubyte_cswrite[cs mod 128];
r:= null;
while p<> null do
if info(p)= cs then
begin
if r<> null then link(r):= link(link(p))
else mubyte_cswrite[cs mod 128]:= link(link(p));
q:= link(link(p));
free_avail(link(p));free_avail(p);
p:= q;
end else begin
r:= link(p);p:= link(r);
end;
end;

/*:1897*/
#line 1882 "pdftex-final.ch"

#line 8345 "pdftexdir/pdftex.web"

/*:354*//*358:*/
#line 8368 "pdftexdir/pdftex.web"
procedure check_outer_validity;
var p:pointer;{points to inserted token list}
q:pointer;{auxiliary pointer}
begin if scanner_status<> normal then
begin deletions_allowed:= false;
/*359:*/
#line 8394 "pdftexdir/pdftex.web"

if cur_cs<> 0 then
begin if(state= token_list)or(name<1)or(name> 17)then
begin p:= get_avail;info(p):= cs_token_flag+cur_cs;
back_list(p);{prepare to read the control sequence again}
end;
cur_cmd:= spacer;cur_chr:= " ";{replace it by a space}
end

/*:359*/
#line 8373 "pdftexdir/pdftex.web"
;
if scanner_status> skipping then
/*360:*/
#line 8403 "pdftexdir/pdftex.web"

begin runaway;{print a definition,argument,or preamble}
if cur_cs= 0 then print_err("File ended")

else begin cur_cs:= 0;print_err("Forbidden control sequence found");

end;
#line 8411 "pdftexdir/pdftex.web"
/*361:*/
#line 8428 "pdftexdir/pdftex.web"

p:= get_avail;
case scanner_status of
#line 1901 "pdftex-final.ch"
 defining:begin print(" while scanning definition");info(p):= right_brace_token+"}";
end;
matching:begin print(" while scanning use");info(p):= par_token;long_state:= outer_call;
end;
aligning:begin print(" while scanning preamble");info(p):= right_brace_token+"}";q:= p;
p:= get_avail;link(p):= q;info(p):= cs_token_flag+frozen_cr;
align_state:= -1000000;
end;
absorbing:begin print(" while scanning text");info(p):= right_brace_token+"}";
#line 8440 "pdftexdir/pdftex.web"
end;
end;{there are no other cases}
ins_list(p)

/*:361*/
#line 8412 "pdftexdir/pdftex.web"
;
print(" of ");sprint_cs(warning_index);
help4("I suspect you have forgotten a `}', causing me")
("to read past where you wanted me to stop.")
("I'll try to recover; but if the error is serious,")
("you'd better type `E' or `X' now and fix your file.");
error;
end

/*:360*/
#line 8375 "pdftexdir/pdftex.web"

else begin print_err("Incomplete ");print_cmd_chr(if_test,cur_if);

print("; all text was ignored after line ");print_int(skip_line);
help3("A forbidden control sequence occurred in skipped text.")
("This kind of error happens when you say `\if...' and forget")
("the matching `\fi'. I've inserted a `\fi'; this might work.");
if cur_cs<> 0 then cur_cs:= 0
else help_line[2]:= 
"The file ended while I was skipping conditional text.";
cur_tok:= cs_token_flag+frozen_fi;ins_error;
end;
deletions_allowed:= true;
end;
end;

/*:358*//*362:*/
#line 8446 "pdftexdir/pdftex.web"
procedure firm_up_the_line;forward;

/*:362*//*363:*/
#line 8455 "pdftexdir/pdftex.web"
procedure get_next;{sets|cur_cmd|,|cur_chr|,|cur_cs|to next token}
label restart,{go here to get the next input token}
switch,{go here to eat the next character from a file}
reswitch,{go here to digest it again}
start_cs,{go here to start looking for a control sequence}
found,{go here when a control sequence has been found}
exit;{go here when the next input token has been got}
#line 1916 "pdftex-final.ch"
var k:0..buf_size;{an index into|buffer|}
t:halfword;{a token}
i,j:0..buf_size;{more indexes for encTeX}
mubyte_incs:boolean;{control sequence is converted by mubyte}
p:pointer;{for encTeX test if noexpanding}
#line 8464 "pdftexdir/pdftex.web"
cat:0..max_char_code;{|cat_code(cur_chr)|,usually}
c,cc:ASCII_code;{constituents of a possible expanded code}
d:2. .3;{number of excess characters in an expanded code}
begin restart:cur_cs:= 0;
if state<> token_list then
/*365:*/
#line 8485 "pdftexdir/pdftex.web"


begin switch:if loc<=limit then{current line not yet finished}
#line 1926 "pdftex-final.ch"
begin
{Use|k|instead of|loc|for type correctness.}
k:= loc;
cur_chr:= read_buffer(k);
loc:= k;incr(loc);
if(mubyte_token> 0)then
begin
state:= mid_line;
cur_cs:= mubyte_token-cs_token_flag;
goto found;
end;
#line 8489 "pdftexdir/pdftex.web"
reswitch:cur_cmd:= cat_code(cur_chr);
/*366:*/
#line 8512 "pdftexdir/pdftex.web"

case state+cur_cmd of
/*367:*/
#line 8528 "pdftexdir/pdftex.web"

any_state_plus(ignore),skip_blanks+spacer,new_line+spacer

/*:367*/
#line 8514 "pdftexdir/pdftex.web"
:goto switch;
any_state_plus(escape):/*376:*/
#line 8634 "pdftexdir/pdftex.web"

begin if loc> limit then cur_cs:= null_cs{|state|is irrelevant in this case}
#line 1943 "pdftex-final.ch"
else begin start_cs:
mubyte_incs:= false;k:= loc;mubyte_skeep:= mubyte_keep;
cur_chr:= read_buffer(k);cat:= cat_code(cur_chr);
if(mubyte_in> 0)and(not mubyte_incs)and
((mubyte_skip> 0)or(cur_chr<> buffer[k]))then mubyte_incs:= true;
incr(k);
if mubyte_token> 0 then
begin
state:= mid_line;
cur_cs:= mubyte_token-cs_token_flag;
goto found;
end;
#line 8638 "pdftexdir/pdftex.web"
if cat= letter then state:= skip_blanks
else if cat= spacer then state:= skip_blanks
else state:= mid_line;
if(cat= letter)and(k<=limit)then
/*378:*/
#line 8682 "pdftexdir/pdftex.web"

#line 1997 "pdftex-final.ch"
begin
repeat cur_chr:= read_buffer(k);cat:= cat_code(cur_chr);
if mubyte_token> 0 then cat:= escape;
if(mubyte_in> 0)and(not mubyte_incs)and(cat= letter)and
((mubyte_skip> 0)or(cur_chr<> buffer[k]))then mubyte_incs:= true;
incr(k);
until(cat<> letter)or(k> limit);
/*377:*/
#line 8661 "pdftexdir/pdftex.web"

begin if buffer[k]= cur_chr then if cat= sup_mark then if k<limit then
begin c:= buffer[k+1];if c<50
begin d:= 2;
if is_hex(c)then if k+2<=limit then
begin cc:= buffer[k+2];if is_hex(cc)then incr(d);
end;
if d> 2 then
begin hex_to_cur_chr;buffer[k-1]:= cur_chr;
end
else if c<49 100
else buffer[k-1]:= c-49
#line 1982 "pdftex-final.ch"
 limit:= limit-d;first:= first-d;
if mubyte_in> 0 then mubyte_keep:= k-loc;
#line 8674 "pdftexdir/pdftex.web"
while k<=limit do
begin buffer[k]:= buffer[k+d];incr(k);
end;
goto start_cs;
end;
end;
end

/*:377*/
#line 2004 "pdftex-final.ch"
;
if cat<> letter then
begin
decr(k);k:= k-mubyte_skip;
end;
if k> loc+1 then{multiletter control sequence has been scanned}
begin
if mubyte_incs then{multibyte in csname occurrs}
begin
i:= loc;j:= first;mubyte_keep:= mubyte_skeep;
if j-loc+k> max_buf_stack then
begin
max_buf_stack:= j-loc+k;
if max_buf_stack>=buf_size then
begin
max_buf_stack:= buf_size;
overflow("buffer size",buf_size);
end;
end;
while i<k do
begin
buffer[j]:= read_buffer(i);
incr(i);incr(j);
end;
if j= first+1 then
cur_cs:= single_base+buffer[first]
else
cur_cs:= id_lookup(first,j-first);
end else cur_cs:= id_lookup(loc,k-loc);
loc:= k;
goto found;
end;
end
#line 8692 "pdftexdir/pdftex.web"

/*:378*/
#line 8646 "pdftexdir/pdftex.web"

else/*377:*/
#line 8661 "pdftexdir/pdftex.web"

begin if buffer[k]= cur_chr then if cat= sup_mark then if k<limit then
begin c:= buffer[k+1];if c<50
begin d:= 2;
if is_hex(c)then if k+2<=limit then
begin cc:= buffer[k+2];if is_hex(cc)then incr(d);
end;
if d> 2 then
begin hex_to_cur_chr;buffer[k-1]:= cur_chr;
end
else if c<49 100
else buffer[k-1]:= c-49
#line 1982 "pdftex-final.ch"
 limit:= limit-d;first:= first-d;
if mubyte_in> 0 then mubyte_keep:= k-loc;
#line 8674 "pdftexdir/pdftex.web"
while k<=limit do
begin buffer[k]:= buffer[k+d];incr(k);
end;
goto start_cs;
end;
end;
end

/*:377*/
#line 8647 "pdftexdir/pdftex.web"
;
#line 1963 "pdftex-final.ch"
mubyte_keep:= mubyte_skeep;
cur_cs:= single_base+read_buffer(loc);incr(loc);
end;
found:cur_cmd:= eq_type(cur_cs);cur_chr:= equiv(cur_cs);
if cur_cmd>=outer_call then check_outer_validity;
if write_noexpanding then
begin
p:= mubyte_cswrite[cur_cs mod 128];
while p<> null do
if info(p)= cur_cs then
begin
cur_cmd:= relax;cur_chr:= 256;p:= null;
end else p:= link(link(p));
end;
#line 8652 "pdftexdir/pdftex.web"
end

/*:376*/
#line 8516 "pdftexdir/pdftex.web"
;
any_state_plus(active_char):/*375:*/
#line 8613 "pdftexdir/pdftex.web"

begin cur_cs:= cur_chr+active_base;
cur_cmd:= eq_type(cur_cs);cur_chr:= equiv(cur_cs);state:= mid_line;
if cur_cmd>=outer_call then check_outer_validity;
end

/*:375*/
#line 8518 "pdftexdir/pdftex.web"
;
any_state_plus(sup_mark):/*374:*/
#line 8597 "pdftexdir/pdftex.web"

begin if cur_chr= buffer[loc]then if loc<limit then
begin c:= buffer[loc+1];if c<50
begin loc:= loc+2;
if is_hex(c)then if loc<=limit then
begin cc:= buffer[loc];if is_hex(cc)then
begin incr(loc);hex_to_cur_chr;goto reswitch;
end;
end;
if c<49 100 else cur_chr:= c-49
goto reswitch;
end;
end;
state:= mid_line;
end

/*:374*/
#line 8521 "pdftexdir/pdftex.web"
;
any_state_plus(invalid_char):/*368:*/
#line 8535 "pdftexdir/pdftex.web"

begin print_err("Text line contains an invalid character");

help2("A funny symbol that I can't read has just been input.")
("Continue, and I'll forget that it ever happened.");
deletions_allowed:= false;error;deletions_allowed:= true;
goto restart;
end

/*:368*/
#line 8523 "pdftexdir/pdftex.web"
;
/*369:*/
#line 8547 "pdftexdir/pdftex.web"

mid_line+spacer:/*371:*/
#line 8575 "pdftexdir/pdftex.web"

begin state:= skip_blanks;cur_chr:= " ";
end

/*:371*/
#line 8548 "pdftexdir/pdftex.web"
;
mid_line+car_ret:/*370:*/
#line 8569 "pdftexdir/pdftex.web"

begin loc:= limit+1;cur_cmd:= spacer;cur_chr:= " ";
end

/*:370*/
#line 8549 "pdftexdir/pdftex.web"
;
skip_blanks+car_ret,any_state_plus(comment):
/*372:*/
#line 8579 "pdftexdir/pdftex.web"

begin loc:= limit+1;goto switch;
end

/*:372*/
#line 8551 "pdftexdir/pdftex.web"
;
new_line+car_ret:/*373:*/
#line 8583 "pdftexdir/pdftex.web"

begin loc:= limit+1;cur_cs:= par_loc;cur_cmd:= eq_type(cur_cs);
cur_chr:= equiv(cur_cs);
if cur_cmd>=outer_call then check_outer_validity;
end

/*:373*/
#line 8552 "pdftexdir/pdftex.web"
;
mid_line+left_brace:incr(align_state);
skip_blanks+left_brace,new_line+left_brace:begin
state:= mid_line;incr(align_state);
end;
mid_line+right_brace:decr(align_state);
skip_blanks+right_brace,new_line+right_brace:begin
state:= mid_line;decr(align_state);
end;
add_delims_to(skip_blanks),add_delims_to(new_line):state:= mid_line;

/*:369*/
#line 8524 "pdftexdir/pdftex.web"

othercases do_nothing
endcases

/*:366*/
#line 8493 "pdftexdir/pdftex.web"
;
end
else begin state:= new_line;
/*382:*/
#line 8745 "pdftexdir/pdftex.web"

if name> 17 then/*384:*/
#line 8782 "pdftexdir/pdftex.web"

begin incr(line);first:= start;
if not force_eof then
if name<=19 then
begin if pseudo_input then{not end of file}
firm_up_the_line{this sets|limit|}
else if(every_eof<> null)and not eof_seen[index]then
begin limit:= first-1;eof_seen[index]:= true;{fake one empty line}
begin_token_list(every_eof,every_eof_text);goto restart;
end
else force_eof:= true;
end
else
begin if input_ln(cur_file,true)then{not end of file}
firm_up_the_line{this sets|limit|}
else if(every_eof<> null)and not eof_seen[index]then
begin limit:= first-1;eof_seen[index]:= true;{fake one empty line}
begin_token_list(every_eof,every_eof_text);goto restart;
end
else force_eof:= true;
end;
if force_eof then
begin if tracing_nesting> 0 then
if(grp_stack[in_open]<> cur_boundary)or
(if_stack[in_open]<> cond_ptr)then file_warning;
{give warning for some unfinished groups and/or conditionals}
if name>=19 then
begin print_char(")");decr(open_parens);
update_terminal;{show user that file has been read}
end;
force_eof:= false;
end_file_reading;{resume previous level}
check_outer_validity;goto restart;
end;
if end_line_char_inactive then decr(limit)
else buffer[limit]:= end_line_char;
first:= limit+1;loc:= start;{ready to read}
end

/*:384*/
#line 8747 "pdftexdir/pdftex.web"

else begin if not terminal_input then{\.{\\read}line has ended}
begin cur_cmd:= 0;cur_chr:= 0;return;
end;
if input_ptr> 0 then{text was inserted during error recovery}
begin end_file_reading;goto restart;{resume previous level}
end;
if selector<log_only then open_log_file;
if interaction> nonstop_mode then
begin if end_line_char_inactive then incr(limit);
if limit= start then{previous line was empty}
print_nl("(Please type a command or say `\end')");

print_ln;first:= start;
prompt_input("*");{input on-line into|buffer|}

limit:= last;
if end_line_char_inactive then decr(limit)
else buffer[limit]:= end_line_char;
first:= limit+1;
loc:= start;
end
else fatal_error("*** (job aborted, no legal \end found)");

{nonstop mode,which is intended for overnight batch processing,
never waits for on-line input}
end

/*:382*/
#line 8498 "pdftexdir/pdftex.web"
;
check_interrupt;
goto switch;
end;
end

/*:365*/
#line 8469 "pdftexdir/pdftex.web"

else/*379:*/
#line 8696 "pdftexdir/pdftex.web"

if loc<> null then{list not exhausted}

begin t:= info(loc);loc:= link(loc);{move to next}
if t>=cs_token_flag then{a control sequence token}
begin cur_cs:= t-cs_token_flag;
cur_cmd:= eq_type(cur_cs);cur_chr:= equiv(cur_cs);
if cur_cmd>=outer_call then
if cur_cmd= dont_expand then
/*380:*/
#line 8727 "pdftexdir/pdftex.web"

begin cur_cs:= info(loc)-cs_token_flag;loc:= null;
cur_cmd:= eq_type(cur_cs);cur_chr:= equiv(cur_cs);
if cur_cmd> max_command then
begin cur_cmd:= relax;cur_chr:= no_expand_flag;
end;
end

/*:380*/
#line 8705 "pdftexdir/pdftex.web"

#line 2042 "pdftex-final.ch"
else check_outer_validity;
if write_noexpanding then
begin
p:= mubyte_cswrite[cur_cs mod 128];
while p<> null do
if info(p)= cur_cs then
begin
cur_cmd:= relax;cur_chr:= 256;p:= null;
end else p:= link(link(p));
end;
#line 8707 "pdftexdir/pdftex.web"
end
else begin cur_cmd:= t div 52 400;
case cur_cmd of
left_brace:incr(align_state);
right_brace:decr(align_state);
out_param:/*381:*/
#line 8735 "pdftexdir/pdftex.web"

begin begin_token_list(param_stack[param_start+cur_chr-1],parameter);
goto restart;
end

/*:381*/
#line 8712 "pdftexdir/pdftex.web"
;
othercases do_nothing
endcases;
end;
end
else begin{we are done with this token list}
end_token_list;goto restart;{resume previous level}
end

/*:379*/
#line 8471 "pdftexdir/pdftex.web"
;
/*364:*/
#line 8481 "pdftexdir/pdftex.web"

if cur_cmd<=car_ret then if cur_cmd>=tab_mark then if align_state= 0 then
/*963:*/
#line 23517 "pdftexdir/pdftex.web"

begin if(scanner_status= aligning)or(cur_align= null)then
fatal_error("(interwoven alignment preambles are not allowed)");

cur_cmd:= extra_info(cur_align);extra_info(cur_align):= cur_chr;
if cur_cmd= omit then begin_token_list(omit_template,v_template)
else begin_token_list(v_part(cur_align),v_template);
align_state:= 1000000;goto restart;
end

/*:963*/
#line 8483 "pdftexdir/pdftex.web"


/*:364*/
#line 8472 "pdftexdir/pdftex.web"
;
exit:end;

/*:363*//*385:*/
#line 8828 "pdftexdir/pdftex.web"
procedure firm_up_the_line;
var k:0..buf_size;{an index into|buffer|}
begin limit:= last;
if pausing> 0 then if interaction> nonstop_mode then
begin wake_up_terminal;print_ln;
#line 2057 "pdftex-final.ch"
k:= start;
while k<limit do begin print_buffer(k)end;
#line 8834 "pdftexdir/pdftex.web"
first:= limit;prompt_input("=>");{wait for user response}

if last> first then
begin for k:= first to last-1 do{move line down in buffer}
buffer[k+start-first]:= buffer[k];
limit:= start+last-first;
end;
end;
end;

/*:385*//*387:*/
#line 8867 "pdftexdir/pdftex.web"
procedure get_token;{sets|cur_cmd|,|cur_chr|,|cur_tok|}
begin no_new_control_sequence:= false;get_next;no_new_control_sequence:= true;

if cur_cs= 0 then cur_tok:= (cur_cmd*52
else cur_tok:= cs_token_flag+cur_cs;
end;

/*:387*//*388:*/
#line 8893 "pdftexdir/pdftex.web"
/*415:*/
#line 9279 "pdftexdir/pdftex.web"

procedure macro_call;{invokes a user-defined control sequence}
label exit,continue,done,done1,found;
var r:pointer;{current node in the macro's token list}
p:pointer;{current node in parameter token list being built}
q:pointer;{new node being put into the token list}
s:pointer;{backup pointer for parameter matching}
t:pointer;{cycle pointer for backup recovery}
u,v:pointer;{auxiliary pointers for backup recovery}
rbrace_ptr:pointer;{one step before the last|right_brace|token}
n:small_number;{the number of parameters scanned}
unbalance:halfword;{unmatched left braces in current parameter}
m:halfword;{the number of tokens or groups(usually)}
ref_count:pointer;{start of the token list}
save_scanner_status:small_number;{|scanner_status|upon entry}
save_warning_index:pointer;{|warning_index|upon entry}
match_chr:ASCII_code;{character used in parameter}
begin save_scanner_status:= scanner_status;save_warning_index:= warning_index;
warning_index:= cur_cs;ref_count:= cur_chr;r:= link(ref_count);n:= 0;
if tracing_macros> 0 then/*427:*/
#line 9505 "pdftexdir/pdftex.web"

begin begin_diagnostic;print_ln;print_cs(warning_index);
token_show(ref_count);end_diagnostic(false);
end

/*:427*/
#line 9298 "pdftexdir/pdftex.web"
;
if info(r)= protected_token then r:= link(r);
if info(r)<> end_match_token then
/*417:*/
#line 9336 "pdftexdir/pdftex.web"

begin scanner_status:= matching;unbalance:= 0;
long_state:= eq_type(cur_cs);
if long_state>=outer_call then long_state:= long_state-2;
repeat link(temp_head):= null;
if(info(r)> match_token+255)or(info(r)<match_token)then s:= null
else begin match_chr:= info(r)-match_token;s:= link(r);r:= s;
p:= temp_head;m:= 0;
end;
/*418:*/
#line 9356 "pdftexdir/pdftex.web"

continue:get_token;{set|cur_tok|to the next token of input}
if cur_tok= info(r)then
/*420:*/
#line 9389 "pdftexdir/pdftex.web"

begin r:= link(r);
if(info(r)>=match_token)and(info(r)<=end_match_token)then
begin if cur_tok<left_brace_limit then decr(align_state);
goto found;
end
else goto continue;
end

/*:420*/
#line 9360 "pdftexdir/pdftex.web"
;
/*423:*/
#line 9445 "pdftexdir/pdftex.web"

if s<> r then
if s= null then/*424:*/
#line 9462 "pdftexdir/pdftex.web"

begin print_err("Use of ");sprint_cs(warning_index);

print(" doesn't match its definition");
help4("If you say, e.g., `\def\a1{...}', then you must always")
("put `1' after `\a', since control sequence names are")
("made up of letters only. The macro here has not been")
("followed by the required stuff, so I'm ignoring it.");
error;return;
end

/*:424*/
#line 9447 "pdftexdir/pdftex.web"

else begin t:= s;
repeat store_new_token(info(t));incr(m);u:= link(t);v:= s;
loop begin if u= r then
if cur_tok<> info(v)then goto done
else begin r:= link(v);goto continue;
end;
if info(u)<> info(v)then goto done;
u:= link(u);v:= link(v);
end;
done:t:= link(t);
until t= r;
r:= s;{at this point,no tokens are recently matched}
end

/*:423*/
#line 9363 "pdftexdir/pdftex.web"
;
if cur_tok= par_token then if long_state<> long_call then
/*422:*/
#line 9414 "pdftexdir/pdftex.web"

begin if long_state= call then
begin runaway;print_err("Paragraph ended before ");

sprint_cs(warning_index);print(" was complete");
help3("I suspect you've forgotten a `}', causing me to apply this")
("control sequence to too much text. How can we recover?")
("My plan is to forget the whole thing and hope for the best.");
back_error;
end;
pstack[n]:= link(temp_head);align_state:= align_state-unbalance;
for m:= 0 to n do flush_list(pstack[m]);
return;
end

/*:422*/
#line 9365 "pdftexdir/pdftex.web"
;
if cur_tok<right_brace_limit then
if cur_tok<left_brace_limit then
/*425:*/
#line 9473 "pdftexdir/pdftex.web"

begin unbalance:= 1;

loop begin fast_store_new_token(cur_tok);get_token;
if cur_tok= par_token then if long_state<> long_call then
/*422:*/
#line 9414 "pdftexdir/pdftex.web"

begin if long_state= call then
begin runaway;print_err("Paragraph ended before ");

sprint_cs(warning_index);print(" was complete");
help3("I suspect you've forgotten a `}', causing me to apply this")
("control sequence to too much text. How can we recover?")
("My plan is to forget the whole thing and hope for the best.");
back_error;
end;
pstack[n]:= link(temp_head);align_state:= align_state-unbalance;
for m:= 0 to n do flush_list(pstack[m]);
return;
end

/*:422*/
#line 9478 "pdftexdir/pdftex.web"
;
if cur_tok<right_brace_limit then
if cur_tok<left_brace_limit then incr(unbalance)
else begin decr(unbalance);
if unbalance= 0 then goto done1;
end;
end;
done1:rbrace_ptr:= p;store_new_token(cur_tok);
end

/*:425*/
#line 9368 "pdftexdir/pdftex.web"

else/*421:*/
#line 9398 "pdftexdir/pdftex.web"

begin back_input;print_err("Argument of ");sprint_cs(warning_index);

print(" has an extra }");
help6("I've run across a `}' that doesn't seem to match anything.")
("For example, `\def\a#1{...}' and `\a}' would produce")
("this error. If you simply proceed now, the `\par' that")
("I've just inserted will cause me to report a runaway")
("argument that might be the root of the problem. But if")
("your `}' was spurious, just type `2' and it will go away.");
incr(align_state);long_state:= call;cur_tok:= par_token;ins_error;
goto continue;
end{a white lie;the\.{\\par}won't always trigger a runaway}

/*:421*/
#line 9369 "pdftexdir/pdftex.web"

else/*419:*/
#line 9377 "pdftexdir/pdftex.web"

begin if cur_tok= space_token then
if info(r)<=end_match_token then
if info(r)>=match_token then goto continue;
store_new_token(cur_tok);
end

/*:419*/
#line 9371 "pdftexdir/pdftex.web"
;
incr(m);
if info(r)> end_match_token then goto continue;
if info(r)<match_token then goto continue;
found:if s<> null then/*426:*/
#line 9491 "pdftexdir/pdftex.web"

begin if(m= 1)and(info(p)<right_brace_limit)and(p<> temp_head)then
begin link(rbrace_ptr):= null;free_avail(p);
p:= link(temp_head);pstack[n]:= link(p);free_avail(p);
end
else pstack[n]:= link(temp_head);
incr(n);
if tracing_macros> 0 then
begin begin_diagnostic;print_nl(match_chr);print_int(n);
print("<-");show_token_list(pstack[n-1],null,1000);
end_diagnostic(false);
end;
end

/*:426*/
#line 9375 "pdftexdir/pdftex.web"


/*:418*/
#line 9346 "pdftexdir/pdftex.web"
;
{now|info(r)|is a token whose command code is either|match|or|end_match|}
until info(r)= end_match_token;
end

/*:417*/
#line 9302 "pdftexdir/pdftex.web"
;
/*416:*/
#line 9311 "pdftexdir/pdftex.web"

while(state= token_list)and(loc= null)and(token_type<> v_template)do
end_token_list;{conserve stack space}
begin_token_list(ref_count,macro);name:= warning_index;loc:= link(r);
if n> 0 then
begin if param_ptr+n> max_param_stack then
begin max_param_stack:= param_ptr+n;
if max_param_stack> param_size then
overflow("parameter stack size",param_size);

end;
for m:= 0 to n-1 do param_stack[param_ptr+m]:= pstack[m];
param_ptr:= param_ptr+n;
end

/*:416*/
#line 9303 "pdftexdir/pdftex.web"
;
exit:scanner_status:= save_scanner_status;warning_index:= save_warning_index;
end;

/*:415*/
#line 8893 "pdftexdir/pdftex.web"

/*405:*/
#line 9136 "pdftexdir/pdftex.web"

procedure insert_relax;
begin cur_tok:= cs_token_flag+cur_cs;back_input;
cur_tok:= cs_token_flag+frozen_relax;back_input;token_type:= inserted;
end;

/*:405*/
#line 8894 "pdftexdir/pdftex.web"

/*1749:*/
#line 38126 "pdftexdir/pdftex.web"

procedure pseudo_start;forward;

/*:1749*//*1807:*/
#line 39037 "pdftexdir/pdftex.web"

procedure scan_register_num;forward;

/*:1807*//*1812:*/
#line 39111 "pdftexdir/pdftex.web"

procedure new_index(i:quarterword;q:pointer);
var k:small_number;{loop index}
begin cur_ptr:= get_node(index_node_size);sa_index(cur_ptr):= i;
sa_used(cur_ptr):= 0;link(cur_ptr):= q;
for k:= 1 to index_node_size-1 do{clear all 16 pointers}
mem[cur_ptr+k]:= sa_null;
end;

/*:1812*//*1816:*/
#line 39170 "pdftexdir/pdftex.web"

procedure find_sa_element(t:small_number;n:halfword;w:boolean);
{sets|cur_val|to sparse array element location or|null|}
label not_found,not_found1,not_found2,not_found3,not_found4,exit;
var q:pointer;{for list manipulations}
i:small_number;{a four bit index}
begin cur_ptr:= sa_root[t];
if_cur_ptr_is_null_then_return_or_goto(not_found);
q:= cur_ptr;i:= hex_dig1(n);get_sa_ptr;
if_cur_ptr_is_null_then_return_or_goto(not_found1);
q:= cur_ptr;i:= hex_dig2(n);get_sa_ptr;
if_cur_ptr_is_null_then_return_or_goto(not_found2);
q:= cur_ptr;i:= hex_dig3(n);get_sa_ptr;
if_cur_ptr_is_null_then_return_or_goto(not_found3);
q:= cur_ptr;i:= hex_dig4(n);get_sa_ptr;
if(cur_ptr= null)and w then goto not_found4;
return;
not_found:new_index(t,null);{create first level index node}
sa_root[t]:= cur_ptr;q:= cur_ptr;i:= hex_dig1(n);
not_found1:new_index(i,q);{create second level index node}
add_sa_ptr;q:= cur_ptr;i:= hex_dig2(n);
not_found2:new_index(i,q);{create third level index node}
add_sa_ptr;q:= cur_ptr;i:= hex_dig3(n);
not_found3:new_index(i,q);{create fourth level index node}
add_sa_ptr;q:= cur_ptr;i:= hex_dig4(n);
not_found4:/*1817:*/
#line 39235 "pdftexdir/pdftex.web"

if t= mark_val then{a mark class}
begin cur_ptr:= get_node(mark_class_node_size);
mem[cur_ptr+1]:= sa_null;mem[cur_ptr+2]:= sa_null;mem[cur_ptr+3]:= sa_null;
end
else begin if t<=dimen_val then{a count or dimen register}
begin cur_ptr:= get_node(word_node_size);sa_int(cur_ptr):= 0;
sa_num(cur_ptr):= n;
end
else begin cur_ptr:= get_node(pointer_node_size);
if t<=mu_val then{a skip or muskip register}
begin sa_ptr(cur_ptr):= zero_glue;add_glue_ref(zero_glue);
end
else sa_ptr(cur_ptr):= null;{a box or token list register}
end;
sa_ref(cur_ptr):= null;{all registers have a reference count}
end;
sa_index(cur_ptr):= 16*t+i;sa_lev(cur_ptr):= level_one

/*:1817*/
#line 39195 "pdftexdir/pdftex.web"
;
link(cur_ptr):= q;add_sa_ptr;
exit:end;

/*:1816*/
#line 8895 "pdftexdir/pdftex.web"

procedure pass_text;forward;
procedure start_input;forward;
procedure conditional;forward;
procedure get_x_token;forward;
procedure conv_toks;forward;
procedure ins_the_toks;forward;
procedure expand;
label reswitch;
var t:halfword;{token that is being``expanded after''}
b:boolean;{keep track of nested csnames}
p,q,r:pointer;{for list manipulation}
j:0..buf_size;{index into|buffer|}
cv_backup:integer;{to save the global quantity|cur_val|}
cvl_backup,radix_backup,co_backup:small_number;
{to save|cur_val_level|,etc.}
backup_backup:pointer;{to save|link(backup_head)|}
save_scanner_status:small_number;{temporary storage of|scanner_status|}
#line 2064 "pdftex-final.ch"
begin
incr(expand_depth_count);
if expand_depth_count>=expand_depth then overflow("expansion depth",expand_depth);
cv_backup:= cur_val;cvl_backup:= cur_val_level;radix_backup:= radix;
#line 8914 "pdftexdir/pdftex.web"
co_backup:= cur_order;backup_backup:= link(backup_head);
reswitch:
if cur_cmd<call then/*391:*/
#line 8929 "pdftexdir/pdftex.web"

begin if tracing_commands> 1 then show_cur_cmd_chr;
case cur_cmd of
top_bot_mark:/*412:*/
#line 9232 "pdftexdir/pdftex.web"

begin t:= cur_chr mod marks_code;
if cur_chr>=marks_code then scan_register_num else cur_val:= 0;
if cur_val= 0 then cur_ptr:= cur_mark[t]
else/*1821:*/
#line 39354 "pdftexdir/pdftex.web"

begin find_sa_element(mark_val,cur_val,false);
if cur_ptr<> null then
if odd(t)then cur_ptr:= link(cur_ptr+(t div 2)+1)
else cur_ptr:= info(cur_ptr+(t div 2)+1);
end

/*:1821*/
#line 9236 "pdftexdir/pdftex.web"
;
if cur_ptr<> null then begin_token_list(cur_ptr,mark_text);
end

/*:412*/
#line 8932 "pdftexdir/pdftex.web"
;
expand_after:if cur_chr= 0 then/*392:*/
#line 8949 "pdftexdir/pdftex.web"

begin get_token;t:= cur_tok;get_token;
if cur_cmd> max_command then expand else back_input;
cur_tok:= t;back_input;
end

/*:392*/
#line 8933 "pdftexdir/pdftex.web"

else/*1762:*/
#line 38290 "pdftexdir/pdftex.web"

begin get_token;
if(cur_cmd= if_test)and(cur_chr<> if_case_code)then
begin cur_chr:= cur_chr+unless_code;goto reswitch;
end;
print_err("You can't use `");print_esc("unless");print("' before `");

print_cmd_chr(cur_cmd,cur_chr);print_char("'");
help1("Continue, and I'll forget that it ever happened.");
back_error;
end

/*:1762*/
#line 8934 "pdftexdir/pdftex.web"
;
no_expand:if cur_chr= 0 then/*393:*/
#line 8963 "pdftexdir/pdftex.web"

begin save_scanner_status:= scanner_status;scanner_status:= normal;
get_token;scanner_status:= save_scanner_status;t:= cur_tok;
back_input;{now|start|and|loc|point to the backed-up token|t|}
if t>=cs_token_flag then
begin p:= get_avail;info(p):= cs_token_flag+frozen_dont_expand;
link(p):= loc;start:= p;loc:= p;
end;
end

/*:393*/
#line 8935 "pdftexdir/pdftex.web"

else/*394:*/
#line 8986 "pdftexdir/pdftex.web"

begin save_scanner_status:= scanner_status;scanner_status:= normal;
get_token;scanner_status:= save_scanner_status;
if cur_cs<hash_base then
cur_cs:= prim_lookup(cur_cs-single_base)
else
cur_cs:= prim_lookup(text(cur_cs));
if cur_cs<> undefined_primitive then begin
t:= prim_eq_type(cur_cs);
if t> max_command then begin
cur_cmd:= t;
cur_chr:= prim_equiv(cur_cs);
cur_tok:= (cur_cmd*52
cur_cs:= 0;
goto reswitch;
end
else begin
back_input;{now|loc|and|start|point to a one-item list}
p:= get_avail;info(p):= cs_token_flag+frozen_primitive;
link(p):= loc;loc:= p;start:= p;
end;
end;
end

/*:394*/
#line 8936 "pdftexdir/pdftex.web"
;
cs_name:/*398:*/
#line 9061 "pdftexdir/pdftex.web"

begin r:= get_avail;p:= r;{head of the list of characters}
b:= is_in_csname;is_in_csname:= true;
repeat get_x_token;
if cur_cs= 0 then store_new_token(cur_tok);
until cur_cs<> 0;
#line 2080 "pdftex-final.ch"
if(cur_cmd<> end_cs_name)or(cur_chr<> 0)then/*399:*/
#line 9077 "pdftexdir/pdftex.web"

begin print_err("Missing ");print_esc("endcsname");print(" inserted");

help2("The control sequence marked <to be read again> should")
("not appear between \csname and \endcsname.");
back_error;
end

/*:399*/
#line 2080 "pdftex-final.ch"
;
#line 9068 "pdftexdir/pdftex.web"
is_in_csname:= b;
/*400:*/
#line 9085 "pdftexdir/pdftex.web"

j:= first;p:= link(r);
while p<> null do
begin if j>=max_buf_stack then
begin max_buf_stack:= j+1;
if max_buf_stack= buf_size then
overflow("buffer size",buf_size);

end;
buffer[j]:= info(p)mod 52
end;
if j> first+1 then
begin no_new_control_sequence:= false;cur_cs:= id_lookup(first,j-first);
no_new_control_sequence:= true;
end
else if j= first then cur_cs:= null_cs{the list is empty}
else cur_cs:= single_base+buffer[first]{the list has length one}

/*:400*/
#line 9069 "pdftexdir/pdftex.web"
;
flush_list(r);
if eq_type(cur_cs)= undefined_cs then
begin eq_define(cur_cs,relax,256);{N.B.:The|save_stack|might change}
end;{the control sequence will now match`\.{\\relax}'}
cur_tok:= cur_cs+cs_token_flag;back_input;
end

/*:398*/
#line 8937 "pdftexdir/pdftex.web"
;
convert:conv_toks;{this procedure is discussed in Part 27 below}
the:ins_the_toks;{this procedure is discussed in Part 27 below}
if_test:conditional;{this procedure is discussed in Part 28 below}
fi_or_else:/*536:*/
#line 12025 "pdftexdir/pdftex.web"

begin if tracing_ifs> 0 then if tracing_commands<=1 then show_cur_cmd_chr;
if cur_chr> if_limit then
if if_limit= if_code then insert_relax{condition not yet evaluated}
else begin print_err("Extra ");print_cmd_chr(fi_or_else,cur_chr);



help1("I'm ignoring this; it doesn't match any \if.");
error;
end
else begin while cur_chr<> fi_code do pass_text;{skip to\.{\\fi}}
/*522:*/
#line 11794 "pdftexdir/pdftex.web"

begin if if_stack[in_open]= cond_ptr then if_warning;
{conditionals possibly not properly nested with files}
p:= cond_ptr;if_line:= if_line_field(p);
cur_if:= subtype(p);if_limit:= type(p);cond_ptr:= link(p);
free_node(p,if_node_size);
end

/*:522*/
#line 12037 "pdftexdir/pdftex.web"
;
end;
end

/*:536*/
#line 8941 "pdftexdir/pdftex.web"
;
input:/*404:*/
#line 9127 "pdftexdir/pdftex.web"

if cur_chr= 1 then force_eof:= true
/*1746:*/
#line 38109 "pdftexdir/pdftex.web"

else if cur_chr= 2 then pseudo_start

/*:1746*/
#line 9129 "pdftexdir/pdftex.web"

else if name_in_progress then insert_relax
else start_input

/*:404*/
#line 8942 "pdftexdir/pdftex.web"
;
othercases/*396:*/
#line 9039 "pdftexdir/pdftex.web"

begin print_err("Undefined control sequence");

help5("The control sequence at the end of the top line")
("of your error message was never \def'ed. If you have")
("misspelled it (e.g., `\hobx'), type `I' and the correct")
("spelling (e.g., `I\hbox'). Otherwise just continue,")
("and I'll forget about whatever was undefined.");
error;
end

/*:396*/
#line 8943 "pdftexdir/pdftex.web"

endcases;
end

/*:391*/
#line 8916 "pdftexdir/pdftex.web"

else if cur_cmd<end_template then macro_call
else/*401:*/
#line 9109 "pdftexdir/pdftex.web"

begin cur_tok:= cs_token_flag+frozen_endv;back_input;
end

/*:401*/
#line 8918 "pdftexdir/pdftex.web"
;
cur_val:= cv_backup;cur_val_level:= cvl_backup;radix:= radix_backup;
#line 2073 "pdftex-final.ch"
cur_order:= co_backup;link(backup_head):= backup_backup;
decr(expand_depth_count);
#line 8921 "pdftexdir/pdftex.web"
end;

/*:388*//*406:*/
#line 9146 "pdftexdir/pdftex.web"
procedure get_x_token;{sets|cur_cmd|,|cur_chr|,|cur_tok|,
and expands macros}
label restart,done;
begin restart:get_next;

if cur_cmd<=max_command then goto done;
if cur_cmd>=call then
if cur_cmd<end_template then macro_call
else begin cur_cs:= frozen_endv;cur_cmd:= endv;
goto done;{|cur_chr= null_list|}
end
else expand;
goto restart;
done:if cur_cs= 0 then cur_tok:= (cur_cmd*52
else cur_tok:= cs_token_flag+cur_cs;
end;

/*:406*//*407:*/
#line 9166 "pdftexdir/pdftex.web"
procedure x_token;{|get_x_token|without the initial|get_next|}
begin while cur_cmd> max_command do
begin expand;
get_next;
end;
if cur_cs= 0 then cur_tok:= (cur_cmd*52
else cur_tok:= cs_token_flag+cur_cs;
end;

/*:407*//*429:*/
#line 9523 "pdftexdir/pdftex.web"
procedure scan_left_brace;{reads a mandatory|left_brace|}
begin/*430:*/
#line 9537 "pdftexdir/pdftex.web"

repeat get_x_token;
until(cur_cmd<> spacer)and(cur_cmd<> relax)

/*:430*/
#line 9524 "pdftexdir/pdftex.web"
;
if cur_cmd<> left_brace then
begin print_err("Missing { inserted");

help4("A left brace was mandatory here, so I've put one in.")
("You might want to delete and/or insert some corrections")
("so that I will find a matching right brace soon.")
("(If you're confused by all this, try typing `I}' now.)");
back_error;cur_tok:= left_brace_token+"{";cur_cmd:= left_brace;
cur_chr:= "{";incr(align_state);
end;
end;

/*:429*//*431:*/
#line 9544 "pdftexdir/pdftex.web"
procedure scan_optional_equals;
begin/*432:*/
#line 9549 "pdftexdir/pdftex.web"

repeat get_x_token;
until cur_cmd<> spacer

/*:432*/
#line 9545 "pdftexdir/pdftex.web"
;
if cur_tok<> other_token+"="then back_input;
end;

/*:431*//*433:*/
#line 9568 "pdftexdir/pdftex.web"
function scan_keyword(s:str_number):boolean;{look for a given string}
label exit;
var p:pointer;{tail of the backup list}
q:pointer;{new node being added to the token list via|store_new_token|}
k:pool_pointer;{index into|str_pool|}
save_cur_cs:pointer;{to save|cur_cs|}
begin p:= backup_head;link(p):= null;k:= str_start[s];
save_cur_cs:= cur_cs;
while k<str_start[s+1]do
begin get_x_token;{recursion is possible here}

if(cur_cs= 0)and
((cur_chr= so(str_pool[k]))or(cur_chr= so(str_pool[k])-"a"+"A"))then
begin store_new_token(cur_tok);incr(k);
end
else if(cur_cmd<> spacer)or(p<> backup_head)then
begin back_input;
if p<> backup_head then back_list(link(backup_head));
cur_cs:= save_cur_cs;
scan_keyword:= false;return;
end;
end;
flush_list(link(backup_head));scan_keyword:= true;
exit:end;

/*:433*//*434:*/
#line 9596 "pdftexdir/pdftex.web"
procedure mu_error;
begin print_err("Incompatible glue units");

help1("I'm going to assume that 1mu=1pt when they're mixed.");
error;
end;

/*:434*//*435:*/
#line 9613 "pdftexdir/pdftex.web"
procedure scan_int;forward;{scans an integer value}
/*459:*/
#line 10123 "pdftexdir/pdftex.web"

procedure scan_eight_bit_int;
begin scan_int;
if(cur_val<0)or(cur_val> 255)then
begin print_err("Bad register code");

help2("A register number must be between 0 and 255.")
("I changed this one to zero.");int_error(cur_val);cur_val:= 0;
end;
end;

/*:459*//*460:*/
#line 10134 "pdftexdir/pdftex.web"

procedure scan_char_num;
begin scan_int;
if(cur_val<0)or(cur_val> 255)then
begin print_err("Bad character code");

help2("A character number must be between 0 and 255.")
("I changed this one to zero.");int_error(cur_val);cur_val:= 0;
end;
end;

/*:460*//*461:*/
#line 10148 "pdftexdir/pdftex.web"

procedure scan_four_bit_int;
begin scan_int;
if(cur_val<0)or(cur_val> 15)then
begin print_err("Bad number");

help2("Since I expected to read a number between 0 and 15,")
("I changed this one to zero.");int_error(cur_val);cur_val:= 0;
end;
end;

/*:461*//*462:*/
#line 10159 "pdftexdir/pdftex.web"

procedure scan_fifteen_bit_int;
begin scan_int;
if(cur_val<0)or(cur_val> 55
begin print_err("Bad mathchar");

help2("A mathchar number must be between 0 and 32767.")
("I changed this one to zero.");int_error(cur_val);cur_val:= 0;
end;
end;

/*:462*//*463:*/
#line 10170 "pdftexdir/pdftex.web"

procedure scan_twenty_seven_bit_int;
begin scan_int;
if(cur_val<0)or(cur_val> 55
begin print_err("Bad delimiter code");

help2("A numeric delimiter code must be between 0 and 2^{27}-1.")
("I changed this one to zero.");int_error(cur_val);cur_val:= 0;
end;
end;

/*:463*//*1808:*/
#line 39040 "pdftexdir/pdftex.web"

procedure scan_register_num;
begin scan_int;
if(cur_val<0)or(cur_val> max_reg_num)then
begin print_err("Bad register code");

help2(max_reg_help_line)("I changed this one to zero.");
int_error(cur_val);cur_val:= 0;
end;
end;

/*:1808*//*1870:*/
#line 6086 "pdftex-final.ch"

procedure scan_four_bit_int_or_18;
begin scan_int;
if(cur_val<0)or((cur_val> 15)and(cur_val<> 18))then
begin print_err("Bad number");

help2("Since I expected to read a number between 0 and 15,")
("I changed this one to zero.");int_error(cur_val);cur_val:= 0;
end;
end;

/*:1870*/
#line 9614 "pdftexdir/pdftex.web"

/*1679:*/
#line 37256 "pdftexdir/pdftex.web"

procedure scan_general_text;forward;

/*:1679*//*1769:*/
#line 38396 "pdftexdir/pdftex.web"

procedure get_x_or_protected;{sets|cur_cmd|,|cur_chr|,|cur_tok|,
and expands non-protected macros}
label exit;
begin loop begin get_token;
if cur_cmd<=max_command then return;
if(cur_cmd>=call)and(cur_cmd<end_template)then
if info(link(cur_chr))= protected_token then return;
expand;
end;
exit:end;

/*:1769*//*1778:*/
#line 38573 "pdftexdir/pdftex.web"

procedure scan_expr;forward;

/*:1778*//*1783:*/
#line 38665 "pdftexdir/pdftex.web"

procedure scan_normal_glue;forward;
procedure scan_mu_glue;forward;

/*:1783*//*1881:*/
#line 6287 "pdftex-final.ch"

function effective_char(err_p:boolean;
f:internal_font_number;c:quarterword):integer;
label found;
var base_c:integer;{or|eightbits|:replacement base character}
result:integer;{or|quarterword|}
begin result:= c;{return|c|unless it does not exist in the font}
if not mltex_enabled_p then goto found;
if font_ec[f]>=qo(c)then if font_bc[f]<=qo(c)then
if char_exists(orig_char_info(f)(c))then{N.B.:not|char_info|(f)(c)}
goto found;
if qo(c)>=char_sub_def_min then if qo(c)<=char_sub_def_max then
if char_list_exists(qo(c))then
begin base_c:= char_list_char(qo(c));
result:= qi(base_c);{return|base_c|}
if not err_p then goto found;
if font_ec[f]>=base_c then if font_bc[f]<=base_c then
if char_exists(orig_char_info(f)(qi(base_c)))then goto found;
end;
if err_p then{print error and return existing character?}
begin begin_diagnostic;
print_nl("Missing character: There is no ");print("substitution for ");

print_ASCII(qo(c));print(" in font ");
slow_print(font_name[f]);print_char("!");end_diagnostic(false);
result:= qi(font_bc[f]);{N.B.:not non-existing character|c|!}
end;
found:effective_char:= result;
end;


/*:1881*/
#line 9615 "pdftexdir/pdftex.web"

/*604:*/
#line 13390 "pdftexdir/pdftex.web"

function test_no_ligatures(f:internal_font_number):integer;
label exit;
var c:integer;
begin
test_no_ligatures:= 1;
for c:= font_bc[f]to font_ec[f]do
if char_exists(orig_char_info(f)(c))then
if odd(char_tag(orig_char_info(f)(c)))then begin
test_no_ligatures:= 0;
return;
end;
exit:
end;

function get_tag_code(f:internal_font_number;c:eight_bits):integer;
var i:small_number;
begin
if is_valid_char(c)then
#line 2963 "pdftex-final.ch"
 begin i:= char_tag(orig_char_info(f)(c));
#line 13410 "pdftexdir/pdftex.web"
if i= lig_tag then
get_tag_code:= 1
else if i= list_tag then
get_tag_code:= 2
else if i= ext_tag then
get_tag_code:= 4
else
get_tag_code:= 0;
end
else
get_tag_code:= -1;
end;
procedure scan_font_ident;
var f:internal_font_number;
m:halfword;
begin/*432:*/
#line 9549 "pdftexdir/pdftex.web"

repeat get_x_token;
until cur_cmd<> spacer

/*:432*/
#line 13425 "pdftexdir/pdftex.web"
;
if(cur_cmd= def_font)or(cur_cmd= letterspace_font)or(cur_cmd= pdf_copy_font)then f:= cur_font
else if cur_cmd= set_font then f:= cur_chr
else if cur_cmd= def_family then
begin m:= cur_chr;scan_four_bit_int;f:= equiv(m+cur_val);
end
else begin print_err("Missing font identifier");

help2("I was looking for a control sequence whose")
("current meaning has been defined by \font.");
back_error;f:= null_font;
end;
cur_val:= f;
end;

/*:604*//*605:*/
#line 13444 "pdftexdir/pdftex.web"

procedure find_font_dimen(writing:boolean);
{sets|cur_val|to|font_info|location}
var f:internal_font_number;
n:integer;{the parameter number}
begin scan_int;n:= cur_val;scan_font_ident;f:= cur_val;
if n<=0 then cur_val:= fmem_ptr
else begin if writing and(n<=space_shrink_code)and
(n>=space_code)and(font_glue[f]<> null)then
begin delete_glue_ref(font_glue[f]);
font_glue[f]:= null;
end;
if n> font_params[f]then
if f<font_ptr then cur_val:= fmem_ptr
else/*607:*/
#line 13475 "pdftexdir/pdftex.web"

begin repeat if fmem_ptr= font_mem_size then
overflow("font memory",font_mem_size);

font_info[fmem_ptr].sc:= 0;incr(fmem_ptr);incr(font_params[f]);
until n= font_params[f];
cur_val:= fmem_ptr-1;{this equals|param_base[f]+font_params[f]|}
end

/*:607*/
#line 13458 "pdftexdir/pdftex.web"

else cur_val:= n+param_base[f];
end;
/*606:*/
#line 13464 "pdftexdir/pdftex.web"

if cur_val= fmem_ptr then
begin print_err("Font ");print_esc(font_id_text(f));
print(" has only ");print_int(font_params[f]);
print(" fontdimen parameters");

help2("To increase the number of font parameters, you must")
("use \fontdimen immediately after the \font is loaded.");
error;
end

/*:606*/
#line 13461 "pdftexdir/pdftex.web"
;
end;

/*:605*/
#line 9616 "pdftexdir/pdftex.web"


/*:435*//*439:*/
#line 9685 "pdftexdir/pdftex.web"
procedure scan_something_internal(level:small_number;negative:boolean);
{fetch an internal parameter}
label exit,restart;
var m:halfword;{|chr_code|part of the operand token}
n,k:integer;{accumulators}
q,r:pointer;{general purpose indices}
tx:pointer;{effective tail node}
i:four_quarters;{character info}
p:0..nest_size;{index into|nest|}
begin restart:m:= cur_chr;
case cur_cmd of
def_code:/*440:*/
#line 9722 "pdftexdir/pdftex.web"

begin scan_char_num;
#line 2086 "pdftex-final.ch"
if m= xord_code_base then scanned_result(xord[cur_val])(int_val)
else if m= xchr_code_base then scanned_result(xchr[cur_val])(int_val)
else if m= xprn_code_base then scanned_result(xprn[cur_val])(int_val)
else if m= math_code_base then scanned_result(ho(math_code(cur_val)))(int_val)
#line 9725 "pdftexdir/pdftex.web"
else if m<math_code_base then scanned_result(equiv(m+cur_val))(int_val)
else scanned_result(eqtb[m+cur_val].int)(int_val);
end

/*:440*/
#line 9696 "pdftexdir/pdftex.web"
;
toks_register,assign_toks,def_family,set_font,def_font,letterspace_font,pdf_copy_font:/*441:*/
#line 9729 "pdftexdir/pdftex.web"

if level<> tok_val then
begin print_err("Missing number, treated as zero");

help3("A number should have been here; I inserted `0'.")
("(If you can't figure out why I needed to see a number,")
("look up `weird error' in the index to The TeXbook.)");

back_error;scanned_result(0)(dimen_val);
end
else if cur_cmd<=assign_toks then
begin if cur_cmd<assign_toks then{|cur_cmd= toks_register|}
if m= mem_bot then
begin scan_register_num;
if cur_val<256 then cur_val:= equiv(toks_base+cur_val)
else begin find_sa_element(tok_val,cur_val,false);
if cur_ptr= null then cur_val:= null
else cur_val:= sa_ptr(cur_ptr);
end;
end
else cur_val:= sa_ptr(m)
else cur_val:= equiv(m);
cur_val_level:= tok_val;
end
else begin back_input;scan_font_ident;
scanned_result(font_id_base+cur_val)(ident_val);
end

/*:441*/
#line 9698 "pdftexdir/pdftex.web"
;
assign_int:scanned_result(eqtb[m].int)(int_val);
assign_dimen:scanned_result(eqtb[m].sc)(dimen_val);
assign_glue:scanned_result(equiv(m))(glue_val);
assign_mu_glue:scanned_result(equiv(m))(mu_val);
set_aux:/*444:*/
#line 9882 "pdftexdir/pdftex.web"

if abs(mode)<> m then
begin print_err("Improper ");print_cmd_chr(set_aux,m);


help4("You can refer to \spacefactor only in horizontal mode;")
("you can refer to \prevdepth only in vertical mode; and")
("neither of these is meaningful inside \write. So")
("I'm forgetting what you said and using zero instead.");
error;
if level<> tok_val then scanned_result(0)(dimen_val)
else scanned_result(0)(int_val);
end
else if m= vmode then scanned_result(prev_depth)(dimen_val)
else scanned_result(space_factor)(int_val)

/*:444*/
#line 9703 "pdftexdir/pdftex.web"
;
set_prev_graf:/*448:*/
#line 9923 "pdftexdir/pdftex.web"

if mode= 0 then scanned_result(0)(int_val){|prev_graf= 0|within\.{\\write}}
else begin nest[nest_ptr]:= cur_list;p:= nest_ptr;
while abs(nest[p].mode_field)<> vmode do decr(p);
scanned_result(nest[p].pg_field)(int_val);
end

/*:448*/
#line 9704 "pdftexdir/pdftex.web"
;
set_page_int:/*445:*/
#line 9898 "pdftexdir/pdftex.web"

begin if m= 0 then cur_val:= dead_cycles
/*1691:*/
#line 37375 "pdftexdir/pdftex.web"

else if m= 2 then cur_val:= interaction

/*:1691*/
#line 9900 "pdftexdir/pdftex.web"

else cur_val:= insert_penalties;
cur_val_level:= int_val;
end

/*:445*/
#line 9705 "pdftexdir/pdftex.web"
;
set_page_dimen:/*447:*/
#line 9916 "pdftexdir/pdftex.web"

begin if(page_contents= empty)and(not output_active)then
if m= 0 then cur_val:= max_dimen else cur_val:= 0
else cur_val:= page_so_far[m];
cur_val_level:= dimen_val;
end

/*:447*/
#line 9706 "pdftexdir/pdftex.web"
;
set_shape:/*449:*/
#line 9930 "pdftexdir/pdftex.web"

begin if m> par_shape_loc then/*1863:*/
#line 39932 "pdftexdir/pdftex.web"

begin scan_int;
if(equiv(m)= null)or(cur_val<0)then cur_val:= 0
else begin if cur_val> penalty(equiv(m))then cur_val:= penalty(equiv(m));
cur_val:= penalty(equiv(m)+cur_val);
end;
end

#line 6003 "pdftex-final.ch"
/*:1863*/
#line 9931 "pdftexdir/pdftex.web"

else if par_shape_ptr= null then cur_val:= 0
else cur_val:= info(par_shape_ptr);
cur_val_level:= int_val;
end

/*:449*/
#line 9707 "pdftexdir/pdftex.web"
;
set_box_dimen:/*446:*/
#line 9905 "pdftexdir/pdftex.web"

begin scan_register_num;fetch_box(q);
if q= null then cur_val:= 0 else cur_val:= mem[q+m].sc;
cur_val_level:= dimen_val;
end

/*:446*/
#line 9708 "pdftexdir/pdftex.web"
;
char_given,math_given:scanned_result(cur_chr)(int_val);
assign_font_dimen:/*451:*/
#line 10023 "pdftexdir/pdftex.web"

begin find_font_dimen(false);font_info[fmem_ptr].sc:= 0;
scanned_result(font_info[cur_val].sc)(dimen_val);
end

/*:451*/
#line 9710 "pdftexdir/pdftex.web"
;
assign_font_int:/*452:*/
#line 10028 "pdftexdir/pdftex.web"

begin scan_font_ident;
if m= 0 then scanned_result(hyphen_char[cur_val])(int_val)
else if m= 1 then scanned_result(skew_char[cur_val])(int_val)
else if m= no_lig_code then scanned_result(test_no_ligatures(cur_val))(int_val)
else begin
n:= cur_val;
scan_char_num;
k:= cur_val;
case m of
lp_code_base:scanned_result(get_lp_code(n,k))(int_val);
rp_code_base:scanned_result(get_rp_code(n,k))(int_val);
ef_code_base:scanned_result(get_ef_code(n,k))(int_val);
tag_code:scanned_result(get_tag_code(n,k))(int_val);
kn_bs_code_base:scanned_result(get_kn_bs_code(n,k))(int_val);
st_bs_code_base:scanned_result(get_st_bs_code(n,k))(int_val);
sh_bs_code_base:scanned_result(get_sh_bs_code(n,k))(int_val);
kn_bc_code_base:scanned_result(get_kn_bc_code(n,k))(int_val);
kn_ac_code_base:scanned_result(get_kn_ac_code(n,k))(int_val);
end;
end;
end

/*:452*/
#line 9711 "pdftexdir/pdftex.web"
;
register:/*453:*/
#line 10051 "pdftexdir/pdftex.web"

begin if(m<mem_bot)or(m> lo_mem_stat_max)then
begin cur_val_level:= sa_type(m);
if cur_val_level<glue_val then cur_val:= sa_int(m)
else cur_val:= sa_ptr(m);
end
else begin scan_register_num;cur_val_level:= m-mem_bot;
if cur_val> 255 then
begin find_sa_element(cur_val_level,cur_val,false);
if cur_ptr= null then
if cur_val_level<glue_val then cur_val:= 0
else cur_val:= zero_glue
else if cur_val_level<glue_val then cur_val:= sa_int(cur_ptr)
else cur_val:= sa_ptr(cur_ptr);
end
else
case cur_val_level of
int_val:cur_val:= count(cur_val);
dimen_val:cur_val:= dimen(cur_val);
glue_val:cur_val:= skip(cur_val);
mu_val:cur_val:= mu_skip(cur_val);
end;{there are no other cases}
end;
end

/*:453*/
#line 9712 "pdftexdir/pdftex.web"
;
last_item:/*450:*/
#line 9959 "pdftexdir/pdftex.web"

if m>=input_line_no_code then
if m>=eTeX_glue then/*1777:*/
#line 38542 "pdftexdir/pdftex.web"

begin if m<eTeX_mu then
begin case m of
/*1804:*/
#line 38992 "pdftexdir/pdftex.web"

mu_to_glue_code:scan_mu_glue;

/*:1804*/
#line 38545 "pdftexdir/pdftex.web"

end;{there are no other cases}
cur_val_level:= glue_val;
end
else if m<eTeX_expr then
begin case m of
/*1805:*/
#line 38995 "pdftexdir/pdftex.web"

glue_to_mu_code:scan_normal_glue;

/*:1805*/
#line 38551 "pdftexdir/pdftex.web"

end;{there are no other cases}
cur_val_level:= mu_val;
end
else begin cur_val_level:= m-eTeX_expr+int_val;scan_expr;
end;
while cur_val_level> level do
begin if cur_val_level= glue_val then
begin m:= cur_val;cur_val:= width(m);delete_glue_ref(m);
end
else if cur_val_level= mu_val then mu_error;
decr(cur_val_level);
end;
if negative then
if cur_val_level>=glue_val then
begin m:= cur_val;cur_val:= new_spec(m);delete_glue_ref(m);
/*457:*/
#line 10112 "pdftexdir/pdftex.web"

begin negate(width(cur_val));
negate(stretch(cur_val));
negate(shrink(cur_val));
end

/*:457*/
#line 38567 "pdftexdir/pdftex.web"
;
end
else negate(cur_val);
return;
end

/*:1777*/
#line 9961 "pdftexdir/pdftex.web"

else if m>=eTeX_dim then
begin case m of
/*1668:*/
#line 37067 "pdftexdir/pdftex.web"

font_char_wd_code,
font_char_ht_code,
font_char_dp_code,
font_char_ic_code:begin scan_font_ident;q:= cur_val;scan_char_num;
if(font_bc[q]<=cur_val)and(font_ec[q]>=cur_val)then
begin i:= char_info(q)(qi(cur_val));
case m of
font_char_wd_code:cur_val:= char_width(q)(i);
font_char_ht_code:cur_val:= char_height(q)(height_depth(i));
font_char_dp_code:cur_val:= char_depth(q)(height_depth(i));
font_char_ic_code:cur_val:= char_italic(q)(i);
end;{there are no other cases}
end
else cur_val:= 0;
end;

/*:1668*//*1671:*/
#line 37105 "pdftexdir/pdftex.web"

par_shape_length_code,
par_shape_indent_code,
par_shape_dimen_code:begin q:= cur_chr-par_shape_length_code;scan_int;
if(par_shape_ptr= null)or(cur_val<=0)then cur_val:= 0
else begin if q= 2 then
begin q:= cur_val mod 2;cur_val:= (cur_val+q)div 2;
end;
if cur_val> info(par_shape_ptr)then cur_val:= info(par_shape_ptr);
cur_val:= mem[par_shape_ptr+2*cur_val-q].sc;
end;
cur_val_level:= dimen_val;
end;

/*:1671*//*1801:*/
#line 38967 "pdftexdir/pdftex.web"

glue_stretch_code,glue_shrink_code:
begin scan_normal_glue;q:= cur_val;
if m= glue_stretch_code then cur_val:= stretch(q)
else cur_val:= shrink(q);
delete_glue_ref(q);
end;

/*:1801*/
#line 9964 "pdftexdir/pdftex.web"

end;{there are no other cases}
cur_val_level:= dimen_val;
end
else begin case m of
input_line_no_code:cur_val:= line;
badness_code:cur_val:= last_badness;
pdftex_version_code:cur_val:= pdftex_version;
pdf_last_obj_code:cur_val:= pdf_last_obj;
pdf_last_xform_code:cur_val:= pdf_last_xform;
pdf_last_ximage_code:cur_val:= pdf_last_ximage;
pdf_last_ximage_pages_code:cur_val:= pdf_last_ximage_pages;
pdf_last_annot_code:cur_val:= pdf_last_annot;
pdf_last_x_pos_code:cur_val:= pdf_last_x_pos;
pdf_last_y_pos_code:cur_val:= pdf_last_y_pos;
pdf_retval_code:cur_val:= pdf_retval;
pdf_last_ximage_colordepth_code:cur_val:= pdf_last_ximage_colordepth;
elapsed_time_code:cur_val:= get_microinterval;
random_seed_code:cur_val:= random_seed;
pdf_shell_escape_code:
begin
if shellenabledp then begin
if restrictedshell then cur_val:= 2
else cur_val:= 1;
end
else cur_val:= 0;
end;
pdf_last_link_code:cur_val:= pdf_last_link;
/*1648:*/
#line 36847 "pdftexdir/pdftex.web"

eTeX_version_code:cur_val:= eTeX_version;

/*:1648*//*1662:*/
#line 37003 "pdftexdir/pdftex.web"

current_group_level_code:cur_val:= cur_level-level_one;
current_group_type_code:cur_val:= cur_group;

/*:1662*//*1665:*/
#line 37028 "pdftexdir/pdftex.web"

current_if_level_code:begin q:= cond_ptr;cur_val:= 0;
while q<> null do
begin incr(cur_val);q:= link(q);
end;
end;
current_if_type_code:if cond_ptr= null then cur_val:= 0
else if cur_if<unless_code then cur_val:= cur_if+1
else cur_val:= -(cur_if-unless_code+1);
current_if_branch_code:
if(if_limit= or_code)or(if_limit= else_code)then cur_val:= 1
else if if_limit= fi_code then cur_val:= -1
else cur_val:= 0;

/*:1665*//*1800:*/
#line 38959 "pdftexdir/pdftex.web"

glue_stretch_order_code,glue_shrink_order_code:
begin scan_normal_glue;q:= cur_val;
if m= glue_stretch_order_code then cur_val:= stretch_order(q)
else cur_val:= shrink_order(q);
delete_glue_ref(q);
end;

/*:1800*/
#line 9992 "pdftexdir/pdftex.web"

end;{there are no other cases}
cur_val_level:= int_val;
end
else begin if cur_chr= glue_val then cur_val:= zero_glue else cur_val:= 0;
find_effective_tail;
if cur_chr= last_node_type_code then
begin cur_val_level:= int_val;
if(tx= head)or(mode= 0)then cur_val:= -1;
end
else cur_val_level:= cur_chr;
if not is_char_node(tx)and(mode<> 0)then
case cur_chr of
int_val:if type(tx)= penalty_node then cur_val:= penalty(tx);
dimen_val:if type(tx)= kern_node then cur_val:= width(tx);
glue_val:if type(tx)= glue_node then
begin cur_val:= glue_ptr(tx);
if subtype(tx)= mu_glue then cur_val_level:= mu_val;
end;
last_node_type_code:if type(tx)<=unset_node then cur_val:= type(tx)+1
else cur_val:= unset_node+2;
end{there are no other cases}
else if(mode= vmode)and(tx= head)then
case cur_chr of
int_val:cur_val:= last_penalty;
dimen_val:cur_val:= last_kern;
glue_val:if last_glue<> max_halfword then cur_val:= last_glue;
last_node_type_code:cur_val:= last_node_type;
end;{there are no other cases}
end

/*:450*/
#line 9713 "pdftexdir/pdftex.web"
;
ignore_spaces:{trap unexpandable primitives}
if cur_chr= 1 then/*395:*/
#line 9017 "pdftexdir/pdftex.web"

begin
get_token;
if cur_cs<hash_base then
cur_cs:= prim_lookup(cur_cs-single_base)
else
cur_cs:= prim_lookup(text(cur_cs));
if cur_cs<> undefined_primitive then begin
cur_cmd:= prim_eq_type(cur_cs);
cur_chr:= prim_equiv(cur_cs);
cur_cs:= prim_eqtb_base+cur_cs;
cur_tok:= cs_token_flag+cur_cs;
end
else begin
cur_cmd:= relax;
cur_chr:= 0;
cur_tok:= cs_token_flag+frozen_relax;
cur_cs:= frozen_relax;
end;
goto restart;
end

/*:395*/
#line 9715 "pdftexdir/pdftex.web"
;
othercases/*454:*/
#line 10076 "pdftexdir/pdftex.web"

begin print_err("You can't use `");print_cmd_chr(cur_cmd,cur_chr);

print("' after ");print_esc("the");
help1("I'm forgetting what you said and using zero instead.");
error;
if level<> tok_val then scanned_result(0)(dimen_val)
else scanned_result(0)(int_val);
end

/*:454*/
#line 9716 "pdftexdir/pdftex.web"

endcases;
while cur_val_level> level do/*455:*/
#line 10092 "pdftexdir/pdftex.web"

begin if cur_val_level= glue_val then cur_val:= width(cur_val)
else if cur_val_level= mu_val then mu_error;
decr(cur_val_level);
end

/*:455*/
#line 9718 "pdftexdir/pdftex.web"
;
/*456:*/
#line 10102 "pdftexdir/pdftex.web"

if negative then
if cur_val_level>=glue_val then
begin cur_val:= new_spec(cur_val);
/*457:*/
#line 10112 "pdftexdir/pdftex.web"

begin negate(width(cur_val));
negate(stretch(cur_val));
negate(shrink(cur_val));
end

/*:457*/
#line 10106 "pdftexdir/pdftex.web"
;
end
else negate(cur_val)
else if(cur_val_level>=glue_val)and(cur_val_level<=mu_val)then
add_glue_ref(cur_val)

/*:456*/
#line 9719 "pdftexdir/pdftex.web"
;
exit:end;

/*:439*//*466:*/
#line 10213 "pdftexdir/pdftex.web"
procedure scan_int;{sets|cur_val|to an integer}
label done,restart;
var negative:boolean;{should the answer be negated?}
m:integer;{|div radix|,the threshold of danger}
d:small_number;{the digit just scanned}
vacuous:boolean;{have no digits appeared?}
OK_so_far:boolean;{has an error message been issued?}
begin radix:= 0;OK_so_far:= true;
/*467:*/
#line 10232 "pdftexdir/pdftex.web"

negative:= false;
repeat/*432:*/
#line 9549 "pdftexdir/pdftex.web"

repeat get_x_token;
until cur_cmd<> spacer

/*:432*/
#line 10234 "pdftexdir/pdftex.web"
;
if cur_tok= other_token+"-"then
begin negative:= not negative;cur_tok:= other_token+"+";
end;
until cur_tok<> other_token+"+"

/*:467*/
#line 10221 "pdftexdir/pdftex.web"
;
restart:
if cur_tok= alpha_token then/*468:*/
#line 10243 "pdftexdir/pdftex.web"

begin get_token;{suppress macro expansion}
if cur_tok<cs_token_flag then
begin cur_val:= cur_chr;
if cur_cmd<=right_brace then
if cur_cmd= right_brace then incr(align_state)
else decr(align_state);
end
else if cur_tok<cs_token_flag+single_base then
cur_val:= cur_tok-cs_token_flag-active_base
else cur_val:= cur_tok-cs_token_flag-single_base;
if cur_val> 255 then
begin print_err("Improper alphabetic constant");

help2("A one-character control sequence belongs after a ` mark.")
("So I'm essentially inserting \0 here.");
cur_val:= "0";back_error;
end
else/*469:*/
#line 10264 "pdftexdir/pdftex.web"

begin get_x_token;if cur_cmd<> spacer then back_input;
end

/*:469*/
#line 10261 "pdftexdir/pdftex.web"
;
end

/*:468*/
#line 10223 "pdftexdir/pdftex.web"

else if cur_tok= cs_token_flag+frozen_primitive then
/*395:*/
#line 9017 "pdftexdir/pdftex.web"

begin
get_token;
if cur_cs<hash_base then
cur_cs:= prim_lookup(cur_cs-single_base)
else
cur_cs:= prim_lookup(text(cur_cs));
if cur_cs<> undefined_primitive then begin
cur_cmd:= prim_eq_type(cur_cs);
cur_chr:= prim_equiv(cur_cs);
cur_cs:= prim_eqtb_base+cur_cs;
cur_tok:= cs_token_flag+cur_cs;
end
else begin
cur_cmd:= relax;
cur_chr:= 0;
cur_tok:= cs_token_flag+frozen_relax;
cur_cs:= frozen_relax;
end;
goto restart;
end

/*:395*/
#line 10225 "pdftexdir/pdftex.web"

else if(cur_cmd>=min_internal)and(cur_cmd<=max_internal)then
scan_something_internal(int_val,false)
else/*470:*/
#line 10268 "pdftexdir/pdftex.web"

begin radix:= 10;m:= 214748364;
if cur_tok= octal_token then
begin radix:= 8;m:= 50
end
else if cur_tok= hex_token then
begin radix:= 16;m:= 49
end;
vacuous:= true;cur_val:= 0;
/*471:*/
#line 10287 "pdftexdir/pdftex.web"

loop begin if(cur_tok<zero_token+radix)and(cur_tok>=zero_token)and
(cur_tok<=zero_token+9)then d:= cur_tok-zero_token
else if radix= 16 then
if(cur_tok<=A_token+5)and(cur_tok>=A_token)then d:= cur_tok-A_token+10
else if(cur_tok<=other_A_token+5)and(cur_tok>=other_A_token)then
d:= cur_tok-other_A_token+10
else goto done
else goto done;
vacuous:= false;
if(cur_val>=m)and((cur_val> m)or(d> 7)or(radix<> 10))then
begin if OK_so_far then
begin print_err("Number too big");

help2("I can only go up to 2147483647='17777777777=""7FFFFFFF,")
("so I'm using that number instead of yours.");
error;cur_val:= infinity;OK_so_far:= false;
end;
end
else cur_val:= cur_val*radix+d;
get_x_token;
end;
done:

/*:471*/
#line 10277 "pdftexdir/pdftex.web"
;
if vacuous then/*472:*/
#line 10311 "pdftexdir/pdftex.web"

begin print_err("Missing number, treated as zero");

help3("A number should have been here; I inserted `0'.")
("(If you can't figure out why I needed to see a number,")
("look up `weird error' in the index to The TeXbook.)");

back_error;
end

/*:472*/
#line 10278 "pdftexdir/pdftex.web"

else if cur_cmd<> spacer then back_input;
end

/*:470*/
#line 10228 "pdftexdir/pdftex.web"
;
if negative then negate(cur_val);
end;

/*:466*//*474:*/
#line 10352 "pdftexdir/pdftex.web"
procedure scan_dimen(mu,inf,shortcut:boolean);
{sets|cur_val|to a dimension}
label done,done1,done2,found,not_found,attach_fraction,attach_sign;
var negative:boolean;{should the answer be negated?}
f:integer;{numerator of a fraction whose denominator is $2^{16}$}
/*476:*/
#line 10395 "pdftexdir/pdftex.web"

num,denom:1. .65536;{conversion ratio for the scanned units}
k,kk:small_number;{number of digits in a decimal fraction}
p,q:pointer;{top of decimal digit stack}
v:scaled;{an internal dimension}
save_cur_val:integer;{temporary storage of|cur_val|}

/*:476*/
#line 10357 "pdftexdir/pdftex.web"

begin f:= 0;arith_error:= false;cur_order:= normal;negative:= false;
if not shortcut then
begin/*467:*/
#line 10232 "pdftexdir/pdftex.web"

negative:= false;
repeat/*432:*/
#line 9549 "pdftexdir/pdftex.web"

repeat get_x_token;
until cur_cmd<> spacer

/*:432*/
#line 10234 "pdftexdir/pdftex.web"
;
if cur_tok= other_token+"-"then
begin negative:= not negative;cur_tok:= other_token+"+";
end;
until cur_tok<> other_token+"+"

/*:467*/
#line 10360 "pdftexdir/pdftex.web"
;
if(cur_cmd>=min_internal)and(cur_cmd<=max_internal)then
/*475:*/
#line 10384 "pdftexdir/pdftex.web"

if mu then
begin scan_something_internal(mu_val,false);
/*477:*/
#line 10406 "pdftexdir/pdftex.web"

if cur_val_level>=glue_val then
begin v:= width(cur_val);delete_glue_ref(cur_val);cur_val:= v;
end

/*:477*/
#line 10387 "pdftexdir/pdftex.web"
;
if cur_val_level= mu_val then goto attach_sign;
if cur_val_level<> int_val then mu_error;
end
else begin scan_something_internal(dimen_val,false);
if cur_val_level= dimen_val then goto attach_sign;
end

/*:475*/
#line 10363 "pdftexdir/pdftex.web"

else begin back_input;
if cur_tok= continental_point_token then cur_tok:= point_token;
if cur_tok<> point_token then scan_int
else begin radix:= 10;cur_val:= 0;
end;
if cur_tok= continental_point_token then cur_tok:= point_token;
if(radix= 10)and(cur_tok= point_token)then/*478:*/
#line 10417 "pdftexdir/pdftex.web"

begin k:= 0;p:= null;get_token;{|point_token|is being re-scanned}
loop begin get_x_token;
if(cur_tok> zero_token+9)or(cur_tok<zero_token)then goto done1;
if k<17 then{digits for|k>=17|cannot affect the result}
begin q:= get_avail;link(q):= p;info(q):= cur_tok-zero_token;
p:= q;incr(k);
end;
end;
done1:for kk:= k downto 1 do
begin dig[kk-1]:= info(p);q:= p;p:= link(p);free_avail(q);
end;
f:= round_decimals(k);
if cur_cmd<> spacer then back_input;
end

/*:478*/
#line 10370 "pdftexdir/pdftex.web"
;
end;
end;
if cur_val<0 then{in this case|f= 0|}
begin negative:= not negative;negate(cur_val);
end;
/*479:*/
#line 10440 "pdftexdir/pdftex.web"

if inf then/*480:*/
#line 10458 "pdftexdir/pdftex.web"

if scan_keyword("fil")then

begin cur_order:= fil;
while scan_keyword("l")do
begin if cur_order= filll then
begin print_err("Illegal unit of measure (");

print("replaced by filll)");
help1("I dddon't go any higher than filll.");error;
end
else incr(cur_order);
end;
goto attach_fraction;
end

/*:480*/
#line 10441 "pdftexdir/pdftex.web"
;
/*481:*/
#line 10474 "pdftexdir/pdftex.web"

save_cur_val:= cur_val;
/*432:*/
#line 9549 "pdftexdir/pdftex.web"

repeat get_x_token;
until cur_cmd<> spacer

/*:432*/
#line 10476 "pdftexdir/pdftex.web"
;
if(cur_cmd<min_internal)or(cur_cmd> max_internal)then back_input
else begin if mu then
begin scan_something_internal(mu_val,false);/*477:*/
#line 10406 "pdftexdir/pdftex.web"

if cur_val_level>=glue_val then
begin v:= width(cur_val);delete_glue_ref(cur_val);cur_val:= v;
end

/*:477*/
#line 10479 "pdftexdir/pdftex.web"
;
if cur_val_level<> mu_val then mu_error;
end
else scan_something_internal(dimen_val,false);
v:= cur_val;goto found;
end;
if mu then goto not_found;
if scan_keyword("em")then v:= (/*584:*/
#line 13019 "pdftexdir/pdftex.web"
quad(cur_font)

/*:584*/
#line 10486 "pdftexdir/pdftex.web"
)

else if scan_keyword("ex")then v:= (/*585:*/
#line 13021 "pdftexdir/pdftex.web"
x_height(cur_font)

/*:585*/
#line 10488 "pdftexdir/pdftex.web"
)

else if scan_keyword("px")then v:= pdf_px_dimen

else goto not_found;
/*469:*/
#line 10264 "pdftexdir/pdftex.web"

begin get_x_token;if cur_cmd<> spacer then back_input;
end

/*:469*/
#line 10493 "pdftexdir/pdftex.web"
;
found:cur_val:= nx_plus_y(save_cur_val,v,xn_over_d(v,f,50
goto attach_sign;
not_found:

/*:481*/
#line 10443 "pdftexdir/pdftex.web"
;
if mu then/*482:*/
#line 10498 "pdftexdir/pdftex.web"

if scan_keyword("mu")then goto attach_fraction

else begin print_err("Illegal unit of measure (");print("mu inserted)");

help4("The unit of measurement in math glue must be mu.")
("To recover gracefully from this error, it's best to")
("delete the erroneous units; e.g., type `2' to delete")
("two letters. (See Chapter 27 of The TeXbook.)");

error;goto attach_fraction;
end

/*:482*/
#line 10444 "pdftexdir/pdftex.web"
;
if scan_keyword("true")then/*483:*/
#line 10511 "pdftexdir/pdftex.web"

begin prepare_mag;
if mag<> 1000 then
begin cur_val:= xn_over_d(cur_val,1000,mag);
f:= (1000*f+50
cur_val:= cur_val+(f div 50 200000;
end;
end

/*:483*/
#line 10445 "pdftexdir/pdftex.web"
;

if scan_keyword("pt")then goto attach_fraction;{the easy case}

/*484:*/
#line 10540 "pdftexdir/pdftex.web"

if scan_keyword("in")then set_conversion(7227)(100)

else if scan_keyword("pc")then set_conversion(12)(1)

else if scan_keyword("cm")then set_conversion(7227)(254)

else if scan_keyword("mm")then set_conversion(7227)(2540)

else if scan_keyword("bp")then set_conversion(7227)(7200)

else if scan_keyword("dd")then set_conversion(1238)(1157)

else if scan_keyword("cc")then set_conversion(14856)(1157)

else if scan_keyword("nd")then set_conversion(685)(642)

else if scan_keyword("nc")then set_conversion(1370)(107)

else if scan_keyword("sp")then goto done

else/*485:*/
#line 10567 "pdftexdir/pdftex.web"

begin print_err("Illegal unit of measure (");print("pt inserted)");

help6("Dimensions can be in units of em, ex, in, pt, pc,")
("cm, mm, dd, cc, nd, nc, bp, or sp; but yours is a new one!")
("I'll assume that you meant to say pt, for printer's points.")
("To recover gracefully from this error, it's best to")
("delete the erroneous units; e.g., type `2' to delete")
("two letters. (See Chapter 27 of The TeXbook.)");

error;goto done2;
end


/*:485*/
#line 10561 "pdftexdir/pdftex.web"
;
cur_val:= xn_over_d(cur_val,num,denom);
f:= (num*f+50
cur_val:= cur_val+(f div 50 200000;
done2:

/*:484*/
#line 10450 "pdftexdir/pdftex.web"
;
attach_fraction:if cur_val>=52
else cur_val:= cur_val*unity+f;
done:

/*:479*/
#line 10377 "pdftexdir/pdftex.web"
;
/*469:*/
#line 10264 "pdftexdir/pdftex.web"

begin get_x_token;if cur_cmd<> spacer then back_input;
end

/*:469*/
#line 10378 "pdftexdir/pdftex.web"
;
attach_sign:if arith_error or(abs(cur_val)>=49
/*486:*/
#line 10581 "pdftexdir/pdftex.web"

begin print_err("Dimension too large");

help2("I can't work with sizes bigger than about 19 feet.")
("Continue and I'll use the largest value I can.");
error;cur_val:= max_dimen;arith_error:= false;
end

/*:486*/
#line 10380 "pdftexdir/pdftex.web"
;
if negative then negate(cur_val);
end;

/*:474*//*487:*/
#line 10599 "pdftexdir/pdftex.web"
procedure scan_glue(level:small_number);
{sets|cur_val|to a glue spec pointer}
label exit;
var negative:boolean;{should the answer be negated?}
q:pointer;{new glue specification}
mu:boolean;{does|level= mu_val|?}
begin mu:= (level= mu_val);/*467:*/
#line 10232 "pdftexdir/pdftex.web"

negative:= false;
repeat/*432:*/
#line 9549 "pdftexdir/pdftex.web"

repeat get_x_token;
until cur_cmd<> spacer

/*:432*/
#line 10234 "pdftexdir/pdftex.web"
;
if cur_tok= other_token+"-"then
begin negative:= not negative;cur_tok:= other_token+"+";
end;
until cur_tok<> other_token+"+"

/*:467*/
#line 10605 "pdftexdir/pdftex.web"
;
if(cur_cmd>=min_internal)and(cur_cmd<=max_internal)then
begin scan_something_internal(level,negative);
if cur_val_level>=glue_val then
begin if cur_val_level<> level then mu_error;
return;
end;
if cur_val_level= int_val then scan_dimen(mu,false,true)
else if level= mu_val then mu_error;
end
else begin back_input;scan_dimen(mu,false,false);
if negative then negate(cur_val);
end;
/*488:*/
#line 10624 "pdftexdir/pdftex.web"

q:= new_spec(zero_glue);width(q):= cur_val;
if scan_keyword("plus")then

begin scan_dimen(mu,true,false);
stretch(q):= cur_val;stretch_order(q):= cur_order;
end;
if scan_keyword("minus")then

begin scan_dimen(mu,true,false);
shrink(q):= cur_val;shrink_order(q):= cur_order;
end;
cur_val:= q

/*:488*/
#line 10619 "pdftexdir/pdftex.web"
;
exit:end;

/*1779:*/
#line 38578 "pdftexdir/pdftex.web"

/*1790:*/
#line 38770 "pdftexdir/pdftex.web"

function add_or_sub(x,y,max_answer:integer;negative:boolean):integer;
var a:integer;{the answer}
begin if negative then negate(y);
if x>=0 then
if y<=max_answer-x then a:= x+y else num_error(a)
else if y>=-max_answer-x then a:= x+y else num_error(a);
add_or_sub:= a;
end;

/*:1790*//*1794:*/
#line 38825 "pdftexdir/pdftex.web"

function quotient(n,d:integer):integer;
var negative:boolean;{should the answer be negated?}
a:integer;{the answer}
begin if d= 0 then num_error(a)
else begin if d> 0 then negative:= false
else begin negate(d);negative:= true;
end;
if n<0 then
begin negate(n);negative:= not negative;
end;
a:= n div d;n:= n-a*d;d:= n-d;{avoid certain compiler optimizations!}
if d+n>=0 then incr(a);
if negative then negate(a);
end;
quotient:= a;
end;

/*:1794*//*1796:*/
#line 38864 "pdftexdir/pdftex.web"

function fract(x,n,d,max_answer:integer):integer;
label found,found1,too_big,done;
var negative:boolean;{should the answer be negated?}
a:integer;{the answer}
f:integer;{a proper fraction}
h:integer;{smallest integer such that|2*h>=d|}
r:integer;{intermediate remainder}
t:integer;{temp variable}
begin if d= 0 then goto too_big;
a:= 0;
if d> 0 then negative:= false
else begin negate(d);negative:= true;
end;
if x<0 then
begin negate(x);negative:= not negative;
end
else if x= 0 then goto done;
if n<0 then
begin negate(n);negative:= not negative;
end;
t:= n div d;
if t> max_answer div x then goto too_big;
a:= t*x;n:= n-t*d;
if n= 0 then goto found;
t:= x div d;
if t> (max_answer-a)div n then goto too_big;
a:= a+t*n;x:= x-t*d;
if x= 0 then goto found;
if x<n then
begin t:= x;x:= n;n:= t;
end;{now|0<n<=x<d|}
/*1797:*/
#line 38914 "pdftexdir/pdftex.web"

f:= 0;r:= (d div 2)-d;h:= -r;
loop begin if odd(n)then
begin r:= r+x;
if r>=0 then
begin r:= r-d;incr(f);
end;
end;
n:= n div 2;
if n= 0 then goto found1;
if x<h then x:= x+x
else begin t:= x-d;x:= t+x;f:= f+n;
if x<n then
begin if x= 0 then goto found1;
t:= x;x:= n;n:= t;
end;
end;
end;
found1:

/*:1797*/
#line 38896 "pdftexdir/pdftex.web"

if f> (max_answer-a)then goto too_big;
a:= a+f;
found:if negative then negate(a);
goto done;
too_big:num_error(a);
done:fract:= a;
end;

/*:1796*/
#line 38579 "pdftexdir/pdftex.web"

procedure scan_expr;{scans and evaluates an expression}
label restart,continue,found;
var a,b:boolean;{saved values of|arith_error|}
l:small_number;{type of expression}
r:small_number;{state of expression so far}
s:small_number;{state of term so far}
o:small_number;{next operation or type of next factor}
e:integer;{expression so far}
t:integer;{term so far}
f:integer;{current factor}
n:integer;{numerator of combined multiplication and division}
p:pointer;{top of expression stack}
q:pointer;{for stack manipulations}
begin l:= cur_val_level;a:= arith_error;b:= false;p:= null;
/*1780:*/
#line 38622 "pdftexdir/pdftex.web"

restart:r:= expr_none;e:= 0;s:= expr_none;t:= 0;n:= 0;
continue:if s= expr_none then o:= l else o:= int_val;
/*1782:*/
#line 38654 "pdftexdir/pdftex.web"

/*432:*/
#line 9549 "pdftexdir/pdftex.web"

repeat get_x_token;
until cur_cmd<> spacer

/*:432*/
#line 38655 "pdftexdir/pdftex.web"
;
if cur_tok= other_token+"("then
/*1785:*/
#line 38694 "pdftexdir/pdftex.web"

begin q:= get_node(expr_node_size);link(q):= p;type(q):= l;
subtype(q):= 4*s+r;
expr_e_field(q):= e;expr_t_field(q):= t;expr_n_field(q):= n;
p:= q;l:= o;goto restart;
end

/*:1785*/
#line 38657 "pdftexdir/pdftex.web"
;
back_input;
if o= int_val then scan_int
else if o= dimen_val then scan_normal_dimen
else if o= glue_val then scan_normal_glue
else scan_mu_glue;
f:= cur_val

/*:1782*/
#line 38625 "pdftexdir/pdftex.web"
;
found:/*1781:*/
#line 38636 "pdftexdir/pdftex.web"

/*432:*/
#line 9549 "pdftexdir/pdftex.web"

repeat get_x_token;
until cur_cmd<> spacer

/*:432*/
#line 38637 "pdftexdir/pdftex.web"
;
if cur_tok= other_token+"+"then o:= expr_add
else if cur_tok= other_token+"-"then o:= expr_sub
else if cur_tok= other_token+"*"then o:= expr_mult
else if cur_tok= other_token+"/"then o:= expr_div
else begin o:= expr_none;
if p= null then
begin if cur_cmd<> relax then back_input;
end
else if cur_tok<> other_token+")"then
begin print_err("Missing ) inserted for expression");

help1("I was expecting to see `+', `-', `*', `/', or `)'. Didn't.");
back_error;
end;
end

/*:1781*/
#line 38626 "pdftexdir/pdftex.web"
;
arith_error:= b;
/*1787:*/
#line 38722 "pdftexdir/pdftex.web"

if(l= int_val)or(s> expr_sub)then
begin if(f> infinity)or(f<-infinity)then num_error(f);
end
else if l= dimen_val then
begin if abs(f)> max_dimen then num_error(f);
end
else begin if(abs(width(f))> max_dimen)or
(abs(stretch(f))> max_dimen)or
(abs(shrink(f))> max_dimen)then glue_error(f);
end

/*:1787*/
#line 38628 "pdftexdir/pdftex.web"
;
case s of/*1788:*/
#line 38744 "pdftexdir/pdftex.web"

expr_none:if(l>=glue_val)and(o<> expr_none)then
begin t:= new_spec(f);delete_glue_ref(f);normalize_glue(t);
end
else t:= f;

/*:1788*//*1792:*/
#line 38804 "pdftexdir/pdftex.web"

expr_mult:if o= expr_div then
begin n:= f;o:= expr_scale;
end
else if l= int_val then t:= mult_integers(t,f)
else if l= dimen_val then expr_m(t)
else begin expr_m(width(t));expr_m(stretch(t));expr_m(shrink(t));
end;

/*:1792*//*1793:*/
#line 38817 "pdftexdir/pdftex.web"

expr_div:if l<glue_val then expr_d(t)
else begin expr_d(width(t));expr_d(stretch(t));expr_d(shrink(t));
end;

/*:1793*//*1795:*/
#line 38847 "pdftexdir/pdftex.web"

expr_scale:if l= int_val then t:= fract(t,n,f,infinity)
else if l= dimen_val then expr_s(t)
else begin expr_s(width(t));expr_s(stretch(t));expr_s(shrink(t));
end;

/*:1795*/
#line 38629 "pdftexdir/pdftex.web"

end;{there are no other cases}
if o> expr_sub then s:= o else/*1789:*/
#line 38756 "pdftexdir/pdftex.web"

begin s:= expr_none;
if r= expr_none then e:= t
else if l= int_val then e:= expr_add_sub(e,t,infinity)
else if l= dimen_val then e:= expr_a(e,t)
else/*1791:*/
#line 38783 "pdftexdir/pdftex.web"

begin width(e):= expr_a(width(e),width(t));
if stretch_order(e)= stretch_order(t)then
stretch(e):= expr_a(stretch(e),stretch(t))
else if(stretch_order(e)<stretch_order(t))and(stretch(t)<> 0)then
begin stretch(e):= stretch(t);stretch_order(e):= stretch_order(t);
end;
if shrink_order(e)= shrink_order(t)then
shrink(e):= expr_a(shrink(e),shrink(t))
else if(shrink_order(e)<shrink_order(t))and(shrink(t)<> 0)then
begin shrink(e):= shrink(t);shrink_order(e):= shrink_order(t);
end;
delete_glue_ref(t);normalize_glue(e);
end

/*:1791*/
#line 38761 "pdftexdir/pdftex.web"
;
r:= o;
end

/*:1789*/
#line 38631 "pdftexdir/pdftex.web"
;
b:= arith_error;
if o<> expr_none then goto continue;
if p<> null then/*1786:*/
#line 38701 "pdftexdir/pdftex.web"

begin f:= e;q:= p;
e:= expr_e_field(q);t:= expr_t_field(q);n:= expr_n_field(q);
s:= subtype(q)div 4;r:= subtype(q)mod 4;
l:= type(q);p:= link(q);free_node(q,expr_node_size);
goto found;
end

/*:1786*/
#line 38634 "pdftexdir/pdftex.web"


/*:1780*/
#line 38594 "pdftexdir/pdftex.web"
;
if b then
begin print_err("Arithmetic overflow");

help2("I can't evaluate this expression,")
("since the result is out of range.");
error;
if l>=glue_val then
begin delete_glue_ref(e);e:= zero_glue;add_glue_ref(e);
end
else e:= 0;
end;
arith_error:= a;cur_val:= e;cur_val_level:= l;
end;

/*:1779*//*1784:*/
#line 38672 "pdftexdir/pdftex.web"

procedure scan_normal_glue;
begin scan_glue(glue_val);
end;

procedure scan_mu_glue;
begin scan_glue(mu_val);
end;

/*:1784*/
#line 10622 "pdftexdir/pdftex.web"


/*:487*//*489:*/
#line 10647 "pdftexdir/pdftex.web"
function scan_rule_spec:pointer;
label reswitch;
var q:pointer;{the rule node being created}
begin q:= new_rule;{|width|,|depth|,and|height|all equal|null_flag|now}
if cur_cmd= vrule then width(q):= default_rule
else begin height(q):= default_rule;depth(q):= 0;
end;
reswitch:if scan_keyword("width")then

begin scan_normal_dimen;width(q):= cur_val;goto reswitch;
end;
if scan_keyword("height")then

begin scan_normal_dimen;height(q):= cur_val;goto reswitch;
end;
if scan_keyword("depth")then

begin scan_normal_dimen;depth(q):= cur_val;goto reswitch;
end;
scan_rule_spec:= q;
end;

/*:489*//*490:*/
#line 10681 "pdftexdir/pdftex.web"
/*1680:*/
#line 37263 "pdftexdir/pdftex.web"

procedure scan_general_text;
label found;
var s:normal..absorbing;{to save|scanner_status|}
w:pointer;{to save|warning_index|}
d:pointer;{to save|def_ref|}
p:pointer;{tail of the token list being built}
q:pointer;{new node being added to the token list via|store_new_token|}
unbalance:halfword;{number of unmatched left braces}
begin s:= scanner_status;w:= warning_index;d:= def_ref;
scanner_status:= absorbing;warning_index:= cur_cs;
def_ref:= get_avail;token_ref_count(def_ref):= null;p:= def_ref;
scan_left_brace;{remove the compulsory left brace}
unbalance:= 1;
loop begin get_token;
if cur_tok<right_brace_limit then
if cur_cmd<right_brace then incr(unbalance)
else begin decr(unbalance);
if unbalance= 0 then goto found;
end;
store_new_token(cur_tok);
end;
found:q:= link(def_ref);free_avail(def_ref);{discard reference count}
if q= null then cur_val:= temp_head else cur_val:= p;
link(temp_head):= q;
scanner_status:= s;warning_index:= w;def_ref:= d;
end;

/*:1680*//*1750:*/
#line 38129 "pdftexdir/pdftex.web"

procedure pseudo_start;
var old_setting:0..max_selector;{holds|selector|setting}
s:str_number;{string to be converted into a pseudo file}
l,m:pool_pointer;{indices into|str_pool|}
p,q,r:pointer;{for list construction}
w:four_quarters;{four ASCII codes}
nl,sz:integer;
begin scan_general_text;
old_setting:= selector;selector:= new_string;
token_show(temp_head);selector:= old_setting;
flush_list(link(temp_head));
str_room(1);s:= make_string;
/*1751:*/
#line 38147 "pdftexdir/pdftex.web"

str_pool[pool_ptr]:= si(" ");l:= str_start[s];
nl:= si(new_line_char);
p:= get_avail;q:= p;
while l<pool_ptr do
begin m:= l;
while(l<pool_ptr)and(str_pool[l]<> nl)do incr(l);
sz:= (l-m+7)div 4;
if sz= 1 then sz:= 2;
r:= get_node(sz);link(q):= r;q:= r;info(q):= hi(sz);
while sz> 2 do
begin decr(sz);incr(r);
w.b0:= qi(so(str_pool[m]));w.b1:= qi(so(str_pool[m+1]));
w.b2:= qi(so(str_pool[m+2]));w.b3:= qi(so(str_pool[m+3]));
mem[r].qqqq:= w;m:= m+4;
end;
w.b0:= qi(" ");w.b1:= qi(" ");w.b2:= qi(" ");w.b3:= qi(" ");
if l> m then
begin w.b0:= qi(so(str_pool[m]));
if l> m+1 then
begin w.b1:= qi(so(str_pool[m+1]));
if l> m+2 then
begin w.b2:= qi(so(str_pool[m+2]));
if l> m+3 then w.b3:= qi(so(str_pool[m+3]));
end;
end;
end;
mem[r+1].qqqq:= w;
if str_pool[l]= nl then incr(l);
end;
info(p):= link(p);link(p):= pseudo_files;pseudo_files:= p

/*:1751*/
#line 38142 "pdftexdir/pdftex.web"
;
flush_string;
/*1752:*/
#line 38179 "pdftexdir/pdftex.web"

begin_file_reading;{set up|cur_file|and new level of input}
line:= 0;limit:= start;loc:= limit+1;{force line read}
if tracing_scan_tokens> 0 then
begin if term_offset> max_print_line-3 then print_ln
else if(term_offset> 0)or(file_offset> 0)then print_char(" ");
#line 5969 "pdftex-final.ch"
name:= 19;print("( ");incr(open_parens);update_terminal;
end
else begin
name:= 18;
/*1917:*/
#line 7003 "pdftex-final.ch"

synctex_tag:= 0;

/*:1917*/
#line 5973 "pdftex-final.ch"
;
end
#line 38188 "pdftexdir/pdftex.web"

/*:1752*/
#line 38144 "pdftexdir/pdftex.web"
;
end;

/*:1750*/
#line 10681 "pdftexdir/pdftex.web"

function str_toks(b:pool_pointer):pointer;
{changes the string|str_pool[b..pool_ptr]|to a token list}
var p:pointer;{tail of the token list}
q:pointer;{new node being added to the token list via|store_new_token|}
t:halfword;{token being appended}
k:pool_pointer;{index into|str_pool|}
begin str_room(1);
p:= temp_head;link(p):= null;k:= b;
while k<pool_ptr do
begin t:= so(str_pool[k]);
if t= " "then t:= space_token
else t:= other_token+t;
fast_store_new_token(t);
incr(k);
end;
pool_ptr:= b;str_toks:= p;
end;

/*:490*//*491:*/
#line 10707 "pdftexdir/pdftex.web"
function the_toks:pointer;
label exit;
var old_setting:0..max_selector;{holds|selector|setting}
p,q,r:pointer;{used for copying a token list}
b:pool_pointer;{base of temporary string}
c:small_number;{value of|cur_chr|}
begin/*1685:*/
#line 37320 "pdftexdir/pdftex.web"

if odd(cur_chr)then
begin c:= cur_chr;scan_general_text;
if c= 1 then the_toks:= cur_val
else begin old_setting:= selector;selector:= new_string;b:= pool_ptr;
p:= get_avail;link(p):= link(temp_head);
token_show(p);flush_list(p);
selector:= old_setting;the_toks:= str_toks(b);
end;
return;
end

/*:1685*/
#line 10713 "pdftexdir/pdftex.web"
;
get_x_token;scan_something_internal(tok_val,false);
if cur_val_level>=ident_val then/*492:*/
#line 10730 "pdftexdir/pdftex.web"

begin p:= temp_head;link(p):= null;
if cur_val_level= ident_val then store_new_token(cs_token_flag+cur_val)
else if cur_val<> null then
begin r:= link(cur_val);{do not copy the reference count}
while r<> null do
begin fast_store_new_token(info(r));r:= link(r);
end;
end;
the_toks:= p;
end

/*:492*/
#line 10715 "pdftexdir/pdftex.web"

else begin old_setting:= selector;selector:= new_string;b:= pool_ptr;
case cur_val_level of
int_val:print_int(cur_val);
dimen_val:begin print_scaled(cur_val);print("pt");
end;
glue_val:begin print_spec(cur_val,"pt");delete_glue_ref(cur_val);
end;
mu_val:begin print_spec(cur_val,"mu");delete_glue_ref(cur_val);
end;
end;{there are no other cases}
selector:= old_setting;the_toks:= str_toks(b);
end;
exit:end;

/*:491*//*493:*/
#line 10744 "pdftexdir/pdftex.web"
procedure ins_the_toks;
begin link(garbage):= the_toks;ins_list(link(temp_head));
end;

/*:493*//*496:*/
#line 10916 "pdftexdir/pdftex.web"
procedure conv_toks;
label exit;
var old_setting:0..max_selector;{holds|selector|setting}
p,q:pointer;
c:number_code..job_name_code;{desired type of conversion}
save_scanner_status:small_number;{|scanner_status|upon entry}
save_def_ref:pointer;{|def_ref|upon entry,important if inside`\.{\\message}'}
save_warning_index:pointer;
bool:boolean;{temp boolean}
i:integer;{first temp integer}
j:integer;{second temp integer}
b:pool_pointer;{base of temporary string}
s:str_number;{first temp string}
t:str_number;{second temp string}
u:str_number;{saved current string string}
begin
c:= cur_chr;
u:= 0;{will become non-nil if a string is already being built}
/*497:*/
#line 10940 "pdftexdir/pdftex.web"

case c of
number_code,roman_numeral_code:scan_int;
string_code,meaning_code:begin save_scanner_status:= scanner_status;
scanner_status:= normal;get_token;scanner_status:= save_scanner_status;
end;
font_name_code:scan_font_ident;
eTeX_revision_code:do_nothing;
expanded_code:
begin
save_scanner_status:= scanner_status;
save_warning_index:= warning_index;
save_def_ref:= def_ref;
save_cur_string;
scan_pdf_ext_toks;
warning_index:= save_warning_index;
scanner_status:= save_scanner_status;
ins_list(link(def_ref));
free_avail(def_ref);
def_ref:= save_def_ref;
restore_cur_string;
return;
end;
pdftex_revision_code:do_nothing;
pdftex_banner_code:do_nothing;
pdf_font_name_code,pdf_font_objnum_code,pdf_font_size_code:begin
scan_font_ident;
if cur_val= null_font then
pdf_error("font","invalid font identifier");
if c<> pdf_font_size_code then begin
pdf_check_vf_cur_val;
if not font_used[cur_val]then
pdf_init_font_cur_val;
end;
end;
pdf_page_ref_code:begin
scan_int;
if cur_val<=0 then
pdf_error("pageref","invalid page number");
end;
left_margin_kern_code,right_margin_kern_code:begin
scan_register_num;
fetch_box(p);
if(p= null)or(type(p)<> hlist_node)then
pdf_error("marginkern","a non-empty hbox expected")
end;
pdf_xform_name_code:begin
scan_int;
pdf_check_obj(obj_type_xform,cur_val);
end;
pdf_escape_string_code:
begin
save_scanner_status:= scanner_status;
save_warning_index:= warning_index;
save_def_ref:= def_ref;
save_cur_string;
scan_pdf_ext_toks;
s:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
def_ref:= save_def_ref;
warning_index:= save_warning_index;
scanner_status:= save_scanner_status;
b:= pool_ptr;
escapestring(str_start[s]);
link(garbage):= str_toks(b);
flush_str(s);
ins_list(link(temp_head));
restore_cur_string;
return;
end;
pdf_escape_name_code:
begin
save_scanner_status:= scanner_status;
save_warning_index:= warning_index;
save_def_ref:= def_ref;
save_cur_string;
scan_pdf_ext_toks;
s:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
def_ref:= save_def_ref;
warning_index:= save_warning_index;
scanner_status:= save_scanner_status;
b:= pool_ptr;
escapename(str_start[s]);
link(garbage):= str_toks(b);
flush_str(s);
ins_list(link(temp_head));
restore_cur_string;
return;
end;
pdf_escape_hex_code:
begin
save_scanner_status:= scanner_status;
save_warning_index:= warning_index;
save_def_ref:= def_ref;
save_cur_string;
scan_pdf_ext_toks;
s:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
def_ref:= save_def_ref;
warning_index:= save_warning_index;
scanner_status:= save_scanner_status;
b:= pool_ptr;
escapehex(str_start[s]);
link(garbage):= str_toks(b);
flush_str(s);
ins_list(link(temp_head));
restore_cur_string;
return;
end;
pdf_unescape_hex_code:
begin
save_scanner_status:= scanner_status;
save_warning_index:= warning_index;
save_def_ref:= def_ref;
save_cur_string;
scan_pdf_ext_toks;
s:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
def_ref:= save_def_ref;
warning_index:= save_warning_index;
scanner_status:= save_scanner_status;
b:= pool_ptr;
unescapehex(str_start[s]);
link(garbage):= str_toks(b);
flush_str(s);
ins_list(link(temp_head));
restore_cur_string;
return;
end;
pdf_creation_date_code:
begin
b:= pool_ptr;
getcreationdate;
link(garbage):= str_toks(b);
ins_list(link(temp_head));
return;
end;
pdf_file_mod_date_code:
begin
save_scanner_status:= scanner_status;
save_warning_index:= warning_index;
save_def_ref:= def_ref;
save_cur_string;
scan_pdf_ext_toks;
s:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
def_ref:= save_def_ref;
warning_index:= save_warning_index;
scanner_status:= save_scanner_status;
b:= pool_ptr;
getfilemoddate(s);
link(garbage):= str_toks(b);
flush_str(s);
ins_list(link(temp_head));
restore_cur_string;
return;
end;
pdf_file_size_code:
begin
save_scanner_status:= scanner_status;
save_warning_index:= warning_index;
save_def_ref:= def_ref;
save_cur_string;
scan_pdf_ext_toks;
s:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
def_ref:= save_def_ref;
warning_index:= save_warning_index;
scanner_status:= save_scanner_status;
b:= pool_ptr;
getfilesize(s);
link(garbage):= str_toks(b);
flush_str(s);
ins_list(link(temp_head));
restore_cur_string;
return;
end;
pdf_mdfive_sum_code:
begin
save_scanner_status:= scanner_status;
save_warning_index:= warning_index;
save_def_ref:= def_ref;
save_cur_string;
bool:= scan_keyword("file");
scan_pdf_ext_toks;
s:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
def_ref:= save_def_ref;
warning_index:= save_warning_index;
scanner_status:= save_scanner_status;
b:= pool_ptr;
getmd5sum(s,bool);
link(garbage):= str_toks(b);
flush_str(s);
ins_list(link(temp_head));
restore_cur_string;
return;
end;
pdf_file_dump_code:
begin
save_scanner_status:= scanner_status;
save_warning_index:= warning_index;
save_def_ref:= def_ref;
save_cur_string;
{scan offset}
cur_val:= 0;
if(scan_keyword("offset"))then begin
scan_int;
if(cur_val<0)then begin
print_err("Bad file offset");

help2("A file offset must be between 0 and 2^{31}-1,")
("I changed this one to zero.");
int_error(cur_val);
cur_val:= 0;
end;
end;
i:= cur_val;
{scan length}
cur_val:= 0;
if(scan_keyword("length"))then begin
scan_int;
if(cur_val<0)then begin
print_err("Bad dump length");

help2("A dump length must be between 0 and 2^{31}-1,")
("I changed this one to zero.");
int_error(cur_val);
cur_val:= 0;
end;
end;
j:= cur_val;
{scan file name}
scan_pdf_ext_toks;
s:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
def_ref:= save_def_ref;
warning_index:= save_warning_index;
scanner_status:= save_scanner_status;
b:= pool_ptr;
getfiledump(s,i,j);
link(garbage):= str_toks(b);
flush_str(s);
ins_list(link(temp_head));
restore_cur_string;
return;
end;
pdf_match_code:
begin
save_scanner_status:= scanner_status;
save_warning_index:= warning_index;
save_def_ref:= def_ref;
save_cur_string;
{scan for icase}
bool:= scan_keyword("icase");
{scan for subcount}
i:= -1;{default for subcount}
if scan_keyword("subcount")then begin
scan_int;
i:= cur_val;
end;
scan_pdf_ext_toks;
s:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
scan_pdf_ext_toks;
t:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
def_ref:= save_def_ref;
warning_index:= save_warning_index;
scanner_status:= save_scanner_status;
b:= pool_ptr;
matchstrings(s,t,i,bool);
link(garbage):= str_toks(b);
flush_str(t);
flush_str(s);
ins_list(link(temp_head));
restore_cur_string;
return;
end;
pdf_last_match_code:
begin
scan_int;
if cur_val<0 then begin
print_err("Bad match number");

help2("Since I expected zero or a positive number,")
("I changed this one to zero.");
int_error(cur_val);
cur_val:= 0;
end;
b:= pool_ptr;
getmatch(cur_val);
link(garbage):= str_toks(b);
ins_list(link(temp_head));
return;
end;
pdf_strcmp_code:
begin
save_scanner_status:= scanner_status;
save_warning_index:= warning_index;
save_def_ref:= def_ref;
save_cur_string;
compare_strings;
def_ref:= save_def_ref;
warning_index:= save_warning_index;
scanner_status:= save_scanner_status;
restore_cur_string;
end;
pdf_colorstack_init_code:
begin
bool:= scan_keyword("page");
if scan_keyword("direct")then
cur_val:= direct_always
else
if scan_keyword("page")then
cur_val:= direct_page
else
cur_val:= set_origin;
save_scanner_status:= scanner_status;
save_warning_index:= warning_index;
save_def_ref:= def_ref;
save_cur_string;
scan_pdf_ext_toks;
s:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
def_ref:= save_def_ref;
warning_index:= save_warning_index;
scanner_status:= save_scanner_status;
cur_val:= newcolorstack(s,cur_val,bool);
flush_str(s);
cur_val_level:= int_val;
if cur_val<0 then begin
print_err("Too many color stacks");

help2("The number of color stacks is limited to 32768.")
("I'll use the default color stack 0 here.");
error;
cur_val:= 0;
restore_cur_string;
end;
end;
job_name_code:if job_name= 0 then open_log_file;
uniform_deviate_code:scan_int;
normal_deviate_code:do_nothing;
pdf_insert_ht_code:scan_register_num;
pdf_ximage_bbox_code:begin
scan_int;
pdf_check_obj(obj_type_ximage,cur_val);
i:= obj_ximage_data(cur_val);
scan_int;
j:= cur_val;
if(j<1)or(j> 4)then
pdf_error("pdfximagebbox","invalid parameter");
end;
end{there are no other cases}

/*:497*/
#line 10934 "pdftexdir/pdftex.web"
;
old_setting:= selector;selector:= new_string;b:= pool_ptr;
/*498:*/
#line 11297 "pdftexdir/pdftex.web"

case c of
number_code:print_int(cur_val);
roman_numeral_code:print_roman_int(cur_val);
string_code:if cur_cs<> 0 then sprint_cs(cur_cs)
else print_char(cur_chr);
meaning_code:print_meaning;
font_name_code:begin print(font_name[cur_val]);
if font_size[cur_val]<> font_dsize[cur_val]then
begin print(" at ");print_scaled(font_size[cur_val]);
print("pt");
end;
end;
eTeX_revision_code:print(eTeX_revision);
pdftex_revision_code:print(pdftex_revision);
pdftex_banner_code:print(pdftex_banner);
pdf_font_name_code,pdf_font_objnum_code:begin
set_ff(cur_val);
if c= pdf_font_name_code then
print_int(obj_info(pdf_font_num[ff]))
else
print_int(pdf_font_num[ff]);
end;
pdf_font_size_code:begin
print_scaled(font_size[cur_val]);
print("pt");
end;
pdf_page_ref_code:print_int(get_obj(obj_type_page,cur_val,false));
left_margin_kern_code:begin
p:= list_ptr(p);
while(p<> null)and
(cp_skipable(p)or
((not is_char_node(p))and(type(p)= glue_node)and(subtype(p)= left_skip_code+1)))
do
p:= link(p);
if(p<> null)and(not is_char_node(p))and
(type(p)= margin_kern_node)and(subtype(p)= left_side)then
print_scaled(width(p))
else
print("0");
print("pt");
end;
right_margin_kern_code:begin
q:= list_ptr(p);
p:= prev_rightmost(q,null);
while(p<> null)and
(cp_skipable(p)or
((not is_char_node(p))and(type(p)= glue_node)and(subtype(p)= right_skip_code+1)))
do
p:= prev_rightmost(q,p);
if(p<> null)and(not is_char_node(p))and
(type(p)= margin_kern_node)and(subtype(p)= right_side)then
print_scaled(width(p))
else
print("0");
print("pt");
end;
pdf_xform_name_code:print_int(obj_info(cur_val));
pdf_strcmp_code:print_int(cur_val);
pdf_colorstack_init_code:print_int(cur_val);
uniform_deviate_code:print_int(unif_rand(cur_val));
normal_deviate_code:print_int(norm_rand);
pdf_insert_ht_code:begin
i:= qi(cur_val);
p:= page_ins_head;
while i>=subtype(link(p))do
p:= link(p);
if subtype(p)= i then
print_scaled(height(p))
else
print("0");
print("pt");
end;
pdf_ximage_bbox_code:begin
if is_pdf_image(i)then begin
case j of
1:print_scaled(epdf_orig_x(i));
2:print_scaled(epdf_orig_y(i));
3:print_scaled(epdf_orig_x(i)+image_width(i));
4:print_scaled(epdf_orig_y(i)+image_height(i));
endcases;
end else
print_scaled(0);
print("pt");
end;
job_name_code:print(job_name);
end{there are no other cases}

/*:498*/
#line 10936 "pdftexdir/pdftex.web"
;
selector:= old_setting;link(garbage):= str_toks(b);ins_list(link(temp_head));
exit:end;

/*:496*//*499:*/
#line 11409 "pdftexdir/pdftex.web"
function scan_toks(macro_def,xpand:boolean):pointer;
label found,done,done1,done2;
var t:halfword;{token representing the highest parameter number}
s:halfword;{saved token}
p:pointer;{tail of the token list being built}
q:pointer;{new node being added to the token list via|store_new_token|}
unbalance:halfword;{number of unmatched left braces}
hash_brace:halfword;{possible`\.{\#\{}' token}
begin if macro_def then scanner_status:= defining
else scanner_status:= absorbing;
warning_index:= cur_cs;def_ref:= get_avail;token_ref_count(def_ref):= null;
p:= def_ref;hash_brace:= 0;t:= zero_token;
if macro_def then/*500:*/
#line 11429 "pdftexdir/pdftex.web"

begin loop begin get_token;{set|cur_cmd|,|cur_chr|,|cur_tok|}
if cur_tok<right_brace_limit then goto done1;
if cur_cmd= mac_param then
/*502:*/
#line 11450 "pdftexdir/pdftex.web"

begin s:= match_token+cur_chr;get_token;
if cur_cmd= left_brace then
begin hash_brace:= cur_tok;
store_new_token(cur_tok);store_new_token(end_match_token);
goto done;
end;
if t= zero_token+9 then
begin print_err("You already have nine parameters");

help1("I'm going to ignore the # sign you just used.");error;
end
else begin incr(t);
if cur_tok<> t then
begin print_err("Parameters must be numbered consecutively");

help2("I've inserted the digit you should have used after the #.")
("Type `1' to delete what you did use.");back_error;
end;
cur_tok:= s;
end;
end

/*:502*/
#line 11435 "pdftexdir/pdftex.web"
;
store_new_token(cur_tok);
end;
done1:store_new_token(end_match_token);
if cur_cmd= right_brace then
/*501:*/
#line 11443 "pdftexdir/pdftex.web"

begin print_err("Missing { inserted");incr(align_state);

help2("Where was the left brace? You said something like `\def\a}',")
("which I'm going to interpret as `\def\a{}'.");error;goto found;
end

/*:501*/
#line 11440 "pdftexdir/pdftex.web"
;
done:end

/*:500*/
#line 11421 "pdftexdir/pdftex.web"

else scan_left_brace;{remove the compulsory left brace}
/*503:*/
#line 11473 "pdftexdir/pdftex.web"

unbalance:= 1;
loop begin if xpand then/*504:*/
#line 11490 "pdftexdir/pdftex.web"

begin loop begin get_next;
if cur_cmd>=call then
if info(link(cur_chr))= protected_token then
begin cur_cmd:= relax;cur_chr:= no_expand_flag;
end;
if cur_cmd<=max_command then goto done2;
if cur_cmd<> the then expand
else begin q:= the_toks;
if link(temp_head)<> null then
begin link(p):= link(temp_head);p:= q;
end;
end;
end;
done2:x_token
end

/*:504*/
#line 11475 "pdftexdir/pdftex.web"

else get_token;
if cur_tok<right_brace_limit then
if cur_cmd<right_brace then incr(unbalance)
else begin decr(unbalance);
if unbalance= 0 then goto found;
end
else if cur_cmd= mac_param then
if macro_def then/*505:*/
#line 11507 "pdftexdir/pdftex.web"

begin s:= cur_tok;
if xpand then get_x_token else get_token;
if cur_cmd<> mac_param then
if(cur_tok<=zero_token)or(cur_tok> t)then
begin print_err("Illegal parameter number in definition of ");

sprint_cs(warning_index);
help3("You meant to type ## instead of #, right?")
("Or maybe a } was forgotten somewhere earlier, and things")
("are all screwed up? I'm going to assume that you meant ##.");
back_error;cur_tok:= s;
end
else cur_tok:= out_param_token-"0"+cur_chr;
end

/*:505*/
#line 11483 "pdftexdir/pdftex.web"
;
store_new_token(cur_tok);
end

/*:503*/
#line 11423 "pdftexdir/pdftex.web"
;
found:scanner_status:= normal;
if hash_brace<> 0 then store_new_token(hash_brace);
scan_toks:= p;
end;

/*:499*//*508:*/
#line 11544 "pdftexdir/pdftex.web"
procedure read_toks(n:integer;r:pointer;j:halfword);
label done;
var p:pointer;{tail of the token list}
q:pointer;{new node being added to the token list via|store_new_token|}
s:integer;{saved value of|align_state|}
m:small_number;{stream number}
begin scanner_status:= defining;warning_index:= r;
def_ref:= get_avail;token_ref_count(def_ref):= null;
p:= def_ref;{the reference count}
store_new_token(end_match_token);
if(n<0)or(n> 15)then m:= 16 else m:= n;
s:= align_state;align_state:= 1000000;{disable tab marks,etc.}
repeat/*509:*/
#line 11561 "pdftexdir/pdftex.web"

begin_file_reading;name:= m+1;
if read_open[m]= closed then/*510:*/
#line 11586 "pdftexdir/pdftex.web"

if interaction> nonstop_mode then
if n<0 then prompt_input("")
else begin wake_up_terminal;
print_ln;sprint_cs(r);prompt_input("=");n:= -1;
end
else fatal_error("*** (cannot \read from terminal in nonstop modes)")


/*:510*/
#line 11563 "pdftexdir/pdftex.web"

else if read_open[m]= just_open then/*511:*/
#line 11599 "pdftexdir/pdftex.web"

if input_ln(read_file[m],false)then read_open[m]:= normal
else begin a_close(read_file[m]);read_open[m]:= closed;
end

/*:511*/
#line 11564 "pdftexdir/pdftex.web"

else/*512:*/
#line 11607 "pdftexdir/pdftex.web"

begin if not input_ln(read_file[m],true)then
begin a_close(read_file[m]);read_open[m]:= closed;
if align_state<> 1000000 then
begin runaway;
print_err("File ended within ");print_esc("read");

help1("This \read has unbalanced braces.");
align_state:= 1000000;error;
end;
end;
end

/*:512*/
#line 11565 "pdftexdir/pdftex.web"
;
limit:= last;
if end_line_char_inactive then decr(limit)
else buffer[limit]:= end_line_char;
first:= limit+1;loc:= start;state:= new_line;
/*1758:*/
#line 38239 "pdftexdir/pdftex.web"

if j= 1 then
begin while loc<=limit do{current line not yet finished}
begin cur_chr:= buffer[loc];incr(loc);
if cur_chr= " "then cur_tok:= space_token
else cur_tok:= cur_chr+other_token;
store_new_token(cur_tok);
end;
goto done;
end

/*:1758*/
#line 11570 "pdftexdir/pdftex.web"
;
loop begin get_token;
if cur_tok= 0 then goto done;
{|cur_cmd= cur_chr= 0|will occur at the end of the line}
if align_state<1000000 then{unmatched`\.\}' aborts the line}
begin repeat get_token;until cur_tok= 0;
align_state:= 1000000;goto done;
end;
store_new_token(cur_tok);
end;
done:end_file_reading

/*:509*/
#line 11556 "pdftexdir/pdftex.web"
;
until align_state= 1000000;
cur_val:= def_ref;scanner_status:= normal;align_state:= s;
end;

/*:508*//*520:*/
#line 11765 "pdftexdir/pdftex.web"
procedure pass_text;
label done;
var l:integer;{level of $\.{\\if}\ldots\.{\\fi}$ nesting}
save_scanner_status:small_number;{|scanner_status|upon entry}
begin save_scanner_status:= scanner_status;scanner_status:= skipping;l:= 0;
skip_line:= line;
loop begin get_next;
if cur_cmd= fi_or_else then
begin if l= 0 then goto done;
if cur_chr= fi_code then decr(l);
end
else if cur_cmd= if_test then incr(l);
end;
done:scanner_status:= save_scanner_status;
if tracing_ifs> 0 then show_cur_cmd_chr;
end;

/*:520*//*523:*/
#line 11805 "pdftexdir/pdftex.web"
procedure change_if_limit(l:small_number;p:pointer);
label exit;
var q:pointer;
begin if p= cond_ptr then if_limit:= l{that's the easy case}
else begin q:= cond_ptr;
loop begin if q= null then confusion("if");

if link(q)= p then
begin type(q):= l;return;
end;
q:= link(q);
end;
end;
exit:end;

/*:523*//*524:*/
#line 11825 "pdftexdir/pdftex.web"
procedure conditional;
label exit,common_ending;
var b:boolean;{is the condition true?}
e:boolean;{keep track of nested csnames}
r:"<"..">";{relation to be evaluated}
m,n:integer;{to be tested against the second operand}
p,q:pointer;{for traversing token lists in\.{\\ifx}tests}
save_scanner_status:small_number;{|scanner_status|upon entry}
save_cond_ptr:pointer;{|cond_ptr|corresponding to this conditional}
this_if:small_number;{type of this conditional}
is_unless:boolean;{was this if preceded by`\.{\\unless}' ?}
begin if tracing_ifs> 0 then if tracing_commands<=1 then show_cur_cmd_chr;
/*521:*/
#line 11788 "pdftexdir/pdftex.web"

begin p:= get_node(if_node_size);link(p):= cond_ptr;type(p):= if_limit;
subtype(p):= cur_if;if_line_field(p):= if_line;
cond_ptr:= p;cur_if:= cur_chr;if_limit:= if_code;if_line:= line;
end

/*:521*/
#line 11837 "pdftexdir/pdftex.web"
;save_cond_ptr:= cond_ptr;
is_unless:= (cur_chr>=unless_code);this_if:= cur_chr mod unless_code;
/*527:*/
#line 11868 "pdftexdir/pdftex.web"

case this_if of
if_char_code,if_cat_code:/*532:*/
#line 11955 "pdftexdir/pdftex.web"

begin get_x_token_or_active_char;
if(cur_cmd> active_char)or(cur_chr> 255)then{not a character}
begin m:= relax;n:= 256;
end
else begin m:= cur_cmd;n:= cur_chr;
end;
get_x_token_or_active_char;
if(cur_cmd> active_char)or(cur_chr> 255)then
begin cur_cmd:= relax;cur_chr:= 256;
end;
if this_if= if_char_code then b:= (n= cur_chr)else b:= (m= cur_cmd);
end

/*:532*/
#line 11870 "pdftexdir/pdftex.web"
;
if_int_code,if_dim_code:/*529:*/
#line 11912 "pdftexdir/pdftex.web"

begin if this_if= if_int_code then scan_int else scan_normal_dimen;
n:= cur_val;/*432:*/
#line 9549 "pdftexdir/pdftex.web"

repeat get_x_token;
until cur_cmd<> spacer

/*:432*/
#line 11914 "pdftexdir/pdftex.web"
;
if(cur_tok>=other_token+"<")and(cur_tok<=other_token+">")then
r:= cur_tok-other_token
else begin print_err("Missing = inserted for ");

print_cmd_chr(if_test,this_if);
help1("I was expecting to see `<', `=', or `>'. Didn't.");
back_error;r:= "=";
end;
if this_if= if_int_code then scan_int else scan_normal_dimen;
case r of
"<":b:= (n<cur_val);
"=":b:= (n= cur_val);
">":b:= (n> cur_val);
end;
end

/*:529*/
#line 11871 "pdftexdir/pdftex.web"
;
if_odd_code:/*530:*/
#line 11931 "pdftexdir/pdftex.web"

begin scan_int;b:= odd(cur_val);
end

/*:530*/
#line 11872 "pdftexdir/pdftex.web"
;
if_vmode_code:b:= (abs(mode)= vmode);
if_hmode_code:b:= (abs(mode)= hmode);
if_mmode_code:b:= (abs(mode)= mmode);
if_inner_code:b:= (mode<0);
if_void_code,if_hbox_code,if_vbox_code:/*531:*/
#line 11935 "pdftexdir/pdftex.web"

begin scan_register_num;fetch_box(p);
if this_if= if_void_code then b:= (p= null)
else if p= null then b:= false
else if this_if= if_hbox_code then b:= (type(p)= hlist_node)
else b:= (type(p)= vlist_node);
end

/*:531*/
#line 11877 "pdftexdir/pdftex.web"
;
ifx_code:/*533:*/
#line 11976 "pdftexdir/pdftex.web"

begin save_scanner_status:= scanner_status;scanner_status:= normal;
get_next;n:= cur_cs;p:= cur_cmd;q:= cur_chr;
get_next;if cur_cmd<> p then b:= false
else if cur_cmd<call then b:= (cur_chr= q)
else/*534:*/
#line 11993 "pdftexdir/pdftex.web"

begin p:= link(cur_chr);q:= link(equiv(n));{omit reference counts}
if p= q then b:= true
else begin while(p<> null)and(q<> null)do
if info(p)<> info(q)then p:= null
else begin p:= link(p);q:= link(q);
end;
b:= ((p= null)and(q= null));
end;
end

/*:534*/
#line 11981 "pdftexdir/pdftex.web"
;
scanner_status:= save_scanner_status;
end

/*:533*/
#line 11878 "pdftexdir/pdftex.web"
;
#line 2096 "pdftex-final.ch"
if_eof_code:begin scan_four_bit_int_or_18;
if cur_val= 18 then b:= not shellenabledp
else b:= (read_open[cur_val]= closed);
end;
#line 11881 "pdftexdir/pdftex.web"
if_true_code:b:= true;
if_false_code:b:= false;
/*1763:*/
#line 38308 "pdftexdir/pdftex.web"

if_def_code:begin save_scanner_status:= scanner_status;
scanner_status:= normal;
get_next;b:= (cur_cmd<> undefined_cs);
scanner_status:= save_scanner_status;
end;

/*:1763*//*1764:*/
#line 38320 "pdftexdir/pdftex.web"

if_cs_code:begin n:= get_avail;p:= n;{head of the list of characters}
e:= is_in_csname;is_in_csname:= true;
repeat get_x_token;
if cur_cs= 0 then store_new_token(cur_tok);
until cur_cs<> 0;
if cur_cmd<> end_cs_name then/*399:*/
#line 9077 "pdftexdir/pdftex.web"

begin print_err("Missing ");print_esc("endcsname");print(" inserted");

help2("The control sequence marked <to be read again> should")
("not appear between \csname and \endcsname.");
back_error;
end

/*:399*/
#line 38326 "pdftexdir/pdftex.web"
;
/*1765:*/
#line 38333 "pdftexdir/pdftex.web"

m:= first;p:= link(n);
while p<> null do
begin if m>=max_buf_stack then
begin max_buf_stack:= m+1;
if max_buf_stack= buf_size then
overflow("buffer size",buf_size);

end;
buffer[m]:= info(p)mod 52
end;
if m> first+1 then
cur_cs:= id_lookup(first,m-first){|no_new_control_sequence|is|true|}
else if m= first then cur_cs:= null_cs{the list is empty}
else cur_cs:= single_base+buffer[first]{the list has length one}

/*:1765*/
#line 38327 "pdftexdir/pdftex.web"
;
flush_list(n);
b:= (eq_type(cur_cs)<> undefined_cs);
is_in_csname:= e;
end;

/*:1764*//*1766:*/
#line 38352 "pdftexdir/pdftex.web"

if_in_csname_code:b:= is_in_csname;
if_pdfabs_dim_code,if_pdfabs_num_code:begin
if this_if= if_pdfabs_num_code then scan_int else scan_normal_dimen;
n:= cur_val;
if n<0 then negate(n);
/*432:*/
#line 9549 "pdftexdir/pdftex.web"

repeat get_x_token;
until cur_cmd<> spacer

/*:432*/
#line 38358 "pdftexdir/pdftex.web"
;
if(cur_tok>=other_token+"<")and(cur_tok<=other_token+">")then
r:= cur_tok-other_token
else begin print_err("Missing = inserted for ");

print_cmd_chr(if_test,this_if);
help1("I was expecting to see `<', `=', or `>'. Didn't.");
back_error;r:= "=";
end;
if this_if= if_pdfabs_num_code then scan_int else scan_normal_dimen;
if cur_val<0 then negate(cur_val);
case r of
"<":b:= (n<cur_val);
"=":b:= (n= cur_val);
">":b:= (n> cur_val);
end;
end;
if_font_char_code:begin scan_font_ident;n:= cur_val;scan_char_num;
if(font_bc[n]<=cur_val)and(font_ec[n]>=cur_val)then
b:= char_exists(char_info(n)(qi(cur_val)))
else b:= false;
end;

/*:1766*/
#line 11883 "pdftexdir/pdftex.web"

if_case_code:/*535:*/
#line 12004 "pdftexdir/pdftex.web"

begin scan_int;n:= cur_val;{|n|is the number of cases to pass}
if tracing_commands> 1 then
begin begin_diagnostic;print("{case ");print_int(n);print_char("}");
end_diagnostic(false);
end;
while n<> 0 do
begin pass_text;
if cond_ptr= save_cond_ptr then
if cur_chr= or_code then decr(n)
else goto common_ending
else if cur_chr= fi_code then/*522:*/
#line 11794 "pdftexdir/pdftex.web"

begin if if_stack[in_open]= cond_ptr then if_warning;
{conditionals possibly not properly nested with files}
p:= cond_ptr;if_line:= if_line_field(p);
cur_if:= subtype(p);if_limit:= type(p);cond_ptr:= link(p);
free_node(p,if_node_size);
end

/*:522*/
#line 12015 "pdftexdir/pdftex.web"
;
end;
change_if_limit(or_code,save_cond_ptr);
return;{wait for\.{\\or},\.{\\else},or\.{\\fi}}
end

/*:535*/
#line 11885 "pdftexdir/pdftex.web"
;
if_pdfprimitive_code:begin
save_scanner_status:= scanner_status;
scanner_status:= normal;
get_next;
scanner_status:= save_scanner_status;
if cur_cs<hash_base then
m:= prim_lookup(cur_cs-single_base)
else
m:= prim_lookup(text(cur_cs));
b:= ((cur_cmd<> undefined_cs)and
(m<> undefined_primitive)and
(cur_cmd= prim_eq_type(m))and
(cur_chr= prim_equiv(m)));
end;
end{there are no other cases}

/*:527*/
#line 11839 "pdftexdir/pdftex.web"
;
if is_unless then b:= not b;
if tracing_commands> 1 then/*528:*/
#line 11902 "pdftexdir/pdftex.web"

begin begin_diagnostic;
if b then print("{true}")else print("{false}");
end_diagnostic(false);
end

/*:528*/
#line 11841 "pdftexdir/pdftex.web"
;
if b then
begin change_if_limit(else_code,save_cond_ptr);
return;{wait for\.{\\else}or\.{\\fi}}
end;
/*526:*/
#line 11856 "pdftexdir/pdftex.web"

loop begin pass_text;
if cond_ptr= save_cond_ptr then
begin if cur_chr<> or_code then goto common_ending;
print_err("Extra ");print_esc("or");

help1("I'm ignoring this; it doesn't match any \if.");
error;
end
else if cur_chr= fi_code then/*522:*/
#line 11794 "pdftexdir/pdftex.web"

begin if if_stack[in_open]= cond_ptr then if_warning;
{conditionals possibly not properly nested with files}
p:= cond_ptr;if_line:= if_line_field(p);
cur_if:= subtype(p);if_limit:= type(p);cond_ptr:= link(p);
free_node(p,if_node_size);
end

/*:522*/
#line 11865 "pdftexdir/pdftex.web"
;
end

/*:526*/
#line 11846 "pdftexdir/pdftex.web"
;
common_ending:if cur_chr= fi_code then/*522:*/
#line 11794 "pdftexdir/pdftex.web"

begin if if_stack[in_open]= cond_ptr then if_warning;
{conditionals possibly not properly nested with files}
p:= cond_ptr;if_line:= if_line_field(p);
cur_if:= subtype(p);if_limit:= type(p);cond_ptr:= link(p);
free_node(p,if_node_size);
end

/*:522*/
#line 11847 "pdftexdir/pdftex.web"

else if_limit:= fi_code;{wait for\.{\\fi}}
exit:end;

/*:524*//*541:*/
#line 12144 "pdftexdir/pdftex.web"
procedure begin_name;
#line 2139 "pdftex-final.ch"
begin area_delimiter:= 0;ext_delimiter:= 0;quoted_filename:= false;
#line 12146 "pdftexdir/pdftex.web"
end;

/*:541*//*542:*/
#line 12154 "pdftexdir/pdftex.web"
function more_name(c:ASCII_code):boolean;
#line 2145 "pdftex-final.ch"
begin if(c= " ")and stop_at_space and(not quoted_filename)then
more_name:= false
else if c= """"then begin
quoted_filename:= not quoted_filename;
more_name:= true;
end
#line 12156 "pdftexdir/pdftex.web"
 else begin str_room(1);append_char(c);{contribute|c|to the current string}
#line 2156 "pdftex-final.ch"
if IS_DIR_SEP(c)then
#line 12158 "pdftexdir/pdftex.web"
 begin area_delimiter:= cur_length;ext_delimiter:= 0;
end
#line 2162 "pdftex-final.ch"
 else if c= "."then ext_delimiter:= cur_length;
#line 12161 "pdftexdir/pdftex.web"
more_name:= true;
end;
end;

#line 2171 "pdftex-final.ch"
/*:542*//*543:*/
#line 2179 "pdftex-final.ch"
procedure end_name;
var temp_str:str_number;{result of file name cache lookups}
j,s,t:pool_pointer;{running indices}
must_quote:boolean;{whether we need to quote a string}
#line 12169 "pdftexdir/pdftex.web"
begin if str_ptr+3> max_strings then
overflow("number of strings",max_strings-init_str_ptr);
#line 2188 "pdftex-final.ch"

str_room(6);{Room for quotes,if needed.}
{add quotes if needed}
if area_delimiter<> 0 then begin
{maybe quote|cur_area|}
must_quote:= false;
s:= str_start[str_ptr];
t:= str_start[str_ptr]+area_delimiter;
j:= s;
while(not must_quote)and(j<t)do begin
must_quote:= str_pool[j]= " ";incr(j);
end;
if must_quote then begin
for j:= pool_ptr-1 downto t do str_pool[j+2]:= str_pool[j];
str_pool[t+1]:= """";
for j:= t-1 downto s do str_pool[j+1]:= str_pool[j];
str_pool[s]:= """";
if ext_delimiter<> 0 then ext_delimiter:= ext_delimiter+2;
area_delimiter:= area_delimiter+2;
pool_ptr:= pool_ptr+2;
end;
end;
{maybe quote|cur_name|}
s:= str_start[str_ptr]+area_delimiter;
if ext_delimiter= 0 then t:= pool_ptr else t:= str_start[str_ptr]+ext_delimiter-1;
must_quote:= false;
j:= s;
while(not must_quote)and(j<t)do begin
must_quote:= str_pool[j]= " ";incr(j);
end;
if must_quote then begin
for j:= pool_ptr-1 downto t do str_pool[j+2]:= str_pool[j];
str_pool[t+1]:= """";
for j:= t-1 downto s do str_pool[j+1]:= str_pool[j];
str_pool[s]:= """";
if ext_delimiter<> 0 then ext_delimiter:= ext_delimiter+2;
pool_ptr:= pool_ptr+2;
end;
if ext_delimiter<> 0 then begin
{maybe quote|cur_ext|}
s:= str_start[str_ptr]+ext_delimiter-1;
t:= pool_ptr;
must_quote:= false;
j:= s;
while(not must_quote)and(j<t)do begin
must_quote:= str_pool[j]= " ";incr(j);
end;
if must_quote then begin
str_pool[t+1]:= """";
for j:= t-1 downto s do str_pool[j+1]:= str_pool[j];
str_pool[s]:= """";
pool_ptr:= pool_ptr+2;
end;
end;
#line 12172 "pdftexdir/pdftex.web"
if area_delimiter= 0 then cur_area:= ""
else begin cur_area:= str_ptr;
str_start[str_ptr+1]:= str_start[str_ptr]+area_delimiter;incr(str_ptr);
#line 2249 "pdftex-final.ch"
temp_str:= search_string(cur_area);
if temp_str> 0 then
begin cur_area:= temp_str;
decr(str_ptr);{no|flush_string|,|pool_ptr|will be wrong!}
for j:= str_start[str_ptr+1]to pool_ptr-1 do
begin str_pool[j-area_delimiter]:= str_pool[j];
end;
pool_ptr:= pool_ptr-area_delimiter;{update|pool_ptr|}
end;
end;
if ext_delimiter= 0 then
begin cur_ext:= "";cur_name:= slow_make_string;
#line 12178 "pdftexdir/pdftex.web"
end
else begin cur_name:= str_ptr;
str_start[str_ptr+1]:= str_start[str_ptr]+ext_delimiter-area_delimiter-1;
#line 2266 "pdftex-final.ch"
incr(str_ptr);cur_ext:= make_string;
decr(str_ptr);{undo extension string to look at name part}
temp_str:= search_string(cur_name);
if temp_str> 0 then
begin cur_name:= temp_str;
decr(str_ptr);{no|flush_string|,|pool_ptr|will be wrong!}
for j:= str_start[str_ptr+1]to pool_ptr-1 do
begin str_pool[j-ext_delimiter+area_delimiter+1]:= str_pool[j];
end;
pool_ptr:= pool_ptr-ext_delimiter+area_delimiter+1;{update|pool_ptr|}
end;
cur_ext:= slow_make_string;{remake extension string}
#line 12182 "pdftexdir/pdftex.web"
end;
end;

/*:543*//*545:*/
#line 12205 "pdftexdir/pdftex.web"
procedure pack_file_name(n,a,e:str_number);
var k:integer;{number of positions filled in|name_of_file|}
c:ASCII_code;{character being packed}
j:pool_pointer;{index into|str_pool|}
#line 2334 "pdftex-final.ch"
begin k:= 0;
if name_of_file then libc_free(name_of_file);
name_of_file:= xmalloc_array(ASCII_code,length(a)+length(n)+length(e)+1);
#line 12210 "pdftexdir/pdftex.web"
for j:= str_start[a]to str_start[a+1]-1 do append_to_name(so(str_pool[j]));
for j:= str_start[n]to str_start[n+1]-1 do append_to_name(so(str_pool[j]));
for j:= str_start[e]to str_start[e+1]-1 do append_to_name(so(str_pool[j]));
if k<=file_name_size then name_length:= k else name_length:= file_name_size;
#line 2342 "pdftex-final.ch"
name_of_file[name_length+1]:= 0;
#line 12215 "pdftexdir/pdftex.web"
end;

/*:545*//*549:*/
#line 12251 "pdftexdir/pdftex.web"
procedure pack_buffered_name(n:small_number;a,b:integer);
var k:integer;{number of positions filled in|name_of_file|}
c:ASCII_code;{character being packed}
j:integer;{index into|buffer|or|TEX_format_default|}
begin if n+b-a+1+format_ext_length> file_name_size then
b:= a+file_name_size-n-1-format_ext_length;
k:= 0;
#line 2380 "pdftex-final.ch"
if name_of_file then libc_free(name_of_file);
name_of_file:= xmalloc_array(ASCII_code,n+(b-a+1)+format_ext_length+1);
for j:= 1 to n do append_to_name(xord[ucharcast(TEX_format_default[j])]);
for j:= a to b do append_to_name(buffer[j]);
for j:= format_default_length-format_ext_length+1 to format_default_length do
append_to_name(xord[ucharcast(TEX_format_default[j])]);
if k<=file_name_size then name_length:= k else name_length:= file_name_size;
name_of_file[name_length+1]:= 0;
#line 12264 "pdftexdir/pdftex.web"
end;

/*:549*//*551:*/
#line 12313 "pdftexdir/pdftex.web"
function make_name_string:str_number;
var k:1..file_name_size;{index into|name_of_file|}
#line 2424 "pdftex-final.ch"
save_area_delimiter,save_ext_delimiter:pool_pointer;
save_name_in_progress,save_stop_at_space:boolean;
begin if(pool_ptr+name_length> pool_size)or(str_ptr= max_strings)or
#line 12316 "pdftexdir/pdftex.web"
(cur_length> 0)then
make_name_string:= "?"
else begin for k:= 1 to name_length do append_char(xord[name_of_file[k]]);
#line 2432 "pdftex-final.ch"
make_name_string:= make_string;
{At this point we also set|cur_name|,|cur_ext|,and|cur_area|to
match the contents of|name_of_file|.}
save_area_delimiter:= area_delimiter;save_ext_delimiter:= ext_delimiter;
save_name_in_progress:= name_in_progress;save_stop_at_space:= stop_at_space;
name_in_progress:= true;
begin_name;
stop_at_space:= false;
k:= 1;
while(k<=name_length)and(more_name(name_of_file[k]))do
incr(k);
stop_at_space:= save_stop_at_space;
end_name;
name_in_progress:= save_name_in_progress;
area_delimiter:= save_area_delimiter;ext_delimiter:= save_ext_delimiter;
#line 12320 "pdftexdir/pdftex.web"
end;
end;
function a_make_name_string(var f:alpha_file):str_number;
begin a_make_name_string:= make_name_string;
end;
function b_make_name_string(var f:byte_file):str_number;
begin b_make_name_string:= make_name_string;
end;
function w_make_name_string(var f:word_file):str_number;
begin w_make_name_string:= make_name_string;
end;

/*:551*//*552:*/
#line 2453 "pdftex-final.ch"
procedure scan_file_name;
label done;
var
save_warning_index:pointer;
begin
save_warning_index:= warning_index;
warning_index:= cur_cs;{store|cur_cs|here to remember until later}
/*430:*/
#line 9537 "pdftexdir/pdftex.web"

repeat get_x_token;
until(cur_cmd<> spacer)and(cur_cmd<> relax)

/*:430*/
#line 2460 "pdftex-final.ch"
;{here the program expands
tokens and removes spaces and\.{\\relax}es from the input.The\.{\\relax}
removal follows LuaTeX''s implementation,and other cases of
balanced text scanning.}
back_input;{return the last token to be read by either code path}
if cur_cmd= left_brace then
scan_file_name_braced
else
#line 12339 "pdftexdir/pdftex.web"
 begin name_in_progress:= true;begin_name;
/*432:*/
#line 9549 "pdftexdir/pdftex.web"

repeat get_x_token;
until cur_cmd<> spacer

/*:432*/
#line 12340 "pdftexdir/pdftex.web"
;
loop begin if(cur_cmd> other_char)or(cur_chr> 255)then{not a character}
begin back_input;goto done;
end;
#line 2473 "pdftex-final.ch"
{If|cur_chr|is a space and we're not scanning a token list, check
whether we're at the end of the buffer. Otherwise we end up adding
spurious spaces to file names in some cases.}
if(cur_chr= " ")and(state<> token_list)and(loc> limit)then goto done;
if not more_name(cur_chr)then goto done;
#line 12345 "pdftexdir/pdftex.web"
get_x_token;
end;
#line 2484 "pdftex-final.ch"
end;
done:end_name;name_in_progress:= false;
warning_index:= save_warning_index;{restore|warning_index|}
end;
#line 12349 "pdftexdir/pdftex.web"

/*:552*//*555:*/
#line 12380 "pdftexdir/pdftex.web"
procedure pack_job_name(s:str_number);{|s= ".log"|,|".dvi"|,or
|format_extension|}
begin cur_area:= "";cur_ext:= s;
cur_name:= job_name;pack_cur_name;
end;

/*:555*//*556:*/
#line 12393 "pdftexdir/pdftex.web"
procedure prompt_file_name(s,e:str_number);
label done;
#line 2493 "pdftex-final.ch"
var k:0..buf_size;{index into|buffer|}
saved_cur_name:str_number;{to catch empty terminal input}
saved_cur_ext:str_number;{to catch empty terminal input}
saved_cur_area:str_number;{to catch empty terminal input}
#line 12396 "pdftexdir/pdftex.web"
begin if interaction= scroll_mode then wake_up_terminal;
if s= "input file name"then print_err("I can't find file `")

else print_err("I can't write on file `");

print_file_name(cur_name,cur_area,cur_ext);print("'.");
#line 2502 "pdftex-final.ch"
if(e= ".tex")or(e= "")then show_context;
print_ln;print_c_string(prompt_file_name_help_msg);
if(e<> "")then
begin
print("; default file extension is `");print(e);print("'");
end;
print(")");print_ln;
#line 12403 "pdftexdir/pdftex.web"
print_nl("Please type another ");print(s);

if interaction<scroll_mode then
fatal_error("*** (job aborted, file error in nonstop mode)");

#line 2515 "pdftex-final.ch"
saved_cur_name:= cur_name;
saved_cur_ext:= cur_ext;
saved_cur_area:= cur_area;
clear_terminal;prompt_input(": ");/*557:*/
#line 12413 "pdftexdir/pdftex.web"

begin begin_name;k:= first;
while(buffer[k]= " ")and(k<last)do incr(k);
loop begin if k= last then goto done;
if not more_name(buffer[k])then goto done;
incr(k);
end;
done:end_name;
end

/*:557*/
#line 2518 "pdftex-final.ch"
;
if(length(cur_name)= 0)and(cur_ext= "")and(cur_area= "")then
begin
cur_name:= saved_cur_name;
cur_ext:= saved_cur_ext;
cur_area:= saved_cur_area;
end
else
if cur_ext= ""then cur_ext:= e;
#line 12410 "pdftexdir/pdftex.web"
pack_cur_name;
end;

/*:556*//*560:*/
#line 12444 "pdftexdir/pdftex.web"
procedure open_log_file;
var old_setting:0..max_selector;{previous|selector|setting}
k:0..buf_size;{index into|months|and|buffer|}
l:0..buf_size;{end of first input line}
#line 2539 "pdftex-final.ch"
months:const_cstring;
#line 12449 "pdftexdir/pdftex.web"
begin old_setting:= selector;
#line 2546 "pdftex-final.ch"
if job_name= 0 then job_name:= get_job_name("texput");

pack_job_name(".fls");
recorder_change_filename(stringcast(name_of_file+1));
#line 12452 "pdftexdir/pdftex.web"
pack_job_name(".log");
while not a_open_out(log_file)do/*561:*/
#line 12481 "pdftexdir/pdftex.web"

begin selector:= term_only;
prompt_file_name("transcript file name",".log");
end

/*:561*/
#line 12453 "pdftexdir/pdftex.web"
;
log_name:= a_make_name_string(log_file);
selector:= log_only;log_opened:= true;
#line 2555 "pdftex-final.ch"
/*562:*/
#line 12486 "pdftexdir/pdftex.web"

#line 2571 "pdftex-final.ch"
begin
if src_specials_p or file_line_error_style_p or parse_first_line_p
then
wlog(banner_k)
else
wlog(banner);
#line 2582 "pdftex-final.ch"
wlog(version_string);
slow_print(format_ident);print("  ");
#line 12489 "pdftexdir/pdftex.web"
print_int(day);print_char(" ");
#line 2589 "pdftex-final.ch"
months:= ' JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC';
#line 12491 "pdftexdir/pdftex.web"
for k:= 3*month-2 to 3*month do wlog(months[k]);
print_char(" ");print_int(year);print_char(" ");
print_two(time div 60);print_char(":");print_two(time mod 60);
if eTeX_ex then
begin;wlog_cr;wlog('entering extended mode');
end;
#line 2595 "pdftex-final.ch"
if shellenabledp then begin
wlog_cr;
wlog(' ');
if restrictedshell then begin
wlog('restricted ');
end;
wlog('\write18 enabled.')
end;
if src_specials_p then begin
wlog_cr;
wlog(' Source specials enabled.')
end;
if file_line_error_style_p then begin
wlog_cr;
wlog(' file:line:error style messages enabled.')
end;
if parse_first_line_p then begin
wlog_cr;
wlog(' %&-line parsing enabled.');
end;
if translate_filename then begin
wlog_cr;
wlog(' (');
fputs(translate_filename,log_file);
wlog(')');
end;
end
#line 12498 "pdftexdir/pdftex.web"

/*:562*/
#line 2555 "pdftex-final.ch"
;
if mltex_enabled_p then
begin wlog_cr;wlog('MLTeX v2.2 enabled');
end;
if enctex_enabled_p then
begin wlog_cr;wlog(encTeX_banner);wlog(', reencoding enabled');
if translate_filename then
begin wlog_cr;
wlog(' (\xordcode, \xchrcode, \xprncode overridden by TCX)');
end;
end;
#line 12457 "pdftexdir/pdftex.web"
input_stack[input_ptr]:= cur_input;{make sure bottom level is in memory}
print_nl("**");

l:= input_stack[0].limit_field;{last position of first line}
if buffer[l]= end_line_char then decr(l);
for k:= 1 to l do print(buffer[k]);
print_ln;{now the transcript file contains the first line of input}
selector:= old_setting+2;{|log_only|or|term_and_log|}
end;

/*:560*//*563:*/
#line 2627 "pdftex-final.ch"
procedure start_input;{\TeX\will\.{\\input}something}
#line 12503 "pdftexdir/pdftex.web"
label done;
#line 2641 "pdftex-final.ch"
var temp_str:str_number;
begin scan_file_name;{set|cur_name|to desired file name}
pack_cur_name;
loop begin
begin_file_reading;{set up|cur_file|and new level of input}
tex_input_type:= 1;{Tell|open_input|we are\.{\\input}.}
{Kpathsea tries all the various ways to get the file.}
if kpse_in_name_ok(stringcast(name_of_file+1))
and a_open_in(cur_file,kpse_tex_format)then
goto done;
#line 12513 "pdftexdir/pdftex.web"
end_file_reading;{remove the level that didn't work}
#line 2656 "pdftex-final.ch"
prompt_file_name("input file name","");
#line 12515 "pdftexdir/pdftex.web"
end;
#line 2662 "pdftex-final.ch"
done:name:= a_make_name_string(cur_file);
source_filename_stack[in_open]:= name;
full_source_filename_stack[in_open]:= make_full_name_string;
if name= str_ptr-1 then{we can try to conserve string pool space now}
begin temp_str:= search_string(name);
if temp_str> 0 then
begin name:= temp_str;flush_string;
end;
end;
#line 12517 "pdftexdir/pdftex.web"
if job_name= 0 then
#line 2676 "pdftex-final.ch"
 begin job_name:= get_job_name(cur_name);open_log_file;
#line 12519 "pdftexdir/pdftex.web"
end;{|open_log_file|doesn't |show_context|, so |limit|
and|loc|needn't be set to meaningful values yet}
#line 2684 "pdftex-final.ch"
if term_offset+length(full_source_filename_stack[in_open])> max_print_line-2
then print_ln
else if(term_offset> 0)or(file_offset> 0)then print_char(" ");
print_char("(");incr(open_parens);
slow_print(full_source_filename_stack[in_open]);update_terminal;
#line 12524 "pdftexdir/pdftex.web"
state:= new_line;
#line 2697 "pdftex-final.ch"
/*1915:*/
#line 6997 "pdftex-final.ch"

synctex_start_input;{Give control to the{\sl Sync\TeX}controller}

/*:1915*/
#line 2697 "pdftex-final.ch"
;
/*564:*/
#line 12537 "pdftexdir/pdftex.web"

begin line:= 1;
if input_ln(cur_file,false)then do_nothing;
firm_up_the_line;
if end_line_char_inactive then decr(limit)
else buffer[limit]:= end_line_char;
first:= limit+1;loc:= start;
end

/*:564*/
#line 2698 "pdftex-final.ch"
;
#line 12529 "pdftexdir/pdftex.web"
end;

/*:563*//*586:*/
#line 2898 "pdftex-final.ch"
/*1882:*/
#line 6326 "pdftex-final.ch"

function effective_char_info(f:internal_font_number;
c:quarterword):four_quarters;
label exit;
var ci:four_quarters;{character information bytes for|c|}
base_c:integer;{or|eightbits|:replacement base character}
begin if not mltex_enabled_p then
begin effective_char_info:= orig_char_info(f)(c);return;
end;
if font_ec[f]>=qo(c)then if font_bc[f]<=qo(c)then
begin ci:= orig_char_info(f)(c);{N.B.:not|char_info|(f)(c)}
if char_exists(ci)then
begin effective_char_info:= ci;return;
end;
end;
if qo(c)>=char_sub_def_min then if qo(c)<=char_sub_def_max then
if char_list_exists(qo(c))then
begin{|effective_char_info:= char_info(f)(qi(char_list_char(qo(c))));|}
base_c:= char_list_char(qo(c));
if font_ec[f]>=base_c then if font_bc[f]<=base_c then
begin ci:= orig_char_info(f)(qi(base_c));{N.B.:not|char_info|(f)(c)}
if char_exists(ci)then
begin effective_char_info:= ci;return;
end;
end;
end;
effective_char_info:= null_character;
exit:end;


/*:1882*/
#line 2898 "pdftex-final.ch"


function read_font_info(u:pointer;nom,aire:str_number;
#line 13043 "pdftexdir/pdftex.web"
s:scaled):internal_font_number;{input a\.{TFM}file}
label done,bad_tfm,not_found;
var k:font_index;{index into|font_info|}
#line 2906 "pdftex-final.ch"
name_too_long:boolean;{|nom|or|aire|exceeds 255 bytes?}
file_opened:boolean;{was|tfm_file|successfully opened?}
#line 13047 "pdftexdir/pdftex.web"
lf,lh,bc,ec,nw,nh,nd,ni,nl,nk,ne,np:halfword;
{sizes of subfiles}
f:internal_font_number;{the new font's number}
g:internal_font_number;{the number to return}
a,b,c,d:eight_bits;{byte variables}
qw:four_quarters;sw:scaled;{accumulators}
bch_label:integer;{left boundary start location,or infinity}
bchar:0. .256;{right boundary character,or 256}
z:scaled;{the design size or the``at''size}
alpha:integer;beta:1. .16;
{auxiliary quantities used in fixed-point multiplication}
begin g:= null_font;
/*588:*/
#line 13095 "pdftexdir/pdftex.web"

/*589:*/
#line 13107 "pdftexdir/pdftex.web"

file_opened:= false;
#line 2921 "pdftex-final.ch"
name_too_long:= (length(nom)> 255)or(length(aire)> 255);
if name_too_long then abort;
{|kpse_find_file|will append the|".tfm"|,and avoid searching the disk
before the font alias files as well.}
pack_file_name(nom,aire,"");
#line 13111 "pdftexdir/pdftex.web"
if not b_open_in(tfm_file)then abort;
file_opened:= true

/*:589*/
#line 13096 "pdftexdir/pdftex.web"
;
/*591:*/
#line 13135 "pdftexdir/pdftex.web"

begin read_sixteen(lf);
fget;read_sixteen(lh);
fget;read_sixteen(bc);
fget;read_sixteen(ec);
if(bc> ec+1)or(ec> 255)then abort;
if bc> 255 then{|bc= 256|and|ec= 255|}
begin bc:= 1;ec:= 0;
end;
fget;read_sixteen(nw);
fget;read_sixteen(nh);
fget;read_sixteen(nd);
fget;read_sixteen(ni);
fget;read_sixteen(nl);
fget;read_sixteen(nk);
fget;read_sixteen(ne);
fget;read_sixteen(np);
if lf<> 6+lh+(ec-bc+1)+nw+nh+nd+ni+nl+nk+ne+np then abort;
if(nw= 0)or(nh= 0)or(nd= 0)or(ni= 0)then abort;
end

/*:591*/
#line 13097 "pdftexdir/pdftex.web"
;
/*592:*/
#line 13162 "pdftexdir/pdftex.web"

lf:= lf-6-lh;{|lf|words should be loaded into|font_info|}
if np<7 then lf:= lf+7-np;{at least seven parameters will appear}
if(font_ptr= font_max)or(fmem_ptr+lf> font_mem_size)then
/*593:*/
#line 13178 "pdftexdir/pdftex.web"

begin start_font_error_message;
print(" not loaded: Not enough room left");

help4("I'm afraid I won't be able to make use of this font,")
("because my memory for character-size data is too small.")
("If you're really stuck, ask a wizard to enlarge me.")
("Or maybe try `I\font<same font id>=<name of loaded font>'.");
error;goto done;
end

/*:593*/
#line 13166 "pdftexdir/pdftex.web"
;
f:= font_ptr+1;
char_base[f]:= fmem_ptr-bc;
width_base[f]:= char_base[f]+ec+1;
height_base[f]:= width_base[f]+nw;
depth_base[f]:= height_base[f]+nh;
italic_base[f]:= depth_base[f]+nd;
lig_kern_base[f]:= italic_base[f]+ni;
kern_base[f]:= lig_kern_base[f]+nl-kern_base_offset;
exten_base[f]:= kern_base[f]+kern_base_offset+nk;
param_base[f]:= exten_base[f]+ne

/*:592*/
#line 13098 "pdftexdir/pdftex.web"
;
/*594:*/
#line 13191 "pdftexdir/pdftex.web"

begin if lh<2 then abort;
store_four_quarters(font_check[f]);
fget;read_sixteen(z);{this rejects a negative design size}
fget;z:= z*52 20)+(fbyte div 50
if z<unity then abort;
while lh> 2 do
begin fget;fget;fget;fget;decr(lh);{ignore the rest of the header}
end;
font_dsize[f]:= z;
if s<> -1000 then
if s>=0 then z:= s
else z:= xn_over_d(z,-s,1000);
font_size[f]:= z;
end

/*:594*/
#line 13099 "pdftexdir/pdftex.web"
;
/*595:*/
#line 13207 "pdftexdir/pdftex.web"

for k:= fmem_ptr to width_base[f]-1 do
begin store_four_quarters(font_info[k].qqqq);
if(a>=nw)or(b div 50 20>=nd)or
(c div 4>=ni)then abort;
case c mod 4 of
lig_tag:if d>=nl then abort;
ext_tag:if d>=ne then abort;
list_tag:/*596:*/
#line 13228 "pdftexdir/pdftex.web"

begin check_byte_range(d);
while d<current_character_being_worked_on do
#line 2939 "pdftex-final.ch"
 begin qw:= orig_char_info(f)(d);
#line 13232 "pdftexdir/pdftex.web"
{N.B.:not|qi(d)|,since|char_base[f]|hasn't been adjusted yet}
if char_tag(qw)<> list_tag then goto not_found;
d:= qo(rem_byte(qw));{next character on the list}
end;
if d= current_character_being_worked_on then abort;{yes,there's a cycle}
not_found:end

/*:596*/
#line 13215 "pdftexdir/pdftex.web"
;
othercases do_nothing{|no_tag|}
endcases;
end

/*:595*/
#line 13100 "pdftexdir/pdftex.web"
;
/*598:*/
#line 13291 "pdftexdir/pdftex.web"

begin/*599:*/
#line 13301 "pdftexdir/pdftex.web"

begin alpha:= 16;
if z>=49
while z>=52
begin z:= z div 2;alpha:= alpha+alpha;
end;
beta:= 256 div alpha;alpha:= alpha*z;
end

/*:599*/
#line 13292 "pdftexdir/pdftex.web"
;
for k:= width_base[f]to lig_kern_base[f]-1 do
store_scaled(font_info[k].sc);
if font_info[width_base[f]].sc<> 0 then abort;{\\{width}[0]must be zero}
if font_info[height_base[f]].sc<> 0 then abort;{\\{height}[0]must be zero}
if font_info[depth_base[f]].sc<> 0 then abort;{\\{depth}[0]must be zero}
if font_info[italic_base[f]].sc<> 0 then abort;{\\{italic}[0]must be zero}
end

/*:598*/
#line 13101 "pdftexdir/pdftex.web"
;
/*600:*/
#line 13316 "pdftexdir/pdftex.web"

bch_label:= 55
if nl> 0 then
begin for k:= lig_kern_base[f]to kern_base[f]+kern_base_offset-1 do
begin store_four_quarters(font_info[k].qqqq);
if a> 128 then
begin if 256*c+d>=nl then abort;
if a= 255 then if k= lig_kern_base[f]then bchar:= b;
end
else begin if b<> bchar then check_existence(b);
if c<128 then check_existence(d){check ligature}
else if 256*(c-128)+d>=nk then abort;{check kern}
if a<128 then if k-lig_kern_base[f]+a+1>=nl then abort;
end;
end;
if a= 255 then bch_label:= 256*c+d;
end;
for k:= kern_base[f]+kern_base_offset to exten_base[f]-1 do
store_scaled(font_info[k].sc);

/*:600*/
#line 13102 "pdftexdir/pdftex.web"
;
/*601:*/
#line 13336 "pdftexdir/pdftex.web"

for k:= exten_base[f]to param_base[f]-1 do
begin store_four_quarters(font_info[k].qqqq);
if a<> 0 then check_existence(a);
if b<> 0 then check_existence(b);
if c<> 0 then check_existence(c);
check_existence(d);
end

/*:601*/
#line 13103 "pdftexdir/pdftex.web"
;
/*602:*/
#line 13348 "pdftexdir/pdftex.web"

begin for k:= 1 to np do
if k= 1 then{the|slant|parameter is a pure number}
begin fget;sw:= fbyte;if sw> 127 then sw:= sw-256;
fget;sw:= sw*52 400+fbyte;
fget;font_info[param_base[f]].sc:= 
(sw*50 20);
end
else store_scaled(font_info[param_base[f]+k-1].sc);
#line 2951 "pdftex-final.ch"
if feof(tfm_file)then abort;
#line 13358 "pdftexdir/pdftex.web"
for k:= np+1 to 7 do font_info[param_base[f]+k-1].sc:= 0;
end

/*:602*/
#line 13104 "pdftexdir/pdftex.web"
;
/*603:*/
#line 13368 "pdftexdir/pdftex.web"

if np>=7 then font_params[f]:= np else font_params[f]:= 7;
hyphen_char[f]:= default_hyphen_char;skew_char[f]:= default_skew_char;
if bch_label<nl then bchar_label[f]:= bch_label+lig_kern_base[f]
else bchar_label[f]:= non_address;
font_bchar[f]:= qi(bchar);
font_false_bchar[f]:= qi(bchar);
if bchar<=ec then if bchar>=bc then
#line 2957 "pdftex-final.ch"
 begin qw:= orig_char_info(f)(bchar);{N.B.:not|qi(bchar)|}
#line 13377 "pdftexdir/pdftex.web"
if char_exists(qw)then font_false_bchar[f]:= non_char;
end;
font_name[f]:= nom;
font_area[f]:= aire;
font_bc[f]:= bc;font_ec[f]:= ec;font_glue[f]:= null;
adjust(char_base);adjust(width_base);adjust(lig_kern_base);
adjust(kern_base);adjust(exten_base);
decr(param_base[f]);
fmem_ptr:= fmem_ptr+lf;font_ptr:= f;g:= f;goto done

/*:603*/
#line 13105 "pdftexdir/pdftex.web"


/*:588*/
#line 13061 "pdftexdir/pdftex.web"
;
bad_tfm:/*587:*/
#line 13083 "pdftexdir/pdftex.web"

start_font_error_message;

if file_opened then print(" not loadable: Bad metric (TFM) file")
#line 2913 "pdftex-final.ch"
else if name_too_long then print(" not loadable: Metric (TFM) file name too long")
else print(" not loadable: Metric (TFM) file not found");
#line 13088 "pdftexdir/pdftex.web"
help5("I wasn't able to read the size data for this font,")
("so I will ignore the font specification.")
("[Wizards can fix TFM files using TFtoPL/PLtoTF.]")
("You might try inserting a different font spec;")
("e.g., type `I\font<same font id>=<substitute font name>'.");
error

/*:587*/
#line 13062 "pdftexdir/pdftex.web"
;
done:if file_opened then b_close(tfm_file);
read_font_info:= g;
end;

/*:586*//*597:*/
#line 13263 "pdftexdir/pdftex.web"
function store_scaled_f(sq,z:scaled):scaled;
var a,b,c,d:eight_bits;sw:scaled;
alpha:integer;
beta:1. .16;
begin
alpha:= 16;
if z>=49
while z>=52
begin z:= z div 2;alpha:= alpha+alpha;
end;
beta:= 256 div alpha;alpha:= alpha*z;
if sq>=0 then begin
d:= sq mod 256;sq:= sq div 256;{any"mod 256"not really needed,would typecast alone be safe?}
c:= sq mod 256;sq:= sq div 256;
b:= sq mod 256;sq:= sq div 256;
a:= sq mod 256;
end else begin
sq:= (sq+1073741824)+1073741824;{braces for optimizing compiler}
d:= sq mod 256;sq:= sq div 256;
c:= sq mod 256;sq:= sq div 256;
b:= sq mod 256;sq:= sq div 256;
a:= (sq+128)mod 256;
end;
sw:= (((((d*z)div 52 400)+(b*z))div beta;
if a= 0 then store_scaled_f:= sw else if a= 255 then store_scaled_f:= sw-alpha else pdf_error("store_scaled_f","vf scaling");
end;


/*:597*//*608:*/
#line 2982 "pdftex-final.ch"
procedure char_warning(f:internal_font_number;c:eight_bits);
var old_setting:integer;{saved value of|tracing_online|}
begin if tracing_lost_chars> 0 then
begin old_setting:= tracing_online;
if eTeX_ex and(tracing_lost_chars> 1)then tracing_online:= 1;
if tracing_lost_chars> 2 then
print_err("Missing character: There is no ")
else begin
begin_diagnostic;
print_nl("Missing character: There is no ")
end;

print_ASCII(c);
if tracing_lost_chars> 2 then begin
print(" (");
print_hex(c);
print(")");
end;
print(" in font ");
slow_print(font_name[f]);
if tracing_lost_chars<3 then print_char("!");
tracing_online:= old_setting;
if tracing_lost_chars> 2 then begin
help0;
error;
end else end_diagnostic(false);
end;{of|tracing_lost_chars> 0|}
end;{of procedure}
#line 13503 "pdftexdir/pdftex.web"

/*:608*//*609:*/
#line 3023 "pdftex-final.ch"
function new_character(f:internal_font_number;c:eight_bits):pointer;
label exit;
var p:pointer;{newly allocated node}
ec:quarterword;{effective character of|c|}
begin ec:= effective_char(false,f,qi(c));
if font_bc[f]<=qo(ec)then if font_ec[f]>=qo(ec)then
if char_exists(orig_char_info(f)(ec))then{N.B.:not|char_info|}
#line 13513 "pdftexdir/pdftex.web"
begin p:= get_avail;font(p):= f;character(p):= qi(c);
new_character:= p;return;
end;
char_warning(f,c);
new_character:= null;
exit:end;

/*:609*//*625:*/
#line 14130 "pdftexdir/pdftex.web"
procedure dvi_swap;{outputs half of the buffer}
#line 3075 "pdftex-final.ch"
begin if dvi_ptr> (7FFFFFFF-dvi_offset)then
begin cur_s:= -2;
fatal_error("dvi length exceeds ""7FFFFFFF");

end;
if dvi_limit= dvi_buf_size then
#line 14132 "pdftexdir/pdftex.web"
 begin write_dvi(0,half_buf-1);dvi_limit:= half_buf;
dvi_offset:= dvi_offset+dvi_buf_size;dvi_ptr:= 0;
end
else begin write_dvi(half_buf,dvi_buf_size-1);dvi_limit:= dvi_buf_size;
end;
dvi_gone:= dvi_gone+half_buf;
end;

/*:625*//*627:*/
#line 14150 "pdftexdir/pdftex.web"
procedure dvi_four(x:integer);
begin if x>=0 then dvi_out(x div 49
else begin x:= x+49
x:= x+49
dvi_out((x div 49
end;
x:= x mod 49 200000);
x:= x mod 50 400);
dvi_out(x mod 52
end;

/*:627*//*628:*/
#line 14166 "pdftexdir/pdftex.web"
procedure dvi_pop(l:integer);
begin if(l= dvi_offset+dvi_ptr)and(dvi_ptr> 0)then decr(dvi_ptr)
else dvi_out(pop);
end;

/*:628*//*629:*/
#line 14174 "pdftexdir/pdftex.web"
procedure dvi_font_def(f:internal_font_number);
var k:pool_pointer;{index into|str_pool|}
#line 3098 "pdftex-final.ch"
begin if f<=256+font_base then
begin dvi_out(fnt_def1);
dvi_out(f-font_base-1);
end
else begin dvi_out(fnt_def1+1);
dvi_out((f-font_base-1)div 52
dvi_out((f-font_base-1)mod 52
end;
#line 14178 "pdftexdir/pdftex.web"
dvi_out(qo(font_check[f].b0));
dvi_out(qo(font_check[f].b1));
dvi_out(qo(font_check[f].b2));
dvi_out(qo(font_check[f].b3));
dvi_four(font_size[f]);
dvi_four(font_dsize[f]);
dvi_out(length(font_area[f]));
dvi_out(length(font_name[f]));
/*630:*/
#line 14189 "pdftexdir/pdftex.web"

for k:= str_start[font_area[f]]to str_start[font_area[f]+1]-1 do
dvi_out(so(str_pool[k]));
for k:= str_start[font_name[f]]to str_start[font_name[f]+1]-1 do
dvi_out(so(str_pool[k]))

/*:630*/
#line 14186 "pdftexdir/pdftex.web"
;
end;

/*:629*//*634:*/
#line 14268 "pdftexdir/pdftex.web"
procedure movement(w:scaled;o:eight_bits);
label exit,found,not_found,2,1;
var mstate:small_number;{have we seen a|y|or|z|?}
p,q:pointer;{current and top nodes on the stack}
k:integer;{index into|dvi_buf|,modulo|dvi_buf_size|}
begin q:= get_node(movement_node_size);{new node for the top of the stack}
width(q):= w;location(q):= dvi_offset+dvi_ptr;
if o= down1 then
begin link(q):= down_ptr;down_ptr:= q;
end
else begin link(q):= right_ptr;right_ptr:= q;
end;
/*638:*/
#line 14384 "pdftexdir/pdftex.web"

p:= link(q);mstate:= none_seen;
while p<> null do
begin if width(p)= w then/*639:*/
#line 14403 "pdftexdir/pdftex.web"

case mstate+info(p)of
none_seen+yz_OK,none_seen+y_OK,z_seen+yz_OK,z_seen+y_OK:
if location(p)<dvi_gone then goto not_found
else/*640:*/
#line 14415 "pdftexdir/pdftex.web"

begin k:= location(p)-dvi_offset;
if k<0 then k:= k+dvi_buf_size;
dvi_buf[k]:= dvi_buf[k]+y1-down1;
info(p):= y_here;goto found;
end

/*:640*/
#line 14407 "pdftexdir/pdftex.web"
;
none_seen+z_OK,y_seen+yz_OK,y_seen+z_OK:
if location(p)<dvi_gone then goto not_found
else/*641:*/
#line 14422 "pdftexdir/pdftex.web"

begin k:= location(p)-dvi_offset;
if k<0 then k:= k+dvi_buf_size;
dvi_buf[k]:= dvi_buf[k]+z1-down1;
info(p):= z_here;goto found;
end

/*:641*/
#line 14410 "pdftexdir/pdftex.web"
;
none_seen+y_here,none_seen+z_here,y_seen+z_here,z_seen+y_here:goto found;
othercases do_nothing
endcases

/*:639*/
#line 14388 "pdftexdir/pdftex.web"

else case mstate+info(p)of
none_seen+y_here:mstate:= y_seen;
none_seen+z_here:mstate:= z_seen;
y_seen+z_here,z_seen+y_here:goto not_found;
othercases do_nothing
endcases;
p:= link(p);
end;
not_found:

/*:638*/
#line 14281 "pdftexdir/pdftex.web"
;
/*637:*/
#line 14351 "pdftexdir/pdftex.web"

info(q):= yz_OK;
if abs(w)>=52
begin dvi_out(o+3);{|down4|or|right4|}
dvi_four(w);return;
end;
if abs(w)>=49
begin dvi_out(o+2);{|down3|or|right3|}
if w<0 then w:= w+49
dvi_out(w div 50 200000;goto 2;
end;
if abs(w)>=50
begin dvi_out(o+1);{|down2|or|right2|}
if w<0 then w:= w+50
goto 2;
end;
dvi_out(o);{|down1|or|right1|}
if w<0 then w:= w+52
goto 1;
2:dvi_out(w div 52
1:dvi_out(w mod 52

/*:637*/
#line 14282 "pdftexdir/pdftex.web"
;
found:/*636:*/
#line 14327 "pdftexdir/pdftex.web"

info(q):= info(p);
if info(q)= y_here then
begin dvi_out(o+y0-down1);{|y0|or|w0|}
while link(q)<> p do
begin q:= link(q);
case info(q)of
yz_OK:info(q):= z_OK;
y_OK:info(q):= d_fixed;
othercases do_nothing
endcases;
end;
end
else begin dvi_out(o+z0-down1);{|z0|or|x0|}
while link(q)<> p do
begin q:= link(q);
case info(q)of
yz_OK:info(q):= y_OK;
z_OK:info(q):= d_fixed;
othercases do_nothing
endcases;
end;
end

/*:636*/
#line 14284 "pdftexdir/pdftex.web"
;
exit:end;

/*:634*//*642:*/
#line 14435 "pdftexdir/pdftex.web"
procedure prune_movements(l:integer);
{delete movement nodes with|location>=l|}
label done,exit;
var p:pointer;{node being deleted}
begin while down_ptr<> null do
begin if location(down_ptr)<l then goto done;
p:= down_ptr;down_ptr:= link(p);free_node(p,movement_node_size);
end;
done:while right_ptr<> null do
begin if location(right_ptr)<l then return;
p:= right_ptr;right_ptr:= link(p);free_node(p,movement_node_size);
end;
exit:end;

/*:642*//*646:*/
#line 14554 "pdftexdir/pdftex.web"
procedure vlist_out;forward;{|hlist_out|and|vlist_out|are mutually
recursive}

/*:646*//*647:*/
#line 14567 "pdftexdir/pdftex.web"
/*1612:*/
#line 35717 "pdftexdir/pdftex.web"

procedure special_out(p:pointer);
var old_setting:0..max_selector;{holds print|selector|}
k:pool_pointer;{index into|str_pool|}
begin synch_h;synch_v;
#line 5650 "pdftex-final.ch"
old_setting:= selector;selector:= new_string;
spec_sout:= spec_out;spec_out:= write_stream(p)-mubyte_zero;
mubyte_sout:= mubyte_out;mubyte_out:= write_mubyte(p)-mubyte_zero;
active_noconvert:= true;
mubyte_slog:= mubyte_log;
mubyte_log:= 0;
if(mubyte_out> 0)or(mubyte_out= -1)then mubyte_log:= 1;
if(spec_out= 2)or(spec_out= 3)then
begin
if(mubyte_out> 0)or(mubyte_out= -1)then
begin
special_printing:= true;mubyte_log:= 1;
end;
if mubyte_out> 1 then cs_converting:= true;
end;
#line 35723 "pdftexdir/pdftex.web"
show_token_list(link(write_tokens(p)),null,pool_size-pool_ptr);
selector:= old_setting;
str_room(1);
if cur_length<256 then
begin dvi_out(xxx1);dvi_out(cur_length);
end
else begin dvi_out(xxx4);dvi_four(cur_length);
end;
#line 5670 "pdftex-final.ch"
if(spec_out= 1)or(spec_out= 3)then
for k:= str_start[str_ptr]to pool_ptr-1 do
str_pool[k]:= si(xchr[so(str_pool[k])]);
for k:= str_start[str_ptr]to pool_ptr-1 do dvi_out(so(str_pool[k]));
spec_out:= spec_sout;mubyte_out:= mubyte_sout;mubyte_log:= mubyte_slog;
special_printing:= false;cs_converting:= false;
active_noconvert:= false;
#line 35732 "pdftexdir/pdftex.web"
pool_ptr:= str_start[str_ptr];{erase the string}
end;

/*:1612*//*1614:*/
#line 35748 "pdftexdir/pdftex.web"

procedure write_out(p:pointer);
var old_setting:0..max_selector;{holds print|selector|}
old_mode:integer;{saved|mode|}
j:small_number;{write stream number}
q,r:pointer;{temporary variables for list manipulation}
#line 5682 "pdftex-final.ch"
d:integer;{number of characters in incomplete current string}
clobbered:boolean;{system string is ok?}
runsystem_ret:integer;{return value from|runsystem|}
begin
mubyte_sout:= mubyte_out;mubyte_out:= write_mubyte(p)-mubyte_zero;
if(mubyte_out> 2)or(mubyte_out= -1)or(mubyte_out= -2)then
write_noexpanding:= true;
/*1615:*/
#line 35776 "pdftexdir/pdftex.web"

q:= get_avail;info(q):= right_brace_token+"}";
r:= get_avail;link(q):= r;info(r):= end_write_token;ins_list(q);
begin_token_list(write_tokens(p),write_text);
q:= get_avail;info(q):= left_brace_token+"{";ins_list(q);
{now we're ready to scan
`\.\{$\langle\,$token list$\,\rangle$\.{\}\\endwrite}'}
old_mode:= mode;mode:= 0;
{disable\.{\\prevdepth},\.{\\spacefactor},\.{\\lastskip},\.{\\prevgraf}}
cur_cs:= write_loc;q:= scan_toks(false,true);{expand macros,etc.}
get_token;if cur_tok<> end_write_token then
/*1616:*/
#line 35791 "pdftexdir/pdftex.web"

begin print_err("Unbalanced write command");

help2("On this page there's a \write with fewer real {'s than }'s.")
("I can't handle that very well; good luck.");error;
repeat get_token;
until cur_tok= end_write_token;
end

/*:1616*/
#line 35787 "pdftexdir/pdftex.web"
;
mode:= old_mode;
end_token_list{conserve stack space}

/*:1615*/
#line 35755 "pdftexdir/pdftex.web"
;
#line 35756 "pdftexdir/pdftex.web"
old_setting:= selector;j:= write_stream(p);
#line 5695 "pdftex-final.ch"
if j= 18 then selector:= new_string
else if write_open[j]then selector:= j
#line 35758 "pdftexdir/pdftex.web"
 else begin{write to the terminal if file isn't open}
if(j= 17)and(selector= term_and_log)then selector:= log_only;
print_nl("");
end;
#line 5702 "pdftex-final.ch"
active_noconvert:= true;
if mubyte_out> 1 then cs_converting:= true;
mubyte_slog:= mubyte_log;
if(mubyte_out> 0)or(mubyte_out= -1)then mubyte_log:= 1
else mubyte_log:= 0;
token_show(def_ref);print_ln;
cs_converting:= false;write_noexpanding:= false;
active_noconvert:= false;
mubyte_out:= mubyte_sout;mubyte_log:= mubyte_slog;
#line 5716 "pdftex-final.ch"
flush_list(def_ref);
if j= 18 then
begin if(tracing_online<=0)then
selector:= log_only{Show what we're doing in the log file.}
else selector:= term_and_log;{Show what we're doing.}
{If the log file isn't open yet, we can only send output to the terminal.
Calling|open_log_file|from here seems to result in bad data in the log.}
if not log_opened then selector:= term_only;
print_nl("runsystem(");
for d:= 0 to cur_length-1 do
begin{|print|gives up if passed|str_ptr|,so do it by hand.}
print(so(str_pool[str_start[str_ptr]+d]));{N.B.:not|print_char|}
end;
print(")...");
if shellenabledp then begin
str_room(1);append_char(0);{Append a null byte to the expansion.}
clobbered:= false;
for d:= 0 to cur_length-1 do{Convert to external character set.}
begin
str_pool[str_start[str_ptr]+d]:= xchr[str_pool[str_start[str_ptr]+d]];
if(str_pool[str_start[str_ptr]+d]= null_code)
and(d<cur_length-1)then clobbered:= true;
{minimal checking:NUL not allowed in argument string of|system|()}
end;
if clobbered then print("clobbered")
else begin{We have the command.See if we're allowed to execute it,
and report in the log.We don't check the actual exit status of
the command,or do anything with the output.}
runsystem_ret:= runsystem(conststringcast(addressof(
str_pool[str_start[str_ptr]])));
if runsystem_ret= -1 then print("quotation error in system command")
else if runsystem_ret= 0 then print("disabled (restricted)")
else if runsystem_ret= 1 then print("executed")
else if runsystem_ret= 2 then print("executed safely (allowed)")
end;
end else begin
print("disabled");{|shellenabledp|false}
end;
print_char(".");print_nl("");print_ln;
pool_ptr:= str_start[str_ptr];{erase the string}
end;
selector:= old_setting;
#line 35764 "pdftexdir/pdftex.web"
end;

/*:1614*//*1617:*/
#line 35803 "pdftexdir/pdftex.web"

#line 5764 "pdftex-final.ch"
procedure out_what(p:pointer);
var j:small_number;{write stream number}
old_setting:0..max_selector;
#line 35806 "pdftexdir/pdftex.web"
begin case subtype(p)of
open_node,write_node,close_node:/*1619:*/
#line 35835 "pdftexdir/pdftex.web"

if not doing_leaders then
begin j:= write_stream(p);
if subtype(p)= write_node then write_out(p)
#line 5773 "pdftex-final.ch"
else begin if write_open[j]then begin a_close(write_file[j]);
write_open[j]:= false;end;
if subtype(p)= close_node then do_nothing{already closed}
#line 35841 "pdftexdir/pdftex.web"
else if j<16 then
begin cur_name:= open_name(p);cur_area:= open_area(p);
cur_ext:= open_ext(p);
if cur_ext= ""then cur_ext:= ".tex";
pack_cur_name;
#line 5783 "pdftex-final.ch"
while not kpse_out_name_ok(stringcast(name_of_file+1))
or not a_open_out(write_file[j])do
prompt_file_name("output file name",".tex");
write_open[j]:= true;
{If on first line of input,log file is not ready yet,so don't log.}
if log_opened and texmf_yesno('log_openout')then begin
old_setting:= selector;
if(tracing_online<=0)then
selector:= log_only{Show what we're doing in the log file.}
else selector:= term_and_log;{Show what we're doing.}
print_nl("\openout");
print_int(j);
print(" = `");
print_file_name(cur_name,cur_area,cur_ext);
print("'.");print_nl("");print_ln;
selector:= old_setting;
end;
#line 35849 "pdftexdir/pdftex.web"
end;
end;
end

/*:1619*/
#line 35808 "pdftexdir/pdftex.web"
;
special_node:special_out(p);
language_node:do_nothing;
pdf_save_pos_node:
/*1618:*/
#line 35823 "pdftexdir/pdftex.web"

begin
{4736286= 1 in,the funny DVI origin offset}
pdf_last_x_pos:= cur_h+4736286;
pdf_last_y_pos:= cur_page_height-cur_v-4736286;
end

/*:1618*/
#line 35812 "pdftexdir/pdftex.web"
;
others:begin
if(pdftex_first_extension_code<=subtype(p))and(subtype(p)<=pdftex_last_extension_code)then
pdf_error("ext4","pdf node ended up in DVI mode")
else
confusion("ext4")

end;
endcases;
end;

/*:1617*//*1716:*/
#line 37671 "pdftexdir/pdftex.web"

function new_edge(s:small_number;w:scaled):pointer;
{create an edge node}
var p:pointer;{the new node}
begin p:= get_node(edge_node_size);type(p):= edge_node;subtype(p):= s;
width(p):= w;edge_dist(p):= 0;{the|edge_dist|field will be set later}
new_edge:= p;
end;

/*:1716*//*1720:*/
#line 37717 "pdftexdir/pdftex.web"

function reverse(this_box,t:pointer;var cur_g:scaled;
var cur_glue:real):pointer;
label reswitch,next_p,done;
var l:pointer;{the new list}
p:pointer;{the current node}
q:pointer;{the next node}
g_order:glue_ord;{applicable order of infinity for glue}
g_sign:normal..shrinking;{selects type of glue}
glue_temp:real;{glue value before rounding}
m,n:halfword;{count of unmatched math nodes}
begin g_order:= glue_order(this_box);g_sign:= glue_sign(this_box);
l:= t;p:= temp_ptr;m:= min_halfword;n:= min_halfword;
loop begin while p<> null do
/*1721:*/
#line 37740 "pdftexdir/pdftex.web"

reswitch:if is_char_node(p)then
repeat f:= font(p);c:= character(p);
cur_h:= cur_h+char_width(f)(char_info(f)(c));
q:= link(p);link(p):= l;l:= p;p:= q;
until not is_char_node(p)
else/*1722:*/
#line 37748 "pdftexdir/pdftex.web"

begin q:= link(p);
case type(p)of
hlist_node,vlist_node,rule_node,kern_node:rule_wd:= width(p);
/*1723:*/
#line 37767 "pdftexdir/pdftex.web"

glue_node:begin round_glue;
/*1696:*/
#line 37425 "pdftexdir/pdftex.web"

if(((g_sign= stretching)and(stretch_order(g)= g_order))or
((g_sign= shrinking)and(shrink_order(g)= g_order)))then
begin fast_delete_glue_ref(g);
if subtype(p)<a_leaders then
begin type(p):= kern_node;width(p):= rule_wd;
end
else begin g:= get_node(glue_spec_size);
stretch_order(g):= filll+1;shrink_order(g):= filll+1;{will never match}
width(g):= rule_wd;stretch(g):= 0;shrink(g):= 0;glue_ptr(p):= g;
end;
end

/*:1696*/
#line 37769 "pdftexdir/pdftex.web"
;
end;

/*:1723*//*1724:*/
#line 37774 "pdftexdir/pdftex.web"

ligature_node:begin flush_node_list(lig_ptr(p));
temp_ptr:= p;p:= get_avail;mem[p]:= mem[lig_char(temp_ptr)];link(p):= q;
free_node(temp_ptr,small_node_size);goto reswitch;
end;

/*:1724*//*1725:*/
#line 37783 "pdftexdir/pdftex.web"

math_node:begin rule_wd:= width(p);
if end_LR(p)then
if info(LR_ptr)<> end_LR_type(p)then
begin type(p):= kern_node;incr(LR_problems);
end
else begin pop_LR;
if n> min_halfword then
begin decr(n);decr(subtype(p));{change|after|into|before|}
end
else begin type(p):= kern_node;
if m> min_halfword then decr(m)
else/*1726:*/
#line 5873 "pdftex-final.ch"

begin free_node(p,medium_node_size);{{\sl Sync\TeX}:p is a|kern_node|}
link(t):= q;width(t):= rule_wd;edge_dist(t):= -cur_h-rule_wd;goto done;
end
#line 37815 "pdftexdir/pdftex.web"

/*:1726*/
#line 37795 "pdftexdir/pdftex.web"
;
end;
end
else begin push_LR(p);
if(n> min_halfword)or(LR_dir(p)<> cur_dir)then
begin incr(n);incr(subtype(p));{change|before|into|after|}
end
else begin type(p):= kern_node;incr(m);
end;
end;
end;

/*:1725*/
#line 37752 "pdftexdir/pdftex.web"

edge_node:confusion("LR2");

othercases goto next_p
endcases;
cur_h:= cur_h+rule_wd;
next_p:link(p):= l;
#line 5862 "pdftex-final.ch"
if type(p)= kern_node then if(rule_wd= 0)or(l= null)then
begin free_node(p,medium_node_size);p:= l;
end;
#line 37762 "pdftexdir/pdftex.web"
l:= p;p:= q;
end

/*:1722*/
#line 37746 "pdftexdir/pdftex.web"


/*:1721*/
#line 37732 "pdftexdir/pdftex.web"
;
if(t= null)and(m= min_halfword)and(n= min_halfword)then goto done;
p:= new_math(0,info(LR_ptr));LR_problems:= LR_problems+10000;
{manufacture one missing math node}
end;
done:reverse:= l;
end;

/*:1720*/
#line 14567 "pdftexdir/pdftex.web"

#line 3130 "pdftex-final.ch"
procedure hlist_out;{output an|hlist_node|box}
label reswitch,move_past,fin_rule,next_p,continue,found;
#line 14570 "pdftexdir/pdftex.web"
var base_line:scaled;{the baseline coordinate for this box}
left_edge:scaled;{the left coordinate for this box}
save_h,save_v:scaled;{what|dvi_h|and|dvi_v|should pop to}
this_box:pointer;{pointer to containing box}
g_order:glue_ord;{applicable order of infinity for glue}
g_sign:normal..shrinking;{selects type of glue}
p:pointer;{current position in the hlist}
save_loc:integer;{\.{DVI}byte location upon entry}
leader_box:pointer;{the leader box being replicated}
leader_wd:scaled;{width of leader box being replicated}
lx:scaled;{extra space between leader boxes}
outer_doing_leaders:boolean;{were we doing leaders?}
edge:scaled;{right edge of sub-box or leader space}
prev_p:pointer;{one step behind|p|}
glue_temp:real;{glue value before rounding}
cur_glue:real;{glue seen so far}
cur_g:scaled;{rounded equivalent of|cur_glue|times the glue ratio}
begin cur_g:= 0;cur_glue:= float_constant(0);
this_box:= temp_ptr;g_order:= glue_order(this_box);
g_sign:= glue_sign(this_box);p:= list_ptr(this_box);
incr(cur_s);
if cur_s> 0 then dvi_out(push);
if cur_s> max_push then max_push:= cur_s;
save_loc:= dvi_offset+dvi_ptr;base_line:= cur_v;
prev_p:= this_box+list_offset;
/*1711:*/
#line 37615 "pdftexdir/pdftex.web"

if eTeX_ex then
begin/*1707:*/
#line 37583 "pdftexdir/pdftex.web"

put_LR(before){this will never match}

/*:1707*/
#line 37617 "pdftexdir/pdftex.web"
;
if box_lr(this_box)= dlist then
if cur_dir= right_to_left then
begin cur_dir:= left_to_right;cur_h:= cur_h-width(this_box);
end
else set_box_lr(this_box)(0);
if(cur_dir= right_to_left)and(box_lr(this_box)<> reversed)then
/*1718:*/
#line 5841 "pdftex-final.ch"

begin save_h:= cur_h;temp_ptr:= p;p:= new_kern(0);
sync_tag(p+medium_node_size):= 0;{{\sl Sync\TeX}:do nothing,it is too late}
link(prev_p):= p;
#line 37690 "pdftexdir/pdftex.web"
cur_h:= 0;link(p):= reverse(this_box,null,cur_g,cur_glue);width(p):= -cur_h;
cur_h:= save_h;set_box_lr(this_box)(reversed);
end

/*:1718*/
#line 37624 "pdftexdir/pdftex.web"
;
end

/*:1711*/
#line 14595 "pdftexdir/pdftex.web"
;
left_edge:= cur_h;
#line 3138 "pdftex-final.ch"
/*1924:*/
#line 7033 "pdftex-final.ch"

synctex_hlist(this_box);

/*:1924*/
#line 3138 "pdftex-final.ch"
;
while p<> null do/*648:*/
#line 3170 "pdftex-final.ch"

#line 14612 "pdftexdir/pdftex.web"
 reswitch:if is_char_node(p)then
begin synch_h;synch_v;
repeat f:= font(p);c:= character(p);
if f<> dvi_f then/*649:*/
#line 14627 "pdftexdir/pdftex.web"

begin if not font_used[f]then
begin dvi_font_def(f);font_used[f]:= true;
end;
if f<=64+font_base then dvi_out(f-font_base-1+fnt_num_0)
#line 3201 "pdftex-final.ch"
else if f<=256+font_base then
begin dvi_out(fnt1);dvi_out(f-font_base-1);
end
else begin dvi_out(fnt1+1);
dvi_out((f-font_base-1)div 52
dvi_out((f-font_base-1)mod 52
end;
#line 14634 "pdftexdir/pdftex.web"
dvi_f:= f;
end

#line 3213 "pdftex-final.ch"
/*:649*/
#line 14615 "pdftexdir/pdftex.web"
;
#line 3178 "pdftex-final.ch"
if font_ec[f]>=qo(c)then if font_bc[f]<=qo(c)then
if char_exists(orig_char_info(f)(c))then{N.B.:not|char_info|}
begin if c>=qi(128)then dvi_out(set1);
dvi_out(qo(c));
cur_h:= cur_h+char_width(f)(orig_char_info(f)(c));
goto continue;
end;
if mltex_enabled_p then
/*1883:*/
#line 6375 "pdftex-final.ch"

begin
/*1886:*/
#line 6416 "pdftex-final.ch"

if qo(c)>=char_sub_def_min then if qo(c)<=char_sub_def_max then
if char_list_exists(qo(c))then
begin base_c:= char_list_char(qo(c));
accent_c:= char_list_accent(qo(c));
if(font_ec[f]>=base_c)then if(font_bc[f]<=base_c)then
if(font_ec[f]>=accent_c)then if(font_bc[f]<=accent_c)then
begin ia_c:= char_info(f)(qi(accent_c));
ib_c:= char_info(f)(qi(base_c));
if char_exists(ib_c)then
if char_exists(ia_c)then goto found;
end;
begin_diagnostic;
print_nl("Missing character: Incomplete substitution ");

print_ASCII(qo(c));print(" = ");print_ASCII(accent_c);
print(" ");print_ASCII(base_c);print(" in font ");
slow_print(font_name[f]);print_char("!");end_diagnostic(false);
goto continue;
end;
begin_diagnostic;
print_nl("Missing character: There is no ");print("substitution for ");

print_ASCII(qo(c));print(" in font ");
slow_print(font_name[f]);print_char("!");end_diagnostic(false);
goto continue


/*:1886*/
#line 6378 "pdftex-final.ch"
;
found:/*1887:*/
#line 6446 "pdftex-final.ch"

if tracing_lost_chars> 99 then
begin begin_diagnostic;
print_nl("Using character substitution: ");
print_ASCII(qo(c));print(" = ");
print_ASCII(accent_c);print(" ");print_ASCII(base_c);
print(" in font ");slow_print(font_name[f]);print_char(".");
end_diagnostic(false);
end


/*:1887*/
#line 6379 "pdftex-final.ch"
;
/*1888:*/
#line 6469 "pdftex-final.ch"

base_x_height:= x_height(f);
base_slant:= slant(f)/float_constant(65536);

accent_slant:= base_slant;{slant of accent character font}
base_width:= char_width(f)(ib_c);
base_height:= char_height(f)(height_depth(ib_c));
accent_width:= char_width(f)(ia_c);
accent_height:= char_height(f)(height_depth(ia_c));
{compute necessary horizontal shift(don't forget slant)}@/
delta:= round((base_width-accent_width)/float_constant(2)+
base_height*base_slant-base_x_height*accent_slant);


dvi_h:= cur_h;{update|dvi_h|,similar to the last statement in module 620}
{1. For centering/horizontal shifting insert a kern node.}
cur_h:= cur_h+delta;synch_h;
{2. Then insert the accent character possibly shifted up or down.}
if((base_height<> base_x_height)and(accent_height> 0))then
begin{the accent must be shifted up or down}
cur_v:= base_line+(base_x_height-base_height);synch_v;
if accent_c>=128 then dvi_out(set1);
dvi_out(accent_c);
cur_v:= base_line;
end
else begin synch_v;
if accent_c>=128 then dvi_out(set1);
dvi_out(accent_c);
end;
cur_h:= cur_h+accent_width;dvi_h:= cur_h;
{3. For centering/horizontal shifting insert another kern node.}
cur_h:= cur_h+(-accent_width-delta);
{4. Output the base character.}
synch_h;synch_v;
if base_c>=128 then dvi_out(set1);
dvi_out(base_c);
cur_h:= cur_h+base_width;
dvi_h:= cur_h{update of|dvi_h|is unnecessary,will be set in module 620}

/*:1888*/
#line 6380 "pdftex-final.ch"
;
end


/*:1883*/
#line 3186 "pdftex-final.ch"
;
continue:
#line 14619 "pdftexdir/pdftex.web"
prev_p:= link(prev_p);{N.B.:not|prev_p:= p|,|p|might be|lig_trick|}
p:= link(p);
#line 3193 "pdftex-final.ch"
until not is_char_node(p);
/*1927:*/
#line 7047 "pdftex-final.ch"

synctex_current;

/*:1927*/
#line 3194 "pdftex-final.ch"
;
#line 14622 "pdftexdir/pdftex.web"
dvi_h:= cur_h;
end
else/*650:*/
#line 3213 "pdftex-final.ch"

#line 14638 "pdftexdir/pdftex.web"
 begin case type(p)of
hlist_node,vlist_node:/*651:*/
#line 3245 "pdftex-final.ch"

if list_ptr(p)= null then begin
/*1926:*/
#line 7039 "pdftex-final.ch"

if type(p)= vlist_node then begin
synctex_void_vlist(p,this_box);
end
else begin
synctex_void_hlist(p,this_box);
end;

/*:1926*/
#line 3247 "pdftex-final.ch"
;
cur_h:= cur_h+width(p);
end
#line 14660 "pdftexdir/pdftex.web"
 else begin save_h:= dvi_h;save_v:= dvi_v;
cur_v:= base_line+shift_amount(p);{shift the box down}
temp_ptr:= p;edge:= cur_h+width(p);
if cur_dir= right_to_left then cur_h:= edge;
if type(p)= vlist_node then vlist_out else hlist_out;
dvi_h:= save_h;dvi_v:= save_v;
cur_h:= edge;cur_v:= base_line;
end

/*:651*/
#line 14639 "pdftexdir/pdftex.web"
;
rule_node:begin rule_ht:= height(p);rule_dp:= depth(p);rule_wd:= width(p);
goto fin_rule;
end;
whatsit_node:/*1611:*/
#line 35710 "pdftexdir/pdftex.web"

out_what(p)

/*:1611*/
#line 14643 "pdftexdir/pdftex.web"
;
glue_node:/*653:*/
#line 14704 "pdftexdir/pdftex.web"

begin round_glue;
if eTeX_ex then/*1696:*/
#line 37425 "pdftexdir/pdftex.web"

if(((g_sign= stretching)and(stretch_order(g)= g_order))or
((g_sign= shrinking)and(shrink_order(g)= g_order)))then
begin fast_delete_glue_ref(g);
if subtype(p)<a_leaders then
begin type(p):= kern_node;width(p):= rule_wd;
end
else begin g:= get_node(glue_spec_size);
stretch_order(g):= filll+1;shrink_order(g):= filll+1;{will never match}
width(g):= rule_wd;stretch(g):= 0;shrink(g):= 0;glue_ptr(p):= g;
end;
end

/*:1696*/
#line 14706 "pdftexdir/pdftex.web"
;
if subtype(p)>=a_leaders then
/*654:*/
#line 14713 "pdftexdir/pdftex.web"

begin leader_box:= leader_ptr(p);
if type(leader_box)= rule_node then
begin rule_ht:= height(leader_box);rule_dp:= depth(leader_box);
goto fin_rule;
end;
leader_wd:= width(leader_box);
if(leader_wd> 0)and(rule_wd> 0)then
begin rule_wd:= rule_wd+10;{compensate for floating-point rounding}
if cur_dir= right_to_left then cur_h:= cur_h-10;
edge:= cur_h+rule_wd;lx:= 0;
/*655:*/
#line 14751 "pdftexdir/pdftex.web"

if subtype(p)= a_leaders then
begin save_h:= cur_h;
cur_h:= left_edge+leader_wd*((cur_h-left_edge)div leader_wd);
if cur_h<save_h then cur_h:= cur_h+leader_wd;
end
else begin lq:= rule_wd div leader_wd;{the number of box copies}
lr:= rule_wd mod leader_wd;{the remaining space}
if subtype(p)= c_leaders then cur_h:= cur_h+(lr div 2)
else begin lx:= lr div(lq+1);
cur_h:= cur_h+((lr-(lq-1)*lx)div 2);
end;
end

/*:655*/
#line 14725 "pdftexdir/pdftex.web"
;
while cur_h+leader_wd<=edge do
/*656:*/
#line 14768 "pdftexdir/pdftex.web"

begin cur_v:= base_line+shift_amount(leader_box);synch_v;save_v:= dvi_v;
synch_h;save_h:= dvi_h;temp_ptr:= leader_box;
if cur_dir= right_to_left then cur_h:= cur_h+leader_wd;
outer_doing_leaders:= doing_leaders;doing_leaders:= true;
if type(leader_box)= vlist_node then vlist_out else hlist_out;
doing_leaders:= outer_doing_leaders;
dvi_v:= save_v;dvi_h:= save_h;cur_v:= base_line;
cur_h:= save_h+leader_wd+lx;
end

/*:656*/
#line 14728 "pdftexdir/pdftex.web"
;
if cur_dir= right_to_left then cur_h:= edge
else cur_h:= edge-10;
goto next_p;
end;
end

/*:654*/
#line 14709 "pdftexdir/pdftex.web"
;
goto move_past;
end

/*:653*/
#line 14644 "pdftexdir/pdftex.web"
;
#line 3221 "pdftex-final.ch"
margin_kern_node:cur_h:= cur_h+width(p);{separate the|margin_kern_node|case in|hlist_out|}
kern_node:begin
/*1929:*/
#line 7053 "pdftex-final.ch"

synctex_kern(p,this_box);

/*:1929*/
#line 3223 "pdftex-final.ch"
;
cur_h:= cur_h+width(p);
end;
math_node:begin
/*1930:*/
#line 7056 "pdftex-final.ch"

synctex_math(p,this_box);

/*:1930*/
#line 3227 "pdftex-final.ch"
;
/*1713:*/
#line 37633 "pdftexdir/pdftex.web"

begin if eTeX_ex then
/*1714:*/
#line 37646 "pdftexdir/pdftex.web"

begin if end_LR(p)then
if info(LR_ptr)= end_LR_type(p)then pop_LR
else begin if subtype(p)> L_code then incr(LR_problems);
end
else begin push_LR(p);
if LR_dir(p)<> cur_dir then
/*1719:*/
#line 5852 "pdftex-final.ch"

begin save_h:= cur_h;temp_ptr:= link(p);rule_wd:= width(p);
free_node(p,medium_node_size);{{\sl Sync\TeX}:p is a|math_node|}
#line 37702 "pdftexdir/pdftex.web"
cur_dir:= reflected;p:= new_edge(cur_dir,rule_wd);link(prev_p):= p;
cur_h:= cur_h-left_edge+rule_wd;
link(p):= reverse(this_box,new_edge(reflected,0),cur_g,cur_glue);
edge_dist(p):= cur_h;cur_dir:= reflected;cur_h:= save_h;
goto reswitch;
end

/*:1719*/
#line 37653 "pdftexdir/pdftex.web"
;
end;
type(p):= kern_node;
end

/*:1714*/
#line 37636 "pdftexdir/pdftex.web"
;
cur_h:= cur_h+width(p);
end

/*:1713*/
#line 3228 "pdftex-final.ch"
;
end;
#line 14648 "pdftexdir/pdftex.web"
ligature_node:/*824:*/
#line 20850 "pdftexdir/pdftex.web"

begin mem[lig_trick]:= mem[lig_char(p)];link(lig_trick):= link(p);
p:= lig_trick;goto reswitch;
end

/*:824*/
#line 14648 "pdftexdir/pdftex.web"
;
/*1717:*/
#line 37680 "pdftexdir/pdftex.web"

edge_node:begin cur_h:= cur_h+width(p);
left_edge:= cur_h+edge_dist(p);cur_dir:= subtype(p);
end;

/*:1717*/
#line 14649 "pdftexdir/pdftex.web"

othercases do_nothing
endcases;
goto next_p;
fin_rule:/*652:*/
#line 14669 "pdftexdir/pdftex.web"

if is_running(rule_ht)then rule_ht:= height(this_box);
if is_running(rule_dp)then rule_dp:= depth(this_box);
rule_ht:= rule_ht+rule_dp;{this is the rule thickness}
if(rule_ht> 0)and(rule_wd> 0)then{we don't output empty rules}
begin synch_h;cur_v:= base_line+rule_dp;synch_v;
dvi_out(set_rule);dvi_four(rule_ht);dvi_four(rule_wd);
cur_v:= base_line;dvi_h:= dvi_h+rule_wd;
end

/*:652*/
#line 14653 "pdftexdir/pdftex.web"
;
#line 3235 "pdftex-final.ch"
move_past:begin
cur_h:= cur_h+rule_wd;
/*1928:*/
#line 7050 "pdftex-final.ch"

synctex_horizontal_rule_or_glue(p,this_box);

/*:1928*/
#line 3237 "pdftex-final.ch"
;
end;
#line 14655 "pdftexdir/pdftex.web"
next_p:prev_p:= p;p:= link(p);
end

#line 3245 "pdftex-final.ch"
/*:650*/
#line 14625 "pdftexdir/pdftex.web"


/*:648*/
#line 3140 "pdftex-final.ch"
;
/*1925:*/
#line 7036 "pdftex-final.ch"

synctex_tsilh(this_box);

/*:1925*/
#line 3141 "pdftex-final.ch"
;
#line 14599 "pdftexdir/pdftex.web"
/*1712:*/
#line 37627 "pdftexdir/pdftex.web"

if eTeX_ex then
begin/*1715:*/
#line 37658 "pdftexdir/pdftex.web"

begin while info(LR_ptr)<> before do
begin if info(LR_ptr)> L_code then LR_problems:= LR_problems+10000;
pop_LR;
end;
pop_LR;
end

/*:1715*/
#line 37629 "pdftexdir/pdftex.web"
;
if box_lr(this_box)= dlist then cur_dir:= right_to_left;
end

/*:1712*/
#line 14599 "pdftexdir/pdftex.web"
;
prune_movements(save_loc);
if cur_s> 0 then dvi_pop(save_loc);
decr(cur_s);
end;

/*:647*//*657:*/
#line 3255 "pdftex-final.ch"
procedure vlist_out;{output a|vlist_node|box}
#line 14782 "pdftexdir/pdftex.web"
label move_past,fin_rule,next_p;
var left_edge:scaled;{the left coordinate for this box}
top_edge:scaled;{the top coordinate for this box}
save_h,save_v:scaled;{what|dvi_h|and|dvi_v|should pop to}
this_box:pointer;{pointer to containing box}
g_order:glue_ord;{applicable order of infinity for glue}
g_sign:normal..shrinking;{selects type of glue}
p:pointer;{current position in the vlist}
save_loc:integer;{\.{DVI}byte location upon entry}
leader_box:pointer;{the leader box being replicated}
leader_ht:scaled;{height of leader box being replicated}
lx:scaled;{extra space between leader boxes}
outer_doing_leaders:boolean;{were we doing leaders?}
edge:scaled;{bottom boundary of leader space}
glue_temp:real;{glue value before rounding}
cur_glue:real;{glue seen so far}
cur_g:scaled;{rounded equivalent of|cur_glue|times the glue ratio}
begin cur_g:= 0;cur_glue:= float_constant(0);
this_box:= temp_ptr;g_order:= glue_order(this_box);
g_sign:= glue_sign(this_box);p:= list_ptr(this_box);
incr(cur_s);
if cur_s> 0 then dvi_out(push);
if cur_s> max_push then max_push:= cur_s;
#line 3262 "pdftex-final.ch"
save_loc:= dvi_offset+dvi_ptr;left_edge:= cur_h;
/*1922:*/
#line 7027 "pdftex-final.ch"

synctex_vlist(this_box);

/*:1922*/
#line 3263 "pdftex-final.ch"
;
cur_v:= cur_v-height(this_box);
top_edge:= cur_v;
#line 3272 "pdftex-final.ch"
while p<> null do/*658:*/
#line 14814 "pdftexdir/pdftex.web"

begin if is_char_node(p)then confusion("vlistout")

else/*659:*/
#line 14821 "pdftexdir/pdftex.web"

begin case type(p)of
hlist_node,vlist_node:/*660:*/
#line 3281 "pdftex-final.ch"

if list_ptr(p)= null then begin
cur_v:= cur_v+height(p);
/*1926:*/
#line 7039 "pdftex-final.ch"

if type(p)= vlist_node then begin
synctex_void_vlist(p,this_box);
end
else begin
synctex_void_hlist(p,this_box);
end;

/*:1926*/
#line 3284 "pdftex-final.ch"
;
cur_v:= cur_v+depth(p);
end
#line 14843 "pdftexdir/pdftex.web"
 else begin cur_v:= cur_v+height(p);synch_v;
save_h:= dvi_h;save_v:= dvi_v;
if cur_dir= right_to_left then cur_h:= left_edge-shift_amount(p)
else cur_h:= left_edge+shift_amount(p);{shift the box right}
temp_ptr:= p;
if type(p)= vlist_node then vlist_out else hlist_out;
dvi_h:= save_h;dvi_v:= save_v;
cur_v:= save_v+depth(p);cur_h:= left_edge;
end

/*:660*/
#line 14823 "pdftexdir/pdftex.web"
;
rule_node:begin rule_ht:= height(p);rule_dp:= depth(p);rule_wd:= width(p);
goto fin_rule;
end;
whatsit_node:/*1610:*/
#line 35707 "pdftexdir/pdftex.web"

out_what(p)

/*:1610*/
#line 14827 "pdftexdir/pdftex.web"
;
glue_node:/*662:*/
#line 14865 "pdftexdir/pdftex.web"

begin g:= glue_ptr(p);rule_ht:= width(g)-cur_g;
if g_sign<> normal then
begin if g_sign= stretching then
begin if stretch_order(g)= g_order then
begin cur_glue:= cur_glue+stretch(g);
vet_glue(float(glue_set(this_box))*cur_glue);

cur_g:= round(glue_temp);
end;
end
else if shrink_order(g)= g_order then
begin cur_glue:= cur_glue-shrink(g);
vet_glue(float(glue_set(this_box))*cur_glue);
cur_g:= round(glue_temp);
end;
end;
rule_ht:= rule_ht+cur_g;
if subtype(p)>=a_leaders then
/*663:*/
#line 14889 "pdftexdir/pdftex.web"

begin leader_box:= leader_ptr(p);
if type(leader_box)= rule_node then
begin rule_wd:= width(leader_box);rule_dp:= 0;
goto fin_rule;
end;
leader_ht:= height(leader_box)+depth(leader_box);
if(leader_ht> 0)and(rule_ht> 0)then
begin rule_ht:= rule_ht+10;{compensate for floating-point rounding}
edge:= cur_v+rule_ht;lx:= 0;
/*664:*/
#line 14908 "pdftexdir/pdftex.web"

if subtype(p)= a_leaders then
begin save_v:= cur_v;
cur_v:= top_edge+leader_ht*((cur_v-top_edge)div leader_ht);
if cur_v<save_v then cur_v:= cur_v+leader_ht;
end
else begin lq:= rule_ht div leader_ht;{the number of box copies}
lr:= rule_ht mod leader_ht;{the remaining space}
if subtype(p)= c_leaders then cur_v:= cur_v+(lr div 2)
else begin lx:= lr div(lq+1);
cur_v:= cur_v+((lr-(lq-1)*lx)div 2);
end;
end

/*:664*/
#line 14900 "pdftexdir/pdftex.web"
;
while cur_v+leader_ht<=edge do
/*665:*/
#line 14925 "pdftexdir/pdftex.web"

begin if cur_dir= right_to_left then
cur_h:= left_edge-shift_amount(leader_box)
else cur_h:= left_edge+shift_amount(leader_box);
synch_h;save_h:= dvi_h;
cur_v:= cur_v+height(leader_box);synch_v;save_v:= dvi_v;
temp_ptr:= leader_box;
outer_doing_leaders:= doing_leaders;doing_leaders:= true;
if type(leader_box)= vlist_node then vlist_out else hlist_out;
doing_leaders:= outer_doing_leaders;
dvi_v:= save_v;dvi_h:= save_h;cur_h:= left_edge;
cur_v:= save_v-height(leader_box)+leader_ht+lx;
end

/*:665*/
#line 14903 "pdftexdir/pdftex.web"
;
cur_v:= edge-10;goto next_p;
end;
end

/*:663*/
#line 14885 "pdftexdir/pdftex.web"
;
goto move_past;
end

/*:662*/
#line 14828 "pdftexdir/pdftex.web"
;
kern_node:cur_v:= cur_v+width(p);
othercases do_nothing
endcases;
goto next_p;
fin_rule:/*661:*/
#line 14853 "pdftexdir/pdftex.web"

if is_running(rule_wd)then rule_wd:= width(this_box);
rule_ht:= rule_ht+rule_dp;{this is the rule thickness}
cur_v:= cur_v+rule_ht;
if(rule_ht> 0)and(rule_wd> 0)then{we don't output empty rules}
begin if cur_dir= right_to_left then cur_h:= cur_h-rule_wd;
synch_h;synch_v;
dvi_out(put_rule);dvi_four(rule_ht);dvi_four(rule_wd);
cur_h:= left_edge;
end;
goto next_p

/*:661*/
#line 14833 "pdftexdir/pdftex.web"
;
move_past:cur_v:= cur_v+rule_ht;
end

/*:659*/
#line 14817 "pdftexdir/pdftex.web"
;
next_p:p:= link(p);
end

/*:658*/
#line 3273 "pdftex-final.ch"
;
/*1923:*/
#line 7030 "pdftex-final.ch"

synctex_tsilv(this_box);

/*:1923*/
#line 3274 "pdftex-final.ch"
;
#line 14809 "pdftexdir/pdftex.web"
prune_movements(save_loc);
if cur_s> 0 then dvi_pop(save_loc);
decr(cur_s);
end;

/*:657*//*666:*/
#line 14942 "pdftexdir/pdftex.web"
procedure dvi_ship_out(p:pointer);{output the box|p|}
label done;
var page_loc:integer;{location of the current|bop|}
j,k:0. .9;{indices to first ten count registers}
s:pool_pointer;{index into|str_pool|}
#line 3292 "pdftex-final.ch"
old_setting:0..max_selector;{saved|selector|setting}
begin/*1920:*/
#line 7021 "pdftex-final.ch"

synctex_sheet(mag);

/*:1920*/
#line 3293 "pdftex-final.ch"
;
#line 14948 "pdftexdir/pdftex.web"
begin if tracing_output> 0 then
begin print_nl("");print_ln;
print("Completed box being shipped out");

end;
if term_offset> max_print_line-9 then print_ln
else if(term_offset> 0)or(file_offset> 0)then print_char(" ");
print_char("[");j:= 9;
while(count(j)= 0)and(j> 0)do decr(j);
for k:= 0 to j do
begin print_int(count(k));
if k<j then print_char(".");
end;
update_terminal;
if tracing_output> 0 then
begin print_char("]");
begin_diagnostic;show_box(p);end_diagnostic(true);
end;
/*668:*/
#line 14991 "pdftexdir/pdftex.web"

/*669:*/
#line 15008 "pdftexdir/pdftex.web"

if(height(p)> max_dimen)or(depth(p)> max_dimen)or
(height(p)+depth(p)+v_offset> max_dimen)or
(width(p)+h_offset> max_dimen)then
begin print_err("Huge page cannot be shipped out");

help2("The page just created is more than 18 feet tall or")
("more than 18 feet wide, so I suspect something went wrong.");
error;
if tracing_output<=0 then
begin begin_diagnostic;
print_nl("The following box has been deleted:");

show_box(p);
end_diagnostic(true);
end;
goto done;
end;
if height(p)+depth(p)+v_offset> max_v then max_v:= height(p)+depth(p)+v_offset;
if width(p)+h_offset> max_h then max_h:= width(p)+h_offset

/*:669*/
#line 14993 "pdftexdir/pdftex.web"
;
/*645:*/
#line 14526 "pdftexdir/pdftex.web"

dvi_h:= 0;dvi_v:= 0;cur_h:= h_offset;dvi_f:= null_font;
/*644:*/
#line 14512 "pdftexdir/pdftex.web"

cur_h_offset:= h_offset;
cur_v_offset:= v_offset;
if pdf_page_width<> 0 then
cur_page_width:= pdf_page_width
else
cur_page_width:= width(p)+2*cur_h_offset+2*4736286;
{4736286= 1 in,the funny DVI origin offset}
if pdf_page_height<> 0 then
cur_page_height:= pdf_page_height
else
cur_page_height:= height(p)+depth(p)+2*cur_v_offset+2*4736286
{4736286= 1 in,the funny DVI origin offset}

/*:644*/
#line 14528 "pdftexdir/pdftex.web"
;
ensure_dvi_open;
if total_pages= 0 then
begin dvi_out(pre);dvi_out(id_byte);{output the preamble}

dvi_four(25400000);dvi_four(473628672);{conversion ratio for sp}
prepare_mag;dvi_four(mag);{magnification factor is frozen}
#line 3111 "pdftex-final.ch"
if output_comment then
begin l:= strlen(output_comment);dvi_out(l);
for s:= 0 to l-1 do dvi_out(output_comment[s]);
end
else begin{the default code is unchanged}
old_setting:= selector;selector:= new_string;
#line 14536 "pdftexdir/pdftex.web"
print(" TeX output ");print_int(year);print_char(".");
print_two(month);print_char(".");print_two(day);
print_char(":");print_two(time div 60);
print_two(time mod 60);
selector:= old_setting;dvi_out(cur_length);
for s:= str_start[str_ptr]to pool_ptr-1 do dvi_out(so(str_pool[s]));
pool_ptr:= str_start[str_ptr];{flush the current string}
#line 3122 "pdftex-final.ch"
end;
end
#line 14544 "pdftexdir/pdftex.web"

/*:645*/
#line 14994 "pdftexdir/pdftex.web"
;
page_loc:= dvi_offset+dvi_ptr;
dvi_out(bop);
for k:= 0 to 9 do dvi_four(count(k));
dvi_four(last_bop);last_bop:= page_loc;
cur_v:= height(p)+v_offset;temp_ptr:= p;
if type(p)= vlist_node then vlist_out else hlist_out;
dvi_out(eop);incr(total_pages);cur_s:= -1;
#line 3309 "pdftex-final.ch"
ifdef('IPC')
if ipc_on> 0 then
begin if dvi_limit= half_buf then
begin write_dvi(half_buf,dvi_buf_size-1);
flush_dvi;
dvi_gone:= dvi_gone+half_buf;
end;
if dvi_ptr> (7FFFFFFF-dvi_offset)then
begin cur_s:= -2;
fatal_error("dvi length exceeds ""7FFFFFFF");

end;
if dvi_ptr> 0 then
begin write_dvi(0,dvi_ptr-1);
flush_dvi;
dvi_offset:= dvi_offset+dvi_ptr;dvi_gone:= dvi_gone+dvi_ptr;
end;
dvi_ptr:= 0;dvi_limit:= dvi_buf_size;
ipc_page(dvi_gone);
end;
endif('IPC');
done:
#line 15003 "pdftexdir/pdftex.web"

/*:668*/
#line 14966 "pdftexdir/pdftex.web"
;
if eTeX_ex then/*1727:*/
#line 37816 "pdftexdir/pdftex.web"

begin if LR_problems> 0 then
begin/*1710:*/
#line 37608 "pdftexdir/pdftex.web"

begin print_ln;print_nl("\endL or \endR problem (");
print_int(LR_problems div 10000);print(" missing, ");
print_int(LR_problems mod 10000);print(" extra");
LR_problems:= 0;
end

/*:1710*/
#line 37818 "pdftexdir/pdftex.web"
;print_char(")");print_ln;
end;
if(LR_ptr<> null)or(cur_dir<> left_to_right)then confusion("LR3");

end

/*:1727*/
#line 14967 "pdftexdir/pdftex.web"
;
if tracing_output<=0 then print_char("]");
dead_cycles:= 0;
update_terminal;{progress report}
#line 3300 "pdftex-final.ch"
/*667:*/
#line 14974 "pdftexdir/pdftex.web"

stat if tracing_stats> 1 then
begin print_nl("Memory usage before: ");

print_int(var_used);print_char("&");
print_int(dyn_used);print_char(";");
end;
tats
flush_node_list(p);
stat if tracing_stats> 1 then
begin print(" after: ");
print_int(var_used);print_char("&");
print_int(dyn_used);print("; still untouched: ");
print_int(hi_mem_min-lo_mem_max-1);print_ln;
end;
tats

/*:667*/
#line 3300 "pdftex-final.ch"
;
end;
/*1921:*/
#line 7024 "pdftex-final.ch"

synctex_teehs;

/*:1921*/
#line 3302 "pdftex-final.ch"
;
end;
#line 14973 "pdftexdir/pdftex.web"

/*:666*//*673:*/
#line 15101 "pdftexdir/pdftex.web"
function get_pdf_compress_level:integer;
begin
get_pdf_compress_level:= pdf_compress_level;
end;

function get_pdf_suppress_warning_dup_map:integer;
begin
get_pdf_suppress_warning_dup_map:= pdf_suppress_warning_dup_map;
end;

function get_pdf_suppress_warning_page_group:integer;
begin
get_pdf_suppress_warning_page_group:= pdf_suppress_warning_page_group;
end;

function get_pdf_suppress_ptex_info:integer;
begin
get_pdf_suppress_ptex_info:= pdf_suppress_ptex_info;
end;

function get_pdf_omit_charset:integer;
begin
get_pdf_omit_charset:= pdf_omit_charset;
end;

function get_nullfont:internal_font_number;
begin
get_nullfont:= null_font;
end;

function get_fontbase:internal_font_number;
begin
get_fontbase:= font_base;
end;

function get_nullcs:pointer;
begin
get_nullcs:= null_cs;
end;

function get_nullptr:pointer;
begin
get_nullptr:= null;
end;

function get_tex_int(code:integer):integer;
begin
get_tex_int:= int_par(code);
end;

function get_tex_dimen(code:integer):scaled;
begin
get_tex_dimen:= dimen_par(code);
end;

function get_x_height(f:internal_font_number):scaled;
begin
get_x_height:= x_height(f);
end;

#line 3399 "pdftex-final.ch"
function get_charwidth(f:internal_font_number;c:eight_bits):scaled;
begin
if is_valid_char(c)then
get_charwidth:= char_width(f)(orig_char_info(f)(c))
else
get_charwidth:= 0;
end;

function get_charheight(f:internal_font_number;c:eight_bits):scaled;
begin
if is_valid_char(c)then
get_charheight:= char_height(f)(height_depth(orig_char_info(f)(c)))
else
get_charheight:= 0;
end;

function get_chardepth(f:internal_font_number;c:eight_bits):scaled;
begin
if is_valid_char(c)then
get_chardepth:= char_depth(f)(height_depth(orig_char_info(f)(c)))
else
get_chardepth:= 0;
end;
#line 15184 "pdftexdir/pdftex.web"

function get_quad(f:internal_font_number):scaled;
begin
get_quad:= quad(f);
end;

function get_slant(f:internal_font_number):scaled;
begin
get_slant:= slant(f);
end;

function new_dummy_font:internal_font_number;
begin
new_dummy_font:= read_font_info(null_cs,"dummy","",-1000);
end;

/*:673*//*674:*/
#line 15202 "pdftexdir/pdftex.web"
procedure short_display_n(p,m:integer);{prints highlights of list|p|}
var n:integer;{for replacement counts}
i:integer;
begin
i:= 0;
font_in_short_display:= null_font;
if p= null then
return;
while p> mem_min do
begin if is_char_node(p)then
begin if p<=mem_end then
begin if font(p)<> font_in_short_display then
begin if(font(p)<font_base)or(font(p)> font_max)then
print_char("*")

else print_font_identifier(font(p));
print_char(" ");font_in_short_display:= font(p);
end;
print_ASCII(qo(character(p)));
end;
end
else begin
if(type(p)= glue_node)or
(type(p)= disc_node)or
(type(p)= penalty_node)or
((type(p)= kern_node)and(subtype(p)= explicit))then
incr(i);
if i>=m then
return;
if(type(p)= disc_node)then begin
print("|");
short_display(pre_break(p));
print("|");
short_display(post_break(p));
print("|");
n:= replace_count(p);
while n> 0 do
begin if link(p)<> null then p:= link(p);
decr(n);
end;
end
else
/*193:*/
#line 4136 "pdftexdir/pdftex.web"

case type(p)of
hlist_node,vlist_node,ins_node,whatsit_node,mark_node,adjust_node,
unset_node:print("[]");
rule_node:print_char("|");
glue_node:if glue_ptr(p)<> zero_glue then print_char(" ");
math_node:if subtype(p)>=L_code then print("[]")
else print_char("$");
ligature_node:short_display(lig_ptr(p));
disc_node:begin short_display(pre_break(p));
short_display(post_break(p));
n:= replace_count(p);
while n> 0 do
begin if link(p)<> null then p:= link(p);
decr(n);
end;
end;
othercases do_nothing
endcases

/*:193*/
#line 15244 "pdftexdir/pdftex.web"
;
end;
p:= link(p);
if p= null then
return;
end;
update_terminal;
end;

/*:674*//*678:*/
#line 15272 "pdftexdir/pdftex.web"
function pdf_get_mem(s:integer):integer;{allocate|s|words in|pdf_mem|}
var a:integer;
begin
if s> sup_pdf_mem_size-pdf_mem_ptr then
overflow("PDF memory size (pdf_mem_size)",pdf_mem_size);
if pdf_mem_ptr+s> pdf_mem_size then begin
a:= 0.2*pdf_mem_size;
if pdf_mem_ptr+s> pdf_mem_size+a then
pdf_mem_size:= pdf_mem_ptr+s
else if pdf_mem_size<sup_pdf_mem_size-a then
pdf_mem_size:= pdf_mem_size+a
else
pdf_mem_size:= sup_pdf_mem_size;
pdf_mem:= xrealloc_array(pdf_mem,integer,pdf_mem_size);
end;
pdf_get_mem:= pdf_mem_ptr;
pdf_mem_ptr:= pdf_mem_ptr+s;
end;

/*:678*//*682:*/
#line 15391 "pdftexdir/pdftex.web"

function fix_int(val,min,max:integer):integer;
begin
if val<min then
fix_int:= min
else if val> max then
fix_int:= max
else
fix_int:= val;
end;

/*:682*//*683:*/
#line 15412 "pdftexdir/pdftex.web"
procedure check_pdfversion;
begin
if not pdf_version_written then begin
pdf_version_written:= true;
if pdf_major_version<1 then begin
print_err("pdfTeX error (invalid pdfmajorversion)");
print_ln;
help2("The pdfmajorversion must be 1 or greater.")
("I changed this to 1.");
int_error(pdf_major_version);
pdf_major_version:= 1;
end;
if(pdf_minor_version<0)or(pdf_minor_version> 9)then begin
print_err("pdfTeX error (invalid pdfminorversion)");
print_ln;
help2("The pdfminorversion must be between 0 and 9.")
("I changed this to 4.");
int_error(pdf_minor_version);
pdf_minor_version:= 4;
end;
fixed_pdf_major_version:= pdf_major_version;
fixed_pdf_minor_version:= pdf_minor_version;
fixed_gamma:= fix_int(pdf_gamma,0,1000000);
fixed_image_gamma:= fix_int(pdf_image_gamma,0,1000000);
fixed_image_hicolor:= fix_int(pdf_image_hicolor,0,1);
fixed_image_apply_gamma:= fix_int(pdf_image_apply_gamma,0,1);
fixed_pdf_objcompresslevel:= fix_int(pdf_objcompresslevel,0,3);
fixed_pdf_draftmode:= fix_int(pdf_draftmode,0,1);
fixed_inclusion_copy_font:= fix_int(pdf_inclusion_copy_font,0,1);
if((fixed_pdf_major_version> 1)or(fixed_pdf_minor_version>=5))
and(fixed_pdf_objcompresslevel> 0)then
pdf_os_enable:= true
else begin
if fixed_pdf_objcompresslevel> 0 then begin
pdf_warning("Object streams","\pdfobjcompresslevel > 0 requires PDF-1.5 or greater. Object streams disabled now.",true,true);
fixed_pdf_objcompresslevel:= 0;
end;
pdf_os_enable:= false;
end;
ensure_pdf_open;
fix_pdfoutput;
pdf_print("%PDF-");
pdf_print_int(fixed_pdf_major_version);
pdf_print(".");
pdf_print_int_ln(fixed_pdf_minor_version);
pdf_print("%");
pdf_out(208);{'P'+128}
pdf_out(212);{'T'+128}
pdf_out(197);{'E'+128}
pdf_out(216);{'X'+128}
pdf_print_nl;
end
else begin
if(fixed_pdf_minor_version<> pdf_minor_version)
or(fixed_pdf_major_version<> pdf_major_version)then
pdf_error("setup",
"PDF version cannot be changed after data is written to the PDF file");
end;
end;

/*:683*//*684:*/
#line 15474 "pdftexdir/pdftex.web"
procedure ensure_pdf_open;
begin
if output_file_name<> 0 then
return;
if job_name= 0 then
open_log_file;
pack_job_name(".pdf");
if fixed_pdf_draftmode= 0 then
while not b_open_out(pdf_file)do
prompt_file_name("file name for output",".pdf");
output_file_name:= b_make_name_string(pdf_file);
end;

/*:684*//*685:*/
#line 15492 "pdftexdir/pdftex.web"
procedure pdf_flush;{flush out the|pdf_buf|}
var saved_pdf_gone:longinteger;
begin
if not pdf_os_mode then begin
saved_pdf_gone:= pdf_gone;
case zip_write_state of
no_zip:if pdf_ptr> 0 then begin
if fixed_pdf_draftmode= 0 then write_pdf(0,pdf_ptr-1);
pdf_gone:= pdf_gone+pdf_ptr;
pdf_last_byte:= pdf_buf[pdf_ptr-1];
end;
zip_writing:
if fixed_pdf_draftmode= 0 then write_zip(false);
zip_finish:begin
if fixed_pdf_draftmode= 0 then write_zip(true);
zip_write_state:= no_zip;
end;
end;
pdf_ptr:= 0;
if saved_pdf_gone> pdf_gone then
pdf_error("file size","File size exceeds architectural limits (pdf_gone wraps around)");
end;
end;

procedure pdf_begin_stream;{begin a stream}
begin
pdf_print_ln("/Length           ");
pdf_seek_write_length:= true;{fill in length at|pdf_end_stream|call}
pdf_stream_length_offset:= pdf_offset-11;
pdf_stream_length:= 0;
pdf_last_byte:= 0;
if pdf_compress_level> 0 then begin
pdf_print_ln("/Filter /FlateDecode");
pdf_print_ln(">>");
pdf_print_ln("stream");
pdf_flush;
zip_write_state:= zip_writing;
end
else begin
pdf_print_ln(">>");
pdf_print_ln("stream");
pdf_save_offset:= pdf_offset;
end;
end;

procedure pdf_end_stream;{end a stream}
begin
if zip_write_state= zip_writing then
zip_write_state:= zip_finish
else
pdf_stream_length:= pdf_offset-pdf_save_offset;
pdf_flush;
if pdf_seek_write_length then
write_stream_length(pdf_stream_length,pdf_stream_length_offset);
pdf_seek_write_length:= false;
pdf_out(pdf_new_line_char);
pdf_print_ln("endstream");
pdf_end_obj;
end;

/*:685*//*690:*/
#line 15838 "pdftexdir/pdftex.web"

procedure adv_char_width(f:internal_font_number;c:eight_bits);{update|pdf_h|
by character width|w|from font|f|}
var w,s_out:scaled;
s:integer;
begin
w:= char_width(f)(char_info(f)(c));
if isscalable(f)then begin
if pdf_cur_Tm_a= 0 then begin
call_func(divide_scaled(w,pdf_font_size[f],4));
pdf_delta_h:= pdf_delta_h+scaled_out;
end
else begin
s:= divide_scaled(round_xn_over_d(w,1000,1000+pdf_cur_Tm_a),
pdf_font_size[f],
4);
s_out:= round_xn_over_d(round_xn_over_d(pdf_font_size[f],abs(s),10000),
1000+pdf_cur_Tm_a,1000);
if s<0 then
s_out:= -s_out;
pdf_delta_h:= pdf_delta_h+s_out;
end;
end else
pdf_delta_h:= pdf_delta_h+get_pk_char_width(f,w);
end;

procedure pdf_print_real(m,d:integer);{print $m/10^d$ as real}
begin
if m<0 then begin
pdf_out("-");
m:= -m;
end;
pdf_print_int(m div ten_pow[d]);
m:= m mod ten_pow[d];
if m> 0 then begin
pdf_out(".");
decr(d);
while m<ten_pow[d]do begin
pdf_out("0");
decr(d);
end;
while m mod 10= 0 do
m:= m div 10;
pdf_print_int(m);
end;
end;

procedure pdf_print_bp(s:scaled);{print scaled as|bp|}
begin
pdf_print_real(divide_scaled(s,one_hundred_bp,fixed_decimal_digits+2),
fixed_decimal_digits);
end;

procedure pdf_print_mag_bp(s:scaled);{take|mag|into account}
begin
prepare_mag;
if mag<> 1000 then
s:= round_xn_over_d(s,mag,1000);
pdf_print_bp(s);
end;

/*:690*//*692:*/
#line 15942 "pdftexdir/pdftex.web"
procedure pdf_set_origin(h,v:scaled);{set the origin to|h|,|v|}
begin
if(abs(h-pdf_origin_h)>=min_bp_val)or
(abs(v-pdf_origin_v)>=min_bp_val)then begin
pdf_print("1 0 0 1 ");
pdf_print_bp(h-pdf_origin_h);
pdf_origin_h:= pdf_origin_h+scaled_out;
pdf_out(" ");
pdf_print_bp(pdf_origin_v-v);
pdf_origin_v:= pdf_origin_v-scaled_out;
pdf_print_ln(" cm");
end;
pdf_h:= pdf_origin_h;
pdf_tj_start_h:= pdf_h;
pdf_v:= pdf_origin_v;
end;

procedure pdf_set_origin_temp(h,v:scaled);{set the origin to|h|,|v|inside group}
begin
if(abs(h-pdf_origin_h)>=min_bp_val)or
(abs(v-pdf_origin_v)>=min_bp_val)then begin
pdf_print("1 0 0 1 ");
pdf_print_bp(h-pdf_origin_h);
pdf_out(" ");
pdf_print_bp(pdf_origin_v-v);
pdf_print_ln(" cm");
end;
end;

procedure pdf_end_string;{end the current string}
begin
if pdf_doing_string then begin
pdf_print(")]TJ");
pdf_doing_string:= false;
end;
end;

procedure pdf_end_string_nl;{end the current string,with new-line}
begin
if pdf_doing_string then begin
pdf_print_ln(")]TJ");
pdf_doing_string:= false;
end;
end;

procedure pdf_set_textmatrix(v,v_out:scaled;f:internal_font_number);
{set the next starting point to|cur_h|,|cur_v|}
var pdf_new_Tm_a:integer;{|a|value of the new text matrix}
begin
pdf_out(" ");
if f= pdf_f then
pdf_new_Tm_a:= pdf_cur_Tm_a
else if not pdf_font_auto_expand[f]then
pdf_new_Tm_a:= 0
else
pdf_new_Tm_a:= pdf_font_expand_ratio[f];
if(pdf_new_Tm_a<> 0)or
((pdf_new_Tm_a= 0)and(pdf_cur_Tm_a<> 0))then begin
pdf_print_real(1000+pdf_new_Tm_a,3);
pdf_print(" 0 0 1 ");
pdf_print_bp(cur_h-pdf_origin_h);
pdf_h:= pdf_origin_h+scaled_out;
pdf_out(" ");
pdf_print_bp(pdf_origin_v-cur_v);
pdf_v:= pdf_origin_v-scaled_out;
pdf_print(" Tm");
pdf_cur_Tm_a:= pdf_new_Tm_a;
pdfassert(pdf_cur_Tm_a> -1000);
end else begin
pdf_print_bp(cur_h-pdf_tj_start_h);{works only for unexpanded fonts}
pdf_h:= pdf_tj_start_h+scaled_out;
pdf_out(" ");
pdf_print_real(v,fixed_decimal_digits);{use|v|and|v_out|to avoid duplicate calculation}
pdf_v:= pdf_v-v_out;
pdf_print(" Td");
end;
pdf_tj_start_h:= pdf_h;
pdf_delta_h:= 0;
end;

procedure pdf_use_font(f:internal_font_number;fontnum:integer);
{mark|f|as a used font;set|font_used[f]|,|pdf_font_size[f]|and|pdf_font_num[f]|}
begin
call_func(divide_scaled(font_size[f],one_hundred_bp,6));
pdf_font_size[f]:= scaled_out;
font_used[f]:= true;
pdfassert((fontnum> 0)or((fontnum<0)and(pdf_font_num[-fontnum]> 0)));
pdf_font_num[f]:= fontnum;
if pdf_move_chars> 0 then begin
pdf_warning(0,"Primitive \pdfmovechars is obsolete.",true,true);
pdf_move_chars:= 0;{warn only once}
end;
end;

/*:692*//*693:*/
#line 16046 "pdftexdir/pdftex.web"
procedure pdf_init_font(f:internal_font_number);
{create a font object}
var k,b:internal_font_number;
i:integer;
begin
pdfassert(not font_used[f]);

{if|f|is auto expanded then ensure the base font is initialized}
if pdf_font_auto_expand[f]and(pdf_font_blink[f]<> null_font)then begin
b:= pdf_font_blink[f];
if not isscalable(b)then
pdf_error("font expansion","auto expansion is only possible with scalable fonts");
if not font_used[b]then
pdf_init_font(b);
pdf_font_map[f]:= pdf_font_map[b];
end;

{check whether|f|can share the font object with some|k|:we have 2 cases
here:1)|f|and|k|have the same tfm name(so they have been loaded at
different sizes,e.g.,'cmr10'and'cmr10 at 11pt');2)|f|has been auto
expanded from|k|}
if isscalable(f)then begin
i:= head_tab[obj_type_font];
while i<> 0 do begin
k:= obj_info(i);
if isscalable(k)and
(pdf_font_map[k]= pdf_font_map[f])and
(str_eq_str(font_name[k],font_name[f])or
(pdf_font_auto_expand[f]and
(pdf_font_blink[f]<> null_font)and
str_eq_str(font_name[k],font_name[pdf_font_blink[f]])))then
begin
pdfassert(pdf_font_num[k]<> 0);
if pdf_font_num[k]<0 then
pdf_use_font(f,pdf_font_num[k])
else
pdf_use_font(f,-k);
return;
end;
i:= obj_link(i);
end;
end;

{create a new font object for|f|}
pdf_create_obj(obj_type_font,f);
pdf_use_font(f,obj_ptr);
end;

procedure pdf_init_font_cur_val;
begin
pdf_init_font(cur_val);
end;

procedure pdf_set_font(f:internal_font_number);
{set the actual font on PDF page}
label found,found1;
var p:pointer;
k:internal_font_number;
begin
if not font_used[f]then
pdf_init_font(f);
set_ff(f);{set|ff|to the tfm number of the font sharing the font object
with|f|;|ff|is either|f|or some font with the same tfm name
at different size and/or expansion}
k:= ff;
p:= pdf_font_list;
while p<> null do begin
set_ff(info(p));
if ff= k then
goto found;
p:= link(p);
end;
pdf_append_list(f)(pdf_font_list);{|f|not found in|pdf_font_list|,append it now}
found:
if(k= pdf_last_f)and(font_size[f]= pdf_last_fs)then
return;
pdf_print("/F");
pdf_print_int(k);
pdf_print_resname_prefix;
pdf_out(" ");
pdf_print_real(divide_scaled(font_size[f],one_hundred_bp,6),4);
pdf_print(" Tf");
pdf_last_f:= k;
pdf_last_fs:= font_size[f];
end;

procedure pdf_begin_text;{begin a text section}
begin
pdf_set_origin(0,cur_page_height);
pdf_print_ln("BT");
pdf_doing_text:= true;
pdf_f:= null_font;
pdf_last_f:= null_font;
pdf_last_fs:= 0;
pdf_doing_string:= false;
pdf_cur_Tm_a:= 0;
end;

procedure pdf_read_dummy_font;
begin
if pdf_dummy_font= null_font then begin
pdf_dummy_font:= read_font_info(null_cs,"dummy-space","",one_bp);
pdf_mark_char(pdf_dummy_font,32);
end;
end;

procedure pdf_insert_interword_space;
{insert an artificial interword space}
begin
pdf_read_dummy_font;
pdf_set_font(pdf_dummy_font);
pdf_print("( )Tj");
end;

procedure pdf_begin_string(f:internal_font_number);{begin to draw a string}
var s_out,v,v_out:scaled;
s:integer;
must_end_string:boolean;{must we end the current string?}
must_insert_space:boolean;{must we insert an interword space?}
begin
if not pdf_doing_text then
pdf_begin_text;
if f<> pdf_f then begin
pdf_end_string;
pdf_set_font(f);
end;
if pdf_cur_Tm_a= 0 then begin
s:= divide_scaled(cur_h-(pdf_tj_start_h+pdf_delta_h),pdf_font_size[f],3);
s_out:= scaled_out;
end
else begin
s:= divide_scaled(round_xn_over_d(cur_h-(pdf_tj_start_h+pdf_delta_h),1000,
1000+pdf_cur_Tm_a),
pdf_font_size[f],
3);
if abs(s)<49
s_out:= round_xn_over_d(round_xn_over_d(pdf_font_size[f],abs(s),1000),
1000+pdf_cur_Tm_a,1000);
if s<0 then
s_out:= -s_out;
end;
{no need to calculate|s_out|when|abs(s)>=49
matrix will be reset below}
end;
if abs(cur_v-pdf_v)>=min_bp_val then begin
v:= divide_scaled(pdf_v-cur_v,one_hundred_bp,
fixed_decimal_digits+2);
v_out:= scaled_out;
end
else begin
v:= 0;
v_out:= 0;
end;

must_insert_space:= false;
must_end_string:= false;

print_nl("s_out = ");print_scaled(s_out);
print_nl("space(f) = ");print_scaled(space(f));
print_nl("space_shrink(f) = ");print_scaled(space_shrink(f));
print_nl("x_height(f) = ");print_scaled(x_height(f));
print_nl("v = ");print_scaled(v);
print_nl("v_out = ");print_scaled(v_out);

if gen_faked_interword_space and
((abs(v_out)> 2*x_height(f))or
(s_out> space(f)-space_shrink(f))or
((f<> pdf_f)and(v= 0)))then
begin
must_insert_space:= true;
end;

if(f<> pdf_f)or(v<> 0)or(abs(s)>=49
must_end_string:= true;
end;

if must_end_string then begin
pdf_end_string;
if must_insert_space then begin
pdf_insert_interword_space;{this will change|pdf_f|}
pdf_set_font(f);
end;
pdf_set_textmatrix(v,v_out,f);
pdf_f:= f;
s:= 0;
end;

if not pdf_doing_string then begin
pdf_print(" [");
if s= 0 then
pdf_out("(");
end;

if s<> 0 then begin
if pdf_doing_string then
pdf_out(")");
pdf_print_int(-s);
pdf_out("(");
pdf_delta_h:= pdf_delta_h+s_out;
end;
pdf_doing_string:= true;
end;

procedure pdf_insert_fake_space;
var s:integer;{to save|gen_faked_interword_space|}
begin
s:= gen_faked_interword_space;
gen_faked_interword_space:= 0;{to prevent inserting another fake space in|pdf_begin_string|}

pdf_read_dummy_font;
pdf_begin_string(pdf_dummy_font);
pdf_print(" ");
pdf_end_string_nl;

gen_faked_interword_space:= s;
end;


procedure pdf_end_text;{end a text section}
begin
if pdf_doing_text then begin
pdf_end_string_nl;
pdf_print_ln("ET");
pdf_doing_text:= false;
end;
end;

procedure pdf_set_rule(x,y,w,h:scaled);{draw a rule}
begin
pdf_end_text;
pdf_print_ln("q");
if h<=one_bp then begin
pdf_set_origin_temp(x,y-(h+1)/2);
pdf_print("[]0 d 0 J ");
pdf_print_bp(h);pdf_print(" w 0 0 m ");
pdf_print_bp(w);pdf_print_ln(" 0 l S");
end
else if w<=one_bp then begin
pdf_set_origin_temp(x+(w+1)/2,y);
pdf_print("[]0 d 0 J ");
pdf_print_bp(w);pdf_print(" w 0 0 m 0 ");
pdf_print_bp(h);pdf_print_ln(" l S");
end
else begin
pdf_set_origin_temp(x,y);
pdf_print("0 0 ");
pdf_print_bp(w);pdf_out(" ");
pdf_print_bp(h);pdf_print_ln(" re f");
end;
pdf_print_ln("Q");
end;

procedure pdf_rectangle(left,top,right,bottom:scaled);{output a
rectangle specification to PDF file}
begin
prepare_mag;
pdf_print("/Rect [");
pdf_print_mag_bp(pdf_x(left));pdf_out(" ");
pdf_print_mag_bp(pdf_y(bottom));pdf_out(" ");
pdf_print_mag_bp(pdf_x(right));pdf_out(" ");
pdf_print_mag_bp(pdf_y(top));
pdf_print_ln("]");
end;

{Prints first|len|characters of string|s|(if it's that long).
There must be a better way to print a substring?}
procedure slow_print_substr(s,max_len:integer);
var j:pool_pointer;{current character code position}
begin if(s>=str_ptr)or(s<256)then print(s)
else begin j:= str_start[s];
while(j<str_start[s+1])and(j<=str_start[s]+max_len)do
begin print(so(str_pool[j]));incr(j);
end;
end;
if j<str_start[s+1]then print("...");{indicate truncation}
end;

procedure literal(s:str_number;literal_mode:integer;warn:boolean);
var j:pool_pointer;{current character code position}
begin
j:= str_start[s];
if literal_mode= scan_special then begin
if not(str_in_str(s,"PDF:",0)or str_in_str(s,"pdf:",0))then begin
if warn and not(str_in_str(s,"SRC:",0)
or str_in_str(s,"src:",0)
or(length(s)= 0))then begin
print_nl("Non-PDF special ignored!");
print_nl("<special> ");
slow_print_substr(s,64);
{length of printed line should be<=78;good enough.}
print_ln;
end;
return;
end;
j:= j+length("PDF:");
if str_in_str(s,"direct:",length("PDF:"))then begin
j:= j+length("direct:");
literal_mode:= direct_always;end
else if str_in_str(s,"page:",length("PDF:"))then begin
j:= j+length("page:");
literal_mode:= direct_page;end
else
literal_mode:= set_origin;
end;
case literal_mode of
set_origin:begin
pdf_end_text;
pdf_set_origin(cur_h,cur_v);
end;
direct_page:
pdf_end_text;
direct_always:
pdf_end_string_nl;
othercases confusion("literal1")
endcases;
while j<str_start[s+1]do begin
pdf_out(str_pool[j]);
incr(j);
end;
pdf_print_nl;
end;

/*:693*//*702:*/
#line 16956 "pdftexdir/pdftex.web"
procedure pdf_print_fw_int(n:longinteger;w:integer);{print out an integer with
fixed width;used for outputting cross-reference table}
var k:integer;{$0\le k\le23$}
begin
k:= 0;
repeat dig[k]:= n mod 10;n:= n div 10;incr(k);
until k= w;
pdf_room(k);
while k> 0 do begin
decr(k);
pdf_quick_out("0"+dig[k]);
end;
end;

procedure pdf_out_bytes(n:longinteger;w:integer);{print out an integer as
a number of bytes;used for outputting\.{/XRef}cross-reference stream}
var k:integer;
byte:array[0. .7]of integer;{digits in a number being output}
begin
k:= 0;
repeat byte[k]:= n mod 256;n:= n div 256;incr(k);
until k= w;
pdf_room(k);
while k> 0 do begin
decr(k);
pdf_quick_out(byte[k]);
end;
end;

procedure pdf_int_entry(s:str_number;v:integer);{print out an entry in
dictionary with integer value to PDF buffer}
begin
pdf_out("/");
pdf_print(s);
pdf_out(" ");
pdf_print_int(v);
end;

procedure pdf_int_entry_ln(s:str_number;v:integer);
begin
pdf_int_entry(s,v);
pdf_print_nl;
end;

procedure pdf_indirect(s:str_number;o:integer);{print out an indirect
entry in dictionary}
begin
pdf_out("/");
pdf_print(s);
pdf_out(" ");
pdf_print_int(o);
pdf_print(" 0 R");
end;

procedure pdf_indirect_ln(s:str_number;o:integer);
begin
pdf_indirect(s,o);
pdf_print_nl;
end;

procedure pdf_print_str(s:str_number);{print out|s|as string in PDF
output}
label done;
var i,j:pool_pointer;
is_hex_string:boolean;
begin
i:= str_start[s];
j:= i+length(s)-1;
if i> j then begin
pdf_print("()");{null string}
return;
end;
if(str_pool[i]= '(')and(str_pool[j]= ')')then begin
pdf_print(s);
return;
end;
is_hex_string:= false;
if(str_pool[i]<> '<')or(str_pool[j]<> '>')or odd(length(s))then
goto done;
incr(i);
decr(j);
while i<j do begin
if is_hex_char(str_pool[i])and is_hex_char(str_pool[i+1])then
i:= i+2
else
goto done;
end;
is_hex_string:= true;
done:
if is_hex_string then
pdf_print(s)
else begin
pdf_out("(");
pdf_print(s);
pdf_out(")");
end;
end;

procedure pdf_print_str_ln(s:str_number);{print out|s|as string in PDF
output}
begin
pdf_print_str(s);
pdf_print_nl;
end;

procedure pdf_str_entry(s,v:str_number);{print out an entry in
dictionary with string value to PDF buffer}
begin
if v= 0 then
return;
pdf_out("/");
pdf_print(s);
pdf_out(" ");
pdf_print_str(v);
end;

procedure pdf_str_entry_ln(s,v:str_number);
begin
if v= 0 then
return;
pdf_str_entry(s,v);
pdf_print_nl;
end;

/*:702*//*705:*/
#line 17123 "pdftexdir/pdftex.web"

procedure set_tag_code(f:internal_font_number;c:eight_bits;i:integer);
var fixedi:integer;
begin
if is_valid_char(c)then
begin fixedi:= abs(fix_int(i,-7,0));
if fixedi>=4 then begin
if char_tag(char_info(f)(c))= ext_tag then
op_byte(char_info(f)(c)):= (op_byte(char_info(f)(c)))-ext_tag;
fixedi:= fixedi-4;
end;
if fixedi>=2 then begin
if char_tag(char_info(f)(c))= list_tag then
op_byte(char_info(f)(c)):= (op_byte(char_info(f)(c)))-list_tag;
fixedi:= fixedi-2;
end;
if fixedi>=1 then begin
if char_tag(char_info(f)(c))= lig_tag then
op_byte(char_info(f)(c)):= (op_byte(char_info(f)(c)))-lig_tag;
end;
end;
end;

procedure set_no_ligatures(f:internal_font_number);
var c:integer;
begin
for c:= font_bc[f]to font_ec[f]do
if char_exists(orig_char_info(f)(c))then
if char_tag(orig_char_info(f)(c))= lig_tag then
op_byte(orig_char_info(f)(c)):= (op_byte(orig_char_info(f)(c)))-lig_tag;
end;

function init_font_base(v:integer):integer;
var i,j:integer;
begin
i:= pdf_get_mem(256);
for j:= 0 to 255 do
pdf_mem[i+j]:= v;
init_font_base:= i;
end;

procedure set_lp_code(f:internal_font_number;c:eight_bits;i:integer);
begin
if pdf_font_lp_base[f]= 0 then
pdf_font_lp_base[f]:= init_font_base(0);
pdf_mem[pdf_font_lp_base[f]+c]:= fix_int(i,-1000,1000);
end;

procedure set_rp_code(f:internal_font_number;c:eight_bits;i:integer);
begin
if pdf_font_rp_base[f]= 0 then
pdf_font_rp_base[f]:= init_font_base(0);
pdf_mem[pdf_font_rp_base[f]+c]:= fix_int(i,-1000,1000);
end;

procedure set_ef_code(f:internal_font_number;c:eight_bits;i:integer);
begin
if pdf_font_ef_base[f]= 0 then
pdf_font_ef_base[f]:= init_font_base(1000);
pdf_mem[pdf_font_ef_base[f]+c]:= fix_int(i,0,1000);
end;

procedure set_kn_bs_code(f:internal_font_number;c:eight_bits;i:integer);
begin
if pdf_font_kn_bs_base[f]= 0 then
pdf_font_kn_bs_base[f]:= init_font_base(0);
pdf_mem[pdf_font_kn_bs_base[f]+c]:= fix_int(i,-1000,1000);
end;

procedure set_st_bs_code(f:internal_font_number;c:eight_bits;i:integer);
begin
if pdf_font_st_bs_base[f]= 0 then
pdf_font_st_bs_base[f]:= init_font_base(0);
pdf_mem[pdf_font_st_bs_base[f]+c]:= fix_int(i,-1000,1000);
end;

procedure set_sh_bs_code(f:internal_font_number;c:eight_bits;i:integer);
begin
if pdf_font_sh_bs_base[f]= 0 then
pdf_font_sh_bs_base[f]:= init_font_base(0);
pdf_mem[pdf_font_sh_bs_base[f]+c]:= fix_int(i,-1000,1000);
end;

procedure set_kn_bc_code(f:internal_font_number;c:eight_bits;i:integer);
begin
if pdf_font_kn_bc_base[f]= 0 then
pdf_font_kn_bc_base[f]:= init_font_base(0);
pdf_mem[pdf_font_kn_bc_base[f]+c]:= fix_int(i,-1000,1000);
end;

procedure set_kn_ac_code(f:internal_font_number;c:eight_bits;i:integer);
begin
if pdf_font_kn_ac_base[f]= 0 then
pdf_font_kn_ac_base[f]:= init_font_base(0);
pdf_mem[pdf_font_kn_ac_base[f]+c]:= fix_int(i,-1000,1000);
end;

procedure adjust_interword_glue(p,g:pointer);{adjust the interword
glue|g|after a character|p|}
var kn,st,sh:scaled;
q,r:pointer;
c:halfword;
f:internal_font_number;
begin
if not(not is_char_node(g)and type(g)= glue_node)then begin
pdf_warning("adjust_interword_glue","g is not a glue",false,false);
return;
end;

c:= non_char;{no char before interword glue yet}
set_char_and_font(p){set|f|and|c|if|p|is a char or ligature}
else if(type(p)= kern_node)and
(subtype(p)= auto_kern)and
(save_tail<> null)then
begin
r:= save_tail;
while(link(r)<> null)and(link(r)<> p)do
r:= link(r);
if(link(r)= p)then
set_char_and_font(r);{set|f|and|c|if|r|is a char or ligature}
end;
if(c= non_char)then
return;

kn:= get_kn_bs_code(f,c);
st:= get_st_bs_code(f,c);
sh:= get_sh_bs_code(f,c);
if(kn<> 0)or(st<> 0)or(sh<> 0)then begin
q:= new_spec(glue_ptr(g));
delete_glue_ref(glue_ptr(g));
width(q):= width(q)+round_xn_over_d(quad(f),kn,1000);
stretch(q):= stretch(q)+round_xn_over_d(quad(f),st,1000);
shrink(q):= shrink(q)+round_xn_over_d(quad(f),sh,1000);
glue_ptr(g):= q;
end;
end;

function get_auto_kern(f:internal_font_number;l,r:halfword):pointer;
{return a pointer to an auto kern node,or|null|}
var tmp_w:scaled;
k:integer;
p:pointer;
begin
pdfassert((l>=0)and(r>=0));
get_auto_kern:= null;
if(pdf_append_kern<=0)and(pdf_prepend_kern<=0)then
return;
tmp_w:= 0;
if(pdf_append_kern> 0)and(l<non_char)then begin
k:= get_kn_ac_code(f,l);
if k<> 0 then
tmp_w:= round_xn_over_d(quad(f),k,1000);
end;
if(pdf_prepend_kern> 0)and(r<non_char)then begin
k:= get_kn_bc_code(f,r);
if k<> 0 then
tmp_w:= tmp_w+round_xn_over_d(quad(f),k,1000);
end;
if tmp_w<> 0 then begin
p:= new_kern(tmp_w);
subtype(p):= auto_kern;
get_auto_kern:= p;
end;
end;


function expand_font_name(f:internal_font_number;e:integer):str_number;
var old_setting:0..max_selector;{holds|selector|setting}
begin
old_setting:= selector;selector:= new_string;
print(font_name[f]);
if e> 0 then
print("+");{minus sign will be printed by|print_int|}
print_int(e);
selector:= old_setting;
expand_font_name:= make_string;
end;

function auto_expand_font(f:internal_font_number;e:integer):internal_font_number;
{creates an expanded font from the base font;doesn't load expanded tfm at all}
var k:internal_font_number;
nw,nk,ni,i:integer;
begin
k:= font_ptr+1;
incr(font_ptr);
if(font_ptr>=font_max)then
overflow("maximum internal font number (font_max)",font_max);
font_name[k]:= expand_font_name(f,e);
font_area[k]:= font_area[f];
font_id_text(k):= font_id_text(f);
hyphen_char[k]:= hyphen_char[f];
skew_char[k]:= skew_char[f];
font_bchar[k]:= font_bchar[f];
font_false_bchar[k]:= font_false_bchar[f];
font_bc[k]:= font_bc[f];
font_ec[k]:= font_ec[f];
font_size[k]:= font_size[f];
font_dsize[k]:= font_dsize[f];
font_params[k]:= font_params[f];
font_glue[k]:= font_glue[f];
bchar_label[k]:= bchar_label[f];

char_base[k]:= char_base[f];
height_base[k]:= height_base[f];
depth_base[k]:= depth_base[f];
lig_kern_base[k]:= lig_kern_base[f];
exten_base[k]:= exten_base[f];
param_base[k]:= param_base[f];

nw:= height_base[f]-width_base[f];
ni:= lig_kern_base[f]-italic_base[f];
nk:= exten_base[f]-(kern_base[f]+kern_base_offset);
if(fmem_ptr+nw+ni+nk>=font_mem_size)then
overflow("number of words of font memory (font_mem_size)",font_mem_size);
width_base[k]:= fmem_ptr;
italic_base[k]:= width_base[k]+nw;
kern_base[k]:= italic_base[k]+ni-kern_base_offset;
fmem_ptr:= fmem_ptr+nw+ni+nk;

for i:= 0 to nw-1 do
font_info[width_base[k]+i].sc:= 
round_xn_over_d(font_info[width_base[f]+i].sc,1000+e,1000);
for i:= 0 to ni-1 do
font_info[italic_base[k]+i].sc:= 
round_xn_over_d(font_info[italic_base[f]+i].sc,1000+e,1000);
for i:= 0 to nk-1 do
font_info[kern_base[k]+kern_base_offset+i].sc:= 
round_xn_over_d(font_info[kern_base[f]+kern_base_offset+i].sc,1000+e,1000);

auto_expand_font:= k;
end;

procedure copy_expand_params(k,f:internal_font_number;e:integer);
{set expansion-related parameters for an expanded font|k|,based on the base
font|f|and the expansion amount|e|}
begin
if pdf_font_rp_base[f]= 0 then
pdf_font_rp_base[f]:= init_font_base(0);
if pdf_font_lp_base[f]= 0 then
pdf_font_lp_base[f]:= init_font_base(0);
if pdf_font_ef_base[f]= 0 then
pdf_font_ef_base[f]:= init_font_base(1000);
pdf_font_expand_ratio[k]:= e;
pdf_font_step[k]:= pdf_font_step[f];
pdf_font_auto_expand[k]:= pdf_font_auto_expand[f];
pdf_font_blink[k]:= f;
pdf_font_lp_base[k]:= pdf_font_lp_base[f];
pdf_font_rp_base[k]:= pdf_font_rp_base[f];
pdf_font_ef_base[k]:= pdf_font_ef_base[f];

if pdf_font_kn_bs_base[f]= 0 then
pdf_font_kn_bs_base[f]:= init_font_base(0);
if pdf_font_st_bs_base[f]= 0 then
pdf_font_st_bs_base[f]:= init_font_base(0);
if pdf_font_sh_bs_base[f]= 0 then
pdf_font_sh_bs_base[f]:= init_font_base(0);
if pdf_font_kn_bc_base[f]= 0 then
pdf_font_kn_bc_base[f]:= init_font_base(0);
if pdf_font_kn_ac_base[f]= 0 then
pdf_font_kn_ac_base[f]:= init_font_base(0);
pdf_font_kn_bs_base[k]:= pdf_font_kn_bs_base[f];
pdf_font_st_bs_base[k]:= pdf_font_st_bs_base[f];
pdf_font_sh_bs_base[k]:= pdf_font_sh_bs_base[f];
pdf_font_kn_bc_base[k]:= pdf_font_kn_bc_base[f];
pdf_font_kn_ac_base[k]:= pdf_font_kn_ac_base[f];
end;

function tfm_lookup(s:str_number;fs:scaled):internal_font_number;
{looks up for a TFM with name|s|loaded at|fs|size;if found then flushes|s|}
var k:internal_font_number;
begin
if fs<> 0 then begin
for k:= font_base+1 to font_ptr do
if(font_area[k]<> non_existent_path)and
str_eq_str(font_name[k],s)and
(font_size[k]= fs)then
begin
flush_str(s);
tfm_lookup:= k;
return;
end;
end
else begin
for k:= font_base+1 to font_ptr do
if(font_area[k]<> non_existent_path)and
str_eq_str(font_name[k],s)then
begin
flush_str(s);
tfm_lookup:= k;
return;
end;
end;
tfm_lookup:= null_font;
end;

function load_expand_font(f:internal_font_number;e:integer):internal_font_number;
{loads font|f|expanded by|e|thousandths into font memory;|e|is nonzero
and is a multiple of|pdf_font_step[f]|}
label found;
var s:str_number;{font name}
k:internal_font_number;
begin
s:= expand_font_name(f,e);
k:= tfm_lookup(s,font_size[f]);
if k= null_font then begin
if pdf_font_auto_expand[f]then
k:= auto_expand_font(f,e)
else
k:= read_font_info(null_cs,s,"",font_size[f]);
end;
if k<> null_font then
copy_expand_params(k,f,e);
load_expand_font:= k;
end;

function fix_expand_value(f:internal_font_number;e:integer):integer;
{return the multiple of|pdf_font_step[f]|that is nearest to|e|}
var step:integer;
max_expand:integer;
neg:boolean;
begin
fix_expand_value:= 0;
if e= 0 then
return;
if e<0 then begin
e:= -e;
neg:= true;
max_expand:= -pdf_font_expand_ratio[pdf_font_shrink[f]];
end
else begin
neg:= false;
max_expand:= pdf_font_expand_ratio[pdf_font_stretch[f]];
end;
if e> max_expand then
e:= max_expand
else begin
step:= pdf_font_step[f];
if e mod step> 0 then
e:= step*round_xn_over_d(e,1,step);
end;
if neg then
e:= -e;
fix_expand_value:= e;
end;

function get_expand_font(f:internal_font_number;e:integer):internal_font_number;
{look up and create if not found an expanded version of|f|;|f|is an
expandable font;|e|is nonzero and is a multiple of|pdf_font_step[f]|}
var k:internal_font_number;
begin
k:= pdf_font_elink[f];
while k<> null_font do begin
if pdf_font_expand_ratio[k]= e then begin
get_expand_font:= k;
return;
end;
k:= pdf_font_elink[k];
end;
k:= load_expand_font(f,e);
pdf_font_elink[k]:= pdf_font_elink[f];
pdf_font_elink[f]:= k;
get_expand_font:= k;
end;

function expand_font(f:internal_font_number;e:integer):internal_font_number;
{looks up for font|f|expanded by|e|thousandths,|e|is an arbitrary value
between max stretch and max shrink of|f|;if not found then creates it}
begin
expand_font:= f;
if e= 0 then
return;
e:= fix_expand_value(f,e);
if e= 0 then
return;
if pdf_font_elink[f]= null_font then
pdf_error("font expansion","uninitialized pdf_font_elink");
expand_font:= get_expand_font(f,e);
end;

procedure set_expand_params(f:internal_font_number;auto_expand:boolean;
stretch_limit,shrink_limit,font_step,expand_ratio:integer);
{expand a font with given parameters}
begin
pdf_font_step[f]:= font_step;
pdf_font_auto_expand[f]:= auto_expand;
if stretch_limit> 0 then
pdf_font_stretch[f]:= get_expand_font(f,stretch_limit);
if shrink_limit> 0 then
pdf_font_shrink[f]:= get_expand_font(f,-shrink_limit);
if expand_ratio<> 0 then
pdf_font_expand_ratio[f]:= expand_ratio;
end;

procedure vf_expand_local_fonts(f:internal_font_number);
var lf:internal_font_number;
k:integer;
begin
pdfassert(pdf_font_type[f]= virtual_font_type);
for k:= 0 to vf_local_font_num[f]-1 do begin
lf:= vf_i_fnts[vf_default_font[f]+k];
set_expand_params(lf,pdf_font_auto_expand[f],
pdf_font_expand_ratio[pdf_font_stretch[f]],
-pdf_font_expand_ratio[pdf_font_shrink[f]],
pdf_font_step[f],pdf_font_expand_ratio[f]);
if pdf_font_type[lf]= virtual_font_type then
vf_expand_local_fonts(lf);
end;
end;

procedure read_expand_font;{read font expansion spec and load expanded font}
var shrink_limit,stretch_limit,font_step:integer;
f:internal_font_number;
auto_expand:boolean;
begin
{read font expansion parameters}
scan_font_ident;
f:= cur_val;
if f= null_font then
pdf_error("font expansion","invalid font identifier");
if pdf_font_blink[f]<> null_font then
pdf_error("font expansion","\pdffontexpand cannot be used this way (the base font has been expanded)");
scan_optional_equals;
scan_int;
stretch_limit:= fix_int(cur_val,0,1000);
scan_int;
shrink_limit:= fix_int(cur_val,0,500);
scan_int;
font_step:= fix_int(cur_val,0,100);
if font_step= 0 then
pdf_error("font expansion","invalid step");
stretch_limit:= stretch_limit-stretch_limit mod font_step;
if stretch_limit<0 then
stretch_limit:= 0;
shrink_limit:= shrink_limit-shrink_limit mod font_step;
if shrink_limit<0 then
shrink_limit:= 0;
if(stretch_limit= 0)and(shrink_limit= 0)then
pdf_error("font expansion","invalid limit(s)");
auto_expand:= false;
if scan_keyword("autoexpand")then begin
auto_expand:= true;
/*469:*/
#line 10264 "pdftexdir/pdftex.web"

begin get_x_token;if cur_cmd<> spacer then back_input;
end

/*:469*/
#line 17564 "pdftexdir/pdftex.web"
;
end;

{check if the font can be expanded}
if(pdf_font_expand_ratio[f]<> 0)then
pdf_error("font expansion","this font has been expanded by another font so it cannot be used now");
if(pdf_font_step[f]<> 0)then
{this font has been expanded,ensure the expansion parameters are identical}
begin
if pdf_font_step[f]<> font_step then
pdf_error("font expansion","font has been expanded with different expansion step");

if((pdf_font_stretch[f]= null_font)and(stretch_limit<> 0))or
((pdf_font_stretch[f]<> null_font)and
(pdf_font_expand_ratio[pdf_font_stretch[f]]<> stretch_limit))then
pdf_error("font expansion","font has been expanded with different stretch limit");

if((pdf_font_shrink[f]= null_font)and(shrink_limit<> 0))or
((pdf_font_shrink[f]<> null_font)and
(-pdf_font_expand_ratio[pdf_font_shrink[f]]<> shrink_limit))then
pdf_error("font expansion","font has been expanded with different shrink limit");

if pdf_font_auto_expand[f]<> auto_expand then
pdf_error("font expansion","font has been expanded with different auto expansion value");
end
else begin
if(pdf_font_type[f]<> new_font_type)and(pdf_font_type[f]<> virtual_font_type)then
pdf_warning("font expansion","font should be expanded before its first use",
true,true);
set_expand_params(f,auto_expand,stretch_limit,shrink_limit,font_step,0);
if pdf_font_type[f]= virtual_font_type then
vf_expand_local_fonts(f);
end;
end;

/*:705*//*706:*/
#line 17612 "pdftexdir/pdftex.web"

function letter_space_font(u:pointer;f:internal_font_number;e:integer):internal_font_number;
var k:internal_font_number;
w,r:scaled;
s:str_number;
i,nw:integer;
old_setting:0..max_selector;
vf_z:integer;
vf_alpha:integer;
vf_beta:1. .16;
begin
{read a new font and expand the character widths}
k:= read_font_info(u,font_name[f],"",font_size[f]);
if scan_keyword("nolig")then
set_no_ligatures(k);{disable ligatures for letter-spaced fonts}
nw:= height_base[k]-width_base[k];
for i:= 0 to nw-1 do
font_info[width_base[k]+i].sc:= 
font_info[width_base[k]+i].sc+round_xn_over_d(quad(k),e,1000);

{append,e.g.,'+100ls'to font name}
flush_str(font_name[k]);
str_room(length(font_name[k])+7);{|abs(e)<=1000|}
old_setting:= selector;
selector:= new_string;
print(font_name[k]);
if e> 0 then
print("+");{minus sign will be printed by|print_int|}
print_int(e);
print("ls");
selector:= old_setting;
font_name[k]:= make_string;

{create the corresponding virtual font}
allocvffnts;
vf_e_fnts[vf_nf]:= 0;
vf_i_fnts[vf_nf]:= f;
incr(vf_nf);
vf_local_font_num[k]:= 1;
vf_default_font[k]:= vf_nf-1;
pdf_font_type[k]:= virtual_font_type;

vf_z:= font_size[f];
vf_replace_z;
w:= round_xn_over_d(quad(f),e,2000);
if w>=0 then
tmp_b0:= 0
else begin
tmp_b0:= 255;
w:= vf_alpha+w;
end;
r:= w*vf_beta;
tmp_b1:= r div vf_z;
r:= r mod vf_z;
if r= 0 then
tmp_b2:= 0
else begin
r:= r*256;
tmp_b2:= r div vf_z;
r:= r mod vf_z;
end;
if r= 0 then
tmp_b3:= 0
else begin
r:= r*256;
tmp_b3:= r div vf_z;
end;
vf_packet_base[k]:= new_vf_packet(k);
for c:= font_bc[k]to font_ec[k]do begin
str_room(12);
append_char(right1+3);
append_char(tmp_b0);
append_char(tmp_b1);
append_char(tmp_b2);
append_char(tmp_b3);
if c<set1 then
append_char(c)
else begin
append_char(set1);
append_char(c);
end;
append_char(right1+3);
append_char(tmp_b0);
append_char(tmp_b1);
append_char(tmp_b2);
append_char(tmp_b3);
s:= make_string;
storepacket(k,c,s);
flush_str(s);
end;
letter_space_font:= k;
end;

procedure new_letterspaced_font(a:small_number);
{letter-space a font by creating a virtual font}
var u:pointer;{user's font identifier}
t:str_number;{name for the frozen font identifier}
old_setting:0..max_selector;{holds|selector|setting}
f,k:internal_font_number;
begin
get_r_token;u:= cur_cs;
if u>=hash_base then t:= text(u)
else if u>=single_base then
if u= null_cs then t:= "FONT"else t:= u-single_base
else begin old_setting:= selector;selector:= new_string;
print("FONT");print(u-active_base);selector:= old_setting;

str_room(1);t:= make_string;
end;
define(u,set_font,null_font);scan_optional_equals;scan_font_ident;
k:= cur_val;
scan_int;
f:= letter_space_font(u,k,fix_int(cur_val,-1000,1000));
equiv(u):= f;eqtb[font_id_base+f]:= eqtb[u];font_id_text(f):= t;
end;

function is_letterspaced_font(f:internal_font_number):boolean;
label done;
var i,j:pool_pointer;
begin
is_letterspaced_font:= false;
if pdf_font_type[f]<> virtual_font_type then
return;
i:= str_start[font_name[f]+1]-1;
j:= str_start[font_name[f]];
if(str_pool[i-1]<> 'l')or(str_pool[i]<> 's')then
return;
i:= i-2;
while i>=j do begin
if(str_pool[i]<'0')or(str_pool[i]> '9')then
goto done;
i:= i-1;
end;
done:
if i<j then
return;
if(str_pool[i]<> '+')and(str_pool[i]<> '-')then
return;
is_letterspaced_font:= true;
end;

function copy_font_info(f:internal_font_number):internal_font_number;
{create a copy of|f|in the font mem}
var lf,bc,ec,i:halfword;
k:internal_font_number;
begin
if(pdf_font_expand_ratio[f]<> 0)or(pdf_font_step[f]<> 0)then
pdf_error("\pdfcopyfont","cannot copy an expanded font");
if is_letterspaced_font(f)then
pdf_error("\pdfcopyfont","cannot copy a letterspaced font");

k:= font_ptr+1;
incr(font_ptr);
if(font_ptr>=font_max)then
overflow("maximum internal font number (font_max)",font_max);
font_name[k]:= font_name[f];
font_area[k]:= non_existent_path;{to avoid interferences with|new_font()|and|tfm_lookup()|}
hyphen_char[k]:= hyphen_char[f];
skew_char[k]:= skew_char[f];
font_bchar[k]:= font_bchar[f];
font_false_bchar[k]:= font_false_bchar[f];
font_bc[k]:= font_bc[f];
font_ec[k]:= font_ec[f];
font_size[k]:= font_size[f];
font_dsize[k]:= font_dsize[f];
font_params[k]:= font_params[f];
font_glue[k]:= font_glue[f];
bchar_label[k]:= bchar_label[f];

{set base addresses}
bc:= font_bc[f];
ec:= font_ec[f];
char_base[k]:= fmem_ptr-bc;
width_base[k]:= char_base[k]+ec+1;

height_base[k]:= width_base[k]+(height_base[f]-width_base[f]);
depth_base[k]:= height_base[k]+(depth_base[f]-height_base[f]);
italic_base[k]:= depth_base[k]+(italic_base[f]-depth_base[f]);
lig_kern_base[k]:= italic_base[k]+(lig_kern_base[f]-italic_base[f]);
kern_base[k]:= lig_kern_base[k]+(kern_base[f]-lig_kern_base[f]);
exten_base[k]:= kern_base[k]+(exten_base[f]-kern_base[f]);
param_base[k]:= exten_base[k]+(param_base[f]-exten_base[f]);

{allocate memory for the new font|k|and copy data from|f|}
lf:= (param_base[f]-char_base[f])+font_params[f]+1;
if(fmem_ptr+lf>=font_mem_size)then
overflow("number of words of font memory (font_mem_size)",font_mem_size);
for i:= 0 to lf-1 do
font_info[char_base[k]+bc+i]:= font_info[char_base[f]+bc+i];
fmem_ptr:= fmem_ptr+lf;

copy_font_info:= k;
end;

procedure make_font_copy(a:small_number);
{make a font copy for further use with font expansion}
var u:pointer;{user's font identifier}
t:str_number;{name for the frozen font identifier}
old_setting:0..max_selector;{holds|selector|setting}
f,k:internal_font_number;
begin
get_r_token;u:= cur_cs;
if u>=hash_base then t:= text(u)
else if u>=single_base then
if u= null_cs then t:= "FONT"else t:= u-single_base
else begin old_setting:= selector;selector:= new_string;
print("FONT");print(u-active_base);selector:= old_setting;

str_room(1);t:= make_string;
end;
define(u,set_font,null_font);scan_optional_equals;scan_font_ident;
k:= cur_val;
f:= copy_font_info(k);
equiv(u):= f;eqtb[font_id_base+f]:= eqtb[u];font_id_text(f):= t;
end;

/*:706*//*712:*/
#line 17889 "pdftexdir/pdftex.web"

procedure vf_error(filename,msg:str_number);
var old_setting:0..max_selector;{holds print|selector|}
s:str_number;
begin
str_room(length(filename)+3);
old_setting:= selector;selector:= new_string;
print(filename);
print(".vf");
s:= make_string;
selector:= old_setting;
pdf_error(s,msg);
end;

function vf_byte:eight_bits;{read a byte from|vf_file|}
var i:integer;
begin
i:= getc(vf_file);
if i<0 then
pdf_error("vf","unexpected EOF or error");
vf_byte:= i;
end;

function vf_read_signed(k:integer):integer;
{read|k|bytes as an signed integer from\.{VF}file}
var i:integer;
begin
pdfassert((k> 0)and(k<=4));
i:= vf_byte;
if i>=128 then
i:= i-256;
decr(k);
while k> 0 do begin
i:= i*256+vf_byte;
decr(k);
end;
vf_read_signed:= i;
end;

function vf_read_unsigned(k:integer):integer;
{read|k|bytes as an unsigned integer from\.{VF}file}
var i:integer;
begin
pdfassert((k> 0)and(k<=4));
i:= vf_byte;
if(k= 4)and(i>=128)then
bad_vf("number too big");
decr(k);
while k> 0 do begin
i:= i*256+vf_byte;
decr(k);
end;
vf_read_unsigned:= i;
end;

procedure vf_local_font_warning(f,k:internal_font_number;s:str_number);
{print a warning message if an error occurs during processing local fonts in
\.{VF}file}
begin
print_nl(s);
print(" in local font ");
print(font_name[k]);
print(" in virtual font ");
print(font_name[f]);
print(".vf ignored.");
end;

function vf_def_font(f:internal_font_number):internal_font_number;
{process a local font in\.{VF}file}
var k:internal_font_number;
s:str_number;
ds,fs:scaled;
cs:four_quarters;
begin
cs.b0:= vf_byte;cs.b1:= vf_byte;cs.b2:= vf_byte;cs.b3:= vf_byte;
fs:= store_scaled_f(vf_read_signed(4),font_size[f]);
ds:= vf_read_signed(4)div 50
tmp_b0:= vf_byte;
tmp_b1:= vf_byte;
while tmp_b0> 0 do begin
decr(tmp_b0);
call_func(vf_byte);{skip the font path}
end;
str_room(tmp_b1);
while tmp_b1> 0 do begin
decr(tmp_b1);
append_char(vf_byte);
end;
s:= make_string;
k:= tfm_lookup(s,fs);
if k= null_font then
k:= read_font_info(null_cs,s,"",fs);
if k<> null_font then begin
if((cs.b0<> 0)or(cs.b1<> 0)or(cs.b2<> 0)or(cs.b3<> 0))and
((font_check[k].b0<> 0)or(font_check[k].b1<> 0)or
(font_check[k].b2<> 0)or(font_check[k].b3<> 0))and
((cs.b0<> font_check[k].b0)or(cs.b1<> font_check[k].b1)or
(cs.b2<> font_check[k].b2)or(cs.b3<> font_check[k].b3))then
vf_local_font_warning(f,k,"checksum mismatch");
if ds<> font_dsize[k]then
vf_local_font_warning(f,k,"design size mismatch");
if(pdf_font_step[f]<> 0)then
set_expand_params(k,pdf_font_auto_expand[f],
pdf_font_expand_ratio[pdf_font_stretch[f]],
-pdf_font_expand_ratio[pdf_font_shrink[f]],
pdf_font_step[f],pdf_font_expand_ratio[f]);
end;
vf_def_font:= k;
end;

procedure do_vf(f:internal_font_number);{process\.{VF}file with font internal number|f|}
var cmd,k,n:integer;
cc,cmd_length,packet_length:integer;
tfm_width:scaled;
s:str_number;
stack_level:vf_stack_index;
save_vf_nf:internal_font_number;
begin
pdf_font_type[f]:= real_font_type;
if auto_expand_vf(f)then
return;{auto-expanded virtual font}
stack_level:= 0;
/*713:*/
#line 18024 "pdftexdir/pdftex.web"

pack_file_name(font_name[f],"",".vf");
if not vf_b_open_in(vf_file)then
return

/*:713*/
#line 18011 "pdftexdir/pdftex.web"
;
/*714:*/
#line 18029 "pdftexdir/pdftex.web"

if vf_byte<> pre then
bad_vf("PRE command expected");
if vf_byte<> vf_id then
bad_vf("wrong id byte");
cmd_length:= vf_byte;
for k:= 1 to cmd_length do
call_func(vf_byte);{skip the comment}
tmp_b0:= vf_byte;tmp_b1:= vf_byte;tmp_b2:= vf_byte;tmp_b3:= vf_byte;
if((tmp_b0<> 0)or(tmp_b1<> 0)or(tmp_b2<> 0)or(tmp_b3<> 0))and
((font_check[f].b0<> 0)or(font_check[f].b1<> 0)or
(font_check[f].b2<> 0)or(font_check[f].b3<> 0))and
((tmp_b0<> font_check[f].b0)or(tmp_b1<> font_check[f].b1)or
(tmp_b2<> font_check[f].b2)or(tmp_b3<> font_check[f].b3))then begin
print_nl("checksum mismatch in font ");
print(font_name[f]);
print(".vf ignored");
end;
if vf_read_signed(4)div 50
print_nl("design size mismatch in font ");
print(font_name[f]);
print(".vf ignored");
end;
update_terminal

/*:714*/
#line 18012 "pdftexdir/pdftex.web"
;
/*715:*/
#line 18054 "pdftexdir/pdftex.web"

cmd:= vf_byte;
save_vf_nf:= vf_nf;
while(cmd>=fnt_def1)and(cmd<=fnt_def1+3)do begin
allocvffnts;
vf_e_fnts[vf_nf]:= vf_read_unsigned(cmd-fnt_def1+1);
vf_i_fnts[vf_nf]:= vf_def_font(f);
incr(vf_nf);
cmd:= vf_byte;
end;
vf_default_font[f]:= save_vf_nf;
vf_local_font_num[f]:= vf_nf-save_vf_nf;

/*:715*/
#line 18013 "pdftexdir/pdftex.web"
;
/*716:*/
#line 18067 "pdftexdir/pdftex.web"

vf_packet_base[f]:= new_vf_packet(f)

/*:716*/
#line 18014 "pdftexdir/pdftex.web"
;
while cmd<=long_char do begin
/*717:*/
#line 18070 "pdftexdir/pdftex.web"

if cmd= long_char then begin
packet_length:= vf_read_unsigned(4);
cc:= vf_read_unsigned(4);
if not is_valid_char(cc)then
bad_vf("invalid character code");
tfm_width:= store_scaled_f(vf_read_signed(4),font_size[f]);
end
else begin
packet_length:= cmd;
cc:= vf_byte;
if not is_valid_char(cc)then
bad_vf("invalid character code");
tfm_width:= store_scaled_f(vf_read_unsigned(3),font_size[f]);
end;
if packet_length<0 then
bad_vf("negative packet length");
if packet_length> vf_max_packet_length then
bad_vf("packet length too long");
if tfm_width<> char_width(f)(char_info(f)(cc))then begin
print_nl("character width mismatch in font ");
print(font_name[f]);
print(".vf ignored");
end;
str_room(packet_length);
while packet_length> 0 do begin
cmd:= vf_byte;
decr(packet_length);
/*719:*/
#line 18119 "pdftexdir/pdftex.web"

if(cmd>=set_char_0)and(cmd<=set_char_0+127)then
cmd_length:= 0
else if((fnt_num_0<=cmd)and(cmd<=fnt_num_0+63))or
((fnt1<=cmd)and(cmd<=fnt1+3))then begin
if cmd>=fnt1 then begin
k:= vf_read_unsigned(cmd-fnt1+1);
packet_length:= packet_length-(cmd-fnt1+1);
end
else
k:= cmd-fnt_num_0;
if k>=256 then
bad_vf("too many local fonts");
n:= 0;
while(n<vf_local_font_num[f])and
(vf_e_fnts[vf_default_font[f]+n]<> k)do
incr(n);
if n= vf_local_font_num[f]then
bad_vf("undefined local font");
if k<=63 then
append_char(fnt_num_0+k)
else begin
append_char(fnt1);
append_char(k);
end;
cmd_length:= 0;
cmd:= nop;
end
else case cmd of
set_rule,put_rule:cmd_length:= 8;
four_cases(set1):cmd_length:= cmd-set1+1;
four_cases(put1):cmd_length:= cmd-put1+1;
four_cases(right1):cmd_length:= cmd-right1+1;
four_cases(w1):cmd_length:= cmd-w1+1;
four_cases(x1):cmd_length:= cmd-x1+1;
four_cases(down1):cmd_length:= cmd-down1+1;
four_cases(y1):cmd_length:= cmd-y1+1;
four_cases(z1):cmd_length:= cmd-z1+1;
four_cases(xxx1):begin
cmd_length:= vf_read_unsigned(cmd-xxx1+1);
packet_length:= packet_length-(cmd-xxx1+1);
if cmd_length> vf_max_packet_length then
bad_vf("packet length too long");
if cmd_length<0 then
bad_vf("string of negative length");
append_char(xxx1);
append_char(cmd_length);
cmd:= nop;{|cmd|has been already stored above as|xxx1|}
end;
w0,x0,y0,z0,nop:
cmd_length:= 0;
push,pop:begin
cmd_length:= 0;
if cmd= push then
if stack_level= vf_stack_size then
overflow("virtual font stack size",vf_stack_size)
else
incr(stack_level)
else
if stack_level= 0 then
bad_vf("more POPs than PUSHs in character")
else
decr(stack_level);
end;
othercases
bad_vf("improver DVI command");
endcases

/*:719*/
#line 18098 "pdftexdir/pdftex.web"
;
if cmd<> nop then
append_char(cmd);
packet_length:= packet_length-cmd_length;
while cmd_length> 0 do begin
decr(cmd_length);
append_char(vf_byte);
end;
end;
if stack_level<> 0 then
bad_vf("more PUSHs than POPs in character packet");
if packet_length<> 0 then
bad_vf("invalid packet length or DVI command in packet");
/*718:*/
#line 18114 "pdftexdir/pdftex.web"

s:= make_string;
storepacket(f,cc,s);
flush_str(s)

/*:718*/
#line 18111 "pdftexdir/pdftex.web"
;
cmd:= vf_byte

/*:717*/
#line 18016 "pdftexdir/pdftex.web"
;
end;
if cmd<> post then
bad_vf("POST command expected");
b_close(vf_file);
pdf_font_type[f]:= virtual_font_type;
end;

/*:712*//*720:*/
#line 18187 "pdftexdir/pdftex.web"

procedure pdf_check_vf_cur_val;
var f:internal_font_number;
begin
f:= cur_val;
do_vf(f);
if pdf_font_type[f]= virtual_font_type then
pdf_error("font","command cannot be used with virtual font");
end;

function auto_expand_vf(f:internal_font_number):boolean;
{check for a virtual auto-expanded font}
var bf,lf:internal_font_number;
e,k:integer;
begin
auto_expand_vf:= false;
if(not pdf_font_auto_expand[f])or(pdf_font_blink[f]= null_font)then
return;{not an auto-expanded font}
bf:= pdf_font_blink[f];
if pdf_font_type[bf]= new_font_type then{we must process the base font first}
do_vf(bf);
if pdf_font_type[bf]<> virtual_font_type then
return;{not a virtual font}

e:= pdf_font_expand_ratio[f];
for k:= 0 to vf_local_font_num[bf]-1 do begin
lf:= vf_default_font[bf]+k;
allocvffnts;
{copy vf local font numbers:}
vf_e_fnts[vf_nf]:= vf_e_fnts[lf];
{definition of local vf fonts are expanded from base fonts:}
vf_i_fnts[vf_nf]:= auto_expand_font(vf_i_fnts[lf],e);
copy_expand_params(vf_i_fnts[vf_nf],vf_i_fnts[lf],e);
incr(vf_nf);
end;
vf_packet_base[f]:= vf_packet_base[bf];
vf_local_font_num[f]:= vf_local_font_num[bf];
vf_default_font[f]:= vf_nf-vf_local_font_num[f];

pdf_font_type[f]:= virtual_font_type;
auto_expand_vf:= true;
end;

/*:720*//*725:*/
#line 18258 "pdftexdir/pdftex.web"
function packet_read_signed(k:integer):integer;
{read|k|bytes as a signed integer from character packet}
var i:integer;
begin
pdfassert((k> 0)and(k<=4));
i:= packet_byte;
if i>=128 then
i:= i-256;
decr(k);
while k> 0 do begin
i:= i*256+packet_byte;
decr(k);
end;
packet_read_signed:= i;
end;

function packet_read_unsigned(k:integer):integer;
{read|k|bytes as an unsigned integer from character packet}
var i:integer;
begin
pdfassert((k> 0)and(k<=4));
i:= packet_byte;
if(k= 4)and(i>=128)then
bad_vf("number too big");
decr(k);
while k> 0 do begin
i:= i*256+packet_byte;
decr(k);
end;
packet_read_unsigned:= i;
end;

function packet_scaled(k:integer;fs:scaled):scaled;
{get|k|bytes from packet as scaled}
begin
packet_scaled:= store_scaled_f(packet_read_signed(k),fs);
end;

procedure do_vf_packet(vf_f:internal_font_number;c:eight_bits);{typeset the
\.{DVI}commands in the character packet for character|c|in current font|f|}
label do_char,continue;
var f,k,n:internal_font_number;
save_cur_h,save_cur_v:scaled;
cmd:integer;
char_move:boolean;
w,x,y,z:scaled;
s:str_number;
begin
incr(vf_cur_s);
if vf_cur_s> vf_max_recursion then
overflow("max level recursion of virtual fonts",vf_max_recursion);
save_cur_v:= cur_v;
save_cur_h:= cur_h;
push_packet_state;{save pointer and length of the current packet}
start_packet(vf_f,c);{set pointer and length of the new packet}
f:= vf_i_fnts[vf_default_font[vf_f]];
w:= 0;x:= 0;y:= 0;z:= 0;
while vf_packet_length> 0 do begin
cmd:= packet_byte;
/*726:*/
#line 18340 "pdftexdir/pdftex.web"

if(cmd>=set_char_0)and(cmd<=set_char_0+127)then begin
if not is_valid_char(cmd)then begin
char_warning(f,cmd);
goto continue;
end;
c:= cmd;
char_move:= true;
goto do_char;
end
else if((fnt_num_0<=cmd)and(cmd<=fnt_num_0+63))or(cmd= fnt1)then begin
if cmd= fnt1 then
k:= packet_byte
else
k:= cmd-fnt_num_0;
n:= 0;
while(n<vf_local_font_num[vf_f])and
(vf_e_fnts[vf_default_font[vf_f]+n]<> k)do
incr(n);
if(n= vf_local_font_num[vf_f])then
pdf_error("vf","local font not found")
else
f:= vf_i_fnts[vf_default_font[vf_f]+n];
end
else case cmd of
push:begin
vf_stack[vf_stack_ptr].stack_h:= cur_h;
vf_stack[vf_stack_ptr].stack_v:= cur_v;
vf_stack[vf_stack_ptr].stack_w:= w;
vf_stack[vf_stack_ptr].stack_x:= x;
vf_stack[vf_stack_ptr].stack_y:= y;
vf_stack[vf_stack_ptr].stack_z:= z;
incr(vf_stack_ptr);
end;
pop:begin
decr(vf_stack_ptr);
cur_h:= vf_stack[vf_stack_ptr].stack_h;
cur_v:= vf_stack[vf_stack_ptr].stack_v;
w:= vf_stack[vf_stack_ptr].stack_w;
x:= vf_stack[vf_stack_ptr].stack_x;
y:= vf_stack[vf_stack_ptr].stack_y;
z:= vf_stack[vf_stack_ptr].stack_z;
end;
four_cases(set1),four_cases(put1):begin
if(set1<=cmd)and(cmd<=set1+3)then begin
tmp_int:= packet_read_unsigned(cmd-set1+1);
char_move:= true;
end
else begin
tmp_int:= packet_read_unsigned(cmd-put1+1);
char_move:= false;
end;
if not is_valid_char(tmp_int)then begin
char_warning(f,tmp_int);
goto continue;
end;
c:= tmp_int;
goto do_char;
end;
set_rule,put_rule:begin
rule_ht:= packet_scaled(4,font_size[vf_f]);
rule_wd:= packet_scaled(4,font_size[vf_f]);
if(rule_wd> 0)and(rule_ht> 0)then begin
pdf_set_rule(cur_h,cur_v,rule_wd,rule_ht);
if cmd= set_rule then
cur_h:= cur_h+rule_wd;
end;
end;
four_cases(right1):
cur_h:= cur_h+packet_scaled(cmd-right1+1,font_size[vf_f]);
w0,four_cases(w1):begin
if cmd> w0 then
w:= packet_scaled(cmd-w0,font_size[vf_f]);
cur_h:= cur_h+w;
end;
x0,four_cases(x1):begin
if cmd> x0 then
x:= packet_scaled(cmd-x0,font_size[vf_f]);
cur_h:= cur_h+x;
end;
four_cases(down1):
cur_v:= cur_v+packet_scaled(cmd-down1+1,font_size[vf_f]);
y0,four_cases(y1):begin
if cmd> y0 then
y:= packet_scaled(cmd-y0,font_size[vf_f]);
cur_v:= cur_v+y;
end;
z0,four_cases(z1):begin
if cmd> z0 then
z:= packet_scaled(cmd-z0,font_size[vf_f]);
cur_v:= cur_v+z;
end;
four_cases(xxx1):begin
tmp_int:= packet_read_unsigned(cmd-xxx1+1);
str_room(tmp_int);
while tmp_int> 0 do begin
decr(tmp_int);
append_char(packet_byte);
end;
s:= make_string;
literal(s,scan_special,false);
flush_str(s);
end;
othercases pdf_error("vf","invalid DVI command");
endcases;
goto continue;
do_char:
if is_valid_char(c)then
output_one_char(c)
else
char_warning(f,c);
if char_move then
cur_h:= cur_h+char_width(f)(char_info(f)(c))

/*:726*/
#line 18317 "pdftexdir/pdftex.web"
;
continue:
end;
pop_packet_state;{restore pointer and length of the previous packet}
cur_v:= save_cur_v;
cur_h:= save_cur_h;
decr(vf_cur_s);
end;

/*:725*//*728:*/
#line 18611 "pdftexdir/pdftex.web"
procedure pdf_vlist_out;forward;

/*:728*//*729:*/
#line 18615 "pdftexdir/pdftex.web"
/*727:*/
#line 18460 "pdftexdir/pdftex.web"

procedure pdf_out_literal(p:pointer);
var old_setting:0..max_selector;{holds print|selector|}
s:str_number;
begin
old_setting:= selector;selector:= new_string;
show_token_list(link(pdf_literal_data(p)),null,pool_size-pool_ptr);
selector:= old_setting;
s:= make_string;
literal(s,pdf_literal_mode(p),false);
flush_str(s);
end;

procedure pdf_out_colorstack(p:pointer);
var old_setting:0..max_selector;{holds print|selector|}
s:str_number;
cmd:integer;
stack_no:integer;
literal_mode:integer;
begin
cmd:= pdf_colorstack_cmd(p);
stack_no:= pdf_colorstack_stack(p);
if stack_no>=colorstackused then begin
print_nl("");
print("Color stack ");
print_int(stack_no);
print(" is not initialized for use!");
print_nl("");
return;
end;
case cmd of
colorstack_set,colorstack_push:begin
old_setting:= selector;selector:= new_string;
show_token_list(link(pdf_colorstack_data(p)),null,pool_size-pool_ptr);
selector:= old_setting;
s:= make_string;
if cmd= colorstack_set then
literal_mode:= colorstackset(stack_no,s)
else
literal_mode:= colorstackpush(stack_no,s);
if length(s)> 0 then
literal(s,literal_mode,false);
flush_str(s);
return;
end;
colorstack_pop:literal_mode:= colorstackpop(stack_no);
colorstack_current:literal_mode:= colorstackcurrent(stack_no);
othercases confusion("pdfcolorstack")
endcases;
if cur_length> 0 then begin
s:= make_string;
literal(s,literal_mode,false);
flush_str(s);
end
end;

procedure pdf_out_colorstack_startpage;
var i:integer;
max:integer;
start_status:integer;
literal_mode:integer;
s:str_number;
begin
i:= 0;
max:= colorstackused;
while i<max do begin
start_status:= colorstackskippagestart(i);
if start_status= 0 then begin
literal_mode:= colorstackcurrent(i);
if cur_length> 0 then begin
s:= make_string;
literal(s,literal_mode,false);
flush_str(s);
end;
end;
incr(i);
end;
end;

procedure pdf_out_setmatrix(p:pointer);
var old_setting:0..max_selector;{holds print|selector|}
s:str_number;
begin
old_setting:= selector;selector:= new_string;
show_token_list(link(pdf_setmatrix_data(p)),null,pool_size-pool_ptr);
selector:= old_setting;
str_room(7);
str_pool[pool_ptr]:= 0;{make C string for pdfsetmatrix}
if pdfsetmatrix(str_start[str_ptr],cur_h,cur_page_height-cur_v)= 1 then begin
str_room(7);
append_char(" ");
append_char("0");
append_char(" ");
append_char("0");
append_char(" ");
append_char("c");
append_char("m");
s:= make_string;
literal(s,set_origin,false);
end
else begin
pdf_error("\pdfsetmatrix","Unrecognized format.");
end;
flush_str(s);
end;

procedure pdf_out_save(p:pointer);
begin
checkpdfsave(cur_h,cur_v);
literal("q",set_origin,false);
end;

procedure pdf_out_restore(p:pointer);
begin
checkpdfrestore(cur_h,cur_v);
literal("Q",set_origin,false);
end;

procedure pdf_special(p:pointer);
var old_setting:0..max_selector;{holds print|selector|}
s:str_number;
begin
old_setting:= selector;selector:= new_string;
show_token_list(link(write_tokens(p)),null,pool_size-pool_ptr);
selector:= old_setting;
s:= make_string;
literal(s,scan_special,true);
flush_str(s);
end;

procedure pdf_print_toks(p:pointer);{print tokens list|p|}
var s:str_number;
begin
s:= tokens_to_string(p);
if length(s)> 0 then
pdf_print(s);
flush_str(s);
end;

procedure pdf_print_toks_ln(p:pointer);{print tokens list|p|}
var s:str_number;
begin
s:= tokens_to_string(p);
if length(s)> 0 then begin
pdf_print_ln(s);
end;
flush_str(s);
end;

/*:727*//*772:*/
#line 19303 "pdftexdir/pdftex.web"

procedure pdf_write_obj(n:integer);{write a raw PDF object}
var s:str_number;
f:byte_file;
begin
s:= tokens_to_string(obj_obj_data(n));
delete_toks(obj_obj_data(n));
if obj_obj_is_stream(n)> 0 then begin
pdf_begin_dict(n,0);
if obj_obj_stream_attr(n)<> null then begin
pdf_print_toks_ln(obj_obj_stream_attr(n));
delete_toks(obj_obj_stream_attr(n));
end;
pdf_begin_stream;
end
else
pdf_begin_obj(n,1);
if obj_obj_is_file(n)> 0 then begin
cur_name:= s;
cur_area:= "";
cur_ext:= "";
pack_cur_name;
if not tex_b_openin(f)then begin
print_nl("! ");print(s);print(" not found.");
pdf_error("ext5","cannot open file for embedding");
end;
print("<<");
print(s);
if not eof(f)then begin{at least one byte available}
while not eof(f)do
pdf_out(getc(f));
if(not obj_obj_is_stream(n))and(pdf_ptr> 0)and(pdf_buf[pdf_ptr-1]<> 10)then
pdf_out(10);
end;
print(">>");
b_close(f);
end
else if obj_obj_is_stream(n)> 0 then
pdf_print(s)
else
pdf_print_ln(s);
if obj_obj_is_stream(n)> 0 then
pdf_end_stream
else
pdf_end_obj;
flush_str(s);
end;

procedure flush_whatsit_node(p:pointer;s:small_number);
begin
type(p):= whatsit_node;
subtype(p):= s;
if link(p)<> null then
pdf_error("flush_whatsit_node","link(p) is not null");
flush_node_list(p);
end;

/*:772*//*778:*/
#line 19410 "pdftexdir/pdftex.web"

procedure pdf_write_image(n:integer);{write an image}
begin
pdf_begin_dict(n,0);
if obj_ximage_attr(n)<> null then begin
pdf_print_toks_ln(obj_ximage_attr(n));
delete_toks(obj_ximage_attr(n));
end;
if fixed_pdf_draftmode= 0 then write_image(obj_ximage_data(n));
delete_image(obj_ximage_data(n));
end;

/*:778*//*785:*/
#line 19551 "pdftexdir/pdftex.web"

procedure pdf_print_rect_spec(r:pointer);{prints a rect spec}
begin
pdf_print_mag_bp(pdf_x(pdf_left(r)));
pdf_out(" ");
pdf_print_mag_bp(pdf_y(pdf_bottom(r)));
pdf_out(" ");
pdf_print_mag_bp(pdf_x(pdf_right(r)));
pdf_out(" ");
pdf_print_mag_bp(pdf_y(pdf_top(r)));
end;

/*:785*//*1562:*/
#line 34726 "pdftexdir/pdftex.web"

procedure warn_dest_dup(id:integer;byname:small_number;s1,s2:str_number);
begin
if pdf_suppress_warning_dup_dest> 0 then
return;
pdf_warning(s1,"destination with the same identifier (",false,false);
if byname> 0 then begin
print("name");
print_mark(id);
end
else begin
print("num");
print_int(id);
end;
print(") ");
print(s2);
print_ln;
show_context;
end;

/*:1562*//*1627:*/
#line 35990 "pdftexdir/pdftex.web"

procedure write_action(p:pointer);{write an action specification}
var s:str_number;
d:integer;
begin
if pdf_action_type(p)= pdf_action_user then begin
pdf_print_toks_ln(pdf_action_user_tokens(p));
return;
end;
pdf_print("<< ");
if pdf_action_file(p)<> null then begin
pdf_print("/F ");
s:= tokens_to_string(pdf_action_file(p));
if(str_pool[str_start[s]]= 40)and
(str_pool[str_start[s]+length(s)-1]= 41)then
pdf_print(s)
else begin
pdf_print_str(s);
end;
flush_str(s);
pdf_print(" ");
if pdf_action_new_window(p)> 0 then begin
pdf_print("/NewWindow ");
if pdf_action_new_window(p)= 1 then
pdf_print("true ")
else
pdf_print("false ");
end;
end;
case pdf_action_type(p)of
pdf_action_page:begin
if pdf_action_file(p)= null then begin
pdf_print("/S /GoTo /D [");
pdf_print_int(get_obj(obj_type_page,pdf_action_id(p),false));
pdf_print(" 0 R");
end
else begin
pdf_print("/S /GoToR /D [");
pdf_print_int(pdf_action_id(p)-1);
end;
pdf_out(" ");
pdf_print(tokens_to_string(pdf_action_page_tokens(p)));
flush_str(last_tokens_string);
pdf_out("]");
end;
pdf_action_goto:begin
if pdf_action_file(p)= null then begin
pdf_print("/S /GoTo ");
d:= get_obj(obj_type_dest,pdf_action_id(p),
pdf_action_named_id(p));
end
else
pdf_print("/S /GoToR ");
if pdf_action_named_id(p)> 0 then begin
pdf_str_entry("D",tokens_to_string(pdf_action_id(p)));
flush_str(last_tokens_string);
end
else if pdf_action_file(p)= null then
pdf_indirect("D",d)
else
pdf_error("ext4","`goto' option cannot be used with both `file' and `num'");
end;
pdf_action_thread:begin
pdf_print("/S /Thread ");
if pdf_action_file(p)= null then
d:= get_obj(obj_type_thread,pdf_action_id(p),
pdf_action_named_id(p));
if pdf_action_named_id(p)> 0 then begin
pdf_str_entry("D",tokens_to_string(pdf_action_id(p)));
flush_str(last_tokens_string);
end
else if pdf_action_file(p)= null then
pdf_indirect("D",d)
else
pdf_int_entry("D",pdf_action_id(p));
end;
endcases;
pdf_print_ln(" >>");
end;

procedure set_rect_dimens(p,parent_box:pointer;x,y,w,h,d,margin:scaled);
begin
pdf_left(p):= cur_h;
if is_running(w)then
pdf_right(p):= x+width(parent_box)
else
pdf_right(p):= cur_h+w;
if is_running(h)then
pdf_top(p):= y-height(parent_box)
else
pdf_top(p):= cur_v-h;
if is_running(d)then
pdf_bottom(p):= y+depth(parent_box)
else
pdf_bottom(p):= cur_v+d;
if is_shipping_page and matrixused then begin
matrixtransformrect(pdf_left(p),cur_page_height-pdf_bottom(p),
pdf_right(p),cur_page_height-pdf_top(p));
pdf_left(p):= getllx;
pdf_bottom(p):= cur_page_height-getlly;
pdf_right(p):= geturx;
pdf_top(p):= cur_page_height-getury;
end;
pdf_left(p):= pdf_left(p)-margin;
pdf_top(p):= pdf_top(p)-margin;
pdf_right(p):= pdf_right(p)+margin;
pdf_bottom(p):= pdf_bottom(p)+margin;
end;

procedure do_annot(p,parent_box:pointer;x,y:scaled);
begin
if not is_shipping_page then
pdf_error("ext4","annotations cannot be inside an XForm");
if doing_leaders then
return;
if is_obj_scheduled(pdf_annot_objnum(p))then
pdf_annot_objnum(p):= pdf_new_objnum;
set_rect_dimens(p,parent_box,x,y,
pdf_width(p),pdf_height(p),pdf_depth(p),0);
obj_annot_ptr(pdf_annot_objnum(p)):= p;
pdf_append_list(pdf_annot_objnum(p))(pdf_annot_list);
set_obj_scheduled(pdf_annot_objnum(p));
end;

/*:1627*//*1632:*/
#line 36139 "pdftexdir/pdftex.web"

procedure push_link_level(p:pointer);
begin
if pdf_link_stack_ptr>=pdf_max_link_level then
overflow("pdf link stack size",pdf_max_link_level);
pdfassert((type(p)= whatsit_node)and(subtype(p)= pdf_start_link_node));
incr(pdf_link_stack_ptr);
pdf_link_stack_top.nesting_level:= cur_s;
pdf_link_stack_top.link_node:= copy_node_list(p);
pdf_link_stack_top.ref_link_node:= p;
end;

procedure pop_link_level;
begin
pdfassert(pdf_link_stack_ptr> 0);
flush_node_list(pdf_link_stack_top.link_node);
decr(pdf_link_stack_ptr);
end;

procedure do_link(p,parent_box:pointer;x,y:scaled);
begin
if not is_shipping_page then
pdf_error("ext4","link annotations cannot be inside an XForm");
pdfassert(type(parent_box)= hlist_node);
if is_obj_scheduled(pdf_link_objnum(p))then
pdf_link_objnum(p):= pdf_new_objnum;
push_link_level(p);
set_rect_dimens(p,parent_box,x,y,
pdf_width(p),pdf_height(p),pdf_depth(p),
pdf_link_margin);
obj_annot_ptr(pdf_link_objnum(p)):= p;{the reference for the pdf annot object
must be set here}
pdf_append_list(pdf_link_objnum(p))(pdf_link_list);
set_obj_scheduled(pdf_link_objnum(p));
end;

procedure end_link;
var p:pointer;
begin
if pdf_link_stack_ptr<1 then
pdf_error("ext4","pdf_link_stack empty, \pdfendlink used without \pdfstartlink?");
if pdf_link_stack_top.nesting_level<> cur_s then
pdf_warning(0,"\pdfendlink ended up in different nesting level than \pdfstartlink",true,true);

{N.B.:test for running link must be done on|link_node|and not|ref_link_node|,
as|ref_link_node|can be set by|do_link|or|append_link|already}

if is_running(pdf_width(pdf_link_stack_top.link_node))then begin
p:= pdf_link_stack_top.ref_link_node;
if is_shipping_page and matrixused then begin
matrixrecalculate(cur_h+pdf_link_margin);
pdf_left(p):= getllx-pdf_link_margin;
pdf_top(p):= cur_page_height-getury-pdf_link_margin;
pdf_right(p):= geturx+pdf_link_margin;
pdf_bottom(p):= cur_page_height-getlly+pdf_link_margin;
end
else
pdf_right(p):= cur_h+pdf_link_margin;
end;
pop_link_level;
end;

/*:1632*//*1633:*/
#line 36207 "pdftexdir/pdftex.web"

procedure append_link(parent_box:pointer;x,y:scaled;i:small_number);{append a new
pdf annot to|pdf_link_list|}
var p:pointer;
begin
pdfassert(type(parent_box)= hlist_node);
p:= copy_node_list(pdf_link_stack[i].link_node);
pdf_link_stack[i].ref_link_node:= p;
info(p):= max_halfword;{mark that this node is not a whatsit node}
link(p):= null;{this node is not linked in any list}
set_rect_dimens(p,parent_box,x,y,
pdf_width(p),pdf_height(p),pdf_depth(p),
pdf_link_margin);
pdf_create_obj(obj_type_others,0);
obj_annot_ptr(obj_ptr):= p;
pdf_append_list(obj_ptr)(pdf_link_list);
end;

/*:1633*//*1634:*/
#line 36227 "pdftexdir/pdftex.web"

procedure append_bead(p:pointer);
var a,b,c,t:integer;
begin
if not is_shipping_page then
pdf_error("ext4","threads cannot be inside an XForm");
t:= get_obj(obj_type_thread,pdf_thread_id(p),pdf_thread_named_id(p));
b:= pdf_new_objnum;
obj_bead_ptr(b):= pdf_get_mem(pdfmem_bead_size);
obj_bead_page(b):= pdf_last_page;
obj_bead_data(b):= p;
if pdf_thread_attr(p)<> null then
obj_bead_attr(b):= tokens_to_string(pdf_thread_attr(p))
else
obj_bead_attr(b):= 0;
if obj_thread_first(t)= 0 then begin
obj_thread_first(t):= b;
obj_bead_next(b):= b;
obj_bead_prev(b):= b;
end
else begin
a:= obj_thread_first(t);
c:= obj_bead_prev(a);
obj_bead_prev(b):= c;
obj_bead_next(b):= a;
obj_bead_prev(a):= b;
obj_bead_next(c):= b;
end;
pdf_append_list(b)(pdf_bead_list);
end;

procedure do_thread(p,parent_box:pointer;x,y:scaled);
begin
if doing_leaders then
return;
if subtype(p)= pdf_start_thread_node then begin
pdf_thread_wd:= pdf_width(p);
pdf_thread_ht:= pdf_height(p);
pdf_thread_dp:= pdf_depth(p);
pdf_last_thread_id:= pdf_thread_id(p);
pdf_last_thread_named_id:= (pdf_thread_named_id(p)> 0);
if pdf_last_thread_named_id then
add_token_ref(pdf_thread_id(p));
pdf_thread_level:= cur_s;
end;
set_rect_dimens(p,parent_box,x,y,
pdf_width(p),pdf_height(p),pdf_depth(p),
pdf_thread_margin);
append_bead(p);
last_thread:= p;
end;

procedure append_thread(parent_box:pointer;x,y:scaled);
var p:pointer;
begin
p:= get_node(pdf_thread_node_size);
info(p):= max_halfword;{this is not a whatsit node}
link(p):= null;{this node will be destroyed separately}
pdf_width(p):= pdf_thread_wd;
pdf_height(p):= pdf_thread_ht;
pdf_depth(p):= pdf_thread_dp;
pdf_thread_attr(p):= null;
pdf_thread_id(p):= pdf_last_thread_id;
if pdf_last_thread_named_id then begin
add_token_ref(pdf_thread_id(p));
pdf_thread_named_id(p):= 1;
end
else
pdf_thread_named_id(p):= 0;
set_rect_dimens(p,parent_box,x,y,
pdf_width(p),pdf_height(p),pdf_depth(p),
pdf_thread_margin);
append_bead(p);
last_thread:= p;
end;

procedure end_thread;
begin
if pdf_thread_level<> cur_s then
pdf_error("ext4","\pdfendthread ended up in different nesting level than \pdfstartthread");
if is_running(pdf_thread_dp)and(last_thread<> null)then
pdf_bottom(last_thread):= cur_v+pdf_thread_margin;
if pdf_last_thread_named_id then
delete_token_ref(pdf_last_thread_id);
last_thread:= null;
end;

function open_subentries(p:pointer):integer;
var k,c:integer;
l,r:integer;
begin
k:= 0;
if obj_outline_first(p)<> 0 then begin
l:= obj_outline_first(p);
repeat
incr(k);
c:= open_subentries(l);
if obj_outline_count(l)> 0 then
k:= k+c;
obj_outline_parent(l):= p;
r:= obj_outline_next(l);
if r= 0 then
obj_outline_last(p):= l;
l:= r;
until l= 0;
end;
if obj_outline_count(p)> 0 then
obj_outline_count(p):= k
else
obj_outline_count(p):= -k;
open_subentries:= k;
end;

procedure do_dest(p,parent_box:pointer;x,y:scaled);
var k:integer;
begin
if not is_shipping_page then
pdf_error("ext4","destinations cannot be inside an XForm");
if doing_leaders then
return;
k:= get_obj(obj_type_dest,pdf_dest_id(p),pdf_dest_named_id(p));
if obj_dest_ptr(k)<> null then begin
warn_dest_dup(pdf_dest_id(p),pdf_dest_named_id(p),
"ext4","has been already used, duplicate ignored");
return;
end;
obj_dest_ptr(k):= p;
pdf_append_list(k)(pdf_dest_list);
case pdf_dest_type(p)of
pdf_dest_xyz:
if matrixused then
set_rect_dimens(p,parent_box,x,y,
pdf_width(p),pdf_height(p),pdf_depth(p),
pdf_dest_margin)
else begin
pdf_left(p):= cur_h;
pdf_top(p):= cur_v;
end;
pdf_dest_fith,
pdf_dest_fitbh:
if matrixused then
set_rect_dimens(p,parent_box,x,y,
pdf_width(p),pdf_height(p),pdf_depth(p),
pdf_dest_margin)
else
pdf_top(p):= cur_v;
pdf_dest_fitv,
pdf_dest_fitbv:
if matrixused then
set_rect_dimens(p,parent_box,x,y,
pdf_width(p),pdf_height(p),pdf_depth(p),
pdf_dest_margin)
else
pdf_left(p):= cur_h;
pdf_dest_fit,
pdf_dest_fitb:
do_nothing;
pdf_dest_fitr:
set_rect_dimens(p,parent_box,x,y,
pdf_width(p),pdf_height(p),pdf_depth(p),
pdf_dest_margin);
endcases;
end;

#line 5806 "pdftex-final.ch"
procedure out_form(p:pointer);
begin
synctexpdfrefxform(pdf_xform_objnum(p));
#line 36393 "pdftexdir/pdftex.web"
pdf_end_text;
pdf_print_ln("q");
if pdf_lookup_list(pdf_xform_list,pdf_xform_objnum(p))= null then
pdf_append_list(pdf_xform_objnum(p))(pdf_xform_list);
cur_v:= cur_v+obj_xform_depth(pdf_xform_objnum(p));
pdf_print("1 0 0 1 ");
pdf_print_bp(pdf_x(cur_h));pdf_out(" ");
pdf_print_bp(pdf_y(cur_v));
pdf_print_ln(" cm");
pdf_print("/Fm");
pdf_print_int(obj_info(pdf_xform_objnum(p)));
pdf_print_resname_prefix;
pdf_print_ln(" Do");
pdf_print_ln("Q");
end;

procedure out_image(p:pointer);
var image,groupref:integer;
img_w,img_h:integer;
begin
image:= obj_ximage_data(pdf_ximage_objnum(p));
if(image_rotate(image)= 90)or(image_rotate(image)= 270)then begin
img_h:= image_width(image);
img_w:= image_height(image);
end else begin
img_w:= image_width(image);
img_h:= image_height(image);
end;

pdf_end_text;
pdf_print_ln("q");
if pdf_lookup_list(pdf_ximage_list,pdf_ximage_objnum(p))= null then
pdf_append_list(pdf_ximage_objnum(p))(pdf_ximage_list);
if not is_pdf_image(image)then begin
if is_png_image(image)then begin
groupref:= get_image_group_ref(image);
if(groupref> 0)and(pdf_page_group_val= 0)then
pdf_page_group_val:= groupref;
end;
pdf_print_real(ext_xn_over_d(pdf_width(p),
ten_pow[6],one_hundred_bp),4);
pdf_print(" 0 0 ");
pdf_print_real(ext_xn_over_d(pdf_height(p)+pdf_depth(p),
ten_pow[6],one_hundred_bp),4);
pdf_out(" ");
pdf_print_bp(pdf_x(cur_h));pdf_out(" ");
pdf_print_bp(pdf_y(cur_v));
end
else begin
{for pdf images we generate the page group object number here}
groupref:= get_image_group_ref(image);{0:no group,-1:to be generated;> 0:already written}
if(groupref<> 0)and(pdf_page_group_val= 0)then begin
if groupref= -1 then begin
pdf_page_group_val:= pdf_new_objnum;
set_image_group_ref(image,pdf_page_group_val);
end
else{groupref> 0}
pdf_page_group_val:= groupref;
end;
pdf_print_real(ext_xn_over_d(pdf_width(p),
ten_pow[6],img_w),6);
pdf_print(" 0 0 ");
pdf_print_real(ext_xn_over_d(pdf_height(p)+pdf_depth(p),
ten_pow[6],img_h),6);
pdf_out(" ");
pdf_print_bp(pdf_x(cur_h)-
ext_xn_over_d(pdf_width(p),epdf_orig_x(image),
img_w));
pdf_out(" ");
pdf_print_bp(pdf_y(cur_v)-
ext_xn_over_d(pdf_height(p)+pdf_depth(p),epdf_orig_y(image),
img_h));
end;
pdf_print_ln(" cm");
pdf_print("/Im");
pdf_print_int(obj_info(pdf_ximage_objnum(p)));
pdf_print_resname_prefix;
pdf_print_ln(" Do");
pdf_print_ln("Q");
end;

function gap_amount(p:pointer;cur_pos:scaled):scaled;{find the gap between
the position of the current snap node|p|and the nearest point on the grid}
var snap_unit,stretch_amount,shrink_amount:scaled;
last_pos,next_pos,g,g2:scaled;
begin
snap_unit:= width(snap_glue_ptr(p));
if stretch_order(snap_glue_ptr(p))> normal then
stretch_amount:= max_dimen
else
stretch_amount:= stretch(snap_glue_ptr(p));
if shrink_order(snap_glue_ptr(p))> normal then
shrink_amount:= max_dimen
else
shrink_amount:= shrink(snap_glue_ptr(p));
if subtype(p)= pdf_snapy_node then
last_pos:= pdf_snapy_refpos+
snap_unit*((cur_pos-pdf_snapy_refpos)div snap_unit)
else
pdf_error("snapping","invalid parameter value for gap_amount");
next_pos:= last_pos+snap_unit;

print_nl("snap ref pos = ");print_scaled(pdf_snapy_refpos);
print_nl("snap glue = ");print_spec(snap_glue_ptr(p),0);
print_nl("gap amount = ");print_scaled(snap_unit);
print_nl("stretch amount = ");print_scaled(stretch_amount);
print_nl("shrink amount = ");print_scaled(shrink_amount);
print_nl("last point = ");print_scaled(last_pos);
print_nl("cur point = ");print_scaled(cur_pos);
print_nl("next point = ");print_scaled(next_pos);

g:= max_dimen;
g2:= max_dimen;
gap_amount:= 0;
if cur_pos-last_pos<shrink_amount then
g:= cur_pos-last_pos;
if(next_pos-cur_pos<stretch_amount)then
g2:= next_pos-cur_pos;
if(g= max_dimen)and(g2= max_dimen)then
return;{unable to snap}
if g2<=g then
gap_amount:= g2{skip forward}
else
gap_amount:= -g;{skip backward}
end;

function get_vpos(p,q,b:pointer):pointer;{find the vertical position of
node|q|in the output PDF page;this functions is called when the current node
is|p|and current position is|cur_v|(global variable);|b|is the parent
box;}
var tmp_v:scaled;
g_order:glue_ord;{applicable order of infinity for glue}
g_sign:normal..shrinking;{selects type of glue}
glue_temp:real;{glue value before rounding}
cur_glue:real;{glue seen so far}
cur_g:scaled;{rounded equivalent of|cur_glue|times the glue ratio}
this_box:pointer;{pointer to containing box}
begin
tmp_v:= cur_v;
this_box:= b;
cur_g:= 0;
cur_glue:= float_constant(0);
g_order:= glue_order(this_box);
g_sign:= glue_sign(this_box);
while(p<> q)and(p<> null)do begin
if is_char_node(p)then
confusion("get_vpos")
else begin
case type(p)of
hlist_node,
vlist_node,
rule_node:
tmp_v:= tmp_v+height(p)+depth(p);
whatsit_node:
if(subtype(p)= pdf_refxform_node)or
(subtype(p)= pdf_refximage_node)then
tmp_v:= tmp_v+pdf_height(p)+pdf_depth(p);
glue_node:begin
/*1635:*/
#line 36617 "pdftexdir/pdftex.web"

begin g:= glue_ptr(p);rule_ht:= width(g)-cur_g;
if g_sign<> normal then
begin if g_sign= stretching then
begin if stretch_order(g)= g_order then
begin cur_glue:= cur_glue+stretch(g);
vet_glue(float(glue_set(this_box))*cur_glue);

cur_g:= round(glue_temp);
end;
end
else if shrink_order(g)= g_order then
begin cur_glue:= cur_glue-shrink(g);
vet_glue(float(glue_set(this_box))*cur_glue);
cur_g:= round(glue_temp);
end;
end;
rule_ht:= rule_ht+cur_g;
end

/*:1635*/
#line 36551 "pdftexdir/pdftex.web"
;
tmp_v:= tmp_v+rule_ht;
end;
kern_node:
tmp_v:= tmp_v+width(p);
othercases do_nothing;
endcases;
end;
p:= link(p);
end;
get_vpos:= tmp_v;
end;

procedure do_snapy_comp(p,b:pointer);{do snapping compensation in vertical
direction;search for the next snap node and do the compensation if found}
var q:pointer;
tmp_v,g,g2:scaled;
begin
if not(not is_char_node(p)and
(type(p)= whatsit_node)and
(subtype(p)= pdf_snapy_comp_node))
then
pdf_error("snapping","invalid parameter value for do_snapy_comp");
q:= p;
while(q<> null)do begin
if not is_char_node(q)and
(type(q)= whatsit_node)and
(subtype(q)= pdf_snapy_node)
then begin
tmp_v:= get_vpos(p,q,b);{get the position of|q|}
g:= gap_amount(q,tmp_v);{get the gap to the grid}
g2:= round_xn_over_d(g,snapy_comp_ratio(p),1000);{adjustment for|p|}

print_nl("do_snapy_comp: tmp_v = ");print_scaled(tmp_v);
print_nl("do_snapy_comp: cur_v = ");print_scaled(cur_v);
print_nl("do_snapy_comp: g = ");print_scaled(g);
print_nl("do_snapy_comp: g2 = ");print_scaled(g2);

cur_v:= cur_v+g2;
final_skip(q):= g-g2;{adjustment for|q|}
if final_skip(q)= 0 then
final_skip(q):= 1;{use|1 sp|as the magic value to record
that|final_skip|has been set here}
return;
end;
q:= link(q);
end;
end;

procedure do_snapy(p:pointer);
begin
incr(count_do_snapy);

print_nl("do_snapy: count = ");print_int(count_do_snapy);
print_nl("do_snapy: cur_v = ");print_scaled(cur_v);
print_nl("do_snapy: final skip = ");print_scaled(final_skip(p));

if final_skip(p)<> 0 then
cur_v:= cur_v+final_skip(p)
else
cur_v:= cur_v+gap_amount(p,cur_v);

print_nl("do_snapy: cur_v after snap = ");print_scaled(cur_v);

end;

/*:1634*/
#line 18615 "pdftexdir/pdftex.web"


#line 3427 "pdftex-final.ch"
procedure pdf_hlist_out;{output an|hlist_node|box}
#line 3433 "pdftex-final.ch"
label reswitch,move_past,fin_rule,next_p,found,continue;
#line 18619 "pdftexdir/pdftex.web"
var base_line:scaled;{the baseline coordinate for this box}
left_edge:scaled;{the left coordinate for this box}
save_h:scaled;{what|cur_h|should pop to}
this_box:pointer;{pointer to containing box}
g_order:glue_ord;{applicable order of infinity for glue}
g_sign:normal..shrinking;{selects type of glue}
p:pointer;{current position in the hlist}
leader_box:pointer;{the leader box being replicated}
leader_wd:scaled;{width of leader box being replicated}
lx:scaled;{extra space between leader boxes}
outer_doing_leaders:boolean;{were we doing leaders?}
edge:scaled;{right edge of sub-box or leader space}
prev_p:pointer;{one step behind|p|}
glue_temp:real;{glue value before rounding}
cur_glue:real;{glue seen so far}
cur_g:scaled;{rounded equivalent of|cur_glue|times the glue ratio}
i:small_number;{index to scan|pdf_link_stack|}
begin cur_g:= 0;cur_glue:= float_constant(0);
this_box:= temp_ptr;g_order:= glue_order(this_box);
g_sign:= glue_sign(this_box);p:= list_ptr(this_box);
incr(cur_s);
base_line:= cur_v;
prev_p:= this_box+list_offset;
/*1711:*/
#line 37615 "pdftexdir/pdftex.web"

if eTeX_ex then
begin/*1707:*/
#line 37583 "pdftexdir/pdftex.web"

put_LR(before){this will never match}

/*:1707*/
#line 37617 "pdftexdir/pdftex.web"
;
if box_lr(this_box)= dlist then
if cur_dir= right_to_left then
begin cur_dir:= left_to_right;cur_h:= cur_h-width(this_box);
end
else set_box_lr(this_box)(0);
if(cur_dir= right_to_left)and(box_lr(this_box)<> reversed)then
/*1718:*/
#line 5841 "pdftex-final.ch"

begin save_h:= cur_h;temp_ptr:= p;p:= new_kern(0);
sync_tag(p+medium_node_size):= 0;{{\sl Sync\TeX}:do nothing,it is too late}
link(prev_p):= p;
#line 37690 "pdftexdir/pdftex.web"
cur_h:= 0;link(p):= reverse(this_box,null,cur_g,cur_glue);width(p):= -cur_h;
cur_h:= save_h;set_box_lr(this_box)(reversed);
end

/*:1718*/
#line 37624 "pdftexdir/pdftex.web"
;
end

/*:1711*/
#line 18642 "pdftexdir/pdftex.web"
;
left_edge:= cur_h;
/*730:*/
#line 18652 "pdftexdir/pdftex.web"

for i:= 1 to pdf_link_stack_ptr do begin
pdfassert(is_running(pdf_width(pdf_link_stack[i].link_node)));
if(pdf_link_stack[i].nesting_level= cur_s)and gen_running_link then
append_link(this_box,left_edge,base_line,i);
end

#line 3451 "pdftex-final.ch"
/*:730*/
#line 18644 "pdftexdir/pdftex.web"
;
#line 3441 "pdftex-final.ch"
/*1924:*/
#line 7033 "pdftex-final.ch"

synctex_hlist(this_box);

/*:1924*/
#line 3441 "pdftex-final.ch"
;
while p<> null do
/*731:*/
#line 3451 "pdftex-final.ch"

#line 18660 "pdftexdir/pdftex.web"
reswitch:if is_char_node(p)then
begin
repeat f:= font(p);c:= character(p);
#line 3461 "pdftex-final.ch"
if is_valid_char(c)then begin
output_one_char(c);
cur_h:= cur_h+char_width(f)(char_info(f)(c));
goto continue;
end;
if mltex_enabled_p then
/*1884:*/
#line 6387 "pdftex-final.ch"

begin
/*1886:*/
#line 6416 "pdftex-final.ch"

if qo(c)>=char_sub_def_min then if qo(c)<=char_sub_def_max then
if char_list_exists(qo(c))then
begin base_c:= char_list_char(qo(c));
accent_c:= char_list_accent(qo(c));
if(font_ec[f]>=base_c)then if(font_bc[f]<=base_c)then
if(font_ec[f]>=accent_c)then if(font_bc[f]<=accent_c)then
begin ia_c:= char_info(f)(qi(accent_c));
ib_c:= char_info(f)(qi(base_c));
if char_exists(ib_c)then
if char_exists(ia_c)then goto found;
end;
begin_diagnostic;
print_nl("Missing character: Incomplete substitution ");

print_ASCII(qo(c));print(" = ");print_ASCII(accent_c);
print(" ");print_ASCII(base_c);print(" in font ");
slow_print(font_name[f]);print_char("!");end_diagnostic(false);
goto continue;
end;
begin_diagnostic;
print_nl("Missing character: There is no ");print("substitution for ");

print_ASCII(qo(c));print(" in font ");
slow_print(font_name[f]);print_char("!");end_diagnostic(false);
goto continue


/*:1886*/
#line 6390 "pdftex-final.ch"
;
found:/*1887:*/
#line 6446 "pdftex-final.ch"

if tracing_lost_chars> 99 then
begin begin_diagnostic;
print_nl("Using character substitution: ");
print_ASCII(qo(c));print(" = ");
print_ASCII(accent_c);print(" ");print_ASCII(base_c);
print(" in font ");slow_print(font_name[f]);print_char(".");
end_diagnostic(false);
end


/*:1887*/
#line 6391 "pdftex-final.ch"
;
/*1889:*/
#line 6511 "pdftex-final.ch"

base_x_height:= x_height(f);
base_slant:= slant(f)/float_constant(65536);

accent_slant:= base_slant;{slant of accent character font}
base_width:= char_width(f)(ib_c);
base_height:= char_height(f)(height_depth(ib_c));
accent_width:= char_width(f)(ia_c);
accent_height:= char_height(f)(height_depth(ia_c));
{compute necessary horizontal shift(don't forget slant)}@/
delta:= round((base_width-accent_width)/float_constant(2)+
base_height*base_slant-base_x_height*accent_slant);


{1. For centering/horizontal shifting insert a kern node.}
cur_h:= cur_h+delta;
{2. Then insert the accent character possibly shifted up or down.}
if((base_height<> base_x_height)and(accent_height> 0))then
begin{the accent must be shifted up or down}
cur_v:= base_line+(base_x_height-base_height);
output_one_char(accent_c);
cur_v:= base_line;
end
else begin
output_one_char(accent_c);
end;
cur_h:= cur_h+accent_width;
{3. For centering/horizontal shifting insert another kern node.}
cur_h:= cur_h+(-accent_width-delta);
{4. Output the base character.}
output_one_char(base_c);
cur_h:= cur_h+base_width;

/*:1889*/
#line 6392 "pdftex-final.ch"
;
end

/*:1884*/
#line 3467 "pdftex-final.ch"
;
continue:
#line 18668 "pdftexdir/pdftex.web"
prev_p:= link(prev_p);{N.B.:not|prev_p:= p|,|p|might be|lig_trick|}
p:= link(p);
#line 3474 "pdftex-final.ch"
until not is_char_node(p);
/*1927:*/
#line 7047 "pdftex-final.ch"

synctex_current;

/*:1927*/
#line 3475 "pdftex-final.ch"
;
#line 18671 "pdftexdir/pdftex.web"
end
else/*732:*/
#line 3481 "pdftex-final.ch"

#line 18676 "pdftexdir/pdftex.web"
 begin case type(p)of
hlist_node,vlist_node:/*733:*/
#line 3516 "pdftex-final.ch"

#line 3522 "pdftex-final.ch"
if list_ptr(p)= null then
begin
/*1926:*/
#line 7039 "pdftex-final.ch"

if type(p)= vlist_node then begin
synctex_void_vlist(p,this_box);
end
else begin
synctex_void_hlist(p,this_box);
end;

/*:1926*/
#line 3524 "pdftex-final.ch"
;
cur_h:= cur_h+width(p);
end
#line 18698 "pdftexdir/pdftex.web"
 else begin
cur_v:= base_line+shift_amount(p);{shift the box down}
temp_ptr:= p;edge:= cur_h+width(p);
if cur_dir= right_to_left then cur_h:= edge;
if type(p)= vlist_node then pdf_vlist_out else pdf_hlist_out;
cur_h:= edge;cur_v:= base_line;
end

/*:733*/
#line 18677 "pdftexdir/pdftex.web"
;
rule_node:begin rule_ht:= height(p);rule_dp:= depth(p);rule_wd:= width(p);
goto fin_rule;
end;
whatsit_node:/*1642:*/
#line 36723 "pdftexdir/pdftex.web"

case subtype(p)of
pdf_literal_node:
pdf_out_literal(p);
pdf_colorstack_node:
pdf_out_colorstack(p);
pdf_setmatrix_node:
pdf_out_setmatrix(p);
pdf_save_node:
pdf_out_save(p);
pdf_restore_node:
pdf_out_restore(p);
pdf_refobj_node:
pdf_append_list(pdf_obj_objnum(p))(pdf_obj_list);
pdf_refxform_node:
/*1644:*/
#line 36784 "pdftexdir/pdftex.web"

begin
cur_v:= base_line;
edge:= cur_h;
out_form(p);
cur_h:= edge+pdf_width(p);cur_v:= base_line;
end

/*:1644*/
#line 36738 "pdftexdir/pdftex.web"
;
pdf_refximage_node:
/*1643:*/
#line 36776 "pdftexdir/pdftex.web"

begin
cur_v:= base_line+pdf_depth(p);
edge:= cur_h;
out_image(p);
cur_h:= edge+pdf_width(p);cur_v:= base_line;
end

/*:1643*/
#line 36740 "pdftexdir/pdftex.web"
;
pdf_annot_node:
do_annot(p,this_box,left_edge,base_line);
pdf_start_link_node:
do_link(p,this_box,left_edge,base_line);
pdf_end_link_node:
end_link;
pdf_dest_node:
do_dest(p,this_box,left_edge,base_line);
pdf_thread_node:
do_thread(p,this_box,left_edge,base_line);
pdf_start_thread_node:
pdf_error("ext4","\pdfstartthread ended up in hlist");
pdf_end_thread_node:
pdf_error("ext4","\pdfendthread ended up in hlist");
pdf_save_pos_node:
/*1638:*/
#line 36694 "pdftexdir/pdftex.web"

begin
pdf_last_x_pos:= cur_h;
if is_shipping_page then
pdf_last_y_pos:= cur_page_height-cur_v
else
pdf_last_y_pos:= pdf_xform_height+pdf_xform_depth-cur_v;
end

/*:1638*/
#line 36756 "pdftexdir/pdftex.web"
;
special_node:
pdf_special(p);
pdf_snap_ref_point_node:
/*1639:*/
#line 36703 "pdftexdir/pdftex.web"

begin
pdf_snapx_refpos:= cur_h;
pdf_snapy_refpos:= cur_v;
end

/*:1639*/
#line 36760 "pdftexdir/pdftex.web"
;
pdf_snapy_comp_node,
pdf_snapy_node:do_nothing;{snapy nodes do nothing in hlist}
pdf_interword_space_on_node:
gen_faked_interword_space:= true;
pdf_interword_space_off_node:
gen_faked_interword_space:= false;
pdf_fake_space_node:
pdf_insert_fake_space;
pdf_running_link_off_node:
gen_running_link:= false;
pdf_running_link_on_node:
gen_running_link:= true;
othercases out_what(p);
endcases

/*:1642*/
#line 18681 "pdftexdir/pdftex.web"
;
glue_node:/*735:*/
#line 18716 "pdftexdir/pdftex.web"

begin g:= glue_ptr(p);rule_wd:= width(g)-cur_g;
if g_sign<> normal then
begin if g_sign= stretching then
begin if stretch_order(g)= g_order then
begin cur_glue:= cur_glue+stretch(g);
vet_glue(float(glue_set(this_box))*cur_glue);

cur_g:= round(glue_temp);
end;
end
else if shrink_order(g)= g_order then
begin cur_glue:= cur_glue-shrink(g);
vet_glue(float(glue_set(this_box))*cur_glue);
cur_g:= round(glue_temp);
end;
end;
rule_wd:= rule_wd+cur_g;
if eTeX_ex then/*1696:*/
#line 37425 "pdftexdir/pdftex.web"

if(((g_sign= stretching)and(stretch_order(g)= g_order))or
((g_sign= shrinking)and(shrink_order(g)= g_order)))then
begin fast_delete_glue_ref(g);
if subtype(p)<a_leaders then
begin type(p):= kern_node;width(p):= rule_wd;
end
else begin g:= get_node(glue_spec_size);
stretch_order(g):= filll+1;shrink_order(g):= filll+1;{will never match}
width(g):= rule_wd;stretch(g):= 0;shrink(g):= 0;glue_ptr(p):= g;
end;
end

/*:1696*/
#line 18734 "pdftexdir/pdftex.web"
;
if subtype(p)>=a_leaders then
/*736:*/
#line 18741 "pdftexdir/pdftex.web"

begin leader_box:= leader_ptr(p);
if type(leader_box)= rule_node then
begin rule_ht:= height(leader_box);rule_dp:= depth(leader_box);
goto fin_rule;
end;
leader_wd:= width(leader_box);
if(leader_wd> 0)and(rule_wd> 0)then
begin rule_wd:= rule_wd+10;{compensate for floating-point rounding}
if cur_dir= right_to_left then cur_h:= cur_h-10;
edge:= cur_h+rule_wd;lx:= 0;
/*655:*/
#line 14751 "pdftexdir/pdftex.web"

if subtype(p)= a_leaders then
begin save_h:= cur_h;
cur_h:= left_edge+leader_wd*((cur_h-left_edge)div leader_wd);
if cur_h<save_h then cur_h:= cur_h+leader_wd;
end
else begin lq:= rule_wd div leader_wd;{the number of box copies}
lr:= rule_wd mod leader_wd;{the remaining space}
if subtype(p)= c_leaders then cur_h:= cur_h+(lr div 2)
else begin lx:= lr div(lq+1);
cur_h:= cur_h+((lr-(lq-1)*lx)div 2);
end;
end

/*:655*/
#line 18753 "pdftexdir/pdftex.web"
;
while cur_h+leader_wd<=edge do
/*737:*/
#line 18763 "pdftexdir/pdftex.web"

begin cur_v:= base_line+shift_amount(leader_box);
save_h:= cur_h;temp_ptr:= leader_box;
if cur_dir= right_to_left then cur_h:= cur_h+leader_wd;
outer_doing_leaders:= doing_leaders;doing_leaders:= true;
if type(leader_box)= vlist_node then pdf_vlist_out else pdf_hlist_out;
doing_leaders:= outer_doing_leaders;
cur_v:= base_line;
cur_h:= save_h+leader_wd+lx;
end

/*:737*/
#line 18756 "pdftexdir/pdftex.web"
;
if cur_dir= right_to_left then cur_h:= edge
else cur_h:= edge-10;
goto next_p;
end;
end

/*:736*/
#line 18737 "pdftexdir/pdftex.web"
;
goto move_past;
end

/*:735*/
#line 18682 "pdftexdir/pdftex.web"
;
#line 3488 "pdftex-final.ch"
margin_kern_node:cur_h:= cur_h+width(p);
kern_node:begin
/*1929:*/
#line 7053 "pdftex-final.ch"

synctex_kern(p,this_box);

/*:1929*/
#line 3490 "pdftex-final.ch"
;
cur_h:= cur_h+width(p);
end;
#line 3498 "pdftex-final.ch"
math_node:begin
/*1930:*/
#line 7056 "pdftex-final.ch"

synctex_math(p,this_box);

/*:1930*/
#line 3499 "pdftex-final.ch"
;
/*1713:*/
#line 37633 "pdftexdir/pdftex.web"

begin if eTeX_ex then
/*1714:*/
#line 37646 "pdftexdir/pdftex.web"

begin if end_LR(p)then
if info(LR_ptr)= end_LR_type(p)then pop_LR
else begin if subtype(p)> L_code then incr(LR_problems);
end
else begin push_LR(p);
if LR_dir(p)<> cur_dir then
/*1719:*/
#line 5852 "pdftex-final.ch"

begin save_h:= cur_h;temp_ptr:= link(p);rule_wd:= width(p);
free_node(p,medium_node_size);{{\sl Sync\TeX}:p is a|math_node|}
#line 37702 "pdftexdir/pdftex.web"
cur_dir:= reflected;p:= new_edge(cur_dir,rule_wd);link(prev_p):= p;
cur_h:= cur_h-left_edge+rule_wd;
link(p):= reverse(this_box,new_edge(reflected,0),cur_g,cur_glue);
edge_dist(p):= cur_h;cur_dir:= reflected;cur_h:= save_h;
goto reswitch;
end

/*:1719*/
#line 37653 "pdftexdir/pdftex.web"
;
end;
type(p):= kern_node;
end

/*:1714*/
#line 37636 "pdftexdir/pdftex.web"
;
cur_h:= cur_h+width(p);
end

/*:1713*/
#line 3500 "pdftex-final.ch"
;
end;
#line 18686 "pdftexdir/pdftex.web"
ligature_node:/*824:*/
#line 20850 "pdftexdir/pdftex.web"

begin mem[lig_trick]:= mem[lig_char(p)];link(lig_trick):= link(p);
p:= lig_trick;goto reswitch;
end

/*:824*/
#line 18686 "pdftexdir/pdftex.web"
;
/*1717:*/
#line 37680 "pdftexdir/pdftex.web"

edge_node:begin cur_h:= cur_h+width(p);
left_edge:= cur_h+edge_dist(p);cur_dir:= subtype(p);
end;

/*:1717*/
#line 18687 "pdftexdir/pdftex.web"

othercases do_nothing
endcases;
goto next_p;
fin_rule:/*734:*/
#line 18706 "pdftexdir/pdftex.web"

if is_running(rule_ht)then rule_ht:= height(this_box);
if is_running(rule_dp)then rule_dp:= depth(this_box);
rule_ht:= rule_ht+rule_dp;{this is the rule thickness}
if(rule_ht> 0)and(rule_wd> 0)then{we don't output empty rules}
begin cur_v:= base_line+rule_dp;
pdf_set_rule(cur_h,cur_v,rule_wd,rule_ht);
cur_v:= base_line;
end

/*:734*/
#line 18691 "pdftexdir/pdftex.web"
;
#line 3507 "pdftex-final.ch"
move_past:begin
cur_h:= cur_h+rule_wd;
/*1928:*/
#line 7050 "pdftex-final.ch"

synctex_horizontal_rule_or_glue(p,this_box);

/*:1928*/
#line 3509 "pdftex-final.ch"
;
end;
#line 18693 "pdftexdir/pdftex.web"
next_p:prev_p:= p;p:= link(p);
end

#line 3516 "pdftex-final.ch"
/*:732*/
#line 18673 "pdftexdir/pdftex.web"


#line 3481 "pdftex-final.ch"
/*:731*/
#line 3444 "pdftex-final.ch"
;
/*1925:*/
#line 7036 "pdftex-final.ch"

synctex_tsilh(this_box);

/*:1925*/
#line 3445 "pdftex-final.ch"
;
#line 18648 "pdftexdir/pdftex.web"
/*1712:*/
#line 37627 "pdftexdir/pdftex.web"

if eTeX_ex then
begin/*1715:*/
#line 37658 "pdftexdir/pdftex.web"

begin while info(LR_ptr)<> before do
begin if info(LR_ptr)> L_code then LR_problems:= LR_problems+10000;
pop_LR;
end;
pop_LR;
end

/*:1715*/
#line 37629 "pdftexdir/pdftex.web"
;
if box_lr(this_box)= dlist then cur_dir:= right_to_left;
end

/*:1712*/
#line 18648 "pdftexdir/pdftex.web"
;
decr(cur_s);
end;

/*:729*//*738:*/
#line 3532 "pdftex-final.ch"
procedure pdf_vlist_out;{output a|pdf_vlist_node|box}
#line 18776 "pdftexdir/pdftex.web"
label move_past,fin_rule,next_p;
var left_edge:scaled;{the left coordinate for this box}
top_edge:scaled;{the top coordinate for this box}
save_v:scaled;{what|cur_v|should pop to}
this_box:pointer;{pointer to containing box}
g_order:glue_ord;{applicable order of infinity for glue}
g_sign:normal..shrinking;{selects type of glue}
p:pointer;{current position in the vlist}
leader_box:pointer;{the leader box being replicated}
leader_ht:scaled;{height of leader box being replicated}
lx:scaled;{extra space between leader boxes}
outer_doing_leaders:boolean;{were we doing leaders?}
edge:scaled;{bottom boundary of leader space}
glue_temp:real;{glue value before rounding}
cur_glue:real;{glue seen so far}
cur_g:scaled;{rounded equivalent of|cur_glue|times the glue ratio}
begin cur_g:= 0;cur_glue:= float_constant(0);
this_box:= temp_ptr;g_order:= glue_order(this_box);
g_sign:= glue_sign(this_box);p:= list_ptr(this_box);
incr(cur_s);
#line 3538 "pdftex-final.ch"
left_edge:= cur_h;
/*1922:*/
#line 7027 "pdftex-final.ch"

synctex_vlist(this_box);

/*:1922*/
#line 3539 "pdftex-final.ch"
;
cur_v:= cur_v-height(this_box);top_edge:= cur_v;
#line 18797 "pdftexdir/pdftex.web"
/*739:*/
#line 18804 "pdftexdir/pdftex.web"

if(last_thread<> null)and is_running(pdf_thread_dp)and
(pdf_thread_level= cur_s)then
append_thread(this_box,left_edge,top_edge+height(this_box))

/*:739*/
#line 18797 "pdftexdir/pdftex.web"
;
#line 3548 "pdftex-final.ch"
while p<> null do
/*740:*/
#line 18809 "pdftexdir/pdftex.web"

begin if is_char_node(p)then confusion("pdfvlistout")

else/*741:*/
#line 18816 "pdftexdir/pdftex.web"

begin case type(p)of
hlist_node,vlist_node:/*742:*/
#line 3558 "pdftex-final.ch"

if list_ptr(p)= null then begin
cur_v:= cur_v+height(p);
/*1926:*/
#line 7039 "pdftex-final.ch"

if type(p)= vlist_node then begin
synctex_void_vlist(p,this_box);
end
else begin
synctex_void_hlist(p,this_box);
end;

/*:1926*/
#line 3561 "pdftex-final.ch"
;
cur_v:= cur_v+depth(p);
end
#line 18834 "pdftexdir/pdftex.web"
 else begin cur_v:= cur_v+height(p);save_v:= cur_v;
if cur_dir= right_to_left then cur_h:= left_edge-shift_amount(p)
else cur_h:= left_edge+shift_amount(p);{shift the box right}
temp_ptr:= p;
if type(p)= vlist_node then pdf_vlist_out else pdf_hlist_out;
cur_v:= save_v+depth(p);cur_h:= left_edge;
end

/*:742*/
#line 18818 "pdftexdir/pdftex.web"
;
rule_node:begin rule_ht:= height(p);rule_dp:= depth(p);rule_wd:= width(p);
goto fin_rule;
end;
whatsit_node:/*1636:*/
#line 36637 "pdftexdir/pdftex.web"

case subtype(p)of
pdf_literal_node:
pdf_out_literal(p);
pdf_colorstack_node:
pdf_out_colorstack(p);
pdf_setmatrix_node:
pdf_out_setmatrix(p);
pdf_save_node:
pdf_out_save(p);
pdf_restore_node:
pdf_out_restore(p);
pdf_refobj_node:
pdf_append_list(pdf_obj_objnum(p))(pdf_obj_list);
pdf_refxform_node:
/*1641:*/
#line 36716 "pdftexdir/pdftex.web"

begin cur_v:= cur_v+pdf_height(p);save_v:= cur_v;
cur_h:= left_edge;
out_form(p);
cur_v:= save_v+pdf_depth(p);cur_h:= left_edge;
end

/*:1641*/
#line 36652 "pdftexdir/pdftex.web"
;
pdf_refximage_node:
/*1640:*/
#line 36709 "pdftexdir/pdftex.web"

begin cur_v:= cur_v+pdf_height(p)+pdf_depth(p);save_v:= cur_v;
cur_h:= left_edge;
out_image(p);
cur_v:= save_v;cur_h:= left_edge;
end

/*:1640*/
#line 36654 "pdftexdir/pdftex.web"
;
pdf_annot_node:
do_annot(p,this_box,left_edge,top_edge+height(this_box));
pdf_start_link_node:
pdf_error("ext4","\pdfstartlink ended up in vlist");
pdf_end_link_node:
pdf_error("ext4","\pdfendlink ended up in vlist");
pdf_dest_node:
do_dest(p,this_box,left_edge,top_edge+height(this_box));
pdf_thread_node,
pdf_start_thread_node:
do_thread(p,this_box,left_edge,top_edge+height(this_box));
pdf_end_thread_node:
end_thread;
pdf_save_pos_node:
/*1638:*/
#line 36694 "pdftexdir/pdftex.web"

begin
pdf_last_x_pos:= cur_h;
if is_shipping_page then
pdf_last_y_pos:= cur_page_height-cur_v
else
pdf_last_y_pos:= pdf_xform_height+pdf_xform_depth-cur_v;
end

/*:1638*/
#line 36669 "pdftexdir/pdftex.web"
;
special_node:
pdf_special(p);
pdf_snap_ref_point_node:
/*1639:*/
#line 36703 "pdftexdir/pdftex.web"

begin
pdf_snapx_refpos:= cur_h;
pdf_snapy_refpos:= cur_v;
end

/*:1639*/
#line 36673 "pdftexdir/pdftex.web"
;
pdf_snapy_comp_node:
do_snapy_comp(p,this_box);
pdf_snapy_node:
do_snapy(p);
pdf_interword_space_on_node:
gen_faked_interword_space:= true;
pdf_interword_space_off_node:
gen_faked_interword_space:= false;
pdf_fake_space_node:
pdf_insert_fake_space;
pdf_running_link_off_node:
gen_running_link:= false;
pdf_running_link_on_node:
gen_running_link:= true;
othercases out_what(p);
endcases

/*:1636*/
#line 18822 "pdftexdir/pdftex.web"
;
glue_node:/*744:*/
#line 18853 "pdftexdir/pdftex.web"

begin g:= glue_ptr(p);rule_ht:= width(g)-cur_g;
if g_sign<> normal then
begin if g_sign= stretching then
begin if stretch_order(g)= g_order then
begin cur_glue:= cur_glue+stretch(g);
vet_glue(float(glue_set(this_box))*cur_glue);

cur_g:= round(glue_temp);
end;
end
else if shrink_order(g)= g_order then
begin cur_glue:= cur_glue-shrink(g);
vet_glue(float(glue_set(this_box))*cur_glue);
cur_g:= round(glue_temp);
end;
end;
rule_ht:= rule_ht+cur_g;
if subtype(p)>=a_leaders then
/*745:*/
#line 18877 "pdftexdir/pdftex.web"

begin leader_box:= leader_ptr(p);
if type(leader_box)= rule_node then
begin rule_wd:= width(leader_box);rule_dp:= 0;
goto fin_rule;
end;
leader_ht:= height(leader_box)+depth(leader_box);
if(leader_ht> 0)and(rule_ht> 0)then
begin rule_ht:= rule_ht+10;{compensate for floating-point rounding}
edge:= cur_v+rule_ht;lx:= 0;
/*664:*/
#line 14908 "pdftexdir/pdftex.web"

if subtype(p)= a_leaders then
begin save_v:= cur_v;
cur_v:= top_edge+leader_ht*((cur_v-top_edge)div leader_ht);
if cur_v<save_v then cur_v:= cur_v+leader_ht;
end
else begin lq:= rule_ht div leader_ht;{the number of box copies}
lr:= rule_ht mod leader_ht;{the remaining space}
if subtype(p)= c_leaders then cur_v:= cur_v+(lr div 2)
else begin lx:= lr div(lq+1);
cur_v:= cur_v+((lr-(lq-1)*lx)div 2);
end;
end

/*:664*/
#line 18888 "pdftexdir/pdftex.web"
;
while cur_v+leader_ht<=edge do
/*746:*/
#line 18896 "pdftexdir/pdftex.web"

begin if cur_dir= right_to_left then
cur_h:= left_edge-shift_amount(leader_box)
else cur_h:= left_edge+shift_amount(leader_box);
cur_v:= cur_v+height(leader_box);save_v:= cur_v;
temp_ptr:= leader_box;
outer_doing_leaders:= doing_leaders;doing_leaders:= true;
if type(leader_box)= vlist_node then pdf_vlist_out else pdf_hlist_out;
doing_leaders:= outer_doing_leaders;
cur_h:= left_edge;
cur_v:= save_v-height(leader_box)+leader_ht+lx;
end

/*:746*/
#line 18891 "pdftexdir/pdftex.web"
;
cur_v:= edge-10;goto next_p;
end;
end

/*:745*/
#line 18873 "pdftexdir/pdftex.web"
;
goto move_past;
end

/*:744*/
#line 18823 "pdftexdir/pdftex.web"
;
kern_node:cur_v:= cur_v+width(p);
othercases do_nothing
endcases;
goto next_p;
fin_rule:/*743:*/
#line 18842 "pdftexdir/pdftex.web"

if is_running(rule_wd)then rule_wd:= width(this_box);
rule_ht:= rule_ht+rule_dp;{this is the rule thickness}
cur_v:= cur_v+rule_ht;
if(rule_ht> 0)and(rule_wd> 0)then{we don't output empty rules}
begin if cur_dir= right_to_left then cur_h:= cur_h-rule_wd;
pdf_set_rule(cur_h,cur_v,rule_wd,rule_ht);
cur_h:= left_edge;
end;
goto next_p

/*:743*/
#line 18828 "pdftexdir/pdftex.web"
;
move_past:cur_v:= cur_v+rule_ht;
end

#line 3558 "pdftex-final.ch"
/*:741*/
#line 18812 "pdftexdir/pdftex.web"
;
next_p:p:= link(p);
end

/*:740*/
#line 3550 "pdftex-final.ch"
;
/*1923:*/
#line 7030 "pdftex-final.ch"

synctex_tsilv(this_box);

/*:1923*/
#line 3551 "pdftex-final.ch"
;
#line 18801 "pdftexdir/pdftex.web"
decr(cur_s);
end;

/*:738*//*747:*/
#line 18912 "pdftexdir/pdftex.web"
procedure fix_pdfoutput;
begin
if not fixed_pdfoutput_set then begin
fixed_pdfoutput:= pdf_output;
fixed_pdfoutput_set:= true;
end
else if fixed_pdfoutput<> pdf_output then
pdf_error("setup",
"\pdfoutput can only be changed before anything is written to the output");
if fixed_pdfoutput_set then fix_pdf_draftmode;
end;

/*:747*//*748:*/
#line 18926 "pdftexdir/pdftex.web"
procedure fix_pdf_draftmode;
begin
if not fixed_pdf_draftmode_set then begin
fixed_pdf_draftmode:= pdf_draftmode;
fixed_pdf_draftmode_set:= true;
end
else if fixed_pdf_draftmode<> pdf_draftmode then
pdf_error("setup",
"\pdfdraftmode can only be changed before anything is written to the output");
if fixed_pdf_draftmode_set and fixed_pdf_draftmode> 0 then begin
fixed_pdf_draftmode_set:= true;
pdf_compress_level:= 0;
fixed_pdf_objcompresslevel:= 0;
end;
end;

/*:748*//*749:*/
#line 18943 "pdftexdir/pdftex.web"
function substr_of_str(s,t:str_number):boolean;
label continue,exit;
var j,k,kk:pool_pointer;{running indices}
begin
k:= str_start[t];
while(k<str_start[t+1]-length(s))do begin
j:= str_start[s];
kk:= k;
while(j<str_start[s+1])do begin
if str_pool[j]<> str_pool[kk]then
goto continue;
incr(j);
incr(kk);
end;
substr_of_str:= true;
return;
continue:incr(k);
end;
substr_of_str:= false;
end;

/*:749*//*750:*/
#line 18968 "pdftexdir/pdftex.web"
procedure pdf_ship_out(p:pointer;shipping_page:boolean);{output the box|p|}
label done,done1;
var i,j,k:integer;{general purpose accumulators}
s:pool_pointer;{index into|str_pool|}
mediabox_given:boolean;
save_font_list:pointer;{to save|pdf_font_list|during flushing pending forms}
save_obj_list:pointer;{to save|pdf_obj_list|}
save_ximage_list:pointer;{to save|pdf_ximage_list|}
save_xform_list:pointer;{to save|pdf_xform_list|}
save_image_procset:integer;{to save|pdf_image_procset|}
save_text_procset:integer;{to save|pdf_text_procset|}
pdf_last_resources:integer;{pointer to most recently generated Resources object}
begin if tracing_output> 0 then
begin print_nl("");print_ln;
print("Completed box being shipped out");

end;
if not init_pdf_output then begin
/*792:*/
#line 19674 "pdftexdir/pdftex.web"

check_pdfversion;
prepare_mag;
fixed_decimal_digits:= fix_int(pdf_decimal_digits,0,4);
min_bp_val:= 
divide_scaled(one_hundred_bp,ten_pow[fixed_decimal_digits+2],0);
if pdf_pk_resolution= 0 then{if not set from format file or by user}
pdf_pk_resolution:= pk_dpi;{take it from\.{texmf.cnf}}
fixed_pk_resolution:= fix_int(pdf_pk_resolution,72,8000);
pk_scale_factor:= 
divide_scaled(72,fixed_pk_resolution,5+fixed_decimal_digits);
if pdf_pk_mode<> null then begin
kpse_init_prog('PDFTEX',fixed_pk_resolution,
make_cstring(tokens_to_string(pdf_pk_mode)),nil);
flush_string;
end else
kpse_init_prog('PDFTEX',fixed_pk_resolution,nil,nil);
kpse_set_program_enabled(kpse_pk_format,1,kpse_src_compile);
set_job_id(year,month,day,time);
if(pdf_unique_resname> 0)and(pdf_resname_prefix= 0)then
pdf_resname_prefix:= get_resname_prefix

/*:792*/
#line 18986 "pdftexdir/pdftex.web"
;
init_pdf_output:= true;
end;
is_shipping_page:= shipping_page;
if shipping_page then begin
if term_offset> max_print_line-9 then print_ln
else if(term_offset> 0)or(file_offset> 0)then print_char(" ");
print_char("[");j:= 9;
while(count(j)= 0)and(j> 0)do decr(j);
for k:= 0 to j do
begin print_int(count(k));
if k<j then print_char(".");
end;
update_terminal;
end;
if tracing_output> 0 then
begin if shipping_page then print_char("]");
begin_diagnostic;show_box(p);end_diagnostic(true);
end;
#line 3569 "pdftex-final.ch"
pdf_output_value:= pdf_output;{{\sl Sync\TeX}:we assume that|pdf_output|is properly set up}
if shipping_page then synctex_sheet(mag)else synctex_pdfxform(p);
/*751:*/
#line 19013 "pdftexdir/pdftex.web"

/*669:*/
#line 15008 "pdftexdir/pdftex.web"

if(height(p)> max_dimen)or(depth(p)> max_dimen)or
(height(p)+depth(p)+v_offset> max_dimen)or
(width(p)+h_offset> max_dimen)then
begin print_err("Huge page cannot be shipped out");

help2("The page just created is more than 18 feet tall or")
("more than 18 feet wide, so I suspect something went wrong.");
error;
if tracing_output<=0 then
begin begin_diagnostic;
print_nl("The following box has been deleted:");

show_box(p);
end_diagnostic(true);
end;
goto done;
end;
if height(p)+depth(p)+v_offset> max_v then max_v:= height(p)+depth(p)+v_offset;
if width(p)+h_offset> max_h then max_h:= width(p)+h_offset

/*:669*/
#line 19015 "pdftexdir/pdftex.web"
;
/*752:*/
#line 19024 "pdftexdir/pdftex.web"

fix_pdfoutput;
temp_ptr:= p;
prepare_mag;
pdf_last_resources:= pdf_new_objnum;
pdf_page_group_val:= 0;
/*753:*/
#line 19059 "pdftexdir/pdftex.web"

pdf_font_list:= null;
pdf_obj_list:= null;
pdf_xform_list:= null;
pdf_ximage_list:= null;
pdf_text_procset:= false;
pdf_image_procset:= 0

/*:753*/
#line 19030 "pdftexdir/pdftex.web"
;
if not shipping_page then begin
pdf_xform_width:= width(p);
pdf_xform_height:= height(p);
pdf_xform_depth:= depth(p);
pdf_begin_dict(pdf_cur_form,0);
pdf_last_stream:= pdf_cur_form;
cur_v:= height(p);
cur_h:= 0;
pdf_origin_h:= 0;
pdf_origin_v:= pdf_xform_height+pdf_xform_depth;
end
else begin
/*755:*/
#line 19074 "pdftexdir/pdftex.web"

cur_h_offset:= pdf_h_origin+h_offset;
cur_v_offset:= pdf_v_origin+v_offset;
if pdf_page_width<> 0 then
cur_page_width:= pdf_page_width
else
cur_page_width:= width(p)+2*cur_h_offset;
if pdf_page_height<> 0 then
cur_page_height:= pdf_page_height
else
cur_page_height:= height(p)+depth(p)+2*cur_v_offset

/*:755*/
#line 19043 "pdftexdir/pdftex.web"
;
pdf_last_page:= get_obj(obj_type_page,total_pages+1,0);
obj_aux(pdf_last_page):= 1;{mark that this page has been created}
pdf_new_dict(obj_type_others,0,0);
pdf_last_stream:= obj_ptr;
cur_h:= cur_h_offset;
cur_v:= height(p)+cur_v_offset;
pdf_origin_h:= 0;
pdf_origin_v:= cur_page_height;
/*754:*/
#line 19067 "pdftexdir/pdftex.web"

pdf_annot_list:= null;
pdf_link_list:= null;
pdf_dest_list:= null;
pdf_bead_list:= null;
last_thread:= null

/*:754*/
#line 19052 "pdftexdir/pdftex.web"
;
end;
if not shipping_page then begin
/*756:*/
#line 19088 "pdftexdir/pdftex.web"

pdf_print_ln("/Type /XObject");
pdf_print_ln("/Subtype /Form");
if obj_xform_attr(pdf_cur_form)<> null then begin
pdf_print_toks_ln(obj_xform_attr(pdf_cur_form));
delete_toks(obj_xform_attr(pdf_cur_form));
end;
pdf_print("/BBox [");
pdf_print("0 0 ");
pdf_print_bp(pdf_xform_width);pdf_out(" ");
pdf_print_bp(pdf_xform_height+pdf_xform_depth);pdf_print_ln("]");
pdf_print_ln("/FormType 1");
pdf_print_ln("/Matrix [1 0 0 1 0 0]");
pdf_indirect_ln("Resources",pdf_last_resources)

/*:756*/
#line 19055 "pdftexdir/pdftex.web"
;
end;
/*757:*/
#line 19103 "pdftexdir/pdftex.web"

pdf_begin_stream;
if shipping_page then begin
/*758:*/
#line 19112 "pdftexdir/pdftex.web"

prepare_mag;
if mag<> 1000 then begin
pdf_print_real(mag,3);
pdf_print(" 0 0 ");
pdf_print_real(mag,3);
pdf_print_ln(" 0 0 cm");
end

/*:758*/
#line 19106 "pdftexdir/pdftex.web"
;
end;
pdfshipoutbegin(shipping_page);
if shipping_page then
pdf_out_colorstack_startpage;

/*:757*/
#line 19057 "pdftexdir/pdftex.web"


/*:752*/
#line 19016 "pdftexdir/pdftex.web"
;
if type(p)= vlist_node then pdf_vlist_out else pdf_hlist_out;
if shipping_page then
incr(total_pages);
cur_s:= -1;
/*759:*/
#line 19121 "pdftexdir/pdftex.web"

/*760:*/
#line 19136 "pdftexdir/pdftex.web"

pdf_end_text;
pdfshipoutend(shipping_page);
pdf_end_stream

/*:760*/
#line 19122 "pdftexdir/pdftex.web"
;
if shipping_page then begin
/*769:*/
#line 19240 "pdftexdir/pdftex.web"

pdf_begin_dict(pdf_last_page,1);
pdf_print_ln("/Type /Page");
pdf_indirect_ln("Contents",pdf_last_stream);
pdf_indirect_ln("Resources",pdf_last_resources);
mediabox_given:= false;
if pdf_page_attr<> null then begin
s:= tokens_to_string(pdf_page_attr);
mediabox_given:= substr_of_str("/MediaBox",s);
flush_str(s);
end;
if not mediabox_given then begin
pdf_print("/MediaBox [0 0 ");
pdf_print_mag_bp(cur_page_width);pdf_out(" ");
pdf_print_mag_bp(cur_page_height);
pdf_print_ln("]");
end;
if pdf_page_attr<> null then
pdf_print_toks_ln(pdf_page_attr);
/*770:*/
#line 19268 "pdftexdir/pdftex.web"

if total_pages mod pages_tree_kids_max= 1 then begin
pdf_create_obj(obj_type_pages,pages_tree_kids_max);
pdf_last_pages:= obj_ptr;
end;
pdf_indirect_ln("Parent",pdf_last_pages)

/*:770*/
#line 19259 "pdftexdir/pdftex.web"
;
if pdf_page_group_val> 0 then begin
pdf_print("/Group ");
pdf_print_int(pdf_page_group_val);
pdf_print_ln(" 0 R");
end;
/*771:*/
#line 19275 "pdftexdir/pdftex.web"

if(pdf_annot_list<> null)or(pdf_link_list<> null)then begin
pdf_print("/Annots [ ");
k:= pdf_annot_list;
while k<> null do begin
pdf_print_int(info(k));
pdf_print(" 0 R ");
k:= link(k);
end;
k:= pdf_link_list;
while k<> null do begin
pdf_print_int(info(k));
pdf_print(" 0 R ");
k:= link(k);
end;
pdf_print_ln("]");
end;
if pdf_bead_list<> null then begin
k:= pdf_bead_list;
pdf_print("/B [ ");
while k<> null do begin
pdf_print_int(info(k));
pdf_print(" 0 R ");
k:= link(k);
end;
pdf_print_ln("]");
end

/*:771*/
#line 19265 "pdftexdir/pdftex.web"
;
pdf_end_dict

/*:769*/
#line 19124 "pdftexdir/pdftex.web"
;
end;
/*761:*/
#line 19141 "pdftexdir/pdftex.web"

/*773:*/
#line 19360 "pdftexdir/pdftex.web"

if pdf_obj_list<> null then begin
k:= pdf_obj_list;
while k<> null do begin
if not is_obj_written(info(k))then
pdf_write_obj(info(k));
k:= link(k);
end;
end

/*:773*/
#line 19142 "pdftexdir/pdftex.web"
;
/*775:*/
#line 19377 "pdftexdir/pdftex.web"

if pdf_xform_list<> null then begin
k:= pdf_xform_list;
while k<> null do begin
if not is_obj_written(info(k))then begin
saved_pdf_cur_form:= pdf_cur_form;
pdf_cur_form:= info(k);
/*776:*/
#line 19394 "pdftexdir/pdftex.web"

save_font_list:= pdf_font_list;
save_obj_list:= pdf_obj_list;
save_xform_list:= pdf_xform_list;
save_ximage_list:= pdf_ximage_list;
save_text_procset:= pdf_text_procset;
save_image_procset:= pdf_image_procset

/*:776*/
#line 19384 "pdftexdir/pdftex.web"
;
/*753:*/
#line 19059 "pdftexdir/pdftex.web"

pdf_font_list:= null;
pdf_obj_list:= null;
pdf_xform_list:= null;
pdf_ximage_list:= null;
pdf_text_procset:= false;
pdf_image_procset:= 0

/*:753*/
#line 19385 "pdftexdir/pdftex.web"
;
pdf_ship_out(obj_xform_box(pdf_cur_form),false);
pdf_cur_form:= saved_pdf_cur_form;
/*777:*/
#line 19402 "pdftexdir/pdftex.web"

pdf_font_list:= save_font_list;
pdf_obj_list:= save_obj_list;
pdf_xform_list:= save_xform_list;
pdf_ximage_list:= save_ximage_list;
pdf_text_procset:= save_text_procset;
pdf_image_procset:= save_image_procset

/*:777*/
#line 19388 "pdftexdir/pdftex.web"
;
end;
k:= link(k);
end;
end

/*:775*/
#line 19143 "pdftexdir/pdftex.web"
;
/*779:*/
#line 19422 "pdftexdir/pdftex.web"

if pdf_ximage_list<> null then begin
k:= pdf_ximage_list;
while k<> null do begin
if not is_obj_written(info(k))then
pdf_write_image(info(k));
k:= link(k);
end;
end

/*:779*/
#line 19144 "pdftexdir/pdftex.web"


/*:761*/
#line 19126 "pdftexdir/pdftex.web"
;
if shipping_page then begin
/*780:*/
#line 19432 "pdftexdir/pdftex.web"

pdf_origin_h:= 0;
pdf_origin_v:= cur_page_height;
/*781:*/
#line 19440 "pdftexdir/pdftex.web"

if pdf_annot_list<> null then begin
k:= pdf_annot_list;
while k<> null do begin
i:= obj_annot_ptr(info(k));{|i|points to|pdf_annot_node|}
pdf_begin_dict(info(k),1);
pdf_print_ln("/Type /Annot");
pdf_print_toks_ln(pdf_annot_data(i));
pdf_rectangle(pdf_left(i),pdf_top(i),pdf_right(i),pdf_bottom(i));
pdf_end_dict;
k:= link(k);
end;
end

/*:781*/
#line 19435 "pdftexdir/pdftex.web"
;
/*782:*/
#line 19454 "pdftexdir/pdftex.web"

if pdf_link_list<> null then begin
k:= pdf_link_list;
while k<> null do begin
i:= obj_annot_ptr(info(k));
pdf_begin_dict(info(k),1);
pdf_print_ln("/Type /Annot");
if pdf_action_type(pdf_link_action(i))<> pdf_action_user then
pdf_print_ln("/Subtype /Link");
if pdf_link_attr(i)<> null then
pdf_print_toks_ln(pdf_link_attr(i));
pdf_rectangle(pdf_left(i),pdf_top(i),pdf_right(i),pdf_bottom(i));
if pdf_action_type(pdf_link_action(i))<> pdf_action_user then
pdf_print("/A ");
write_action(pdf_link_action(i));
pdf_end_dict;
k:= link(k);
end;
/*783:*/
#line 19475 "pdftexdir/pdftex.web"

k:= pdf_link_list;
while k<> null do begin
i:= obj_annot_ptr(info(k));
{nodes with|info= max_halfword|were created by|append_link|and
must be flushed here,as they are not linked in any list}
if info(i)= max_halfword then
flush_whatsit_node(i,pdf_start_link_node);
k:= link(k);
end

/*:783*/
#line 19472 "pdftexdir/pdftex.web"
;
end

/*:782*/
#line 19436 "pdftexdir/pdftex.web"
;
/*784:*/
#line 19486 "pdftexdir/pdftex.web"

if pdf_dest_list<> null then begin
k:= pdf_dest_list;
while k<> null do begin
if is_obj_written(info(k))then
pdf_error("ext5",
"destination has been already written (this shouldn't happen)")
else begin
i:= obj_dest_ptr(info(k));
if pdf_dest_named_id(i)> 0 then begin
pdf_begin_dict(info(k),1);
pdf_print("/D ");
end
else
pdf_begin_obj(info(k),1);
pdf_out("[");pdf_print_int(pdf_last_page);pdf_print(" 0 R ");
case pdf_dest_type(i)of
pdf_dest_xyz:begin
pdf_print("/XYZ ");
pdf_print_mag_bp(pdf_x(pdf_left(i)));pdf_out(" ");
pdf_print_mag_bp(pdf_y(pdf_top(i)));pdf_out(" ");
if pdf_dest_xyz_zoom(i)= null then
pdf_print("null")
else begin
pdf_print_int(pdf_dest_xyz_zoom(i)div 1000);
pdf_out(".");
pdf_print_int((pdf_dest_xyz_zoom(i)mod 1000));
end;
end;
pdf_dest_fit:
pdf_print("/Fit");
pdf_dest_fith:begin
pdf_print("/FitH ");
pdf_print_mag_bp(pdf_y(pdf_top(i)));
end;
pdf_dest_fitv:begin
pdf_print("/FitV ");
pdf_print_mag_bp(pdf_x(pdf_left(i)));
end;
pdf_dest_fitb:
pdf_print("/FitB");
pdf_dest_fitbh:begin
pdf_print("/FitBH ");
pdf_print_mag_bp(pdf_y(pdf_top(i)));
end;
pdf_dest_fitbv:begin
pdf_print("/FitBV ");
pdf_print_mag_bp(pdf_x(pdf_left(i)));
end;
pdf_dest_fitr:begin
pdf_print("/FitR ");
pdf_print_rect_spec(i);
end;
othercases pdf_error("ext5","unknown dest type");
endcases;
pdf_print_ln("]");
if pdf_dest_named_id(i)> 0 then
pdf_end_dict
else
pdf_end_obj;
end;
k:= link(k);
end;
end

/*:784*/
#line 19437 "pdftexdir/pdftex.web"
;
/*786:*/
#line 19563 "pdftexdir/pdftex.web"

if pdf_bead_list<> null then begin
k:= pdf_bead_list;
while k<> null do begin
pdf_new_obj(obj_type_others,0,1);
pdf_out("[");
i:= obj_bead_data(info(k));{pointer to a whatsit or whatsit-like node}
pdf_print_rect_spec(i);
if info(i)= max_halfword then{not a whatsit node,so must be destroyed here}
flush_whatsit_node(i,pdf_start_thread_node);
pdf_print_ln("]");
obj_bead_rect(info(k)):= obj_ptr;{rewrite|obj_bead_data|}
pdf_end_obj;
k:= link(k);
end;
end

/*:786*/
#line 19438 "pdftexdir/pdftex.web"


/*:780*/
#line 19128 "pdftexdir/pdftex.web"
;
end;
/*762:*/
#line 19146 "pdftexdir/pdftex.web"

pdf_begin_dict(pdf_last_resources,1);
/*763:*/
#line 19154 "pdftexdir/pdftex.web"

if shipping_page then begin
if pdf_page_resources<> null then
pdf_print_toks_ln(pdf_page_resources);
end
else begin
if obj_xform_resources(pdf_cur_form)<> null then begin
pdf_print_toks_ln(obj_xform_resources(pdf_cur_form));
delete_toks(obj_xform_resources(pdf_cur_form));
end;
end

/*:763*/
#line 19148 "pdftexdir/pdftex.web"
;
/*766:*/
#line 19183 "pdftexdir/pdftex.web"

if pdf_font_list<> null then begin
pdf_print("/Font << ");
k:= pdf_font_list;
while k<> null do begin
pdf_print("/F");
set_ff(info(k));
pdf_print_int(ff);
pdf_print_resname_prefix;
pdf_out(" ");
pdf_print_int(pdf_font_num[ff]);
pdf_print(" 0 R ");
k:= link(k);
end;
pdf_print_ln(">>");
pdf_text_procset:= true;
end

/*:766*/
#line 19149 "pdftexdir/pdftex.web"
;
/*767:*/
#line 19201 "pdftexdir/pdftex.web"

if(pdf_xform_list<> null)or(pdf_ximage_list<> null)then begin
pdf_print("/XObject << ");
k:= pdf_xform_list;
while k<> null do begin
pdf_print("/Fm");
pdf_print_int(obj_info(info(k)));
pdf_print_resname_prefix;
pdf_out(" ");
pdf_print_int(info(k));
pdf_print(" 0 R ");
k:= link(k);
end;
k:= pdf_ximage_list;
while k<> null do begin
pdf_print("/Im");
pdf_print_int(obj_info(info(k)));
pdf_print_resname_prefix;
pdf_out(" ");
pdf_print_int(info(k));
pdf_print(" 0 R ");
update_image_procset(obj_ximage_data(info(k)));
k:= link(k);
end;
pdf_print_ln(">>");
end

/*:767*/
#line 19150 "pdftexdir/pdftex.web"
;
/*768:*/
#line 19228 "pdftexdir/pdftex.web"

pdf_print("/ProcSet [ /PDF");
if pdf_text_procset then
pdf_print(" /Text");
if check_image_b(pdf_image_procset)then
pdf_print(" /ImageB");
if check_image_c(pdf_image_procset)then
pdf_print(" /ImageC");
if check_image_i(pdf_image_procset)then
pdf_print(" /ImageI");
pdf_print_ln(" ]")

/*:768*/
#line 19151 "pdftexdir/pdftex.web"
;
pdf_end_dict

/*:762*/
#line 19130 "pdftexdir/pdftex.web"
;
/*764:*/
#line 19171 "pdftexdir/pdftex.web"

flush_list(pdf_font_list);
flush_list(pdf_obj_list);
flush_list(pdf_xform_list);
flush_list(pdf_ximage_list)

/*:764*/
#line 19131 "pdftexdir/pdftex.web"
;
if shipping_page then begin
/*765:*/
#line 19177 "pdftexdir/pdftex.web"

flush_list(pdf_annot_list);
flush_list(pdf_link_list);
flush_list(pdf_dest_list);
flush_list(pdf_bead_list)

/*:765*/
#line 19133 "pdftexdir/pdftex.web"
;
end

/*:759*/
#line 19021 "pdftexdir/pdftex.web"
;
done:

/*:751*/
#line 3571 "pdftex-final.ch"
;
if shipping_page then synctex_teehs else synctex_mrofxfdp;
#line 19006 "pdftexdir/pdftex.web"
if eTeX_ex then/*1727:*/
#line 37816 "pdftexdir/pdftex.web"

begin if LR_problems> 0 then
begin/*1710:*/
#line 37608 "pdftexdir/pdftex.web"

begin print_ln;print_nl("\endL or \endR problem (");
print_int(LR_problems div 10000);print(" missing, ");
print_int(LR_problems mod 10000);print(" extra");
LR_problems:= 0;
end

/*:1710*/
#line 37818 "pdftexdir/pdftex.web"
;print_char(")");print_ln;
end;
if(LR_ptr<> null)or(cur_dir<> left_to_right)then confusion("LR3");

end

/*:1727*/
#line 19006 "pdftexdir/pdftex.web"
;
if(tracing_output<=0)and shipping_page then print_char("]");
dead_cycles:= 0;
update_terminal;{progress report}
/*667:*/
#line 14974 "pdftexdir/pdftex.web"

stat if tracing_stats> 1 then
begin print_nl("Memory usage before: ");

print_int(var_used);print_char("&");
print_int(dyn_used);print_char(";");
end;
tats
flush_node_list(p);
stat if tracing_stats> 1 then
begin print(" after: ");
print_int(var_used);print_char("&");
print_int(dyn_used);print("; still untouched: ");
print_int(hi_mem_min-lo_mem_max-1);print_ln;
end;
tats

/*:667*/
#line 19010 "pdftexdir/pdftex.web"
;
end;

/*:750*//*791:*/
#line 19665 "pdftexdir/pdftex.web"
procedure ship_out(p:pointer);{output the box|p|}
begin
fix_pdfoutput;
if pdf_output> 0 then
pdf_ship_out(p,true)
else
dvi_ship_out(p);
end;

/*:791*//*793:*/
#line 19731 "pdftexdir/pdftex.web"
function str_less_str(s1,s2:str_number):boolean;{compare two pdf strings}
var j1,j2,e1,e2:pool_pointer;
c1,c2:packed_ASCII_code;
begin
{Minimal requirement:output of\.{\\pdfescapestring}must be supported.}
{This implementation also supports all escape sequences}
{listed in the table`Escape sequences in literal strings'}
{of the pdf specification.}
{End-of-line markers are not detected:}
{The marker is not replaced by`\.{\\n}' or removed if it is escaped.}
j1:= str_start[s1];
j2:= str_start[s2];
e1:= j1+length(s1);
e2:= j2+length(s2);
while(j1<e1)and(j2<e2)do begin
{get next character of first string}
get_next_char(1);
{get next character of second string}
get_next_char(2);
{compare characters}
if c1<c2 then begin
str_less_str:= true;
return;
end
else if c1> c2 then begin
str_less_str:= false;
return;
end;
end;
{compare string lengths}
if(j1>=e1)and(j2<e2)then
str_less_str:= true
else
str_less_str:= false;
exit:end;

procedure sort_dest_names(l,r:integer);{sorts|dest_names|by names}
var i,j:integer;
s:str_number;
e:dest_name_entry;
begin
i:= l;
j:= r;
s:= dest_names[(l+r)div 2].objname;
repeat
while str_less_str(dest_names[i].objname,s)do
incr(i);
while str_less_str(s,dest_names[j].objname)do
decr(j);
if i<=j then begin
e:= dest_names[i];
dest_names[i]:= dest_names[j];
dest_names[j]:= e;
incr(i);
decr(j);
end;
until i> j;
if l<j then
sort_dest_names(l,j);
if i<r then
sort_dest_names(i,r);
end;

/*:793*//*795:*/
#line 19849 "pdftexdir/pdftex.web"
procedure pdf_fix_dest(k:integer);
begin
if obj_dest_ptr(k)<> null then
return;
pdf_warning("dest","",false,false);
if obj_info(k)<0 then begin
print("name{");
print(-obj_info(k));
print("}");
end
else begin
print("num");
print_int(obj_info(k));
end;
print(" has been referenced but does not exist, replaced by a fixed one");
print_ln;print_ln;
pdf_begin_obj(k,1);
pdf_out("[");
pdf_print_int(head_tab[obj_type_page]);
pdf_print_ln(" 0 R /Fit]");
pdf_end_obj;
end;

/*:795*//*805:*/
#line 20141 "pdftexdir/pdftex.web"
procedure pdf_print_info;{print info object}
var s:str_number;
creator_given,producer_given,creationdate_given,moddate_given,trapped_given:boolean;
begin
pdf_new_dict(obj_type_others,0,3);{keep Info readable unless explicitly forced}
creator_given:= false;
producer_given:= false;
creationdate_given:= false;
moddate_given:= false;
trapped_given:= false;
if pdf_info_toks<> null then begin
s:= tokens_to_string(pdf_info_toks);
creator_given:= substr_of_str("/Creator",s);
producer_given:= substr_of_str("/Producer",s);
creationdate_given:= substr_of_str("/CreationDate",s);
moddate_given:= substr_of_str("/ModDate",s);
trapped_given:= substr_of_str("/Trapped",s);
end;
if not producer_given then begin
/*806:*/
#line 20188 "pdftexdir/pdftex.web"

pdf_print("/Producer (pdfTeX-");
pdf_print_int(pdftex_version div 100);
pdf_out(".");
pdf_print_int(pdftex_version mod 100);
pdf_out(".");
pdf_print(pdftex_revision);
pdf_print_ln(")")

/*:806*/
#line 20160 "pdftexdir/pdftex.web"
;
end;
if pdf_info_toks<> null then begin
if length(s)> 0 then begin
pdf_print_ln(s);
end;
flush_str(s);
delete_toks(pdf_info_toks);
end;
if not creator_given then
pdf_str_entry_ln("Creator","TeX");
if pdf_info_omit_date= 0 then begin
if not creationdate_given then begin
/*807:*/
#line 20197 "pdftexdir/pdftex.web"

print_creation_date;

/*:807*/
#line 20173 "pdftexdir/pdftex.web"
;
end;
if not moddate_given then begin
/*808:*/
#line 20200 "pdftexdir/pdftex.web"

print_mod_date;

/*:808*/
#line 20176 "pdftexdir/pdftex.web"
;
end;
end;
if not trapped_given then begin
pdf_print_ln("/Trapped /False");
end;
if pdf_suppress_ptex_info mod 2= 0 then begin
pdf_str_entry_ln("PTEX.Fullbanner",pdftex_banner);
end;
pdf_end_dict;
end;

/*:805*//*815:*/
#line 20354 "pdftexdir/pdftex.web"
procedure scan_spec(c:group_code;three_codes:boolean);
{scans a box specification and left brace}
label found;
var s:integer;{temporarily saved value}
spec_code:exactly..additional;
begin if three_codes then s:= saved(0);
if scan_keyword("to")then spec_code:= exactly

else if scan_keyword("spread")then spec_code:= additional

else begin spec_code:= additional;cur_val:= 0;
goto found;
end;
scan_normal_dimen;
found:if three_codes then
begin saved(0):= s;incr(save_ptr);
end;
saved(0):= spec_code;saved(1):= cur_val;save_ptr:= save_ptr+2;
new_save_level(c);scan_left_brace;
end;

/*:815*//*821:*/
#line 20467 "pdftexdir/pdftex.web"

function check_expand_pars(f:internal_font_number):boolean;
var k:internal_font_number;
begin
check_expand_pars:= false;
if(pdf_font_step[f]= 0)or((pdf_font_stretch[f]= null_font)and
(pdf_font_shrink[f]= null_font))then
return;
if cur_font_step<0 then
cur_font_step:= pdf_font_step[f]
else if cur_font_step<> pdf_font_step[f]then
pdf_error("font expansion","using fonts with different step of expansion in one paragraph is not allowed");
k:= pdf_font_stretch[f];
if k<> null_font then begin
if max_stretch_ratio<0 then
max_stretch_ratio:= pdf_font_expand_ratio[k]
else if max_stretch_ratio<> pdf_font_expand_ratio[k]then
pdf_error("font expansion","using fonts with different limit of expansion in one paragraph is not allowed");
end;
k:= pdf_font_shrink[f];
if k<> null_font then begin
if max_shrink_ratio<0 then
max_shrink_ratio:= -pdf_font_expand_ratio[k]
else if max_shrink_ratio<> -pdf_font_expand_ratio[k]then
pdf_error("font expansion","using fonts with different limit of expansion in one paragraph is not allowed");
end;
check_expand_pars:= true;
end;

function char_stretch(f:internal_font_number;c:eight_bits):scaled;
var k:internal_font_number;
dw:scaled;
ef:integer;
begin
char_stretch:= 0;
k:= pdf_font_stretch[f];
ef:= get_ef_code(f,c);
if(k<> null_font)and(ef> 0)then begin
dw:= char_width(k)(char_info(k)(c))-char_width(f)(char_info(f)(c));
if dw> 0 then
char_stretch:= round_xn_over_d(dw,ef,1000);
end;
end;

function char_shrink(f:internal_font_number;c:eight_bits):scaled;
var k:internal_font_number;
dw:scaled;
ef:integer;
begin
char_shrink:= 0;
k:= pdf_font_shrink[f];
ef:= get_ef_code(f,c);
if(k<> null_font)and(ef> 0)then begin
dw:= char_width(f)(char_info(f)(c))-char_width(k)(char_info(k)(c));
if dw> 0 then
char_shrink:= round_xn_over_d(dw,ef,1000);
end;
end;

function get_kern(f:internal_font_number;lc,rc:eight_bits):scaled;
label continue;
var i:four_quarters;
j:four_quarters;
k:font_index;
begin
get_kern:= 0;
i:= char_info(f)(lc);
if char_tag(i)<> lig_tag then
return;
k:= lig_kern_start(f)(i);
j:= font_info[k].qqqq;
if skip_byte(j)<=stop_flag then
goto continue+1;
k:= lig_kern_restart(f)(j);
continue:
j:= font_info[k].qqqq;
continue+1:
if(next_char(j)= rc)and(skip_byte(j)<=stop_flag)and
(op_byte(j)>=kern_flag)
then begin
get_kern:= char_kern(f)(j);
return;
end;
if skip_byte(j)= qi(0)then
incr(k)
else begin
if skip_byte(j)>=stop_flag then
return;
k:= k+qo(skip_byte(j))+1;
end;
goto continue;
end;

function kern_stretch(p:pointer):scaled;
var l,r:pointer;
d:scaled;
begin
kern_stretch:= 0;
if(prev_char_p= null)or(link(prev_char_p)<> p)or(link(p)= null)
then
return;
l:= prev_char_p;
r:= link(p);
if not is_char_node(l)then
if type(l)= ligature_node then
l:= lig_char(l)
else
return;
if not is_char_node(r)then
if type(r)= ligature_node then
r:= lig_char(r)
else
return;
if not((font(l)= font(r))and
(pdf_font_stretch[font(l)]<> null_font))
then
return;
d:= get_kern(pdf_font_stretch[font(l)],character(l),character(r));
kern_stretch:= round_xn_over_d(d-width(p),
get_ef_code(font(l),character(l)),1000);
end;

function kern_shrink(p:pointer):scaled;
var l,r:pointer;
d:scaled;
begin
kern_shrink:= 0;
if(prev_char_p= null)or(link(prev_char_p)<> p)or(link(p)= null)
then
return;
l:= prev_char_p;
r:= link(p);
if not is_char_node(l)then
if type(l)= ligature_node then
l:= lig_char(l)
else
return;
if not is_char_node(r)then
if type(r)= ligature_node then
r:= lig_char(r)
else
return;
if not((font(l)= font(r))and
(pdf_font_shrink[font(l)]<> null_font))
then
return;
d:= get_kern(pdf_font_shrink[font(l)],character(l),character(r));
kern_shrink:= round_xn_over_d(width(p)-d,
get_ef_code(font(l),character(l)),1000);
end;

procedure do_subst_font(p:pointer;ex_ratio:integer);
var f,k:internal_font_number;
r:pointer;
ef:integer;
begin
if not is_char_node(p)and(type(p)= disc_node)then begin
r:= pre_break(p);
while r<> null do begin
if is_char_node(r)or(type(r)= ligature_node)then
do_subst_font(r,ex_ratio);
r:= link(r);
end;
r:= post_break(p);
while r<> null do begin
if is_char_node(r)or(type(r)= ligature_node)then
do_subst_font(r,ex_ratio);
r:= link(r);
end;
return;
end;
if is_char_node(p)then
r:= p
else if type(p)= ligature_node then
r:= lig_char(p)
else begin
{|short_display_n(p,5);|}
pdf_error("font expansion","invalid node type");
end;
f:= font(r);
ef:= get_ef_code(f,character(r));
if ef= 0 then
return;
if(pdf_font_stretch[f]<> null_font)and(ex_ratio> 0)then
k:= expand_font(f,ext_xn_over_d(ex_ratio*ef,
pdf_font_expand_ratio[pdf_font_stretch[f]],
1000000))
else if(pdf_font_shrink[f]<> null_font)and(ex_ratio<0)then
k:= expand_font(f,ext_xn_over_d(ex_ratio*ef,
-pdf_font_expand_ratio[pdf_font_shrink[f]],
1000000))
else
k:= f;
if k<> f then begin
font(r):= k;
if not is_char_node(p)then begin
r:= lig_ptr(p);
while r<> null do begin
font(r):= k;
r:= link(r);
end;
end;
end;
end;

function char_pw(p:pointer;side:small_number):scaled;
var f:internal_font_number;
c:integer;
begin
char_pw:= 0;
if side= left_side then
last_leftmost_char:= null
else
last_rightmost_char:= null;
if p= null then
return;
if not is_char_node(p)then begin
if type(p)= ligature_node then
p:= lig_char(p)
else
return;
end;
f:= font(p);
if side= left_side then begin
c:= get_lp_code(f,character(p));
last_leftmost_char:= p;
end
else begin
c:= get_rp_code(f,character(p));
last_rightmost_char:= p;
end;
if c= 0 then
return;
char_pw:= 
round_xn_over_d(quad(f),c,1000);
end;

function new_margin_kern(w:scaled;p:pointer;side:small_number):pointer;
var k:pointer;
begin
k:= get_node(margin_kern_node_size);
type(k):= margin_kern_node;
subtype(k):= side;
width(k):= w;
if p= null then
pdf_error("margin kerning","invalid pointer to marginal char node");
fast_get_avail(margin_char(k));
character(margin_char(k)):= character(p);
font(margin_char(k)):= font(p);
new_margin_kern:= k;
end;

function hpack(p:pointer;w:scaled;m:small_number):pointer;
label reswitch,common_ending,exit;
var r:pointer;{the box node that will be returned}
q:pointer;{trails behind|p|}
h,d,x:scaled;{height,depth,and natural width}
s:scaled;{shift amount}
g:pointer;{points to a glue specification}
o:glue_ord;{order of infinity}
f:internal_font_number;{the font in a|char_node|}
i:four_quarters;{font information about a|char_node|}
hd:eight_bits;{height and depth indices for a character}
font_stretch:scaled;
font_shrink:scaled;
k:scaled;
begin last_badness:= 0;r:= get_node(box_node_size);type(r):= hlist_node;
subtype(r):= min_quarterword;shift_amount(r):= 0;
q:= r+list_offset;link(q):= p;
if m= cal_expand_ratio then begin
prev_char_p:= null;
font_stretch:= 0;
font_shrink:= 0;
font_expand_ratio:= 0;
end;
h:= 0;/*822:*/
#line 20764 "pdftexdir/pdftex.web"

d:= 0;x:= 0;
total_stretch[normal]:= 0;total_shrink[normal]:= 0;
total_stretch[fil]:= 0;total_shrink[fil]:= 0;
total_stretch[fill]:= 0;total_shrink[fill]:= 0;
total_stretch[filll]:= 0;total_shrink[filll]:= 0

/*:822*/
#line 20742 "pdftexdir/pdftex.web"
;
if TeXXeT_en then/*1707:*/
#line 37583 "pdftexdir/pdftex.web"

put_LR(before){this will never match}

/*:1707*/
#line 20743 "pdftexdir/pdftex.web"
;
while p<> null do/*823:*/
#line 20771 "pdftexdir/pdftex.web"


begin reswitch:while is_char_node(p)do
/*826:*/
#line 20871 "pdftexdir/pdftex.web"

begin
if m>=cal_expand_ratio then begin
prev_char_p:= p;
case m of
cal_expand_ratio:begin
f:= font(p);
add_char_stretch(font_stretch)(character(p));
add_char_shrink(font_shrink)(character(p));
end;
subst_ex_font:
do_subst_font(p,font_expand_ratio);
endcases;
end;
f:= font(p);i:= char_info(f)(character(p));hd:= height_depth(i);
x:= x+char_width(f)(i);
s:= char_height(f)(hd);if s> h then h:= s;
s:= char_depth(f)(hd);if s> d then d:= s;
p:= link(p);
end

/*:826*/
#line 20775 "pdftexdir/pdftex.web"
;
if p<> null then
begin case type(p)of
hlist_node,vlist_node,rule_node,unset_node:
/*825:*/
#line 20859 "pdftexdir/pdftex.web"

begin x:= x+width(p);
if type(p)>=rule_node then s:= 0 else s:= shift_amount(p);
if height(p)-s> h then h:= height(p)-s;
if depth(p)+s> d then d:= depth(p)+s;
end

/*:825*/
#line 20780 "pdftexdir/pdftex.web"
;
ins_node,mark_node,adjust_node:if(adjust_tail<> null)or(pre_adjust_tail<> null)then
/*829:*/
#line 20916 "pdftexdir/pdftex.web"

begin while link(q)<> p do q:= link(q);
if type(p)= adjust_node then begin
if adjust_pre(p)<> 0 then
update_adjust_list(pre_adjust_tail)
else
update_adjust_list(adjust_tail);
p:= link(p);free_node(link(q),small_node_size);
end
else begin link(adjust_tail):= p;adjust_tail:= p;p:= link(p);
end;
link(q):= p;p:= q;
end

/*:829*/
#line 20782 "pdftexdir/pdftex.web"
;
whatsit_node:/*1604:*/
#line 35660 "pdftexdir/pdftex.web"

if(subtype(p)= pdf_refxform_node)or(subtype(p)= pdf_refximage_node)then
begin x:= x+pdf_width(p);
s:= 0;
if pdf_height(p)-s> h then h:= pdf_height(p)-s;
if pdf_depth(p)+s> d then d:= pdf_depth(p)+s;
end

/*:1604*/
#line 20783 "pdftexdir/pdftex.web"
;
glue_node:/*830:*/
#line 20930 "pdftexdir/pdftex.web"

begin g:= glue_ptr(p);x:= x+width(g);
o:= stretch_order(g);total_stretch[o]:= total_stretch[o]+stretch(g);
o:= shrink_order(g);total_shrink[o]:= total_shrink[o]+shrink(g);
if subtype(p)>=a_leaders then
begin g:= leader_ptr(p);
if height(g)> h then h:= height(g);
if depth(g)> d then d:= depth(g);
end;
end

/*:830*/
#line 20784 "pdftexdir/pdftex.web"
;
margin_kern_node:begin
if m= cal_expand_ratio then begin
f:= font(margin_char(p));
do_subst_font(margin_char(p),1000);
if f<> font(margin_char(p))then
font_stretch:= font_stretch-width(p)-
char_pw(margin_char(p),subtype(p));
font(margin_char(p)):= f;
do_subst_font(margin_char(p),-1000);
if f<> font(margin_char(p))then
font_shrink:= font_shrink-width(p)-
char_pw(margin_char(p),subtype(p));
font(margin_char(p)):= f;
end
else if m= subst_ex_font then begin
do_subst_font(margin_char(p),font_expand_ratio);
width(p):= -char_pw(margin_char(p),subtype(p));
end;
x:= x+width(p);
end;
kern_node:begin
if subtype(p)= normal then begin
if m= cal_expand_ratio then begin
font_stretch:= font_stretch+kern_stretch(p);
font_shrink:= font_shrink+kern_shrink(p);
end
else if m= subst_ex_font then begin
if font_expand_ratio> 0 then
k:= kern_stretch(p)
else if font_expand_ratio<0 then
k:= kern_shrink(p)
else
pdfassert(0);
if k<> 0 then begin
if is_char_node(link(p))then
width(p):= get_kern(font(prev_char_p),
character(prev_char_p),
character(link(p)))
else if type(link(p))= ligature_node then
width(p):= get_kern(font(prev_char_p),
character(prev_char_p),
character(lig_char(link(p))));
end;
end;
end;
x:= x+width(p);
end;
math_node:begin x:= x+width(p);
if TeXXeT_en then/*1708:*/
#line 37586 "pdftexdir/pdftex.web"

if end_LR(p)then
if info(LR_ptr)= end_LR_type(p)then pop_LR
else begin incr(LR_problems);type(p):= kern_node;subtype(p):= explicit;
end
else push_LR(p)

/*:1708*/
#line 20833 "pdftexdir/pdftex.web"
;
end;
ligature_node:begin
if m= subst_ex_font then
do_subst_font(p,font_expand_ratio);
/*824:*/
#line 20850 "pdftexdir/pdftex.web"

begin mem[lig_trick]:= mem[lig_char(p)];link(lig_trick):= link(p);
p:= lig_trick;goto reswitch;
end

/*:824*/
#line 20838 "pdftexdir/pdftex.web"
;
end;
disc_node:
if m= subst_ex_font then
do_subst_font(p,font_expand_ratio);
othercases do_nothing
endcases;
p:= link(p);
end;
end


/*:823*/
#line 20746 "pdftexdir/pdftex.web"
;
if adjust_tail<> null then link(adjust_tail):= null;
if pre_adjust_tail<> null then link(pre_adjust_tail):= null;
height(r):= h;depth(r):= d;
/*831:*/
#line 20944 "pdftexdir/pdftex.web"

if m= additional then w:= x+w;
width(r):= w;x:= w-x;{now|x|is the excess to be made up}
if x= 0 then
begin glue_sign(r):= normal;glue_order(r):= normal;
set_glue_ratio_zero(glue_set(r));
return;
end
else if x> 0 then/*832:*/
#line 20960 "pdftexdir/pdftex.web"

begin/*833:*/
#line 20978 "pdftexdir/pdftex.web"

if total_stretch[filll]<> 0 then o:= filll
else if total_stretch[fill]<> 0 then o:= fill
else if total_stretch[fil]<> 0 then o:= fil
else o:= normal

/*:833*/
#line 20961 "pdftexdir/pdftex.web"
;
if(m= cal_expand_ratio)and(o= normal)and(font_stretch> 0)then begin
font_expand_ratio:= divide_scaled(x,font_stretch,3);
return;
end;
glue_order(r):= o;glue_sign(r):= stretching;
if total_stretch[o]<> 0 then glue_set(r):= unfloat(x/total_stretch[o])

else begin glue_sign(r):= normal;
set_glue_ratio_zero(glue_set(r));{there's nothing to stretch}
end;
if o= normal then if list_ptr(r)<> null then
/*834:*/
#line 20984 "pdftexdir/pdftex.web"

begin last_badness:= badness(x,total_stretch[normal]);
if last_badness> hbadness then
begin print_ln;
if last_badness> 100 then print_nl("Underfull")else print_nl("Loose");
print(" \hbox (badness ");print_int(last_badness);


goto common_ending;
end;
end

/*:834*/
#line 20974 "pdftexdir/pdftex.web"
;
return;
end

/*:832*/
#line 20953 "pdftexdir/pdftex.web"

else/*838:*/
#line 21023 "pdftexdir/pdftex.web"

begin/*839:*/
#line 21047 "pdftexdir/pdftex.web"

if total_shrink[filll]<> 0 then o:= filll
else if total_shrink[fill]<> 0 then o:= fill
else if total_shrink[fil]<> 0 then o:= fil
else o:= normal

/*:839*/
#line 21024 "pdftexdir/pdftex.web"
;
if(m= cal_expand_ratio)and(o= normal)and(font_shrink> 0)then begin
font_expand_ratio:= divide_scaled(x,font_shrink,3);
return;
end;
glue_order(r):= o;glue_sign(r):= shrinking;
if total_shrink[o]<> 0 then glue_set(r):= unfloat((-x)/total_shrink[o])

else begin glue_sign(r):= normal;
set_glue_ratio_zero(glue_set(r));{there's nothing to shrink}
end;
if(total_shrink[o]<-x)and(o= normal)and(list_ptr(r)<> null)then
begin last_badness:= 1000000;
set_glue_ratio_one(glue_set(r));{use the maximum shrinkage}
/*840:*/
#line 21053 "pdftexdir/pdftex.web"

if(-x-total_shrink[normal]> hfuzz)or(hbadness<100)then
begin if(overfull_rule> 0)and(-x-total_shrink[normal]> hfuzz)then
begin while link(q)<> null do q:= link(q);
link(q):= new_rule;
width(link(q)):= overfull_rule;
end;
print_ln;print_nl("Overfull \hbox (");

print_scaled(-x-total_shrink[normal]);print("pt too wide");
goto common_ending;
end

/*:840*/
#line 21039 "pdftexdir/pdftex.web"
;
end
else if o= normal then if list_ptr(r)<> null then
/*841:*/
#line 21066 "pdftexdir/pdftex.web"

begin last_badness:= badness(-x,total_shrink[normal]);
if last_badness> hbadness then
begin print_ln;print_nl("Tight \hbox (badness ");print_int(last_badness);

goto common_ending;
end;
end

/*:841*/
#line 21043 "pdftexdir/pdftex.web"
;
return;
end

/*:838*/
#line 20955 "pdftexdir/pdftex.web"


/*:831*/
#line 20751 "pdftexdir/pdftex.web"
;
common_ending:/*837:*/
#line 21008 "pdftexdir/pdftex.web"

if output_active then print(") has occurred while \output is active")
else begin if pack_begin_line<> 0 then
begin if pack_begin_line> 0 then print(") in paragraph at lines ")
else print(") in alignment at lines ");
print_int(abs(pack_begin_line));
print("--");
end
else print(") detected at line ");
print_int(line);
end;
print_ln;
font_in_short_display:= null_font;short_display(list_ptr(r));print_ln;
begin_diagnostic;show_box(r);end_diagnostic(true)

/*:837*/
#line 20753 "pdftexdir/pdftex.web"
;
exit:if TeXXeT_en then/*1709:*/
#line 37593 "pdftexdir/pdftex.web"

begin if info(LR_ptr)<> before then
begin while link(q)<> null do q:= link(q);
repeat temp_ptr:= q;q:= new_math(0,info(LR_ptr));link(temp_ptr):= q;
LR_problems:= LR_problems+10000;pop_LR;
until info(LR_ptr)= before;
end;
if LR_problems> 0 then
begin/*1710:*/
#line 37608 "pdftexdir/pdftex.web"

begin print_ln;print_nl("\endL or \endR problem (");
print_int(LR_problems div 10000);print(" missing, ");
print_int(LR_problems mod 10000);print(" extra");
LR_problems:= 0;
end

/*:1710*/
#line 37601 "pdftexdir/pdftex.web"
;goto common_ending;
end;
pop_LR;
if LR_ptr<> null then confusion("LR1");

end

/*:1709*/
#line 20754 "pdftexdir/pdftex.web"
;
if(m= cal_expand_ratio)and(font_expand_ratio<> 0)then begin
font_expand_ratio:= fix_int(font_expand_ratio,-1000,1000);
q:= list_ptr(r);
free_node(r,box_node_size);
r:= hpack(q,w,subst_ex_font);
end;
hpack:= r;
end;

/*:821*//*842:*/
#line 21084 "pdftexdir/pdftex.web"
function vpackage(p:pointer;h:scaled;m:small_number;l:scaled):
pointer;
label common_ending,exit;
var r:pointer;{the box node that will be returned}
w,d,x:scaled;{width,depth,and natural height}
s:scaled;{shift amount}
g:pointer;{points to a glue specification}
o:glue_ord;{order of infinity}
begin last_badness:= 0;r:= get_node(box_node_size);type(r):= vlist_node;
subtype(r):= min_quarterword;shift_amount(r):= 0;
list_ptr(r):= p;
w:= 0;/*822:*/
#line 20764 "pdftexdir/pdftex.web"

d:= 0;x:= 0;
total_stretch[normal]:= 0;total_shrink[normal]:= 0;
total_stretch[fil]:= 0;total_shrink[fil]:= 0;
total_stretch[fill]:= 0;total_shrink[fill]:= 0;
total_stretch[filll]:= 0;total_shrink[filll]:= 0

/*:822*/
#line 21095 "pdftexdir/pdftex.web"
;
while p<> null do/*843:*/
#line 21110 "pdftexdir/pdftex.web"

begin if is_char_node(p)then confusion("vpack")

else case type(p)of
hlist_node,vlist_node,rule_node,unset_node:
/*844:*/
#line 21126 "pdftexdir/pdftex.web"

begin x:= x+d+height(p);d:= depth(p);
if type(p)>=rule_node then s:= 0 else s:= shift_amount(p);
if width(p)+s> w then w:= width(p)+s;
end

/*:844*/
#line 21116 "pdftexdir/pdftex.web"
;
whatsit_node:/*1603:*/
#line 35653 "pdftexdir/pdftex.web"

if(subtype(p)= pdf_refxform_node)or(subtype(p)= pdf_refximage_node)then
begin x:= x+d+pdf_height(p);d:= pdf_depth(p);
s:= 0;
if pdf_width(p)+s> w then w:= pdf_width(p)+s;
end

/*:1603*/
#line 21117 "pdftexdir/pdftex.web"
;
glue_node:/*845:*/
#line 21132 "pdftexdir/pdftex.web"

begin x:= x+d;d:= 0;
g:= glue_ptr(p);x:= x+width(g);
o:= stretch_order(g);total_stretch[o]:= total_stretch[o]+stretch(g);
o:= shrink_order(g);total_shrink[o]:= total_shrink[o]+shrink(g);
if subtype(p)>=a_leaders then
begin g:= leader_ptr(p);
if width(g)> w then w:= width(g);
end;
end

/*:845*/
#line 21118 "pdftexdir/pdftex.web"
;
kern_node:begin x:= x+d+width(p);d:= 0;
end;
othercases do_nothing
endcases;
p:= link(p);
end

/*:843*/
#line 21097 "pdftexdir/pdftex.web"
;
width(r):= w;
if d> l then
begin x:= x+d-l;depth(r):= l;
end
else depth(r):= d;
/*846:*/
#line 21146 "pdftexdir/pdftex.web"

if m= additional then h:= x+h;
height(r):= h;x:= h-x;{now|x|is the excess to be made up}
if x= 0 then
begin glue_sign(r):= normal;glue_order(r):= normal;
set_glue_ratio_zero(glue_set(r));
return;
end
else if x> 0 then/*847:*/
#line 21159 "pdftexdir/pdftex.web"

begin/*833:*/
#line 20978 "pdftexdir/pdftex.web"

if total_stretch[filll]<> 0 then o:= filll
else if total_stretch[fill]<> 0 then o:= fill
else if total_stretch[fil]<> 0 then o:= fil
else o:= normal

/*:833*/
#line 21160 "pdftexdir/pdftex.web"
;
glue_order(r):= o;glue_sign(r):= stretching;
if total_stretch[o]<> 0 then glue_set(r):= unfloat(x/total_stretch[o])

else begin glue_sign(r):= normal;
set_glue_ratio_zero(glue_set(r));{there's nothing to stretch}
end;
if o= normal then if list_ptr(r)<> null then
/*848:*/
#line 21173 "pdftexdir/pdftex.web"

begin last_badness:= badness(x,total_stretch[normal]);
if last_badness> vbadness then
begin print_ln;
if last_badness> 100 then print_nl("Underfull")else print_nl("Loose");
print(" \vbox (badness ");print_int(last_badness);


goto common_ending;
end;
end

/*:848*/
#line 21169 "pdftexdir/pdftex.web"
;
return;
end

/*:847*/
#line 21155 "pdftexdir/pdftex.web"

else/*850:*/
#line 21198 "pdftexdir/pdftex.web"

begin/*839:*/
#line 21047 "pdftexdir/pdftex.web"

if total_shrink[filll]<> 0 then o:= filll
else if total_shrink[fill]<> 0 then o:= fill
else if total_shrink[fil]<> 0 then o:= fil
else o:= normal

/*:839*/
#line 21199 "pdftexdir/pdftex.web"
;
glue_order(r):= o;glue_sign(r):= shrinking;
if total_shrink[o]<> 0 then glue_set(r):= unfloat((-x)/total_shrink[o])

else begin glue_sign(r):= normal;
set_glue_ratio_zero(glue_set(r));{there's nothing to shrink}
end;
if(total_shrink[o]<-x)and(o= normal)and(list_ptr(r)<> null)then
begin last_badness:= 1000000;
set_glue_ratio_one(glue_set(r));{use the maximum shrinkage}
/*851:*/
#line 21218 "pdftexdir/pdftex.web"

if(-x-total_shrink[normal]> vfuzz)or(vbadness<100)then
begin print_ln;print_nl("Overfull \vbox (");

print_scaled(-x-total_shrink[normal]);print("pt too high");
goto common_ending;
end

/*:851*/
#line 21210 "pdftexdir/pdftex.web"
;
end
else if o= normal then if list_ptr(r)<> null then
/*852:*/
#line 21226 "pdftexdir/pdftex.web"

begin last_badness:= badness(-x,total_shrink[normal]);
if last_badness> vbadness then
begin print_ln;print_nl("Tight \vbox (badness ");print_int(last_badness);

goto common_ending;
end;
end

/*:852*/
#line 21214 "pdftexdir/pdftex.web"
;
return;
end

/*:850*/
#line 21157 "pdftexdir/pdftex.web"


/*:846*/
#line 21104 "pdftexdir/pdftex.web"
;
common_ending:/*849:*/
#line 21185 "pdftexdir/pdftex.web"

if output_active then print(") has occurred while \output is active")
else begin if pack_begin_line<> 0 then{it's actually negative}
begin print(") in alignment at lines ");
print_int(abs(pack_begin_line));
print("--");
end
else print(") detected at line ");
print_int(line);
print_ln;
end;
begin_diagnostic;show_box(r);end_diagnostic(true)

/*:849*/
#line 21106 "pdftexdir/pdftex.web"
;
exit:vpackage:= r;
end;

/*:842*//*853:*/
#line 21238 "pdftexdir/pdftex.web"
procedure append_to_vlist(b:pointer);
var d:scaled;{deficiency of space between baselines}
p:pointer;{a new glue node}
begin if prev_depth> pdf_ignored_dimen then
begin d:= width(baseline_skip)-prev_depth-height(b);
if d<line_skip_limit then p:= new_param_glue(line_skip_code)
else begin p:= new_skip_param(baseline_skip_code);
width(temp_ptr):= d;{|temp_ptr= glue_ptr(p)|}
end;
link(tail):= p;tail:= p;
end;
link(tail):= b;tail:= b;prev_depth:= depth(b);
end;

/*:853*//*860:*/
#line 21436 "pdftexdir/pdftex.web"
function new_noad:pointer;
var p:pointer;
begin p:= get_node(noad_size);
type(p):= ord_noad;subtype(p):= normal;
mem[nucleus(p)].hh:= empty_field;
mem[subscr(p)].hh:= empty_field;
mem[supscr(p)].hh:= empty_field;
new_noad:= p;
end;

/*:860*//*862:*/
#line 21499 "pdftexdir/pdftex.web"
function new_style(s:small_number):pointer;{create a style node}
var p:pointer;{the new node}
begin p:= get_node(style_node_size);type(p):= style_node;
subtype(p):= s;width(p):= 0;depth(p):= 0;{the|width|and|depth|are not used}
new_style:= p;
end;

/*:862*//*863:*/
#line 21516 "pdftexdir/pdftex.web"
function new_choice:pointer;{create a choice node}
var p:pointer;{the new node}
begin p:= get_node(style_node_size);type(p):= choice_node;
subtype(p):= 0;{the|subtype|is not used}
display_mlist(p):= null;text_mlist(p):= null;script_mlist(p):= null;
script_script_mlist(p):= null;
new_choice:= p;
end;

/*:863*//*867:*/
#line 21604 "pdftexdir/pdftex.web"
procedure show_info;{the reader will kindly forgive this}
begin show_node_list(info(temp_ptr));
end;

/*:867*//*878:*/
#line 21803 "pdftexdir/pdftex.web"
function fraction_rule(t:scaled):pointer;
{construct the bar for a fraction}
var p:pointer;{the new node}
begin p:= new_rule;height(p):= t;depth(p):= 0;fraction_rule:= p;
end;

/*:878*//*879:*/
#line 21813 "pdftexdir/pdftex.web"
function overbar(b:pointer;k,t:scaled):pointer;
var p,q:pointer;{nodes being constructed}
begin p:= new_kern(k);link(p):= b;q:= fraction_rule(t);link(q):= p;
p:= new_kern(t);link(p):= q;overbar:= vpack(p,natural);
end;

/*:879*//*880:*/
#line 21834 "pdftexdir/pdftex.web"
/*883:*/
#line 21908 "pdftexdir/pdftex.web"

function char_box(f:internal_font_number;c:quarterword):pointer;
var q:four_quarters;
hd:eight_bits;{|height_depth|byte}
b,p:pointer;{the new box and its character node}
begin q:= char_info(f)(c);hd:= height_depth(q);
b:= new_null_box;width(b):= char_width(f)(q)+char_italic(f)(q);
height(b):= char_height(f)(hd);depth(b):= char_depth(f)(hd);
p:= get_avail;character(p):= c;font(p):= f;list_ptr(b):= p;char_box:= b;
end;

/*:883*//*885:*/
#line 21932 "pdftexdir/pdftex.web"

procedure stack_into_box(b:pointer;f:internal_font_number;
c:quarterword);
var p:pointer;{new node placed into|b|}
begin p:= char_box(f,c);link(p):= list_ptr(b);list_ptr(b):= p;
height(b):= height(p);
end;

/*:885*//*886:*/
#line 21943 "pdftexdir/pdftex.web"

function height_plus_depth(f:internal_font_number;c:quarterword):scaled;
var q:four_quarters;
hd:eight_bits;{|height_depth|byte}
begin q:= char_info(f)(c);hd:= height_depth(q);
height_plus_depth:= char_height(f)(hd)+char_depth(f)(hd);
end;

/*:886*/
#line 21834 "pdftexdir/pdftex.web"

function var_delimiter(d:pointer;s:small_number;v:scaled):pointer;
label found,continue;
var b:pointer;{the box that will be constructed}
f,g:internal_font_number;{best-so-far and tentative font codes}
c,x,y:quarterword;{best-so-far and tentative character codes}
m,n:integer;{the number of extensible pieces}
u:scaled;{height-plus-depth of a tentative character}
w:scaled;{largest height-plus-depth so far}
q:four_quarters;{character info}
hd:eight_bits;{height-depth byte}
r:four_quarters;{extensible pieces}
z:small_number;{runs through font family members}
large_attempt:boolean;{are we trying the``large''variant?}
begin f:= null_font;w:= 0;large_attempt:= false;
z:= small_fam(d);x:= small_char(d);
loop begin/*881:*/
#line 21869 "pdftexdir/pdftex.web"

if(z<> 0)or(x<> min_quarterword)then
begin z:= z+s+16;
repeat z:= z-16;g:= fam_fnt(z);
if g<> null_font then
/*882:*/
#line 21881 "pdftexdir/pdftex.web"

begin y:= x;
#line 3579 "pdftex-final.ch"
if(qo(y)>=font_bc[g])and(qo(y)<=font_ec[g])then
begin continue:q:= orig_char_info(g)(y);
#line 21885 "pdftexdir/pdftex.web"
if char_exists(q)then
begin if char_tag(q)= ext_tag then
begin f:= g;c:= y;goto found;
end;
hd:= height_depth(q);
u:= char_height(g)(hd)+char_depth(g)(hd);
if u> w then
begin f:= g;c:= y;w:= u;
if u>=v then goto found;
end;
if char_tag(q)= list_tag then
begin y:= rem_byte(q);goto continue;
end;
end;
end;
end

/*:882*/
#line 21877 "pdftexdir/pdftex.web"
;
until z<16;
end

/*:881*/
#line 21852 "pdftexdir/pdftex.web"
;
if large_attempt then goto found;{there were none large enough}
large_attempt:= true;z:= large_fam(d);x:= large_char(d);
end;
found:if f<> null_font then
/*884:*/
#line 21922 "pdftexdir/pdftex.web"

if char_tag(q)= ext_tag then
/*887:*/
#line 21951 "pdftexdir/pdftex.web"

begin b:= new_null_box;
type(b):= vlist_node;
r:= font_info[exten_base[f]+rem_byte(q)].qqqq;
/*888:*/
#line 21976 "pdftexdir/pdftex.web"

c:= ext_rep(r);u:= height_plus_depth(f,c);
w:= 0;q:= char_info(f)(c);width(b):= char_width(f)(q)+char_italic(f)(q);
c:= ext_bot(r);if c<> min_quarterword then w:= w+height_plus_depth(f,c);
c:= ext_mid(r);if c<> min_quarterword then w:= w+height_plus_depth(f,c);
c:= ext_top(r);if c<> min_quarterword then w:= w+height_plus_depth(f,c);
n:= 0;
if u> 0 then while w<v do
begin w:= w+u;incr(n);
if ext_mid(r)<> min_quarterword then w:= w+u;
end

/*:888*/
#line 21956 "pdftexdir/pdftex.web"
;
c:= ext_bot(r);
if c<> min_quarterword then stack_into_box(b,f,c);
c:= ext_rep(r);
for m:= 1 to n do stack_into_box(b,f,c);
c:= ext_mid(r);
if c<> min_quarterword then
begin stack_into_box(b,f,c);c:= ext_rep(r);
for m:= 1 to n do stack_into_box(b,f,c);
end;
c:= ext_top(r);
if c<> min_quarterword then stack_into_box(b,f,c);
depth(b):= w-height(b);
end

/*:887*/
#line 21925 "pdftexdir/pdftex.web"

else b:= char_box(f,c)

/*:884*/
#line 21857 "pdftexdir/pdftex.web"

else begin b:= new_null_box;
width(b):= null_delimiter_space;{use this width if no delimiter was found}
end;
shift_amount(b):= half(height(b)-depth(b))-axis_height(s);
var_delimiter:= b;
end;

/*:880*//*889:*/
#line 22001 "pdftexdir/pdftex.web"
function rebox(b:pointer;w:scaled):pointer;
var p:pointer;{temporary register for list manipulation}
f:internal_font_number;{font in a one-character box}
v:scaled;{width of a character without italic correction}
begin if(width(b)<> w)and(list_ptr(b)<> null)then
begin if type(b)= vlist_node then b:= hpack(b,natural);
p:= list_ptr(b);
if(is_char_node(p))and(link(p)= null)then
begin f:= font(p);v:= char_width(f)(char_info(f)(character(p)));
if v<> width(b)then link(p):= new_kern(width(b)-v);
end;
free_node(b,box_node_size);
b:= new_glue(ss_glue);link(b):= p;
while link(p)<> null do p:= link(p);
link(p):= new_glue(ss_glue);
rebox:= hpack(b,w,exactly);
end
else begin width(b):= w;rebox:= b;
end;
end;

/*:889*//*890:*/
#line 22027 "pdftexdir/pdftex.web"
function math_glue(g:pointer;m:scaled):pointer;
var p:pointer;{the new glue specification}
n:integer;{integer part of|m|}
f:scaled;{fraction part of|m|}
begin n:= x_over_n(m,50
if f<0 then
begin decr(n);f:= f+50
end;
p:= get_node(glue_spec_size);
width(p):= mu_mult(width(g));{convert\.{mu}to\.{pt}}
stretch_order(p):= stretch_order(g);
if stretch_order(p)= normal then stretch(p):= mu_mult(stretch(g))
else stretch(p):= stretch(g);
shrink_order(p):= shrink_order(g);
if shrink_order(p)= normal then shrink(p):= mu_mult(shrink(g))
else shrink(p):= shrink(g);
math_glue:= p;
end;

/*:890*//*891:*/
#line 22049 "pdftexdir/pdftex.web"
procedure math_kern(p:pointer;m:scaled);
var n:integer;{integer part of|m|}
f:scaled;{fraction part of|m|}
begin if subtype(p)= mu_glue then
begin n:= x_over_n(m,50
if f<0 then
begin decr(n);f:= f+50
end;
width(p):= mu_mult(width(p));subtype(p):= explicit;
end;
end;

/*:891*//*892:*/
#line 22064 "pdftexdir/pdftex.web"
procedure flush_math;
begin flush_node_list(link(head));flush_node_list(incompleat_noad);
link(head):= null;tail:= head;incompleat_noad:= null;
end;

/*:892*//*894:*/
#line 22101 "pdftexdir/pdftex.web"
procedure mlist_to_hlist;forward;
function clean_box(p:pointer;s:small_number):pointer;
label found;
var q:pointer;{beginning of a list to be boxed}
save_style:small_number;{|cur_style|to be restored}
x:pointer;{box to be returned}
r:pointer;{temporary pointer}
begin case math_type(p)of
math_char:begin cur_mlist:= new_noad;mem[nucleus(cur_mlist)]:= mem[p];
end;
sub_box:begin q:= info(p);goto found;
end;
sub_mlist:cur_mlist:= info(p);
othercases begin q:= new_null_box;goto found;
end
endcases;
save_style:= cur_style;cur_style:= s;mlist_penalties:= false;
mlist_to_hlist;q:= link(temp_head);{recursive call}
cur_style:= save_style;{restore the style}
/*877:*/
#line 21793 "pdftexdir/pdftex.web"

begin if cur_style<script_style then cur_size:= text_size
else cur_size:= 16*((cur_style-text_style)div 2);
cur_mu:= x_over_n(math_quad(cur_size),18);
end

/*:877*/
#line 22120 "pdftexdir/pdftex.web"
;
found:if is_char_node(q)or(q= null)then x:= hpack(q,natural)
else if(link(q)= null)and(type(q)<=vlist_node)and(shift_amount(q)= 0)then
x:= q{it's already clean}
else x:= hpack(q,natural);
/*895:*/
#line 3586 "pdftex-final.ch"

#line 22132 "pdftexdir/pdftex.web"
q:= list_ptr(x);
if is_char_node(q)then
begin r:= link(q);
if r<> null then if link(r)= null then if not is_char_node(r)then
if type(r)= kern_node then{unneeded italic correction}
#line 3592 "pdftex-final.ch"
begin free_node(r,medium_node_size);link(q):= null;
#line 22138 "pdftexdir/pdftex.web"
end;
end

/*:895*/
#line 22125 "pdftexdir/pdftex.web"
;
clean_box:= x;
end;

/*:894*//*896:*/
#line 22148 "pdftexdir/pdftex.web"
procedure fetch(a:pointer);{unpack the|math_char|field|a|}
begin cur_c:= character(a);cur_f:= fam_fnt(fam(a)+cur_size);
if cur_f= null_font then
/*897:*/
#line 22162 "pdftexdir/pdftex.web"

begin print_err("");print_size(cur_size);print_char(" ");
print_int(fam(a));print(" is undefined (character ");
print_ASCII(qo(cur_c));print_char(")");
help4("Somewhere in the math formula just ended, you used the")
("stated character from an undefined font family. For example,")
("plain TeX doesn't allow \it or \sl in subscripts. Proceed,")
("and I'll try to forget that I needed that character.");
error;cur_i:= null_character;math_type(a):= empty;
end

/*:897*/
#line 22151 "pdftexdir/pdftex.web"

else begin if(qo(cur_c)>=font_bc[cur_f])and(qo(cur_c)<=font_ec[cur_f])then
#line 3598 "pdftex-final.ch"
 cur_i:= orig_char_info(cur_f)(cur_c)
#line 22154 "pdftexdir/pdftex.web"
else cur_i:= null_character;
if not(char_exists(cur_i))then
begin char_warning(cur_f,qo(cur_c));
math_type(a):= empty;
end;
end;
end;

/*:896*//*900:*/
#line 22207 "pdftexdir/pdftex.web"
/*908:*/
#line 22365 "pdftexdir/pdftex.web"

procedure make_over(q:pointer);
begin info(nucleus(q)):= 
overbar(clean_box(nucleus(q),cramped_style(cur_style)),
3*default_rule_thickness,default_rule_thickness);
math_type(nucleus(q)):= sub_box;
end;

/*:908*//*909:*/
#line 22373 "pdftexdir/pdftex.web"

procedure make_under(q:pointer);
var p,x,y:pointer;{temporary registers for box construction}
delta:scaled;{overall height plus depth}
begin x:= clean_box(nucleus(q),cur_style);
p:= new_kern(3*default_rule_thickness);link(x):= p;
link(p):= fraction_rule(default_rule_thickness);
y:= vpack(x,natural);
delta:= height(y)+depth(y)+default_rule_thickness;
height(y):= height(x);depth(y):= delta-height(y);
info(nucleus(q)):= y;math_type(nucleus(q)):= sub_box;
end;

/*:909*//*910:*/
#line 22386 "pdftexdir/pdftex.web"

procedure make_vcenter(q:pointer);
var v:pointer;{the box that should be centered vertically}
delta:scaled;{its height plus depth}
begin v:= info(nucleus(q));
if type(v)<> vlist_node then confusion("vcenter");

delta:= height(v)+depth(v);
height(v):= axis_height(cur_size)+half(delta);
depth(v):= delta-height(v);
end;

/*:910*//*911:*/
#line 22407 "pdftexdir/pdftex.web"

procedure make_radical(q:pointer);
var x,y:pointer;{temporary registers for box construction}
delta,clr:scaled;{dimensions involved in the calculation}
begin x:= clean_box(nucleus(q),cramped_style(cur_style));
if cur_style<text_style then{display style}
clr:= default_rule_thickness+(abs(math_x_height(cur_size))div 4)
else begin clr:= default_rule_thickness;clr:= clr+(abs(clr)div 4);
end;
y:= var_delimiter(left_delimiter(q),cur_size,height(x)+depth(x)+clr+
default_rule_thickness);
delta:= depth(y)-(height(x)+depth(x)+clr);
if delta> 0 then clr:= clr+half(delta);{increase the actual clearance}
shift_amount(y):= -(height(x)+clr);
link(y):= overbar(x,clr,height(y));
info(nucleus(q)):= hpack(y,natural);math_type(nucleus(q)):= sub_box;
end;

/*:911*//*912:*/
#line 22429 "pdftexdir/pdftex.web"

procedure make_math_accent(q:pointer);
label done,done1;
var p,x,y:pointer;{temporary registers for box construction}
a:integer;{address of lig/kern instruction}
c:quarterword;{accent character}
f:internal_font_number;{its font}
i:four_quarters;{its|char_info|}
s:scaled;{amount to skew the accent to the right}
h:scaled;{height of character being accented}
delta:scaled;{space to remove between accent and accentee}
w:scaled;{width of the accentee,not including sub/superscripts}
begin fetch(accent_chr(q));
if char_exists(cur_i)then
begin i:= cur_i;c:= cur_c;f:= cur_f;
/*915:*/
#line 22476 "pdftexdir/pdftex.web"

s:= 0;
if math_type(nucleus(q))= math_char then
begin fetch(nucleus(q));
if char_tag(cur_i)= lig_tag then
begin a:= lig_kern_start(cur_f)(cur_i);
cur_i:= font_info[a].qqqq;
if skip_byte(cur_i)> stop_flag then
begin a:= lig_kern_restart(cur_f)(cur_i);
cur_i:= font_info[a].qqqq;
end;
loop begin if qo(next_char(cur_i))= skew_char[cur_f]then
begin if op_byte(cur_i)>=kern_flag then
if skip_byte(cur_i)<=stop_flag then s:= char_kern(cur_f)(cur_i);
goto done1;
end;
if skip_byte(cur_i)>=stop_flag then goto done1;
a:= a+qo(skip_byte(cur_i))+1;
cur_i:= font_info[a].qqqq;
end;
end;
end;
done1:

/*:915*/
#line 22444 "pdftexdir/pdftex.web"
;
x:= clean_box(nucleus(q),cramped_style(cur_style));w:= width(x);h:= height(x);
/*914:*/
#line 22466 "pdftexdir/pdftex.web"

loop begin if char_tag(i)<> list_tag then goto done;
y:= rem_byte(i);
#line 3604 "pdftex-final.ch"
i:= orig_char_info(f)(y);
#line 22470 "pdftexdir/pdftex.web"
if not char_exists(i)then goto done;
if char_width(f)(i)> w then goto done;
c:= y;
end;
done:

/*:914*/
#line 22446 "pdftexdir/pdftex.web"
;
if h<x_height(f)then delta:= h else delta:= x_height(f);
if(math_type(supscr(q))<> empty)or(math_type(subscr(q))<> empty)then
if math_type(nucleus(q))= math_char then
/*916:*/
#line 22500 "pdftexdir/pdftex.web"

begin flush_node_list(x);x:= new_noad;
mem[nucleus(x)]:= mem[nucleus(q)];
mem[supscr(x)]:= mem[supscr(q)];
mem[subscr(x)]:= mem[subscr(q)];
mem[supscr(q)].hh:= empty_field;
mem[subscr(q)].hh:= empty_field;
math_type(nucleus(q)):= sub_mlist;info(nucleus(q)):= x;
x:= clean_box(nucleus(q),cur_style);delta:= delta+height(x)-h;h:= height(x);
end

/*:916*/
#line 22450 "pdftexdir/pdftex.web"
;
y:= char_box(f,c);
shift_amount(y):= s+half(w-width(y));
width(y):= 0;p:= new_kern(-delta);link(p):= x;link(y):= p;
y:= vpack(y,natural);width(y):= width(x);
if height(y)<h then/*913:*/
#line 22461 "pdftexdir/pdftex.web"

begin p:= new_kern(h-height(y));link(p):= list_ptr(y);list_ptr(y):= p;
height(y):= h;
end

/*:913*/
#line 22455 "pdftexdir/pdftex.web"
;
info(nucleus(q)):= y;
math_type(nucleus(q)):= sub_box;
end;
end;

/*:912*//*917:*/
#line 22514 "pdftexdir/pdftex.web"

procedure make_fraction(q:pointer);
var p,v,x,y,z:pointer;{temporary registers for box construction}
delta,delta1,delta2,shift_up,shift_down,clr:scaled;
{dimensions for box calculations}
begin if thickness(q)= default_code then thickness(q):= default_rule_thickness;
/*918:*/
#line 22532 "pdftexdir/pdftex.web"

x:= clean_box(numerator(q),num_style(cur_style));
z:= clean_box(denominator(q),denom_style(cur_style));
if width(x)<width(z)then x:= rebox(x,width(z))
else z:= rebox(z,width(x));
if cur_style<text_style then{display style}
begin shift_up:= num1(cur_size);shift_down:= denom1(cur_size);
end
else begin shift_down:= denom2(cur_size);
if thickness(q)<> 0 then shift_up:= num2(cur_size)
else shift_up:= num3(cur_size);
end

/*:918*/
#line 22522 "pdftexdir/pdftex.web"
;
if thickness(q)= 0 then/*919:*/
#line 22549 "pdftexdir/pdftex.web"

begin if cur_style<text_style then clr:= 7*default_rule_thickness
else clr:= 3*default_rule_thickness;
delta:= half(clr-((shift_up-depth(x))-(height(z)-shift_down)));
if delta> 0 then
begin shift_up:= shift_up+delta;
shift_down:= shift_down+delta;
end;
end

/*:919*/
#line 22524 "pdftexdir/pdftex.web"

else/*920:*/
#line 22562 "pdftexdir/pdftex.web"

begin if cur_style<text_style then clr:= 3*thickness(q)
else clr:= thickness(q);
delta:= half(thickness(q));
delta1:= clr-((shift_up-depth(x))-(axis_height(cur_size)+delta));
delta2:= clr-((axis_height(cur_size)-delta)-(height(z)-shift_down));
if delta1> 0 then shift_up:= shift_up+delta1;
if delta2> 0 then shift_down:= shift_down+delta2;
end

/*:920*/
#line 22525 "pdftexdir/pdftex.web"
;
/*921:*/
#line 22572 "pdftexdir/pdftex.web"

v:= new_null_box;type(v):= vlist_node;
height(v):= shift_up+height(x);depth(v):= depth(z)+shift_down;
width(v):= width(x);{this also equals|width(z)|}
if thickness(q)= 0 then
begin p:= new_kern((shift_up-depth(x))-(height(z)-shift_down));
link(p):= z;
end
else begin y:= fraction_rule(thickness(q));
p:= new_kern((axis_height(cur_size)-delta)-(height(z)-shift_down));
link(y):= p;link(p):= z;
p:= new_kern((shift_up-depth(x))-(axis_height(cur_size)+delta));
link(p):= y;
end;
link(x):= p;list_ptr(v):= x

/*:921*/
#line 22527 "pdftexdir/pdftex.web"
;
/*922:*/
#line 22588 "pdftexdir/pdftex.web"

if cur_style<text_style then delta:= delim1(cur_size)
else delta:= delim2(cur_size);
x:= var_delimiter(left_delimiter(q),cur_size,delta);link(x):= v;
z:= var_delimiter(right_delimiter(q),cur_size,delta);link(v):= z;
new_hlist(q):= hpack(x,natural)

/*:922*/
#line 22529 "pdftexdir/pdftex.web"
;
end;

/*:917*//*923:*/
#line 22610 "pdftexdir/pdftex.web"

function make_op(q:pointer):scaled;
var delta:scaled;{offset between subscript and superscript}
p,v,x,y,z:pointer;{temporary registers for box construction}
c:quarterword;i:four_quarters;{registers for character examination}
shift_up,shift_down:scaled;{dimensions for box calculation}
begin if(subtype(q)= normal)and(cur_style<text_style)then
subtype(q):= limits;
if math_type(nucleus(q))= math_char then
begin fetch(nucleus(q));
if(cur_style<text_style)and(char_tag(cur_i)= list_tag)then{make it larger}
#line 3610 "pdftex-final.ch"
begin c:= rem_byte(cur_i);i:= orig_char_info(cur_f)(c);
#line 22622 "pdftexdir/pdftex.web"
if char_exists(i)then
begin cur_c:= c;cur_i:= i;character(nucleus(q)):= c;
end;
end;
delta:= char_italic(cur_f)(cur_i);x:= clean_box(nucleus(q),cur_style);
if(math_type(subscr(q))<> empty)and(subtype(q)<> limits)then
width(x):= width(x)-delta;{remove italic correction}
shift_amount(x):= half(height(x)-depth(x))-axis_height(cur_size);
{center vertically}
math_type(nucleus(q)):= sub_box;info(nucleus(q)):= x;
end
else delta:= 0;
if subtype(q)= limits then
/*924:*/
#line 22642 "pdftexdir/pdftex.web"

begin x:= clean_box(supscr(q),sup_style(cur_style));
y:= clean_box(nucleus(q),cur_style);
z:= clean_box(subscr(q),sub_style(cur_style));
v:= new_null_box;type(v):= vlist_node;width(v):= width(y);
if width(x)> width(v)then width(v):= width(x);
if width(z)> width(v)then width(v):= width(z);
x:= rebox(x,width(v));y:= rebox(y,width(v));z:= rebox(z,width(v));
shift_amount(x):= half(delta);shift_amount(z):= -shift_amount(x);
height(v):= height(y);depth(v):= depth(y);
/*925:*/
#line 22662 "pdftexdir/pdftex.web"

if math_type(supscr(q))= empty then
begin free_node(x,box_node_size);list_ptr(v):= y;
end
else begin shift_up:= big_op_spacing3-depth(x);
if shift_up<big_op_spacing1 then shift_up:= big_op_spacing1;
p:= new_kern(shift_up);link(p):= y;link(x):= p;
p:= new_kern(big_op_spacing5);link(p):= x;list_ptr(v):= p;
height(v):= height(v)+big_op_spacing5+height(x)+depth(x)+shift_up;
end;
if math_type(subscr(q))= empty then free_node(z,box_node_size)
else begin shift_down:= big_op_spacing4-height(z);
if shift_down<big_op_spacing2 then shift_down:= big_op_spacing2;
p:= new_kern(shift_down);link(y):= p;link(p):= z;
p:= new_kern(big_op_spacing5);link(z):= p;
depth(v):= depth(v)+big_op_spacing5+height(z)+depth(z)+shift_down;
end

/*:925*/
#line 22653 "pdftexdir/pdftex.web"
;
new_hlist(q):= v;
end

/*:924*/
#line 22635 "pdftexdir/pdftex.web"
;
make_op:= delta;
end;

/*:923*//*926:*/
#line 22690 "pdftexdir/pdftex.web"

procedure make_ord(q:pointer);
label restart,exit;
var a:integer;{address of lig/kern instruction}
p,r:pointer;{temporary registers for list manipulation}
begin restart:
if math_type(subscr(q))= empty then if math_type(supscr(q))= empty then
if math_type(nucleus(q))= math_char then
begin p:= link(q);
if p<> null then if(type(p)>=ord_noad)and(type(p)<=punct_noad)then
if math_type(nucleus(p))= math_char then
if fam(nucleus(p))= fam(nucleus(q))then
begin math_type(nucleus(q)):= math_text_char;
fetch(nucleus(q));
if char_tag(cur_i)= lig_tag then
begin a:= lig_kern_start(cur_f)(cur_i);
cur_c:= character(nucleus(p));
cur_i:= font_info[a].qqqq;
if skip_byte(cur_i)> stop_flag then
begin a:= lig_kern_restart(cur_f)(cur_i);
cur_i:= font_info[a].qqqq;
end;
loop begin/*927:*/
#line 22733 "pdftexdir/pdftex.web"

if next_char(cur_i)= cur_c then if skip_byte(cur_i)<=stop_flag then
if op_byte(cur_i)>=kern_flag then
begin p:= new_kern(char_kern(cur_f)(cur_i));
link(p):= link(q);link(q):= p;return;
end
else begin check_interrupt;{allow a way out of infinite ligature loop}
case op_byte(cur_i)of
qi(1),qi(5):character(nucleus(q)):= rem_byte(cur_i);{\.{= :\?},\.{= :\?> }}
qi(2),qi(6):character(nucleus(p)):= rem_byte(cur_i);{\.{\?= :},\.{\?= :> }}
qi(3),qi(7),qi(11):begin r:= new_noad;{\.{\?= :\?},\.{\?= :\?> },\.{\?= :\?>>}}
character(nucleus(r)):= rem_byte(cur_i);
fam(nucleus(r)):= fam(nucleus(q));
link(q):= r;link(r):= p;
if op_byte(cur_i)<qi(11)then math_type(nucleus(r)):= math_char
else math_type(nucleus(r)):= math_text_char;{prevent combination}
end;
othercases begin link(q):= link(p);
character(nucleus(q)):= rem_byte(cur_i);{\.{= :}}
mem[subscr(q)]:= mem[subscr(p)];mem[supscr(q)]:= mem[supscr(p)];
free_node(p,noad_size);
end
endcases;
if op_byte(cur_i)> qi(3)then return;
math_type(nucleus(q)):= math_char;goto restart;
end

/*:927*/
#line 22715 "pdftexdir/pdftex.web"
;
if skip_byte(cur_i)>=stop_flag then return;
a:= a+qo(skip_byte(cur_i))+1;
cur_i:= font_info[a].qqqq;
end;
end;
end;
end;
exit:end;

/*:926*//*930:*/
#line 22815 "pdftexdir/pdftex.web"

procedure make_scripts(q:pointer;delta:scaled);
var p,x,y,z:pointer;{temporary registers for box construction}
shift_up,shift_down,clr:scaled;{dimensions in the calculation}
t:small_number;{subsidiary size code}
begin p:= new_hlist(q);
if is_char_node(p)then
begin shift_up:= 0;shift_down:= 0;
end
else begin z:= hpack(p,natural);
if cur_style<script_style then t:= script_size else t:= script_script_size;
shift_up:= height(z)-sup_drop(t);
shift_down:= depth(z)+sub_drop(t);
free_node(z,box_node_size);
end;
if math_type(supscr(q))= empty then
/*931:*/
#line 22847 "pdftexdir/pdftex.web"

begin x:= clean_box(subscr(q),sub_style(cur_style));
width(x):= width(x)+script_space;
if shift_down<sub1(cur_size)then shift_down:= sub1(cur_size);
clr:= height(x)-(abs(math_x_height(cur_size)*4)div 5);
if shift_down<clr then shift_down:= clr;
shift_amount(x):= shift_down;
end

/*:931*/
#line 22831 "pdftexdir/pdftex.web"

else begin/*932:*/
#line 22859 "pdftexdir/pdftex.web"

begin x:= clean_box(supscr(q),sup_style(cur_style));
width(x):= width(x)+script_space;
if odd(cur_style)then clr:= sup3(cur_size)
else if cur_style<text_style then clr:= sup1(cur_size)
else clr:= sup2(cur_size);
if shift_up<clr then shift_up:= clr;
clr:= depth(x)+(abs(math_x_height(cur_size))div 4);
if shift_up<clr then shift_up:= clr;
end

/*:932*/
#line 22832 "pdftexdir/pdftex.web"
;
if math_type(subscr(q))= empty then shift_amount(x):= -shift_up
else/*933:*/
#line 22876 "pdftexdir/pdftex.web"

begin y:= clean_box(subscr(q),sub_style(cur_style));
width(y):= width(y)+script_space;
if shift_down<sub2(cur_size)then shift_down:= sub2(cur_size);
clr:= 4*default_rule_thickness-
((shift_up-depth(x))-(height(y)-shift_down));
if clr> 0 then
begin shift_down:= shift_down+clr;
clr:= (abs(math_x_height(cur_size)*4)div 5)-(shift_up-depth(x));
if clr> 0 then
begin shift_up:= shift_up+clr;
shift_down:= shift_down-clr;
end;
end;
shift_amount(x):= delta;{superscript is|delta|to the right of the subscript}
p:= new_kern((shift_up-depth(x))-(height(y)-shift_down));link(x):= p;link(p):= y;
x:= vpack(x,natural);shift_amount(x):= shift_down;
end

/*:933*/
#line 22835 "pdftexdir/pdftex.web"
;
end;
if new_hlist(q)= null then new_hlist(q):= x
else begin p:= new_hlist(q);
while link(p)<> null do p:= link(p);
link(p):= x;
end;
end;

/*:930*//*936:*/
#line 22950 "pdftexdir/pdftex.web"

function make_left_right(q:pointer;style:small_number;
max_d,max_h:scaled):small_number;
var delta,delta1,delta2:scaled;{dimensions used in the calculation}
begin cur_style:= style;/*877:*/
#line 21793 "pdftexdir/pdftex.web"

begin if cur_style<script_style then cur_size:= text_size
else cur_size:= 16*((cur_style-text_style)div 2);
cur_mu:= x_over_n(math_quad(cur_size),18);
end

/*:877*/
#line 22954 "pdftexdir/pdftex.web"
;
delta2:= max_d+axis_height(cur_size);
delta1:= max_h+max_d-delta2;
if delta2> delta1 then delta1:= delta2;{|delta1|is max distance from axis}
delta:= (delta1 div 500)*delimiter_factor;
delta2:= delta1+delta1-delimiter_shortfall;
if delta<delta2 then delta:= delta2;
new_hlist(q):= var_delimiter(delimiter(q),cur_size,delta);
make_left_right:= type(q)-(left_noad-open_noad);{|open_noad|or|close_noad|}
end;

/*:936*/
#line 22207 "pdftexdir/pdftex.web"

procedure mlist_to_hlist;
label reswitch,check_dimensions,done_with_noad,done_with_node,delete_q,
done;
var mlist:pointer;{beginning of the given list}
penalties:boolean;{should penalty nodes be inserted?}
style:small_number;{the given style}
save_style:small_number;{holds|cur_style|during recursion}
q:pointer;{runs through the mlist}
r:pointer;{the most recent noad preceding|q|}
r_type:small_number;{the|type|of noad|r|,or|op_noad|if|r= null|}
t:small_number;{the effective|type|of noad|q|during the second pass}
p,x,y,z:pointer;{temporary registers for list construction}
pen:integer;{a penalty to be inserted}
s:small_number;{the size of a noad to be deleted}
max_h,max_d:scaled;{maximum height and depth of the list translated so far}
delta:scaled;{offset between subscript and superscript}
begin mlist:= cur_mlist;penalties:= mlist_penalties;
style:= cur_style;{tuck global parameters away as local variables}
q:= mlist;r:= null;r_type:= op_noad;max_h:= 0;max_d:= 0;
/*877:*/
#line 21793 "pdftexdir/pdftex.web"

begin if cur_style<script_style then cur_size:= text_size
else cur_size:= 16*((cur_style-text_style)div 2);
cur_mu:= x_over_n(math_quad(cur_size),18);
end

/*:877*/
#line 22227 "pdftexdir/pdftex.web"
;
while q<> null do/*901:*/
#line 22239 "pdftexdir/pdftex.web"

begin/*902:*/
#line 22259 "pdftexdir/pdftex.web"

reswitch:delta:= 0;
case type(q)of
bin_noad:case r_type of
bin_noad,op_noad,rel_noad,open_noad,punct_noad,left_noad:
begin type(q):= ord_noad;goto reswitch;
end;
othercases do_nothing
endcases;
rel_noad,close_noad,punct_noad,right_noad:begin
/*903:*/
#line 22280 "pdftexdir/pdftex.web"

if r_type= bin_noad then type(r):= ord_noad

/*:903*/
#line 22269 "pdftexdir/pdftex.web"
;
if type(q)= right_noad then goto done_with_noad;
end;
/*907:*/
#line 22344 "pdftexdir/pdftex.web"

left_noad:goto done_with_noad;
fraction_noad:begin make_fraction(q);goto check_dimensions;
end;
op_noad:begin delta:= make_op(q);
if subtype(q)= limits then goto check_dimensions;
end;
ord_noad:make_ord(q);
open_noad,inner_noad:do_nothing;
radical_noad:make_radical(q);
over_noad:make_over(q);
under_noad:make_under(q);
accent_noad:make_math_accent(q);
vcenter_noad:make_vcenter(q);

/*:907*/
#line 22272 "pdftexdir/pdftex.web"

/*904:*/
#line 22283 "pdftexdir/pdftex.web"

style_node:begin cur_style:= subtype(q);
/*877:*/
#line 21793 "pdftexdir/pdftex.web"

begin if cur_style<script_style then cur_size:= text_size
else cur_size:= 16*((cur_style-text_style)div 2);
cur_mu:= x_over_n(math_quad(cur_size),18);
end

/*:877*/
#line 22285 "pdftexdir/pdftex.web"
;
goto done_with_node;
end;
choice_node:/*905:*/
#line 22303 "pdftexdir/pdftex.web"

begin case cur_style div 2 of
0:choose_mlist(display_mlist);{|display_style= 0|}
1:choose_mlist(text_mlist);{|text_style= 2|}
2:choose_mlist(script_mlist);{|script_style= 4|}
3:choose_mlist(script_script_mlist);{|script_script_style= 6|}
end;{there are no other cases}
flush_node_list(display_mlist(q));
flush_node_list(text_mlist(q));
flush_node_list(script_mlist(q));
flush_node_list(script_script_mlist(q));
type(q):= style_node;subtype(q):= cur_style;width(q):= 0;depth(q):= 0;
if p<> null then
begin z:= link(q);link(q):= p;
while link(p)<> null do p:= link(p);
link(p):= z;
end;
goto done_with_node;
end

/*:905*/
#line 22289 "pdftexdir/pdftex.web"
;
ins_node,mark_node,adjust_node,
whatsit_node,penalty_node,disc_node:goto done_with_node;
rule_node:begin if height(q)> max_h then max_h:= height(q);
if depth(q)> max_d then max_d:= depth(q);goto done_with_node;
end;
glue_node:begin/*906:*/
#line 22331 "pdftexdir/pdftex.web"

if subtype(q)= mu_glue then
begin x:= glue_ptr(q);
y:= math_glue(x,cur_mu);delete_glue_ref(x);glue_ptr(q):= y;
subtype(q):= normal;
end
else if(cur_size<> text_size)and(subtype(q)= cond_math_glue)then
begin p:= link(q);
if p<> null then if(type(p)= glue_node)or(type(p)= kern_node)then
begin link(q):= link(p);link(p):= null;flush_node_list(p);
end;
end

/*:906*/
#line 22295 "pdftexdir/pdftex.web"
;
goto done_with_node;
end;
kern_node:begin math_kern(q,cur_mu);goto done_with_node;
end;

/*:904*/
#line 22274 "pdftexdir/pdftex.web"

othercases confusion("mlist1")

endcases;
/*928:*/
#line 22772 "pdftexdir/pdftex.web"

case math_type(nucleus(q))of
math_char,math_text_char:
/*929:*/
#line 22794 "pdftexdir/pdftex.web"

begin fetch(nucleus(q));
if char_exists(cur_i)then
begin delta:= char_italic(cur_f)(cur_i);p:= new_character(cur_f,qo(cur_c));
if(math_type(nucleus(q))= math_text_char)and(space(cur_f)<> 0)then
delta:= 0;{no italic correction in mid-word of text font}
if(math_type(subscr(q))= empty)and(delta<> 0)then
begin link(p):= new_kern(delta);delta:= 0;
end;
end
else p:= null;
end

/*:929*/
#line 22777 "pdftexdir/pdftex.web"
;
empty:p:= null;
sub_box:p:= info(nucleus(q));
sub_mlist:begin cur_mlist:= info(nucleus(q));save_style:= cur_style;
mlist_penalties:= false;mlist_to_hlist;{recursive call}

cur_style:= save_style;/*877:*/
#line 21793 "pdftexdir/pdftex.web"

begin if cur_style<script_style then cur_size:= text_size
else cur_size:= 16*((cur_style-text_style)div 2);
cur_mu:= x_over_n(math_quad(cur_size),18);
end

/*:877*/
#line 22783 "pdftexdir/pdftex.web"
;
p:= hpack(link(temp_head),natural);
end;
othercases confusion("mlist2")

endcases;
new_hlist(q):= p;
if(math_type(subscr(q))= empty)and(math_type(supscr(q))= empty)then
goto check_dimensions;
make_scripts(q,delta)

/*:928*/
#line 22278 "pdftexdir/pdftex.web"


/*:902*/
#line 22243 "pdftexdir/pdftex.web"
;
check_dimensions:z:= hpack(new_hlist(q),natural);
if height(z)> max_h then max_h:= height(z);
if depth(z)> max_d then max_d:= depth(z);
free_node(z,box_node_size);
done_with_noad:r:= q;r_type:= type(r);
if r_type= right_noad then
begin r_type:= left_noad;cur_style:= style;/*877:*/
#line 21793 "pdftexdir/pdftex.web"

begin if cur_style<script_style then cur_size:= text_size
else cur_size:= 16*((cur_style-text_style)div 2);
cur_mu:= x_over_n(math_quad(cur_size),18);
end

/*:877*/
#line 22250 "pdftexdir/pdftex.web"
;
end;
done_with_node:q:= link(q);
end

/*:901*/
#line 22230 "pdftexdir/pdftex.web"
;
/*903:*/
#line 22280 "pdftexdir/pdftex.web"

if r_type= bin_noad then type(r):= ord_noad

/*:903*/
#line 22231 "pdftexdir/pdftex.web"
;
/*934:*/
#line 22901 "pdftexdir/pdftex.web"

p:= temp_head;link(p):= null;q:= mlist;r_type:= 0;cur_style:= style;
/*877:*/
#line 21793 "pdftexdir/pdftex.web"

begin if cur_style<script_style then cur_size:= text_size
else cur_size:= 16*((cur_style-text_style)div 2);
cur_mu:= x_over_n(math_quad(cur_size),18);
end

/*:877*/
#line 22903 "pdftexdir/pdftex.web"
;
while q<> null do
begin/*935:*/
#line 22920 "pdftexdir/pdftex.web"

t:= ord_noad;s:= noad_size;pen:= inf_penalty;
case type(q)of
op_noad,open_noad,close_noad,punct_noad,inner_noad:t:= type(q);
bin_noad:begin t:= bin_noad;pen:= bin_op_penalty;
end;
rel_noad:begin t:= rel_noad;pen:= rel_penalty;
end;
ord_noad,vcenter_noad,over_noad,under_noad:do_nothing;
radical_noad:s:= radical_noad_size;
accent_noad:s:= accent_noad_size;
fraction_noad:begin t:= inner_noad;s:= fraction_noad_size;
end;
left_noad,right_noad:t:= make_left_right(q,style,max_d,max_h);
style_node:/*937:*/
#line 22965 "pdftexdir/pdftex.web"

begin cur_style:= subtype(q);s:= style_node_size;
/*877:*/
#line 21793 "pdftexdir/pdftex.web"

begin if cur_style<script_style then cur_size:= text_size
else cur_size:= 16*((cur_style-text_style)div 2);
cur_mu:= x_over_n(math_quad(cur_size),18);
end

/*:877*/
#line 22967 "pdftexdir/pdftex.web"
;
goto delete_q;
end

/*:937*/
#line 22934 "pdftexdir/pdftex.web"
;
whatsit_node,penalty_node,rule_node,disc_node,adjust_node,ins_node,mark_node,
glue_node,kern_node:
begin link(p):= q;p:= q;q:= link(q);link(p):= null;goto done;
end;
othercases confusion("mlist3")

endcases

/*:935*/
#line 22909 "pdftexdir/pdftex.web"
;
/*940:*/
#line 23006 "pdftexdir/pdftex.web"

if r_type> 0 then{not the first noad}
begin case so(str_pool[r_type*8+t+magic_offset])of
"0":x:= 0;
"1":if cur_style<script_style then x:= thin_mu_skip_code else x:= 0;
"2":x:= thin_mu_skip_code;
"3":if cur_style<script_style then x:= med_mu_skip_code else x:= 0;
"4":if cur_style<script_style then x:= thick_mu_skip_code else x:= 0;
othercases confusion("mlist4")

endcases;
if x<> 0 then
begin y:= math_glue(glue_par(x),cur_mu);
z:= new_glue(y);glue_ref_count(y):= null;link(p):= z;p:= z;
subtype(z):= x+1;{store a symbolic subtype}
end;
end

/*:940*/
#line 22910 "pdftexdir/pdftex.web"
;
/*941:*/
#line 23028 "pdftexdir/pdftex.web"

if new_hlist(q)<> null then
begin link(p):= new_hlist(q);
repeat p:= link(p);
until link(p)= null;
end;
if penalties then if link(q)<> null then if pen<inf_penalty then
begin r_type:= type(link(q));
if r_type<> penalty_node then if r_type<> rel_noad then
begin z:= new_penalty(pen);link(p):= z;p:= z;
end;
end

/*:941*/
#line 22911 "pdftexdir/pdftex.web"
;
if type(q)= right_noad then t:= open_noad;
r_type:= t;
delete_q:r:= q;q:= link(q);free_node(r,s);
done:end

/*:934*/
#line 22233 "pdftexdir/pdftex.web"
;
end;

/*:900*//*946:*/
#line 23219 "pdftexdir/pdftex.web"
procedure push_alignment;
var p:pointer;{the new alignment stack node}
begin p:= get_node(align_stack_node_size);
link(p):= align_ptr;info(p):= cur_align;
llink(p):= preamble;rlink(p):= cur_span;
mem[p+2].int:= cur_loop;mem[p+3].int:= align_state;
info(p+4):= cur_head;link(p+4):= cur_tail;
info(p+5):= cur_pre_head;link(p+5):= cur_pre_tail;
align_ptr:= p;
cur_head:= get_avail;
cur_pre_head:= get_avail;
end;

procedure pop_alignment;
var p:pointer;{the top alignment stack node}
begin free_avail(cur_head);
free_avail(cur_pre_head);
p:= align_ptr;
cur_tail:= link(p+4);cur_head:= info(p+4);
cur_pre_tail:= link(p+5);cur_pre_head:= info(p+5);
align_state:= mem[p+3].int;cur_loop:= mem[p+2].int;
cur_span:= rlink(p);preamble:= llink(p);
cur_align:= info(p);align_ptr:= link(p);
free_node(p,align_stack_node_size);
end;

/*:946*//*948:*/
#line 23263 "pdftexdir/pdftex.web"
/*956:*/
#line 23376 "pdftexdir/pdftex.web"

procedure get_preamble_token;
label restart;
begin restart:get_token;
while(cur_chr= span_code)and(cur_cmd= tab_mark)do
begin get_token;{this token will be expanded once}
if cur_cmd> max_command then
begin expand;get_token;
end;
end;
if cur_cmd= endv then
fatal_error("(interwoven alignment preambles are not allowed)");

if(cur_cmd= assign_glue)and(cur_chr= glue_base+tab_skip_code)then
begin scan_optional_equals;scan_glue(glue_val);
if global_defs> 0 then geq_define(glue_base+tab_skip_code,glue_ref,cur_val)
else eq_define(glue_base+tab_skip_code,glue_ref,cur_val);
goto restart;
end;
end;

/*:956*/
#line 23263 "pdftexdir/pdftex.web"

procedure align_peek;forward;
procedure normal_paragraph;forward;
procedure init_align;
label done,done1,done2,continue;
var save_cs_ptr:pointer;{|warning_index|value for error messages}
p:pointer;{for short-term temporary use}
begin save_cs_ptr:= cur_cs;{\.{\\halign}or\.{\\valign},usually}
push_alignment;align_state:= -1000000;{enter a new alignment level}
/*950:*/
#line 23296 "pdftexdir/pdftex.web"

if(mode= mmode)and((tail<> head)or(incompleat_noad<> null))then
begin print_err("Improper ");print_esc("halign");print(" inside $$'s");

help3("Displays can use special alignments (like \eqalignno)")
("only if nothing but the alignment itself is between $$'s.")
("So I've deleted the formulas that preceded this alignment.");
error;flush_math;
end

/*:950*/
#line 23272 "pdftexdir/pdftex.web"
;
push_nest;{enter a new semantic level}
/*949:*/
#line 23287 "pdftexdir/pdftex.web"

if mode= mmode then
begin mode:= -vmode;prev_depth:= nest[nest_ptr-2].aux_field.sc;
end
else if mode> 0 then negate(mode)

/*:949*/
#line 23274 "pdftexdir/pdftex.web"
;
scan_spec(align_group,false);
/*951:*/
#line 23306 "pdftexdir/pdftex.web"

preamble:= null;cur_align:= align_head;cur_loop:= null;scanner_status:= aligning;
warning_index:= save_cs_ptr;align_state:= -1000000;
{at this point,|cur_cmd= left_brace|}
loop begin/*952:*/
#line 23318 "pdftexdir/pdftex.web"

link(cur_align):= new_param_glue(tab_skip_code);
cur_align:= link(cur_align)

/*:952*/
#line 23310 "pdftexdir/pdftex.web"
;
if cur_cmd= car_ret then goto done;{\.{\\cr}ends the preamble}
/*953:*/
#line 23322 "pdftexdir/pdftex.web"

/*957:*/
#line 23399 "pdftexdir/pdftex.web"

p:= hold_head;link(p):= null;
loop begin get_preamble_token;
if cur_cmd= mac_param then goto done1;
if(cur_cmd<=car_ret)and(cur_cmd>=tab_mark)and(align_state= -1000000)then
if(p= hold_head)and(cur_loop= null)and(cur_cmd= tab_mark)
then cur_loop:= cur_align
else begin print_err("Missing # inserted in alignment preamble");

help3("There should be exactly one # between &'s, when an")
("\halign or \valign is being set up. In this case you had")
("none, so I've put one in; maybe that will work.");
back_error;goto done1;
end
else if(cur_cmd<> spacer)or(p<> hold_head)then
begin link(p):= get_avail;p:= link(p);info(p):= cur_tok;
end;
end;
done1:

/*:957*/
#line 23323 "pdftexdir/pdftex.web"
;
link(cur_align):= new_null_box;cur_align:= link(cur_align);{a new alignrecord}
info(cur_align):= end_span;width(cur_align):= null_flag;
u_part(cur_align):= link(hold_head);
/*958:*/
#line 23419 "pdftexdir/pdftex.web"

p:= hold_head;link(p):= null;
loop begin continue:get_preamble_token;
if(cur_cmd<=car_ret)and(cur_cmd>=tab_mark)and(align_state= -1000000)then
goto done2;
if cur_cmd= mac_param then
begin print_err("Only one # is allowed per tab");

help3("There should be exactly one # between &'s, when an")
("\halign or \valign is being set up. In this case you had")
("more than one, so I'm ignoring all but the first.");
error;goto continue;
end;
link(p):= get_avail;p:= link(p);info(p):= cur_tok;
end;
done2:link(p):= get_avail;p:= link(p);
info(p):= end_template_token{put\.{\\endtemplate}at the end}

/*:958*/
#line 23327 "pdftexdir/pdftex.web"
;
v_part(cur_align):= link(hold_head)

/*:953*/
#line 23314 "pdftexdir/pdftex.web"
;
end;
done:scanner_status:= normal

/*:951*/
#line 23276 "pdftexdir/pdftex.web"
;
new_save_level(align_group);
if every_cr<> null then begin_token_list(every_cr,every_cr_text);
align_peek;{look for\.{\\noalign}or\.{\\omit}}
end;

/*:948*//*960:*/
#line 23471 "pdftexdir/pdftex.web"
/*961:*/
#line 23485 "pdftexdir/pdftex.web"

procedure init_span(p:pointer);
begin push_nest;
if mode= -hmode then space_factor:= 1000
else begin prev_depth:= pdf_ignored_dimen;normal_paragraph;
end;
cur_span:= p;
end;

/*:961*/
#line 23471 "pdftexdir/pdftex.web"

procedure init_row;
begin push_nest;mode:= (-hmode-vmode)-mode;
if mode= -hmode then space_factor:= 0 else prev_depth:= 0;
tail_append(new_glue(glue_ptr(preamble)));
subtype(tail):= tab_skip_code+1;
cur_align:= link(preamble);cur_tail:= cur_head;cur_pre_tail:= cur_pre_head;
init_span(cur_align);
end;

/*:960*//*962:*/
#line 23501 "pdftexdir/pdftex.web"
procedure init_col;
begin extra_info(cur_align):= cur_cmd;
if cur_cmd= omit then align_state:= 0
else begin back_input;begin_token_list(u_part(cur_align),u_template);
end;{now|align_state= 1000000|}
end;

/*:962*//*965:*/
#line 23538 "pdftexdir/pdftex.web"
function fin_col:boolean;
label exit;
var p:pointer;{the alignrecord after the current one}
q,r:pointer;{temporary pointers for list manipulation}
s:pointer;{a new span node}
u:pointer;{a new unset box}
w:scaled;{natural width}
o:glue_ord;{order of infinity}
n:halfword;{span counter}
begin if cur_align= null then confusion("endv");
q:= link(cur_align);if q= null then confusion("endv");

if align_state<500000 then
fatal_error("(interwoven alignment preambles are not allowed)");

p:= link(q);
/*966:*/
#line 23571 "pdftexdir/pdftex.web"

if(p= null)and(extra_info(cur_align)<cr_code)then
if cur_loop<> null then/*967:*/
#line 23583 "pdftexdir/pdftex.web"

begin link(q):= new_null_box;p:= link(q);{a new alignrecord}
info(p):= end_span;width(p):= null_flag;cur_loop:= link(cur_loop);
/*968:*/
#line 23591 "pdftexdir/pdftex.web"

q:= hold_head;r:= u_part(cur_loop);
while r<> null do
begin link(q):= get_avail;q:= link(q);info(q):= info(r);r:= link(r);
end;
link(q):= null;u_part(p):= link(hold_head);
q:= hold_head;r:= v_part(cur_loop);
while r<> null do
begin link(q):= get_avail;q:= link(q);info(q):= info(r);r:= link(r);
end;
link(q):= null;v_part(p):= link(hold_head)

/*:968*/
#line 23586 "pdftexdir/pdftex.web"
;
cur_loop:= link(cur_loop);
link(p):= new_glue(glue_ptr(cur_loop));
end

/*:967*/
#line 23573 "pdftexdir/pdftex.web"

else begin print_err("Extra alignment tab has been changed to ");

print_esc("cr");
help3("You have given more \span or & marks than there were")
("in the preamble to the \halign or \valign now in progress.")
("So I'll assume that you meant to type \cr instead.");
extra_info(cur_align):= cr_code;error;
end

/*:966*/
#line 23554 "pdftexdir/pdftex.web"
;
if extra_info(cur_align)<> span_code then
begin unsave;new_save_level(align_group);
/*970:*/
#line 23607 "pdftexdir/pdftex.web"

begin if mode= -hmode then
begin adjust_tail:= cur_tail;pre_adjust_tail:= cur_pre_tail;
u:= hpack(link(head),natural);w:= width(u);
cur_tail:= adjust_tail;adjust_tail:= null;
cur_pre_tail:= pre_adjust_tail;pre_adjust_tail:= null;
end
else begin u:= vpackage(link(head),natural,0);w:= height(u);
end;
n:= min_quarterword;{this represents a span count of 1}
if cur_span<> cur_align then/*972:*/
#line 23643 "pdftexdir/pdftex.web"

begin q:= cur_span;
repeat incr(n);q:= link(link(q));
until q= cur_align;
if n> max_quarterword then confusion("256 spans");{this can happen,but won't}


q:= cur_span;while link(info(q))<n do q:= info(q);
if link(info(q))> n then
begin s:= get_node(span_node_size);info(s):= info(q);link(s):= n;
info(q):= s;width(s):= w;
end
else if width(info(q))<w then width(info(q)):= w;
end

/*:972*/
#line 23617 "pdftexdir/pdftex.web"

else if w> width(cur_align)then width(cur_align):= w;
type(u):= unset_node;span_count(u):= n;
/*833:*/
#line 20978 "pdftexdir/pdftex.web"

if total_stretch[filll]<> 0 then o:= filll
else if total_stretch[fill]<> 0 then o:= fill
else if total_stretch[fil]<> 0 then o:= fil
else o:= normal

/*:833*/
#line 23620 "pdftexdir/pdftex.web"
;
glue_order(u):= o;glue_stretch(u):= total_stretch[o];
/*839:*/
#line 21047 "pdftexdir/pdftex.web"

if total_shrink[filll]<> 0 then o:= filll
else if total_shrink[fill]<> 0 then o:= fill
else if total_shrink[fil]<> 0 then o:= fil
else o:= normal

/*:839*/
#line 23622 "pdftexdir/pdftex.web"
;
glue_sign(u):= o;glue_shrink(u):= total_shrink[o];
pop_nest;link(tail):= u;tail:= u;
end

/*:970*/
#line 23557 "pdftexdir/pdftex.web"
;
/*969:*/
#line 23603 "pdftexdir/pdftex.web"

tail_append(new_glue(glue_ptr(link(cur_align))));
subtype(tail):= tab_skip_code+1

/*:969*/
#line 23558 "pdftexdir/pdftex.web"
;
if extra_info(cur_align)>=cr_code then
begin fin_col:= true;return;
end;
init_span(p);
end;
align_state:= 1000000;
repeat get_x_or_protected;
until cur_cmd<> spacer;
cur_align:= p;
init_col;fin_col:= false;
exit:end;

/*:965*//*973:*/
#line 23663 "pdftexdir/pdftex.web"
procedure fin_row;
var p:pointer;{the new unset box}
begin if mode= -hmode then
begin p:= hpack(link(head),natural);
pop_nest;
if cur_pre_head<> cur_pre_tail then
append_list(cur_pre_head)(cur_pre_tail);
append_to_vlist(p);
if cur_head<> cur_tail then
append_list(cur_head)(cur_tail);
end
else begin p:= vpack(link(head),natural);pop_nest;
link(tail):= p;tail:= p;space_factor:= 1000;
end;
type(p):= unset_node;glue_stretch(p):= 0;
if every_cr<> null then begin_token_list(every_cr,every_cr_text);
align_peek;
end;{note that|glue_shrink(p)= 0|since|glue_shrink==shift_amount|}

/*:973*//*974:*/
#line 23686 "pdftexdir/pdftex.web"
procedure do_assignments;forward;
procedure resume_after_display;forward;
procedure build_page;forward;
procedure fin_align;
var p,q,r,s,u,v:pointer;{registers for the list operations}
t,w:scaled;{width of column}
o:scaled;{shift offset for unset boxes}
n:halfword;{matching span amount}
rule_save:scaled;{temporary storage for|overfull_rule|}
aux_save:memory_word;{temporary storage for|aux|}
begin if cur_group<> align_group then confusion("align1");

unsave;{that|align_group|was for individual entries}
if cur_group<> align_group then confusion("align0");
unsave;{that|align_group|was for the whole alignment}
if nest[nest_ptr-1].mode_field= mmode then o:= display_indent
else o:= 0;
/*975:*/
#line 23736 "pdftexdir/pdftex.web"

q:= link(preamble);
repeat flush_list(u_part(q));flush_list(v_part(q));
p:= link(link(q));
if width(q)= null_flag then
/*976:*/
#line 23750 "pdftexdir/pdftex.web"

begin width(q):= 0;r:= link(q);s:= glue_ptr(r);
if s<> zero_glue then
begin add_glue_ref(zero_glue);delete_glue_ref(s);
glue_ptr(r):= zero_glue;
end;
end

/*:976*/
#line 23741 "pdftexdir/pdftex.web"
;
if info(q)<> end_span then
/*977:*/
#line 23765 "pdftexdir/pdftex.web"

begin t:= width(q)+width(glue_ptr(link(q)));
r:= info(q);s:= end_span;info(s):= p;n:= min_quarterword+1;
repeat width(r):= width(r)-t;u:= info(r);
while link(r)> n do
begin s:= info(s);n:= link(info(s))+1;
end;
if link(r)<n then
begin info(r):= info(s);info(s):= r;decr(link(r));s:= r;
end
else begin if width(r)> width(info(s))then width(info(s)):= width(r);
free_node(r,span_node_size);
end;
r:= u;
until r= end_span;
end

/*:977*/
#line 23744 "pdftexdir/pdftex.web"
;
type(q):= unset_node;span_count(q):= min_quarterword;height(q):= 0;
depth(q):= 0;glue_order(q):= normal;glue_sign(q):= normal;
glue_stretch(q):= 0;glue_shrink(q):= 0;q:= p;
until q= null

/*:975*/
#line 23704 "pdftexdir/pdftex.web"
;
/*978:*/
#line 23788 "pdftexdir/pdftex.web"

save_ptr:= save_ptr-2;pack_begin_line:= -mode_line;
if mode= -vmode then
begin rule_save:= overfull_rule;
overfull_rule:= 0;{prevent rule from being packaged}
p:= hpack(preamble,saved(1),saved(0));overfull_rule:= rule_save;
end
else begin q:= link(preamble);
repeat height(q):= width(q);width(q):= 0;q:= link(link(q));
until q= null;
p:= vpack(preamble,saved(1),saved(0));
q:= link(preamble);
repeat width(q):= height(q);height(q):= 0;q:= link(link(q));
until q= null;
end;
pack_begin_line:= 0

/*:978*/
#line 23706 "pdftexdir/pdftex.web"
;
/*979:*/
#line 23805 "pdftexdir/pdftex.web"

q:= link(head);s:= head;
while q<> null do
begin if not is_char_node(q)then
if type(q)= unset_node then
/*981:*/
#line 23830 "pdftexdir/pdftex.web"

begin if mode= -vmode then
begin type(q):= hlist_node;width(q):= width(p);
if nest[nest_ptr-1].mode_field= mmode then set_box_lr(q)(dlist);{for|ship_out|}
end
else begin type(q):= vlist_node;height(q):= height(p);
end;
glue_order(q):= glue_order(p);glue_sign(q):= glue_sign(p);
glue_set(q):= glue_set(p);shift_amount(q):= o;
r:= link(list_ptr(q));s:= link(list_ptr(p));
repeat/*982:*/
#line 23850 "pdftexdir/pdftex.web"

n:= span_count(r);t:= width(s);w:= t;u:= hold_head;
set_box_lr(r)(0);{for|ship_out|}
while n> min_quarterword do
begin decr(n);
/*983:*/
#line 23868 "pdftexdir/pdftex.web"

s:= link(s);v:= glue_ptr(s);link(u):= new_glue(v);u:= link(u);
subtype(u):= tab_skip_code+1;t:= t+width(v);
if glue_sign(p)= stretching then
begin if stretch_order(v)= glue_order(p)then
t:= t+round(float(glue_set(p))*stretch(v));

end
else if glue_sign(p)= shrinking then
begin if shrink_order(v)= glue_order(p)then
t:= t-round(float(glue_set(p))*shrink(v));
end;
s:= link(s);link(u):= new_null_box;u:= link(u);t:= t+width(s);
if mode= -vmode then width(u):= width(s)else
begin type(u):= vlist_node;height(u):= width(s);
end

/*:983*/
#line 23856 "pdftexdir/pdftex.web"
;
end;
if mode= -vmode then
/*984:*/
#line 23885 "pdftexdir/pdftex.web"

begin height(r):= height(q);depth(r):= depth(q);
if t= width(r)then
begin glue_sign(r):= normal;glue_order(r):= normal;
set_glue_ratio_zero(glue_set(r));
end
else if t> width(r)then
begin glue_sign(r):= stretching;
if glue_stretch(r)= 0 then set_glue_ratio_zero(glue_set(r))
else glue_set(r):= unfloat((t-width(r))/glue_stretch(r));

end
else begin glue_order(r):= glue_sign(r);glue_sign(r):= shrinking;
if glue_shrink(r)= 0 then set_glue_ratio_zero(glue_set(r))
else if(glue_order(r)= normal)and(width(r)-t> glue_shrink(r))then
set_glue_ratio_one(glue_set(r))
else glue_set(r):= unfloat((width(r)-t)/glue_shrink(r));
end;
width(r):= w;type(r):= hlist_node;
end

/*:984*/
#line 23860 "pdftexdir/pdftex.web"

else/*985:*/
#line 23906 "pdftexdir/pdftex.web"

begin width(r):= width(q);
if t= height(r)then
begin glue_sign(r):= normal;glue_order(r):= normal;
set_glue_ratio_zero(glue_set(r));
end
else if t> height(r)then
begin glue_sign(r):= stretching;
if glue_stretch(r)= 0 then set_glue_ratio_zero(glue_set(r))
else glue_set(r):= unfloat((t-height(r))/glue_stretch(r));

end
else begin glue_order(r):= glue_sign(r);glue_sign(r):= shrinking;
if glue_shrink(r)= 0 then set_glue_ratio_zero(glue_set(r))
else if(glue_order(r)= normal)and(height(r)-t> glue_shrink(r))then
set_glue_ratio_one(glue_set(r))
else glue_set(r):= unfloat((height(r)-t)/glue_shrink(r));
end;
height(r):= w;type(r):= vlist_node;
end

/*:985*/
#line 23862 "pdftexdir/pdftex.web"
;
shift_amount(r):= 0;
if u<> hold_head then{append blank boxes to account for spanned nodes}
begin link(u):= link(r);link(r):= link(hold_head);r:= u;
end

/*:982*/
#line 23840 "pdftexdir/pdftex.web"
;
r:= link(link(r));s:= link(link(s));
until r= null;
end

/*:981*/
#line 23810 "pdftexdir/pdftex.web"

else if type(q)= rule_node then
/*980:*/
#line 23817 "pdftexdir/pdftex.web"

begin if is_running(width(q))then width(q):= width(p);
if is_running(height(q))then height(q):= height(p);
if is_running(depth(q))then depth(q):= depth(p);
if o<> 0 then
begin r:= link(q);link(q):= null;q:= hpack(q,natural);
shift_amount(q):= o;link(q):= r;link(s):= q;
end;
end

/*:980*/
#line 23813 "pdftexdir/pdftex.web"
;
s:= q;q:= link(q);
end

/*:979*/
#line 23707 "pdftexdir/pdftex.web"
;
flush_node_list(p);pop_alignment;
/*986:*/
#line 23937 "pdftexdir/pdftex.web"

aux_save:= aux;p:= link(head);q:= tail;pop_nest;
if mode= mmode then/*1382:*/
#line 31277 "pdftexdir/pdftex.web"

begin do_assignments;
if cur_cmd<> math_shift then/*1383:*/
#line 31292 "pdftexdir/pdftex.web"

begin print_err("Missing $$ inserted");

help2("Displays can use special alignments (like \eqalignno)")
("only if nothing but the alignment itself is between $$'s.");
back_error;
end

/*:1383*/
#line 31279 "pdftexdir/pdftex.web"

else/*1373:*/
#line 31120 "pdftexdir/pdftex.web"

begin get_x_token;
if cur_cmd<> math_shift then
begin print_err("Display math should end with $$");

help2("The `$' that I just saw supposedly matches a previous `$$'.")
("So I shall assume that you typed `$$' both times.");
back_error;
end;
end

/*:1373*/
#line 31280 "pdftexdir/pdftex.web"
;
flush_node_list(LR_box);
pop_nest;
tail_append(new_penalty(pre_display_penalty));
tail_append(new_param_glue(above_display_skip_code));
link(tail):= p;
if p<> null then tail:= q;
tail_append(new_penalty(post_display_penalty));
tail_append(new_param_glue(below_display_skip_code));
prev_depth:= aux_save.sc;resume_after_display;
end

/*:1382*/
#line 23939 "pdftexdir/pdftex.web"

else begin aux:= aux_save;link(tail):= p;
if p<> null then tail:= q;
if mode= vmode then build_page;
end

/*:986*/
#line 23709 "pdftexdir/pdftex.web"
;
end;
/*959:*/
#line 23447 "pdftexdir/pdftex.web"

procedure align_peek;
label restart;
begin restart:align_state:= 1000000;
repeat get_x_or_protected;
until cur_cmd<> spacer;
if cur_cmd= no_align then
begin scan_left_brace;new_save_level(no_align_group);
if mode= -vmode then normal_paragraph;
end
else if cur_cmd= right_brace then fin_align
else if(cur_cmd= car_ret)and(cur_chr= cr_cr_code)then
goto restart{ignore\.{\\crcr}}
else begin init_row;{start a new row}
init_col;{start a new column and replace what we peeked at}
end;
end;

/*:959*/
#line 23711 "pdftexdir/pdftex.web"


/*:974*//*989:*/
#line 24003 "pdftexdir/pdftex.web"
/*1000:*/
#line 24268 "pdftexdir/pdftex.web"

function finite_shrink(p:pointer):pointer;{recovers from infinite shrinkage}
var q:pointer;{new glue specification}
begin if no_shrink_error_yet then
begin no_shrink_error_yet:= false;
print_err("Infinite glue shrinkage found in a paragraph");

help5("The paragraph just ended includes some glue that has")
("infinite shrinkability, e.g., `\hskip 0pt minus 1fil'.")
("Such glue doesn't belong there---it allows a paragraph")
("of any length to fit on one line. But it's safe to proceed,")
("since the offensive shrinkability has been made finite.");
error;
end;
q:= new_spec(p);shrink_order(q):= normal;
delete_glue_ref(p);finite_shrink:= q;
end;

/*:1000*//*1003:*/
#line 24376 "pdftexdir/pdftex.web"

procedure push_node(p:pointer);
begin
if hlist_stack_level> max_hlist_stack then
pdf_error("push_node","stack overflow");
hlist_stack[hlist_stack_level]:= p;
hlist_stack_level:= hlist_stack_level+1;
end;

function pop_node:pointer;
begin
hlist_stack_level:= hlist_stack_level-1;
if hlist_stack_level<0 then{would point to some bug}
pdf_error("pop_node","stack underflow (internal error)");
pop_node:= hlist_stack[hlist_stack_level];
end;

function find_protchar_left(l:pointer;d:boolean):pointer;
{searches left to right from list head|l|,returns 1 st non-skipable item}
var t:pointer;
run:boolean;
begin
if(link(l)<> null)and(type(l)= hlist_node)and(width(l)= 0)
and(height(l)= 0)and(depth(l)= 0)and(list_ptr(l)= null)then
l:= link(l){for paragraph start with\.{\\parindent= 0 pt}}
else if d then
while(link(l)<> null)and(not(is_char_node(l)or non_discardable(l)))do
l:= link(l);{std.\discardables at line break,\TeX book,p 95}
hlist_stack_level:= 0;
run:= true;
repeat
t:= l;
while run and(type(l)= hlist_node)and(list_ptr(l)<> null)do begin
push_node(l);
l:= list_ptr(l);
end;
while run and cp_skipable(l)do begin
while(link(l)= null)and(hlist_stack_level> 0)do begin
l:= pop_node;{don't visit this node again}
end;
if link(l)<> null then
l:= link(l)
else if hlist_stack_level= 0 then run:= false
end;
until t= l;
find_protchar_left:= l;
end;

function find_protchar_right(l,r:pointer):pointer;
{searches right to left from list tail|r|to head|l|,returns 1 st non-skipable item}
var t:pointer;
run:boolean;
begin
find_protchar_right:= null;
if r= null then return;
hlist_stack_level:= 0;
run:= true;
repeat
t:= r;
while run and(type(r)= hlist_node)and(list_ptr(r)<> null)do begin
push_node(l);
push_node(r);
l:= list_ptr(r);
r:= l;
while link(r)<> null do
r:= link(r);
end;
while run and cp_skipable(r)do begin
while(r= l)and(hlist_stack_level> 0)do begin
r:= pop_node;{don't visit this node again}
l:= pop_node;
end;
if(r<> l)and(r<> null)then
r:= prev_rightmost(l,r)
else if(r= l)and(hlist_stack_level= 0)then run:= false
end;
until t= r;
find_protchar_right:= r;
end;

function total_pw(q,p:pointer):scaled;
{returns the total width of character protrusion of a line;
|cur_break(break_node(q))|and|p|is the leftmost resp.rightmost node in the
horizontal list representing the actual line}
var l,r:pointer;
n:integer;
begin
if break_node(q)= null then
l:= first_p
else
l:= cur_break(break_node(q));
r:= prev_rightmost(prev_p,p);{get|link(r)= p|}
{let's look at the right margin first}

short_display_n(r,2);
print("&");
short_display_n(p,2);
print_ln;

if(p<> null)and(type(p)= disc_node)and(pre_break(p)<> null)then
{a|disc_node|with non-empty|pre_break|,protrude the last char of|pre_break|}
begin
r:= pre_break(p);
while link(r)<> null do
r:= link(r);
end else r:= find_protchar_right(l,r);
{now the left margin}

short_display_n(l,2);
print_ln;
breadth_max:= 10;
depth_threshold:= 2;
show_node_list(l);
print_ln;

if(l<> null)and(type(l)= disc_node)then begin
if post_break(l)<> null then begin
l:= post_break(l);{protrude the first char}
goto done;
end else{discard|replace_count(l)|nodes}
begin
n:= replace_count(l);
l:= link(l);
while n> 0 do begin
if link(l)<> null then
l:= link(l);
decr(n);
end;
end;
end;
l:= find_protchar_left(l,true);
done:
total_pw:= left_pw(l)+right_pw(r);
end;

procedure try_break(pi:integer;break_type:small_number);
label exit,done,done1,continue,deactivate,found,not_found;
var r:pointer;{runs through the active list}
margin_kern_stretch:scaled;
margin_kern_shrink:scaled;
lp,rp,cp:pointer;
prev_r:pointer;{stays a step behind|r|}
old_l:halfword;{maximum line number in current equivalence class of lines}
no_break_yet:boolean;{have we found a feasible break at|cur_p|?}
/*1004:*/
#line 24539 "pdftexdir/pdftex.web"

prev_prev_r:pointer;{a step behind|prev_r|,if|type(prev_r)= delta_node|}
s:pointer;{runs through nodes ahead of|cur_p|}
q:pointer;{points to a new node being created}
v:pointer;{points to a glue specification or a node ahead of|cur_p|}
t:integer;{node count,if|cur_p|is a discretionary node}
f:internal_font_number;{used in character width calculation}
l:halfword;{line number of current active node}
node_r_stays_active:boolean;{should node|r|remain in the active list?}
line_width:scaled;{the current line will be justified to this width}
fit_class:very_loose_fit..tight_fit;{possible fitness class of test line}
b:halfword;{badness of test line}
d:integer;{demerits of test line}
artificial_demerits:boolean;{has|d|been forced to zero?}
save_link:pointer;{temporarily holds value of|link(cur_p)|}
shortfall:scaled;{used in badness calculations}

/*:1004*//*1841:*/
#line 39697 "pdftexdir/pdftex.web"

g:scaled;{glue stretch or shrink of test line,adjustment for last line}

/*:1841*/
#line 24520 "pdftexdir/pdftex.web"

begin/*1005:*/
#line 24556 "pdftexdir/pdftex.web"

if abs(pi)>=inf_penalty then
if pi> 0 then return{this breakpoint is inhibited by infinite penalty}
else pi:= eject_penalty{this breakpoint will be forced}

/*:1005*/
#line 24521 "pdftexdir/pdftex.web"
;
no_break_yet:= true;prev_r:= active;old_l:= 0;
do_all_eight(copy_to_cur_active);
loop begin continue:r:= link(prev_r);
/*1006:*/
#line 24566 "pdftexdir/pdftex.web"


if type(r)= delta_node then
begin do_all_eight(update_width);
prev_prev_r:= prev_r;prev_r:= r;goto continue;
end

/*:1006*/
#line 24526 "pdftexdir/pdftex.web"
;
/*1009:*/
#line 24611 "pdftexdir/pdftex.web"

begin l:= line_number(r);
if l> old_l then
begin{now we are no longer in the inner loop}
if(minimum_demerits<awful_bad)and
((old_l<> easy_line)or(r= last_active))then
/*1010:*/
#line 24630 "pdftexdir/pdftex.web"

begin if no_break_yet then/*1011:*/
#line 24667 "pdftexdir/pdftex.web"

begin no_break_yet:= false;do_all_eight(set_break_width_to_background);
s:= cur_p;
if break_type> unhyphenated then if cur_p<> null then
/*1014:*/
#line 24745 "pdftexdir/pdftex.web"

begin t:= replace_count(cur_p);v:= cur_p;s:= post_break(cur_p);
while t> 0 do
begin decr(t);v:= link(v);
/*1015:*/
#line 24763 "pdftexdir/pdftex.web"

if is_char_node(v)then
begin f:= font(v);
break_width[1]:= break_width[1]-char_width(f)(char_info(f)(character(v)));
if(pdf_adjust_spacing> 1)and check_expand_pars(f)then begin
prev_char_p:= v;
sub_char_stretch(break_width[7])(character(v));
sub_char_shrink(break_width[8])(character(v));
end;
end
else case type(v)of
ligature_node:begin f:= font(lig_char(v));
break_width[1]:= break_width[1]-
char_width(f)(char_info(f)(character(lig_char(v))));
if(pdf_adjust_spacing> 1)and check_expand_pars(f)then begin
prev_char_p:= v;
sub_char_stretch(break_width[7])(character(lig_char(v)));
sub_char_shrink(break_width[8])(character(lig_char(v)));
end;
end;
hlist_node,vlist_node,rule_node,kern_node:begin
break_width[1]:= break_width[1]-width(v);
if(type(v)= kern_node)and
(pdf_adjust_spacing> 1)and(subtype(v)= normal)
then begin
sub_kern_stretch(break_width[7])(v);
sub_kern_shrink(break_width[8])(v);
end;
end;
othercases confusion("disc1")

endcases

/*:1015*/
#line 24749 "pdftexdir/pdftex.web"
;
end;
while s<> null do
begin/*1016:*/
#line 24796 "pdftexdir/pdftex.web"

if is_char_node(s)then
begin f:= font(s);
break_width[1]:= break_width[1]+char_width(f)(char_info(f)(character(s)));
if(pdf_adjust_spacing> 1)and check_expand_pars(f)then begin
prev_char_p:= s;
add_char_stretch(break_width[7])(character(s));
add_char_shrink(break_width[8])(character(s));
end;
end
else case type(s)of
ligature_node:begin f:= font(lig_char(s));
break_width[1]:= break_width[1]+
char_width(f)(char_info(f)(character(lig_char(s))));
if(pdf_adjust_spacing> 1)and check_expand_pars(f)then begin
prev_char_p:= s;
add_char_stretch(break_width[7])(character(lig_char(s)));
add_char_shrink(break_width[8])(character(lig_char(s)));
end;
end;
hlist_node,vlist_node,rule_node,kern_node:begin
break_width[1]:= break_width[1]+width(s);
if(type(s)= kern_node)and
(pdf_adjust_spacing> 1)and(subtype(s)= normal)
then begin
add_kern_stretch(break_width[7])(s);
add_kern_shrink(break_width[8])(s);
end;
end;
othercases confusion("disc2")

endcases

/*:1016*/
#line 24752 "pdftexdir/pdftex.web"
;
s:= link(s);
end;
do_one_seven_eight(add_disc_width_to_break_width);
if post_break(cur_p)= null then s:= link(v);
{nodes may be discardable after the break}
end

/*:1014*/
#line 24671 "pdftexdir/pdftex.web"
;
while s<> null do
begin if is_char_node(s)then goto done;
case type(s)of
glue_node:/*1012:*/
#line 24686 "pdftexdir/pdftex.web"

begin v:= glue_ptr(s);break_width[1]:= break_width[1]-width(v);
break_width[2+stretch_order(v)]:= break_width[2+stretch_order(v)]-stretch(v);
break_width[6]:= break_width[6]-shrink(v);
end

/*:1012*/
#line 24675 "pdftexdir/pdftex.web"
;
penalty_node:do_nothing;
math_node:break_width[1]:= break_width[1]-width(s);
kern_node:if subtype(s)<> explicit then goto done
else break_width[1]:= break_width[1]-width(s);
othercases goto done
endcases;
s:= link(s);
end;
done:end

/*:1011*/
#line 24631 "pdftexdir/pdftex.web"
;
/*1017:*/
#line 24838 "pdftexdir/pdftex.web"

if type(prev_r)= delta_node then{modify an existing delta node}
begin do_all_eight(convert_to_break_width);
end
else if prev_r= active then{no delta node needed at the beginning}
begin do_all_eight(store_break_width);
end
else begin q:= get_node(delta_node_size);link(q):= r;type(q):= delta_node;
subtype(q):= 0;{the|subtype|is not used}
do_all_eight(new_delta_to_break_width);
link(prev_r):= q;prev_prev_r:= prev_r;prev_r:= q;
end

/*:1017*/
#line 24632 "pdftexdir/pdftex.web"
;
if abs(adj_demerits)>=awful_bad-minimum_demerits then
minimum_demerits:= awful_bad-1
else minimum_demerits:= minimum_demerits+abs(adj_demerits);
for fit_class:= very_loose_fit to tight_fit do
begin if minimal_demerits[fit_class]<=minimum_demerits then
/*1019:*/
#line 24868 "pdftexdir/pdftex.web"

begin q:= get_node(passive_node_size);
link(q):= passive;passive:= q;cur_break(q):= cur_p;
stat incr(pass_number);serial(q):= pass_number;tats
prev_break(q):= best_place[fit_class];
q:= get_node(active_node_size);break_node(q):= passive;
line_number(q):= best_pl_line[fit_class]+1;
fitness(q):= fit_class;type(q):= break_type;
total_demerits(q):= minimal_demerits[fit_class];
if do_last_line_fit then
/*1848:*/
#line 39779 "pdftexdir/pdftex.web"

begin active_short(q):= best_pl_short[fit_class];
active_glue(q):= best_pl_glue[fit_class];
end

/*:1848*/
#line 24878 "pdftexdir/pdftex.web"
;
link(q):= r;link(prev_r):= q;prev_r:= q;
stat if tracing_paragraphs> 0 then
/*1020:*/
#line 24885 "pdftexdir/pdftex.web"

begin print_nl("@@");print_int(serial(passive));

print(": line ");print_int(line_number(q)-1);
print_char(".");print_int(fit_class);
if break_type= hyphenated then print_char("-");
print(" t=");print_int(total_demerits(q));
if do_last_line_fit then/*1849:*/
#line 39784 "pdftexdir/pdftex.web"

begin print(" s=");print_scaled(active_short(q));
if cur_p= null then print(" a=")else print(" g=");
print_scaled(active_glue(q));
end

/*:1849*/
#line 24892 "pdftexdir/pdftex.web"
;
print(" -> @@");
if prev_break(passive)= null then print_char("0")
else print_int(serial(prev_break(passive)));
end

/*:1020*/
#line 24881 "pdftexdir/pdftex.web"
;
tats
end

/*:1019*/
#line 24639 "pdftexdir/pdftex.web"
;
minimal_demerits[fit_class]:= awful_bad;
end;
minimum_demerits:= awful_bad;
/*1018:*/
#line 24857 "pdftexdir/pdftex.web"

if r<> last_active then
begin q:= get_node(delta_node_size);link(q):= r;type(q):= delta_node;
subtype(q):= 0;{the|subtype|is not used}
do_all_eight(new_delta_from_break_width);
link(prev_r):= q;prev_prev_r:= prev_r;prev_r:= q;
end

/*:1018*/
#line 24643 "pdftexdir/pdftex.web"
;
end

/*:1010*/
#line 24618 "pdftexdir/pdftex.web"
;
if r= last_active then return;
/*1024:*/
#line 24962 "pdftexdir/pdftex.web"

if l> easy_line then
begin line_width:= second_width;old_l:= max_halfword-1;
end
else begin old_l:= l;
if l> last_special_line then line_width:= second_width
else if par_shape_ptr= null then line_width:= first_width
else line_width:= mem[par_shape_ptr+2*l].sc;
end

/*:1024*/
#line 24620 "pdftexdir/pdftex.web"
;
end;
end

/*:1009*/
#line 24529 "pdftexdir/pdftex.web"
;
/*1025:*/
#line 24982 "pdftexdir/pdftex.web"

begin artificial_demerits:= false;

shortfall:= line_width-cur_active_width[1];{we're this much too short}


if pdf_output> 2 then begin
print_ln;
if(r<> null)and(break_node(r)<> null)then
short_display_n(cur_break(break_node(r)),5);
print_ln;
short_display_n(cur_p,5);
print_ln;
end;


if pdf_protrude_chars> 1 then
shortfall:= shortfall+total_pw(r,cur_p);
if(pdf_adjust_spacing> 1)and(shortfall<> 0)then begin
margin_kern_stretch:= 0;
margin_kern_shrink:= 0;
if pdf_protrude_chars> 1 then
/*820:*/
#line 20442 "pdftexdir/pdftex.web"

begin
lp:= last_leftmost_char;
rp:= last_rightmost_char;
fast_get_avail(cp);
if lp<> null then
cal_margin_kern_var(lp);
if rp<> null then
cal_margin_kern_var(rp);
free_avail(cp);
end

/*:820*/
#line 25004 "pdftexdir/pdftex.web"
;
if(shortfall> 0)and((total_font_stretch+margin_kern_stretch)> 0)
then begin
if(total_font_stretch+margin_kern_stretch)> shortfall then
shortfall:= ((total_font_stretch+margin_kern_stretch)div
(max_stretch_ratio div cur_font_step))div 2
else
shortfall:= shortfall-(total_font_stretch+margin_kern_stretch);
end
else if(shortfall<0)and((total_font_shrink+margin_kern_shrink)> 0)
then begin
if(total_font_shrink+margin_kern_shrink)> -shortfall then
shortfall:= -((total_font_shrink+margin_kern_shrink)div
(max_shrink_ratio div cur_font_step))div 2
else
shortfall:= shortfall+(total_font_shrink+margin_kern_shrink);
end;
end;
if shortfall> 0 then
/*1026:*/
#line 25050 "pdftexdir/pdftex.web"

if(cur_active_width[3]<> 0)or(cur_active_width[4]<> 0)or
(cur_active_width[5]<> 0)then
begin if do_last_line_fit then
begin if cur_p= null then{the last line of a paragraph}
/*1843:*/
#line 39714 "pdftexdir/pdftex.web"

begin if(active_short(r)= 0)or(active_glue(r)<=0)then goto not_found;
{previous line was neither stretched nor shrunk,or was infinitely bad}
if(cur_active_width[3]<> fill_width[0])or
(cur_active_width[4]<> fill_width[1])or
(cur_active_width[5]<> fill_width[2])then goto not_found;
{infinite stretch of this line not entirely due to|par_fill_skip|}
if active_short(r)> 0 then g:= cur_active_width[2]
else g:= cur_active_width[6];
if g<=0 then goto not_found;{no finite stretch resp.\no shrink}
arith_error:= false;g:= fract(g,active_short(r),active_glue(r),max_dimen);
if last_line_fit<1000 then g:= fract(g,last_line_fit,1000,max_dimen);
if arith_error then
if active_short(r)> 0 then g:= max_dimen else g:= -max_dimen;
if g> 0 then
/*1844:*/
#line 39739 "pdftexdir/pdftex.web"

begin if g> shortfall then g:= shortfall;
if g> 7230584 then if cur_active_width[2]<1663497 then
begin b:= inf_bad;fit_class:= very_loose_fit;goto found;
end;
b:= badness(g,cur_active_width[2]);
if b> 12 then
if b> 99 then fit_class:= very_loose_fit
else fit_class:= loose_fit
else fit_class:= decent_fit;
goto found;
end

/*:1844*/
#line 39730 "pdftexdir/pdftex.web"

else if g<0 then
/*1845:*/
#line 39752 "pdftexdir/pdftex.web"

begin if-g> cur_active_width[6]then g:= -cur_active_width[6];
b:= badness(-g,cur_active_width[6]);
if b> 12 then fit_class:= tight_fit else fit_class:= decent_fit;
goto found;
end

/*:1845*/
#line 39733 "pdftexdir/pdftex.web"
;
not_found:end

/*:1843*/
#line 25055 "pdftexdir/pdftex.web"
;
shortfall:= 0;
end;
b:= 0;fit_class:= decent_fit;{infinite stretch}
end
else begin if shortfall> 7230584 then if cur_active_width[2]<1663497 then
begin b:= inf_bad;fit_class:= very_loose_fit;goto done1;
end;
b:= badness(shortfall,cur_active_width[2]);
if b> 12 then
if b> 99 then fit_class:= very_loose_fit
else fit_class:= loose_fit
else fit_class:= decent_fit;
done1:
end

/*:1026*/
#line 25024 "pdftexdir/pdftex.web"

else/*1027:*/
#line 25074 "pdftexdir/pdftex.web"

begin if-shortfall> cur_active_width[6]then b:= inf_bad+1
else b:= badness(-shortfall,cur_active_width[6]);
if b> 12 then fit_class:= tight_fit else fit_class:= decent_fit;
end

/*:1027*/
#line 25026 "pdftexdir/pdftex.web"
;
if do_last_line_fit then/*1846:*/
#line 39762 "pdftexdir/pdftex.web"

begin if cur_p= null then shortfall:= 0;
if shortfall> 0 then g:= cur_active_width[2]
else if shortfall<0 then g:= cur_active_width[6]
else g:= 0;
end

/*:1846*/
#line 25027 "pdftexdir/pdftex.web"
;
found:
if(b> inf_bad)or(pi= eject_penalty)then
/*1028:*/
#line 25089 "pdftexdir/pdftex.web"

begin if final_pass and(minimum_demerits= awful_bad)and
(link(r)= last_active)and
(prev_r= active)then
artificial_demerits:= true{set demerits zero,this break is forced}
else if b> threshold then goto deactivate;
node_r_stays_active:= false;
end

/*:1028*/
#line 25031 "pdftexdir/pdftex.web"

else begin prev_r:= r;
if b> threshold then goto continue;
node_r_stays_active:= true;
end;
/*1029:*/
#line 25105 "pdftexdir/pdftex.web"

if artificial_demerits then d:= 0
else/*1033:*/
#line 25167 "pdftexdir/pdftex.web"

begin d:= line_penalty+b;
if abs(d)>=10000 then d:= 100000000 else d:= d*d;
if pi<> 0 then
if pi> 0 then d:= d+pi*pi
else if pi> eject_penalty then d:= d-pi*pi;
if(break_type= hyphenated)and(type(r)= hyphenated)then
if cur_p<> null then d:= d+double_hyphen_demerits
else d:= d+final_hyphen_demerits;
if abs(fit_class-fitness(r))> 1 then d:= d+adj_demerits;
end

/*:1033*/
#line 25107 "pdftexdir/pdftex.web"
;
stat if tracing_paragraphs> 0 then
/*1030:*/
#line 25121 "pdftexdir/pdftex.web"

begin if printed_node<> cur_p then
/*1031:*/
#line 25144 "pdftexdir/pdftex.web"

begin print_nl("");
if cur_p= null then short_display(link(printed_node))
else begin save_link:= link(cur_p);
link(cur_p):= null;print_nl("");short_display(link(printed_node));
link(cur_p):= save_link;
end;
printed_node:= cur_p;
end

/*:1031*/
#line 25124 "pdftexdir/pdftex.web"
;
print_nl("@");

if cur_p= null then print_esc("par")
else if type(cur_p)<> glue_node then
begin if type(cur_p)= penalty_node then print_esc("penalty")
else if type(cur_p)= disc_node then print_esc("discretionary")
else if type(cur_p)= kern_node then print_esc("kern")
else print_esc("math");
end;
print(" via @@");
if break_node(r)= null then print_char("0")
else print_int(serial(break_node(r)));
print(" b=");
if b> inf_bad then print_char("*")else print_int(b);

print(" p=");print_int(pi);print(" d=");
if artificial_demerits then print_char("*")else print_int(d);
end

/*:1030*/
#line 25109 "pdftexdir/pdftex.web"
;
tats
d:= d+total_demerits(r);{this is the minimum total demerits
from the beginning to|cur_p|via|r|}
if d<=minimal_demerits[fit_class]then
begin minimal_demerits[fit_class]:= d;
best_place[fit_class]:= break_node(r);best_pl_line[fit_class]:= l;
if do_last_line_fit then
/*1847:*/
#line 39772 "pdftexdir/pdftex.web"

begin best_pl_short[fit_class]:= shortfall;best_pl_glue[fit_class]:= g;
end

/*:1847*/
#line 25117 "pdftexdir/pdftex.web"
;
if d<minimum_demerits then minimum_demerits:= d;
end

/*:1029*/
#line 25036 "pdftexdir/pdftex.web"
;
if node_r_stays_active then goto continue;{|prev_r|has been set to|r|}
deactivate:/*1034:*/
#line 25189 "pdftexdir/pdftex.web"

link(prev_r):= link(r);free_node(r,active_node_size);
if prev_r= active then/*1035:*/
#line 25214 "pdftexdir/pdftex.web"

begin r:= link(active);
if type(r)= delta_node then
begin do_all_eight(update_active);
do_all_eight(copy_to_cur_active);
link(active):= link(r);free_node(r,delta_node_size);
end;
end

/*:1035*/
#line 25192 "pdftexdir/pdftex.web"

else if type(prev_r)= delta_node then
begin r:= link(prev_r);
if r= last_active then
begin do_all_eight(downdate_width);
link(prev_prev_r):= last_active;
free_node(prev_r,delta_node_size);prev_r:= prev_prev_r;
end
else if type(r)= delta_node then
begin do_all_eight(update_width);
do_all_eight(combine_two_deltas);
link(prev_r):= link(r);free_node(r,delta_node_size);
end;
end

/*:1034*/
#line 25038 "pdftexdir/pdftex.web"
;
end

/*:1025*/
#line 24533 "pdftexdir/pdftex.web"
;
end;
exit:stat/*1032:*/
#line 25159 "pdftexdir/pdftex.web"

if cur_p= printed_node then if cur_p<> null then if type(cur_p)= disc_node then
begin t:= replace_count(cur_p);
while t> 0 do
begin decr(t);printed_node:= link(printed_node);
end;
end

/*:1032*/
#line 24536 "pdftexdir/pdftex.web"
tats
end;

/*:1003*//*1051:*/
#line 25586 "pdftexdir/pdftex.web"

procedure post_line_break(d:boolean);
label done,done1;
var q,r,s:pointer;{temporary registers for list manipulation}
p,k:pointer;
w:scaled;
glue_break:boolean;{was a break at glue?}
ptmp:pointer;
disc_break:boolean;{was the current break at a discretionary node?}
post_disc_break:boolean;{and did it have a nonempty post-break part?}
cur_width:scaled;{width of line number|cur_line|}
cur_indent:scaled;{left margin of line number|cur_line|}
t:quarterword;{used for replacement counts in discretionary nodes}
pen:integer;{use when calculating penalties between lines}
cur_line:halfword;{the current line number being justified}
LR_ptr:pointer;{stack of LR codes}
begin LR_ptr:= LR_save;
/*1052:*/
#line 25626 "pdftexdir/pdftex.web"

q:= break_node(best_bet);cur_p:= null;
repeat r:= q;q:= prev_break(q);next_break(r):= cur_p;cur_p:= r;
until q= null

/*:1052*/
#line 25604 "pdftexdir/pdftex.web"
;
cur_line:= prev_graf+1;
repeat/*1054:*/
#line 25665 "pdftexdir/pdftex.web"

if TeXXeT_en then
/*1704:*/
#line 37545 "pdftexdir/pdftex.web"

begin q:= link(temp_head);
if LR_ptr<> null then
begin temp_ptr:= LR_ptr;r:= q;
repeat s:= new_math(0,begin_LR_type(info(temp_ptr)));link(s):= r;r:= s;
temp_ptr:= link(temp_ptr);
until temp_ptr= null;
link(temp_head):= r;
end;
while q<> cur_break(cur_p)do
begin if not is_char_node(q)then
if type(q)= math_node then/*1705:*/
#line 37561 "pdftexdir/pdftex.web"

if end_LR(q)then
begin if LR_ptr<> null then if info(LR_ptr)= end_LR_type(q)then pop_LR;
end
else push_LR(q)

/*:1705*/
#line 37556 "pdftexdir/pdftex.web"
;
q:= link(q);
end;
end

/*:1704*/
#line 25668 "pdftexdir/pdftex.web"
;
/*1055:*/
#line 25681 "pdftexdir/pdftex.web"

q:= cur_break(cur_p);disc_break:= false;post_disc_break:= false;
glue_break:= false;
if q<> null then{|q|cannot be a|char_node|}
if type(q)= glue_node then
begin delete_glue_ref(glue_ptr(q));
glue_ptr(q):= right_skip;
subtype(q):= right_skip_code+1;add_glue_ref(right_skip);
glue_break:= true;
goto done;
end
else begin if type(q)= disc_node then
/*1056:*/
#line 25742 "pdftexdir/pdftex.web"

begin t:= replace_count(q);
/*1057:*/
#line 25751 "pdftexdir/pdftex.web"

if t= 0 then r:= link(q)
else begin r:= q;
while t> 1 do
begin r:= link(r);decr(t);
end;
s:= link(r);
r:= link(s);link(s):= null;
flush_node_list(link(q));replace_count(q):= 0;
end

/*:1057*/
#line 25745 "pdftexdir/pdftex.web"
;
if post_break(q)<> null then/*1058:*/
#line 25765 "pdftexdir/pdftex.web"

begin s:= post_break(q);
while link(s)<> null do s:= link(s);
link(s):= r;r:= post_break(q);post_break(q):= null;post_disc_break:= true;
end

/*:1058*/
#line 25746 "pdftexdir/pdftex.web"
;
if pre_break(q)<> null then/*1059:*/
#line 25774 "pdftexdir/pdftex.web"

begin s:= pre_break(q);link(q):= s;
while link(s)<> null do s:= link(s);
pre_break(q):= null;q:= s;
end

/*:1059*/
#line 25747 "pdftexdir/pdftex.web"
;
link(q):= r;disc_break:= true;
end

/*:1056*/
#line 25694 "pdftexdir/pdftex.web"

else if type(q)= kern_node then width(q):= 0
else if type(q)= math_node then
begin width(q):= 0;
if TeXXeT_en then/*1705:*/
#line 37561 "pdftexdir/pdftex.web"

if end_LR(q)then
begin if LR_ptr<> null then if info(LR_ptr)= end_LR_type(q)then pop_LR;
end
else push_LR(q)

/*:1705*/
#line 25698 "pdftexdir/pdftex.web"
;
end;
end
else begin q:= temp_head;
while link(q)<> null do q:= link(q);
end;
done:

{at this point|q|is the rightmost breakpoint;the only exception is the case
of a discretionary break with non-empty|pre_break|,then|q|has been changed
to the last node of the|pre_break|list}

if pdf_protrude_chars> 0 then begin
if disc_break and(is_char_node(q)or(type(q)<> disc_node))
{|q|has been reset to the last node of|pre_break|}
then begin
p:= q;
ptmp:= p;
end else begin
p:= prev_rightmost(link(temp_head),q);{get|link(p)= q|}
ptmp:= p;
p:= find_protchar_right(link(temp_head),p);
end;

short_display_n(p,1);
print_ln;

w:= right_pw(p);
if w<> 0 then{we have found a marginal kern,append it after|ptmp|}
begin
k:= new_margin_kern(-w,last_rightmost_char,right_side);
link(k):= link(ptmp);
link(ptmp):= k;
if(ptmp= q)then
q:= link(q);
end;
end;

{if|q|was not a breakpoint at glue and has been reset to|rightskip|then
we append|rightskip|after|q|now}
if not glue_break then begin
/*1060:*/
#line 25780 "pdftexdir/pdftex.web"

r:= new_param_glue(right_skip_code);link(r):= link(q);link(q):= r;q:= r

/*:1060*/
#line 25739 "pdftexdir/pdftex.web"
;
end;

/*:1055*/
#line 25670 "pdftexdir/pdftex.web"
;
if TeXXeT_en then/*1706:*/
#line 37569 "pdftexdir/pdftex.web"

if LR_ptr<> null then
begin s:= temp_head;r:= link(s);
while r<> q do
begin s:= r;r:= link(s);
end;
r:= LR_ptr;
while r<> null do
begin temp_ptr:= new_math(0,info(r));
link(s):= temp_ptr;s:= temp_ptr;r:= link(r);
end;
link(s):= q;
end

/*:1706*/
#line 25671 "pdftexdir/pdftex.web"
;
/*1061:*/
#line 25787 "pdftexdir/pdftex.web"

r:= link(q);link(q):= null;q:= link(temp_head);link(temp_head):= r;
{at this point|q|is the leftmost node;all discardable nodes have been discarded}
if pdf_protrude_chars> 0 then begin
p:= q;
p:= find_protchar_left(p,false);{no more discardables}
w:= left_pw(p);
if w<> 0 then begin
k:= new_margin_kern(-w,last_leftmost_char,left_side);
link(k):= q;
q:= k;
end;
end;
if left_skip<> zero_glue then
begin r:= new_param_glue(left_skip_code);
link(r):= q;q:= r;
end

/*:1061*/
#line 25672 "pdftexdir/pdftex.web"
;
/*1064:*/
#line 25834 "pdftexdir/pdftex.web"

if cur_line> last_special_line then
begin cur_width:= second_width;cur_indent:= second_indent;
end
else if par_shape_ptr= null then
begin cur_width:= first_width;cur_indent:= first_indent;
end
else begin cur_width:= mem[par_shape_ptr+2*cur_line].sc;
cur_indent:= mem[par_shape_ptr+2*cur_line-1].sc;
end;
adjust_tail:= adjust_head;
pre_adjust_tail:= pre_adjust_head;
if pdf_adjust_spacing> 0 then
just_box:= hpack(q,cur_width,cal_expand_ratio)
else
just_box:= hpack(q,cur_width,exactly);
shift_amount(just_box):= cur_indent

/*:1064*/
#line 25673 "pdftexdir/pdftex.web"
;
/*1063:*/
#line 25812 "pdftexdir/pdftex.web"

if pdf_each_line_height<> pdf_ignored_dimen then
height(just_box):= pdf_each_line_height;
if pdf_each_line_depth<> pdf_ignored_dimen then
depth(just_box):= pdf_each_line_depth;
if(pdf_first_line_height<> pdf_ignored_dimen)and(cur_line= prev_graf+1)then
height(just_box):= pdf_first_line_height;
if(pdf_last_line_depth<> pdf_ignored_dimen)and(cur_line+1= best_line)then
depth(just_box):= pdf_last_line_depth;
if pre_adjust_head<> pre_adjust_tail then
append_list(pre_adjust_head)(pre_adjust_tail);
pre_adjust_tail:= null;
append_to_vlist(just_box);
if adjust_head<> adjust_tail then
append_list(adjust_head)(adjust_tail);
adjust_tail:= null

/*:1063*/
#line 25675 "pdftexdir/pdftex.web"
;
/*1065:*/
#line 25859 "pdftexdir/pdftex.web"

if cur_line+1<> best_line then
begin q:= inter_line_penalties_ptr;
if q<> null then
begin r:= cur_line;
if r> penalty(q)then r:= penalty(q);
pen:= penalty(q+r);
end
else pen:= inter_line_penalty;
q:= club_penalties_ptr;
if q<> null then
begin r:= cur_line-prev_graf;
if r> penalty(q)then r:= penalty(q);
pen:= pen+penalty(q+r);
end
else if cur_line= prev_graf+1 then pen:= pen+club_penalty;
if d then q:= display_widow_penalties_ptr
else q:= widow_penalties_ptr;
if q<> null then
begin r:= best_line-cur_line-1;
if r> penalty(q)then r:= penalty(q);
pen:= pen+penalty(q+r);
end
else if cur_line+2= best_line then
if d then pen:= pen+display_widow_penalty
else pen:= pen+widow_penalty;
if disc_break then pen:= pen+broken_penalty;
if pen<> 0 then
begin r:= new_penalty(pen);
link(tail):= r;tail:= r;
end;
end

/*:1065*/
#line 25676 "pdftexdir/pdftex.web"


/*:1054*/
#line 25608 "pdftexdir/pdftex.web"
;
incr(cur_line);cur_p:= next_break(cur_p);
if cur_p<> null then if not post_disc_break then
/*1053:*/
#line 25638 "pdftexdir/pdftex.web"

begin r:= temp_head;
loop begin q:= link(r);
if q= cur_break(cur_p)then goto done1;
{|cur_break(cur_p)|is the next breakpoint}
{now|q|cannot be|null|}
if is_char_node(q)then goto done1;
if non_discardable(q)then goto done1;
if type(q)= kern_node then if subtype(q)<> explicit then goto done1;
r:= q;{now|type(q)= glue_node|,|kern_node|,|math_node|or|penalty_node|}
if type(q)= math_node then if TeXXeT_en then
/*1705:*/
#line 37561 "pdftexdir/pdftex.web"

if end_LR(q)then
begin if LR_ptr<> null then if info(LR_ptr)= end_LR_type(q)then pop_LR;
end
else push_LR(q)

/*:1705*/
#line 25649 "pdftexdir/pdftex.web"
;
end;
done1:if r<> temp_head then
begin link(r):= null;flush_node_list(link(temp_head));
link(temp_head):= q;
end;
end

/*:1053*/
#line 25611 "pdftexdir/pdftex.web"
;
until cur_p= null;
if(cur_line<> best_line)or(link(temp_head)<> null)then
confusion("line breaking");

prev_graf:= best_line-1;
LR_save:= LR_ptr;
end;

/*:1051*//*1070:*/
#line 25992 "pdftexdir/pdftex.web"

/*1081:*/
#line 26226 "pdftexdir/pdftex.web"

function reconstitute(j,n:small_number;bchar,hchar:halfword):
small_number;
label continue,done;
var p:pointer;{temporary register for list manipulation}
t:pointer;{a node being appended to}
q:four_quarters;{character information or a lig/kern instruction}
cur_rh:halfword;{hyphen character for ligature testing}
test_char:halfword;{hyphen or other character for ligature testing}
w:scaled;{amount of kerning}
k:font_index;{position of current lig/kern instruction}
begin hyphen_passed:= 0;t:= hold_head;w:= 0;link(hold_head):= null;
{at this point|ligature_present= lft_hit= rt_hit= false|}
/*1083:*/
#line 26278 "pdftexdir/pdftex.web"

cur_l:= qi(hu[j]);cur_q:= t;
if j= 0 then
begin ligature_present:= init_lig;p:= init_list;
if ligature_present then lft_hit:= init_lft;
while p> null do
begin append_charnode_to_t(character(p));p:= link(p);
end;
end
else if cur_l<non_char then append_charnode_to_t(cur_l);
lig_stack:= null;set_cur_r

/*:1083*/
#line 26239 "pdftexdir/pdftex.web"
;
continue:/*1084:*/
#line 26294 "pdftexdir/pdftex.web"

if cur_l= non_char then
begin k:= bchar_label[hf];
if k= non_address then goto done else q:= font_info[k].qqqq;
end
else begin q:= char_info(hf)(cur_l);
if char_tag(q)<> lig_tag then goto done;
k:= lig_kern_start(hf)(q);q:= font_info[k].qqqq;
if skip_byte(q)> stop_flag then
begin k:= lig_kern_restart(hf)(q);q:= font_info[k].qqqq;
end;
end;{now|k|is the starting address of the lig/kern program}
if cur_rh<non_char then test_char:= cur_rh else test_char:= cur_r;
loop begin if next_char(q)= test_char then if skip_byte(q)<=stop_flag then
if cur_rh<non_char then
begin hyphen_passed:= j;hchar:= non_char;cur_rh:= non_char;
goto continue;
end
else begin if hchar<non_char then if odd(hyf[j])then
begin hyphen_passed:= j;hchar:= non_char;
end;
if op_byte(q)<kern_flag then
/*1086:*/
#line 26357 "pdftexdir/pdftex.web"

begin if cur_l= non_char then lft_hit:= true;
if j= n then if lig_stack= null then rt_hit:= true;
check_interrupt;{allow a way out in case there's an infinite ligature loop}
case op_byte(q)of
qi(1),qi(5):begin cur_l:= rem_byte(q);{\.{= :\?},\.{= :\?> }}
ligature_present:= true;
end;
qi(2),qi(6):begin cur_r:= rem_byte(q);{\.{\?= :},\.{\?= :> }}
if lig_stack> null then character(lig_stack):= cur_r
else begin lig_stack:= new_lig_item(cur_r);
if j= n then bchar:= non_char
else begin p:= get_avail;lig_ptr(lig_stack):= p;
character(p):= qi(hu[j+1]);font(p):= hf;
end;
end;
end;
qi(3):begin cur_r:= rem_byte(q);{\.{\?= :\?}}
p:= lig_stack;lig_stack:= new_lig_item(cur_r);link(lig_stack):= p;
end;
qi(7),qi(11):begin wrap_lig(false);{\.{\?= :\?> },\.{\?= :\?>>}}
cur_q:= t;cur_l:= rem_byte(q);ligature_present:= true;
end;
othercases begin cur_l:= rem_byte(q);ligature_present:= true;{\.{= :}}
if lig_stack> null then pop_lig_stack
else if j= n then goto done
else begin append_charnode_to_t(cur_r);incr(j);set_cur_r;
end;
end
endcases;
if op_byte(q)> qi(4)then if op_byte(q)<> qi(7)then goto done;
goto continue;
end

/*:1086*/
#line 26318 "pdftexdir/pdftex.web"
;
w:= char_kern(hf)(q);goto done;{this kern will be inserted below}
end;
if skip_byte(q)>=stop_flag then
if cur_rh= non_char then goto done
else begin cur_rh:= non_char;goto continue;
end;
k:= k+qo(skip_byte(q))+1;q:= font_info[k].qqqq;
end;
done:

/*:1084*/
#line 26241 "pdftexdir/pdftex.web"
;
/*1085:*/
#line 3616 "pdftex-final.ch"

#line 26348 "pdftexdir/pdftex.web"
wrap_lig(rt_hit);
#line 3623 "pdftex-final.ch"
if w<> 0 then
begin link(t):= new_kern(w);t:= link(t);w:= 0;
sync_tag(t+medium_node_size):= 0;{{\sl Sync\TeX}:do nothing,it is too late}
#line 26351 "pdftexdir/pdftex.web"
end;
if lig_stack> null then
begin cur_q:= t;cur_l:= character(lig_stack);ligature_present:= true;
pop_lig_stack;goto continue;
end

/*:1085*/
#line 26243 "pdftexdir/pdftex.web"
;
reconstitute:= j;
end;

/*:1081*/
#line 25993 "pdftexdir/pdftex.web"

procedure hyphenate;
label common_ending,done,found,found1,found2,not_found,exit;
var/*1076:*/
#line 26105 "pdftexdir/pdftex.web"

i,j,l:0. .65;{indices into|hc|or|hu|}
q,r,s:pointer;{temporary registers for list manipulation}
bchar:halfword;{right boundary character of hyphenated word,or|non_char|}

/*:1076*//*1087:*/
#line 26400 "pdftexdir/pdftex.web"

major_tail,minor_tail:pointer;{the end of lists in the main and
discretionary branches being reconstructed}
c:ASCII_code;{character temporarily replaced by a hyphen}
c_loc:0. .63;{where that character came from}
r_count:integer;{replacement count for discretionary}
hyf_node:pointer;{the hyphen,if it exists}

/*:1087*//*1097:*/
#line 26577 "pdftexdir/pdftex.web"

z:trie_pointer;{an index into|trie|}
v:integer;{an index into|hyf_distance|,etc.}

/*:1097*//*1104:*/
#line 26649 "pdftexdir/pdftex.web"

h:hyph_pointer;{an index into|hyph_word|and|hyph_list|}
k:str_number;{an index into|str_start|}
u:pool_pointer;{an index into|str_pool|}

/*:1104*/
#line 25996 "pdftexdir/pdftex.web"

begin/*1098:*/
#line 26586 "pdftexdir/pdftex.web"

for j:= 0 to hn do hyf[j]:= 0;
/*1105:*/
#line 26658 "pdftexdir/pdftex.web"

#line 3766 "pdftex-final.ch"
h:= hc[1];incr(hn);hc[hn]:= cur_lang;
for j:= 2 to hn do h:= (h+h+hc[j])mod hyph_prime;
loop begin/*1106:*/
#line 3782 "pdftex-final.ch"

{This is now a simple hash list,not an ordered one,so
the module title is no longer descriptive.}
k:= hyph_word[h];if k= 0 then goto not_found;
#line 26671 "pdftexdir/pdftex.web"
if length(k)= hn then
begin j:= 1;u:= str_start[k];
#line 3792 "pdftex-final.ch"
repeat
if so(str_pool[u])<> hc[j]then goto done;
#line 26675 "pdftexdir/pdftex.web"
incr(j);incr(u);
until j> hn;
/*1107:*/
#line 26682 "pdftexdir/pdftex.web"

s:= hyph_list[h];
while s<> null do
begin hyf[info(s)]:= 1;s:= link(s);
end

/*:1107*/
#line 26677 "pdftexdir/pdftex.web"
;
decr(hn);goto found;
end;
done:

/*:1106*/
#line 3770 "pdftex-final.ch"
;
h:= hyph_link[h];if h= 0 then goto not_found;
decr(h);
end;
not_found:decr(hn)
#line 26667 "pdftexdir/pdftex.web"

#line 3782 "pdftex-final.ch"
/*:1105*/
#line 26589 "pdftexdir/pdftex.web"
;
if trie_char(cur_lang+1)<> qi(cur_lang)then return;{no patterns for|cur_lang|}
hc[0]:= 0;hc[hn+1]:= 0;hc[hn+2]:= 256;{insert delimiters}
for j:= 0 to hn-r_hyf+1 do
begin z:= trie_link(cur_lang+1)+hc[j];l:= j;
while hc[l]= qo(trie_char(z))do
#line 3701 "pdftex-final.ch"
 begin if trie_op(z)<> min_trie_op then
#line 26596 "pdftexdir/pdftex.web"
/*1099:*/
#line 26603 "pdftexdir/pdftex.web"

begin v:= trie_op(z);
repeat v:= v+op_start[cur_lang];i:= l-hyf_distance[v];
if hyf_num[v]> hyf[i]then hyf[i]:= hyf_num[v];
v:= hyf_next[v];
#line 3707 "pdftex-final.ch"
until v= min_trie_op;
#line 26609 "pdftexdir/pdftex.web"
end

/*:1099*/
#line 26596 "pdftexdir/pdftex.web"
;
incr(l);z:= trie_link(z)+hc[l];
end;
end;
found:for j:= 0 to l_hyf-1 do hyf[j]:= 0;
for j:= 0 to r_hyf-1 do hyf[hn-j]:= 0

/*:1098*/
#line 25997 "pdftexdir/pdftex.web"
;
/*1077:*/
#line 26117 "pdftexdir/pdftex.web"

for j:= l_hyf to hn-r_hyf do if odd(hyf[j])then goto found1;
return;
found1:

/*:1077*/
#line 25998 "pdftexdir/pdftex.web"
;
/*1078:*/
#line 26133 "pdftexdir/pdftex.web"

q:= link(hb);link(hb):= null;r:= link(ha);link(ha):= null;bchar:= hyf_bchar;
if is_char_node(ha)then
if font(ha)<> hf then goto found2
else begin init_list:= ha;init_lig:= false;hu[0]:= qo(character(ha));
end
else if type(ha)= ligature_node then
if font(lig_char(ha))<> hf then goto found2
else begin init_list:= lig_ptr(ha);init_lig:= true;init_lft:= (subtype(ha)> 1);
hu[0]:= qo(character(lig_char(ha)));
if init_list= null then if init_lft then
begin hu[0]:= 256;init_lig:= false;
end;{in this case a ligature will be reconstructed from scratch}
free_node(ha,small_node_size);
end
else begin{no punctuation found;look for left boundary}
if not is_char_node(r)then if type(r)= ligature_node then
if subtype(r)> 1 then goto found2;
j:= 1;s:= ha;init_list:= null;goto common_ending;
end;
s:= cur_p;{we have|cur_p<> ha|because|type(cur_p)= glue_node|}
while link(s)<> ha do s:= link(s);
j:= 0;goto common_ending;
found2:s:= ha;j:= 0;hu[0]:= 256;init_lig:= false;init_list:= null;
common_ending:flush_node_list(r);
/*1088:*/
#line 26410 "pdftexdir/pdftex.web"

repeat l:= j;j:= reconstitute(j,hn,bchar,qi(hyf_char))+1;
if hyphen_passed= 0 then
begin link(s):= link(hold_head);
while link(s)> null do s:= link(s);
if odd(hyf[j-1])then
begin l:= j;hyphen_passed:= j-1;link(hold_head):= null;
end;
end;
if hyphen_passed> 0 then
/*1089:*/
#line 26436 "pdftexdir/pdftex.web"

repeat r:= get_node(small_node_size);
link(r):= link(hold_head);type(r):= disc_node;
major_tail:= r;r_count:= 0;
while link(major_tail)> null do advance_major_tail;
i:= hyphen_passed;hyf[i]:= 0;
/*1090:*/
#line 26453 "pdftexdir/pdftex.web"

minor_tail:= null;pre_break(r):= null;hyf_node:= new_character(hf,hyf_char);
if hyf_node<> null then
begin incr(i);c:= hu[i];hu[i]:= hyf_char;free_avail(hyf_node);
end;
while l<=i do
begin l:= reconstitute(l,i,font_bchar[hf],non_char)+1;
if link(hold_head)> null then
begin if minor_tail= null then pre_break(r):= link(hold_head)
else link(minor_tail):= link(hold_head);
minor_tail:= link(hold_head);
while link(minor_tail)> null do minor_tail:= link(minor_tail);
end;
end;
if hyf_node<> null then
begin hu[i]:= c;{restore the character in the hyphen position}
l:= i;decr(i);
end

/*:1090*/
#line 26442 "pdftexdir/pdftex.web"
;
/*1091:*/
#line 26474 "pdftexdir/pdftex.web"

minor_tail:= null;post_break(r):= null;c_loc:= 0;
if bchar_label[hf]<> non_address then{put left boundary at beginning of new line}
begin decr(l);c:= hu[l];c_loc:= l;hu[l]:= 256;
end;
while l<j do
begin repeat l:= reconstitute(l,hn,bchar,non_char)+1;
if c_loc> 0 then
begin hu[c_loc]:= c;c_loc:= 0;
end;
if link(hold_head)> null then
begin if minor_tail= null then post_break(r):= link(hold_head)
else link(minor_tail):= link(hold_head);
minor_tail:= link(hold_head);
while link(minor_tail)> null do minor_tail:= link(minor_tail);
end;
until l>=j;
while l> j do
/*1092:*/
#line 26495 "pdftexdir/pdftex.web"

begin j:= reconstitute(j,hn,bchar,non_char)+1;
link(major_tail):= link(hold_head);
while link(major_tail)> null do advance_major_tail;
end

/*:1092*/
#line 26492 "pdftexdir/pdftex.web"
;
end

/*:1091*/
#line 26444 "pdftexdir/pdftex.web"
;
/*1093:*/
#line 26505 "pdftexdir/pdftex.web"

if r_count> 127 then{we have to forget the discretionary hyphen}
begin link(s):= link(r);link(r):= null;flush_node_list(r);
end
else begin link(s):= r;replace_count(r):= r_count;
end;
s:= major_tail

/*:1093*/
#line 26446 "pdftexdir/pdftex.web"
;
hyphen_passed:= j-1;link(hold_head):= null;
until not odd(hyf[j-1])

/*:1089*/
#line 26422 "pdftexdir/pdftex.web"
;
until j> hn;
link(s):= q

/*:1088*/
#line 26158 "pdftexdir/pdftex.web"
;
flush_list(init_list)

/*:1078*/
#line 26000 "pdftexdir/pdftex.web"
;
exit:end;

/*:1070*//*1117:*/
#line 26822 "pdftexdir/pdftex.web"

init/*1119:*/
#line 26867 "pdftexdir/pdftex.web"

#line 3926 "pdftex-final.ch"
 function new_trie_op(d,n:small_number;v:trie_opcode):trie_opcode;
label exit;
var h:neg_trie_op_size..trie_op_size;{trial hash location}
u:trie_opcode;{trial op code}
#line 26872 "pdftexdir/pdftex.web"
l:0..trie_op_size;{pointer to stored data}
#line 3936 "pdftex-final.ch"
begin h:= abs(n+313*d+361*v+1009*cur_lang)mod(trie_op_size-neg_trie_op_size)
+neg_trie_op_size;
#line 26875 "pdftexdir/pdftex.web"
loop begin l:= trie_op_hash[h];
if l= 0 then{empty position found for a new op}
begin if trie_op_ptr= trie_op_size then
overflow("pattern memory ops",trie_op_size);
u:= trie_used[cur_lang];
#line 3946 "pdftex-final.ch"
if u= max_trie_op then
overflow("pattern memory ops per language",
max_trie_op-min_trie_op);
incr(trie_op_ptr);incr(u);trie_used[cur_lang]:= u;
if u> max_op_used then max_op_used:= u;
#line 26884 "pdftexdir/pdftex.web"
hyf_distance[trie_op_ptr]:= d;
hyf_num[trie_op_ptr]:= n;hyf_next[trie_op_ptr]:= v;
trie_op_lang[trie_op_ptr]:= cur_lang;trie_op_hash[h]:= trie_op_ptr;
trie_op_val[trie_op_ptr]:= u;new_trie_op:= u;return;
end;
if(hyf_distance[l]= d)and(hyf_num[l]= n)and(hyf_next[l]= v)
and(trie_op_lang[l]= cur_lang)then
begin new_trie_op:= trie_op_val[l];return;
end;
if h> -trie_op_size then decr(h)else h:= trie_op_size;
end;
exit:end;

/*:1119*//*1123:*/
#line 26968 "pdftexdir/pdftex.web"

function trie_node(p:trie_pointer):trie_pointer;{converts
to a canonical form}
label exit;
var h:trie_pointer;{trial hash location}
q:trie_pointer;{trial trie node}
begin h:= abs(trie_c[p]+1009*trie_o[p]+
2718*trie_l[p]+3142*trie_r[p])mod trie_size;
loop begin q:= trie_hash[h];
if q= 0 then
begin trie_hash[h]:= p;trie_node:= p;return;
end;
if(trie_c[q]= trie_c[p])and(trie_o[q]= trie_o[p])and
(trie_l[q]= trie_l[p])and(trie_r[q]= trie_r[p])then
begin trie_node:= q;return;
end;
if h> 0 then decr(h)else h:= trie_size;
end;
exit:end;

/*:1123*//*1124:*/
#line 26994 "pdftexdir/pdftex.web"

function compress_trie(p:trie_pointer):trie_pointer;
begin if p= 0 then compress_trie:= 0
else begin trie_l[p]:= compress_trie(trie_l[p]);
trie_r[p]:= compress_trie(trie_r[p]);
compress_trie:= trie_node(p);
end;
end;

/*:1124*//*1128:*/
#line 27065 "pdftexdir/pdftex.web"

procedure first_fit(p:trie_pointer);{packs a family into|trie|}
label not_found,found;
var h:trie_pointer;{candidate for|trie_ref[p]|}
z:trie_pointer;{runs through holes}
q:trie_pointer;{runs through the family starting at|p|}
c:ASCII_code;{smallest character in the family}
l,r:trie_pointer;{left and right neighbors}
ll:1. .256;{upper limit of|trie_min|updating}
begin c:= so(trie_c[p]);
z:= trie_min[c];{get the first conceivably good hole}
loop begin h:= z-c;
/*1129:*/
#line 27090 "pdftexdir/pdftex.web"

if trie_max<h+256 then
begin if trie_size<=h+256 then overflow("pattern memory",trie_size);

repeat incr(trie_max);trie_taken[trie_max]:= false;
trie_link(trie_max):= trie_max+1;trie_back(trie_max):= trie_max-1;
until trie_max= h+256;
end

/*:1129*/
#line 27077 "pdftexdir/pdftex.web"
;
if trie_taken[h]then goto not_found;
/*1130:*/
#line 27099 "pdftexdir/pdftex.web"

q:= trie_r[p];
while q> 0 do
begin if trie_link(h+so(trie_c[q]))= 0 then goto not_found;
q:= trie_r[q];
end;
goto found

/*:1130*/
#line 27080 "pdftexdir/pdftex.web"
;
not_found:z:= trie_link(z);{move to the next hole}
end;
found:/*1131:*/
#line 27107 "pdftexdir/pdftex.web"

trie_taken[h]:= true;trie_ref[p]:= h;q:= p;
repeat z:= h+so(trie_c[q]);l:= trie_back(z);r:= trie_link(z);
trie_back(r):= l;trie_link(l):= r;trie_link(z):= 0;
if l<256 then
begin if z<256 then ll:= z else ll:= 256;
repeat trie_min[l]:= r;incr(l);
until l= ll;
end;
q:= trie_r[q];
until q= 0

/*:1131*/
#line 27083 "pdftexdir/pdftex.web"
;
end;

/*:1128*//*1132:*/
#line 27122 "pdftexdir/pdftex.web"

procedure trie_pack(p:trie_pointer);{pack subtries of a family}
var q:trie_pointer;{a local variable that need not be saved on recursive calls}
begin repeat q:= trie_l[p];
if(q> 0)and(trie_ref[q]= 0)then
begin first_fit(q);trie_pack(q);
end;
p:= trie_r[p];
until p= 0;
end;

/*:1132*//*1134:*/
#line 27159 "pdftexdir/pdftex.web"

procedure trie_fix(p:trie_pointer);{moves|p|and its siblings into|trie|}
var q:trie_pointer;{a local variable that need not be saved on recursive calls}
c:ASCII_code;{another one that need not be saved}
z:trie_pointer;{|trie|reference;this local variable must be saved}
begin z:= trie_ref[p];
repeat q:= trie_l[p];c:= so(trie_c[p]);
trie_link(z+c):= trie_ref[q];trie_char(z+c):= qi(c);trie_op(z+c):= trie_o[p];
if q> 0 then trie_fix(q);
p:= trie_r[p];
until p= 0;
end;

/*:1134*//*1135:*/
#line 27176 "pdftexdir/pdftex.web"

procedure new_patterns;{initializes the hyphenation pattern data}
label done,done1;
var k,l:0. .64;{indices into|hc|and|hyf|;
not always in|small_number|range}
digit_sensed:boolean;{should the next digit be treated as a letter?}
#line 4059 "pdftex-final.ch"
v:trie_opcode;{trie op code}
#line 27183 "pdftexdir/pdftex.web"
p,q:trie_pointer;{nodes of trie traversed during insertion}
first_child:boolean;{is|p= trie_l[q]|?}
c:ASCII_code;{character being inserted}
begin if trie_not_ready then
begin set_cur_lang;scan_left_brace;{a left brace must follow\.{\\patterns}}
/*1136:*/
#line 27203 "pdftexdir/pdftex.web"

k:= 0;hyf[0]:= 0;digit_sensed:= false;
loop begin get_x_token;
case cur_cmd of
letter,other_char:/*1137:*/
#line 27221 "pdftexdir/pdftex.web"

if digit_sensed or(cur_chr<"0")or(cur_chr> "9")then
begin if cur_chr= "."then cur_chr:= 0{edge-of-word delimiter}
else begin cur_chr:= lc_code(cur_chr);
if cur_chr= 0 then
begin print_err("Nonletter");

help1("(See Appendix H.)");error;
end;
end;
if k<63 then
begin incr(k);hc[k]:= cur_chr;hyf[k]:= 0;digit_sensed:= false;
end;
end
else if k<63 then
begin hyf[k]:= cur_chr-"0";digit_sensed:= true;
end

/*:1137*/
#line 27207 "pdftexdir/pdftex.web"
;
spacer,right_brace:begin if k> 0 then
/*1138:*/
#line 27243 "pdftexdir/pdftex.web"

begin/*1140:*/
#line 27272 "pdftexdir/pdftex.web"

if hc[1]= 0 then hyf[0]:= 0;
if hc[k]= 0 then hyf[k]:= 0;
#line 4077 "pdftex-final.ch"
l:= k;v:= min_trie_op;
#line 27276 "pdftexdir/pdftex.web"
loop begin if hyf[l]<> 0 then v:= new_trie_op(k-l,hyf[l],v);
if l> 0 then decr(l)else goto done1;
end;
done1:

/*:1140*/
#line 27244 "pdftexdir/pdftex.web"
;
q:= 0;hc[0]:= cur_lang;
while l<=k do
begin c:= hc[l];incr(l);p:= trie_l[q];first_child:= true;
while(p> 0)and(c> so(trie_c[p]))do
begin q:= p;p:= trie_r[q];first_child:= false;
end;
if(p= 0)or(c<so(trie_c[p]))then
/*1139:*/
#line 27264 "pdftexdir/pdftex.web"

begin if trie_ptr= trie_size then overflow("pattern memory",trie_size);

incr(trie_ptr);trie_r[trie_ptr]:= p;p:= trie_ptr;trie_l[p]:= 0;
if first_child then trie_l[q]:= p else trie_r[q]:= p;
#line 4071 "pdftex-final.ch"
trie_c[p]:= si(c);trie_o[p]:= min_trie_op;
#line 27270 "pdftexdir/pdftex.web"
end

/*:1139*/
#line 27253 "pdftexdir/pdftex.web"
;
q:= p;{now node|q|represents $p_1\ldots p_{l-1}$}
end;
#line 4065 "pdftex-final.ch"
if trie_o[q]<> min_trie_op then
#line 27257 "pdftexdir/pdftex.web"
 begin print_err("Duplicate pattern");

help1("(See Appendix H.)");error;
end;
trie_o[q]:= v;
end

/*:1138*/
#line 27209 "pdftexdir/pdftex.web"
;
if cur_cmd= right_brace then goto done;
k:= 0;hyf[0]:= 0;digit_sensed:= false;
end;
othercases begin print_err("Bad ");print_esc("patterns");

help1("(See Appendix H.)");error;
end
endcases;
end;
done:

/*:1136*/
#line 27189 "pdftexdir/pdftex.web"
;
if saving_hyph_codes> 0 then
/*1852:*/
#line 39817 "pdftexdir/pdftex.web"

begin c:= cur_lang;first_child:= false;p:= 0;
repeat q:= p;p:= trie_r[q];
until(p= 0)or(c<=so(trie_c[p]));
if(p= 0)or(c<so(trie_c[p]))then
/*1139:*/
#line 27264 "pdftexdir/pdftex.web"

begin if trie_ptr= trie_size then overflow("pattern memory",trie_size);

incr(trie_ptr);trie_r[trie_ptr]:= p;p:= trie_ptr;trie_l[p]:= 0;
if first_child then trie_l[q]:= p else trie_r[q]:= p;
#line 4071 "pdftex-final.ch"
trie_c[p]:= si(c);trie_o[p]:= min_trie_op;
#line 27270 "pdftexdir/pdftex.web"
end

/*:1139*/
#line 39823 "pdftexdir/pdftex.web"
;
q:= p;{now node|q|represents|cur_lang|}
/*1853:*/
#line 39833 "pdftexdir/pdftex.web"

p:= trie_l[q];first_child:= true;
for c:= 0 to 255 do
if(lc_code(c)> 0)or((c= 255)and first_child)then
begin if p= 0 then
/*1139:*/
#line 27264 "pdftexdir/pdftex.web"

begin if trie_ptr= trie_size then overflow("pattern memory",trie_size);

incr(trie_ptr);trie_r[trie_ptr]:= p;p:= trie_ptr;trie_l[p]:= 0;
if first_child then trie_l[q]:= p else trie_r[q]:= p;
#line 4071 "pdftex-final.ch"
trie_c[p]:= si(c);trie_o[p]:= min_trie_op;
#line 27270 "pdftexdir/pdftex.web"
end

/*:1139*/
#line 39839 "pdftexdir/pdftex.web"

else trie_c[p]:= si(c);
trie_o[p]:= qi(lc_code(c));
q:= p;p:= trie_r[q];first_child:= false;
end;
if first_child then trie_l[q]:= 0 else trie_r[q]:= 0

/*:1853*/
#line 39825 "pdftexdir/pdftex.web"
;
end

/*:1852*/
#line 27191 "pdftexdir/pdftex.web"
;
end
else begin print_err("Too late for ");print_esc("patterns");
help1("All patterns must be given before typesetting begins.");
error;link(garbage):= scan_toks(false,false);flush_list(def_ref);
end;
end;

/*:1135*//*1141:*/
#line 27288 "pdftexdir/pdftex.web"

procedure init_trie;
var p:trie_pointer;{pointer for initialization}
j,k,t:integer;{all-purpose registers for initialization}
r,s:trie_pointer;{used to clean up the packed|trie|}
#line 27294 "pdftexdir/pdftex.web"
begin/*1127:*/
#line 27049 "pdftexdir/pdftex.web"

/*1120:*/
#line 26901 "pdftexdir/pdftex.web"

#line 3956 "pdftex-final.ch"
op_start[0]:= -min_trie_op;
#line 26903 "pdftexdir/pdftex.web"
for j:= 1 to 255 do op_start[j]:= op_start[j-1]+qo(trie_used[j-1]);
for j:= 1 to trie_op_ptr do
trie_op_hash[j]:= op_start[trie_op_lang[j]]+trie_op_val[j];{destination}
for j:= 1 to trie_op_ptr do while trie_op_hash[j]> j do
begin k:= trie_op_hash[j];
t:= hyf_distance[k];hyf_distance[k]:= hyf_distance[j];hyf_distance[j]:= t;
t:= hyf_num[k];hyf_num[k]:= hyf_num[j];hyf_num[j]:= t;
t:= hyf_next[k];hyf_next[k]:= hyf_next[j];hyf_next[j]:= t;
trie_op_hash[j]:= trie_op_hash[k];trie_op_hash[k]:= k;
end

/*:1120*/
#line 27050 "pdftexdir/pdftex.web"
;
for p:= 0 to trie_size do trie_hash[p]:= 0;
hyph_root:= compress_trie(hyph_root);
trie_root:= compress_trie(trie_root);{identify equivalent subtries}
for p:= 0 to trie_ptr do trie_ref[p]:= 0;
for p:= 0 to 255 do trie_min[p]:= p+1;
trie_link(0):= 1;trie_max:= 0

/*:1127*/
#line 27294 "pdftexdir/pdftex.web"
;
if trie_root<> 0 then
begin first_fit(trie_root);trie_pack(trie_root);
end;
if hyph_root<> 0 then/*1854:*/
#line 39849 "pdftexdir/pdftex.web"

begin if trie_root= 0 then for p:= 0 to 255 do trie_min[p]:= p+2;
first_fit(hyph_root);trie_pack(hyph_root);
hyph_start:= trie_ref[hyph_root];
end

/*:1854*/
#line 27298 "pdftexdir/pdftex.web"
;
/*1133:*/
#line 4041 "pdftex-final.ch"

#line 27141 "pdftexdir/pdftex.web"
if trie_max= 0 then{no patterns were given}
#line 4047 "pdftex-final.ch"
begin for r:= 0 to 256 do clear_trie;
#line 27143 "pdftexdir/pdftex.web"
trie_max:= 256;
end
else begin if hyph_root> 0 then trie_fix(hyph_root);
if trie_root> 0 then trie_fix(trie_root);{this fixes the non-holes in|trie|}
r:= 0;{now we will zero out all the holes}
#line 4053 "pdftex-final.ch"
repeat s:= trie_link(r);clear_trie;r:= s;
#line 27149 "pdftexdir/pdftex.web"
until r> trie_max;
end;
trie_char(0):= qi("?");{make|trie_char(c)<> c|for all|c|}

/*:1133*/
#line 27299 "pdftexdir/pdftex.web"
;
trie_not_ready:= false;
end;

/*:1141*/
#line 26823 "pdftexdir/pdftex.web"

tini

/*:1117*/
#line 24003 "pdftexdir/pdftex.web"

procedure line_break(d:boolean);
label done,done1,done2,done3,done4,done5,continue;
var/*1036:*/
#line 25243 "pdftexdir/pdftex.web"

q,r,s,prev_s:pointer;{miscellaneous nodes of temporary interest}
f:internal_font_number;{used when calculating character widths}

/*:1036*//*1068:*/
#line 25972 "pdftexdir/pdftex.web"

j:small_number;{an index into|hc|or|hu|}
c:0. .255;{character being considered for hyphenation}

/*:1068*/
#line 24006 "pdftexdir/pdftex.web"

begin pack_begin_line:= mode_line;{this is for over/underfull box messages}
/*990:*/
#line 24029 "pdftexdir/pdftex.web"

link(temp_head):= link(head);
if is_char_node(tail)then tail_append(new_penalty(inf_penalty))
else if type(tail)<> glue_node then tail_append(new_penalty(inf_penalty))
else begin type(tail):= penalty_node;delete_glue_ref(glue_ptr(tail));
flush_node_list(leader_ptr(tail));penalty(tail):= inf_penalty;
end;
link(tail):= new_param_glue(par_fill_skip_code);
last_line_fill:= link(tail);
init_cur_lang:= prev_graf mod 50
init_l_hyf:= prev_graf div 50
init_r_hyf:= (prev_graf div 50 100;
pop_nest;

/*:990*//*1001:*/
#line 24286 "pdftexdir/pdftex.web"

no_shrink_error_yet:= true;
check_shrinkage(left_skip);check_shrinkage(right_skip);
q:= left_skip;r:= right_skip;background[1]:= width(q)+width(r);
background[2]:= 0;background[3]:= 0;background[4]:= 0;background[5]:= 0;
background[2+stretch_order(q)]:= stretch(q);
background[2+stretch_order(r)]:= background[2+stretch_order(r)]+stretch(r);
background[6]:= shrink(q)+shrink(r);
if pdf_adjust_spacing> 1 then begin
background[7]:= 0;
background[8]:= 0;
max_stretch_ratio:= -1;
max_shrink_ratio:= -1;
cur_font_step:= -1;
prev_char_p:= null;
end;
/*1840:*/
#line 39683 "pdftexdir/pdftex.web"

do_last_line_fit:= false;active_node_size:= active_node_size_normal;
{just in case}
if last_line_fit> 0 then
begin q:= glue_ptr(last_line_fill);
if(stretch(q)> 0)and(stretch_order(q)> normal)then
if(background[3]= 0)and(background[4]= 0)and(background[5]= 0)then
begin do_last_line_fit:= true;
active_node_size:= active_node_size_extended;
fill_width[0]:= 0;fill_width[1]:= 0;fill_width[2]:= 0;
fill_width[stretch_order(q)-1]:= stretch(q);
end;
end

/*:1840*/
#line 24302 "pdftexdir/pdftex.web"
;

/*:1001*//*1008:*/
#line 24597 "pdftexdir/pdftex.web"

minimum_demerits:= awful_bad;
minimal_demerits[tight_fit]:= awful_bad;
minimal_demerits[decent_fit]:= awful_bad;
minimal_demerits[loose_fit]:= awful_bad;
minimal_demerits[very_loose_fit]:= awful_bad;

/*:1008*//*1022:*/
#line 24927 "pdftexdir/pdftex.web"

if par_shape_ptr= null then
if hang_indent= 0 then
begin last_special_line:= 0;second_width:= hsize;
second_indent:= 0;
end
else/*1023:*/
#line 24941 "pdftexdir/pdftex.web"

begin last_special_line:= abs(hang_after);
if hang_after<0 then
begin first_width:= hsize-abs(hang_indent);
if hang_indent>=0 then first_indent:= hang_indent
else first_indent:= 0;
second_width:= hsize;second_indent:= 0;
end
else begin first_width:= hsize;first_indent:= 0;
second_width:= hsize-abs(hang_indent);
if hang_indent>=0 then second_indent:= hang_indent
else second_indent:= 0;
end;
end

/*:1023*/
#line 24933 "pdftexdir/pdftex.web"

else begin last_special_line:= info(par_shape_ptr)-1;
second_width:= mem[par_shape_ptr+2*(last_special_line+1)].sc;
second_indent:= mem[par_shape_ptr+2*last_special_line+1].sc;
end;
if looseness= 0 then easy_line:= last_special_line
else easy_line:= max_halfword

/*:1022*/
#line 24008 "pdftexdir/pdftex.web"
;
/*1037:*/
#line 25251 "pdftexdir/pdftex.web"

threshold:= pretolerance;
if threshold>=0 then
begin stat if tracing_paragraphs> 0 then
begin begin_diagnostic;print_nl("@firstpass");end;tats
second_pass:= false;final_pass:= false;
end
else begin threshold:= tolerance;second_pass:= true;
final_pass:= (emergency_stretch<=0);
stat if tracing_paragraphs> 0 then begin_diagnostic;tats
end;
loop begin if threshold> inf_bad then threshold:= inf_bad;
if second_pass then/*1066:*/
#line 25948 "pdftexdir/pdftex.web"

begin init if trie_not_ready then init_trie;tini
cur_lang:= init_cur_lang;l_hyf:= init_l_hyf;r_hyf:= init_r_hyf;
set_hyph_index;
end

/*:1066*/
#line 25263 "pdftexdir/pdftex.web"
;
/*1038:*/
#line 25303 "pdftexdir/pdftex.web"

q:= get_node(active_node_size);
type(q):= unhyphenated;fitness(q):= decent_fit;
link(q):= last_active;break_node(q):= null;
line_number(q):= prev_graf+1;total_demerits(q):= 0;link(active):= q;
if do_last_line_fit then
/*1842:*/
#line 39703 "pdftexdir/pdftex.web"

begin active_short(q):= 0;active_glue(q):= 0;
end

/*:1842*/
#line 25309 "pdftexdir/pdftex.web"
;
do_all_eight(store_background);
passive:= null;printed_node:= temp_head;pass_number:= 0;
font_in_short_display:= null_font

/*:1038*/
#line 25264 "pdftexdir/pdftex.web"
;
cur_p:= link(temp_head);auto_breaking:= true;
prev_p:= cur_p;{glue at beginning is not a legal breakpoint}
prev_char_p:= null;
prev_legal:= null;
rejected_cur_p:= null;
try_prev_break:= false;
before_rejected_cur_p:= false;
first_p:= cur_p;{to access the first node of paragraph as the first active
node has|break_node= null|}
while(cur_p<> null)and(link(active)<> last_active)do
/*1040:*/
#line 25341 "pdftexdir/pdftex.web"

begin if is_char_node(cur_p)then
/*1041:*/
#line 25388 "pdftexdir/pdftex.web"

begin prev_p:= cur_p;
repeat f:= font(cur_p);
act_width:= act_width+char_width(f)(char_info(f)(character(cur_p)));
if(pdf_adjust_spacing> 1)and check_expand_pars(f)then begin
prev_char_p:= cur_p;
add_char_stretch(active_width[7])(character(cur_p));
add_char_shrink(active_width[8])(character(cur_p));
end;
cur_p:= link(cur_p);
until not is_char_node(cur_p);
end

/*:1041*/
#line 25344 "pdftexdir/pdftex.web"
;
case type(cur_p)of
hlist_node,vlist_node,rule_node:act_width:= act_width+width(cur_p);
whatsit_node:/*1606:*/
#line 35677 "pdftexdir/pdftex.web"

begin
adv_past(cur_p);
if(subtype(cur_p)= pdf_refxform_node)or(subtype(cur_p)= pdf_refximage_node)then
act_width:= act_width+pdf_width(cur_p);
end

/*:1606*/
#line 25347 "pdftexdir/pdftex.web"
;
glue_node:begin/*1042:*/
#line 25404 "pdftexdir/pdftex.web"

if auto_breaking then
begin if is_char_node(prev_p)then try_break(0,unhyphenated)
else if precedes_break(prev_p)then try_break(0,unhyphenated)
else if(type(prev_p)= kern_node)and(subtype(prev_p)<> explicit)then
try_break(0,unhyphenated);
end;
check_shrinkage(glue_ptr(cur_p));q:= glue_ptr(cur_p);
act_width:= act_width+width(q);
active_width[2+stretch_order(q)]:= 
active_width[2+stretch_order(q)]+stretch(q);
active_width[6]:= active_width[6]+shrink(q)

/*:1042*/
#line 25349 "pdftexdir/pdftex.web"
;
if second_pass and auto_breaking then
/*1069:*/
#line 25979 "pdftexdir/pdftex.web"

begin prev_s:= cur_p;s:= link(prev_s);
if s<> null then
begin/*1071:*/
#line 26006 "pdftexdir/pdftex.web"

loop begin if is_char_node(s)then
begin c:= qo(character(s));hf:= font(s);
end
else if type(s)= ligature_node then
if lig_ptr(s)= null then goto continue
else begin q:= lig_ptr(s);c:= qo(character(q));hf:= font(q);
end
else if(type(s)= kern_node)and(subtype(s)= normal)then goto continue
else if(type(s)= math_node)and(subtype(s)>=L_code)then goto continue
else if type(s)= whatsit_node then
begin/*1607:*/
#line 35684 "pdftexdir/pdftex.web"

if subtype(s)= language_node then
begin cur_lang:= what_lang(s);l_hyf:= what_lhm(s);r_hyf:= what_rhm(s);
set_hyph_index;
end

/*:1607*/
#line 26017 "pdftexdir/pdftex.web"
;
goto continue;
end
else goto done1;
set_lc_code(c);
if hc[0]<> 0 then
if(hc[0]= c)or(uc_hyph> 0)then goto done2
else goto done1;
continue:prev_s:= s;s:= link(prev_s);
end;
done2:hyf_char:= hyphen_char[hf];
if hyf_char<0 then goto done1;
if hyf_char> 255 then goto done1;
ha:= prev_s

/*:1071*/
#line 25983 "pdftexdir/pdftex.web"
;
if l_hyf+r_hyf> 63 then goto done1;
/*1072:*/
#line 26034 "pdftexdir/pdftex.web"

hn:= 0;
loop begin if is_char_node(s)then
begin if font(s)<> hf then goto done3;
hyf_bchar:= character(s);c:= qo(hyf_bchar);
set_lc_code(c);
if hc[0]= 0 then goto done3;
if hn= 63 then goto done3;
hb:= s;incr(hn);hu[hn]:= c;hc[hn]:= hc[0];hyf_bchar:= non_char;
end
else if type(s)= ligature_node then
/*1073:*/
#line 26061 "pdftexdir/pdftex.web"

begin if font(lig_char(s))<> hf then goto done3;
j:= hn;q:= lig_ptr(s);if q> null then hyf_bchar:= character(q);
while q> null do
begin c:= qo(character(q));
set_lc_code(c);
if hc[0]= 0 then goto done3;
if j= 63 then goto done3;
incr(j);hu[j]:= c;hc[j]:= hc[0];
q:= link(q);
end;
hb:= s;hn:= j;
if odd(subtype(s))then hyf_bchar:= font_bchar[hf]else hyf_bchar:= non_char;
end

/*:1073*/
#line 26046 "pdftexdir/pdftex.web"

else if(type(s)= kern_node)and(subtype(s)= normal)then
begin hb:= s;
hyf_bchar:= font_bchar[hf];
end
else goto done3;
s:= link(s);
end;
done3:

/*:1072*/
#line 25985 "pdftexdir/pdftex.web"
;
/*1074:*/
#line 26076 "pdftexdir/pdftex.web"

if hn<l_hyf+r_hyf then goto done1;{|l_hyf|and|r_hyf|are|>=1|}
loop begin if not(is_char_node(s))then
case type(s)of
ligature_node:do_nothing;
kern_node:if subtype(s)<> normal then goto done4;
whatsit_node,glue_node,penalty_node,ins_node,adjust_node,mark_node:
goto done4;
math_node:if subtype(s)>=L_code then goto done4 else goto done1;
othercases goto done1
endcases;
s:= link(s);
end;
done4:

/*:1074*/
#line 25987 "pdftexdir/pdftex.web"
;
hyphenate;
end;
done1:end

/*:1069*/
#line 25351 "pdftexdir/pdftex.web"
;
end;
kern_node:if subtype(cur_p)= explicit then kern_break
else begin
act_width:= act_width+width(cur_p);
if(pdf_adjust_spacing> 1)and(subtype(cur_p)= normal)then begin
add_kern_stretch(active_width[7])(cur_p);
add_kern_shrink(active_width[8])(cur_p);
end;
end;
ligature_node:begin f:= font(lig_char(cur_p));
act_width:= act_width+char_width(f)(char_info(f)(character(lig_char(cur_p))));
if(pdf_adjust_spacing> 1)and check_expand_pars(f)then begin
prev_char_p:= cur_p;
add_char_stretch(active_width[7])(character(lig_char(cur_p)));
add_char_shrink(active_width[8])(character(lig_char(cur_p)));
end;
end;
disc_node:/*1043:*/
#line 25420 "pdftexdir/pdftex.web"

begin s:= pre_break(cur_p);
do_one_seven_eight(reset_disc_width);
if s= null then try_break(ex_hyphen_penalty,hyphenated)
else begin repeat/*1044:*/
#line 25439 "pdftexdir/pdftex.web"

if is_char_node(s)then
begin f:= font(s);
disc_width[1]:= disc_width[1]+char_width(f)(char_info(f)(character(s)));
if(pdf_adjust_spacing> 1)and check_expand_pars(f)then begin
prev_char_p:= s;
add_char_stretch(disc_width[7])(character(s));
add_char_shrink(disc_width[8])(character(s));
end;
end
else case type(s)of
ligature_node:begin f:= font(lig_char(s));
disc_width[1]:= disc_width[1]+
char_width(f)(char_info(f)(character(lig_char(s))));
if(pdf_adjust_spacing> 1)and check_expand_pars(f)then begin
prev_char_p:= s;
add_char_stretch(disc_width[7])(character(lig_char(s)));
add_char_shrink(disc_width[8])(character(lig_char(s)));
end;
end;
hlist_node,vlist_node,rule_node,kern_node:begin
disc_width[1]:= disc_width[1]+width(s);
if(type(s)= kern_node)and
(pdf_adjust_spacing> 1)and(subtype(s)= normal)
then begin
add_kern_stretch(disc_width[7])(s);
add_kern_shrink(disc_width[8])(s);
end;
end;
othercases confusion("disc3")

endcases

/*:1044*/
#line 25424 "pdftexdir/pdftex.web"
;
s:= link(s);
until s= null;
do_one_seven_eight(add_disc_width_to_active_width);
try_break(hyphen_penalty,hyphenated);
do_one_seven_eight(sub_disc_width_from_active_width);
end;
r:= replace_count(cur_p);s:= link(cur_p);
while r> 0 do
begin/*1045:*/
#line 25472 "pdftexdir/pdftex.web"

if is_char_node(s)then
begin f:= font(s);
act_width:= act_width+char_width(f)(char_info(f)(character(s)));
if(pdf_adjust_spacing> 1)and check_expand_pars(f)then begin
prev_char_p:= s;
add_char_stretch(active_width[7])(character(s));
add_char_shrink(active_width[8])(character(s));
end;
end
else case type(s)of
ligature_node:begin f:= font(lig_char(s));
act_width:= act_width+
char_width(f)(char_info(f)(character(lig_char(s))));
if(pdf_adjust_spacing> 1)and check_expand_pars(f)then begin
prev_char_p:= s;
add_char_stretch(active_width[7])(character(lig_char(s)));
add_char_shrink(active_width[8])(character(lig_char(s)));
end;
end;
hlist_node,vlist_node,rule_node,kern_node:begin
act_width:= act_width+width(s);
if(type(s)= kern_node)and
(pdf_adjust_spacing> 1)and(subtype(s)= normal)
then begin
add_kern_stretch(active_width[7])(s);
add_kern_shrink(active_width[8])(s);
end;
end;
othercases confusion("disc4")

endcases

/*:1045*/
#line 25433 "pdftexdir/pdftex.web"
;
decr(r);s:= link(s);
end;
prev_p:= cur_p;cur_p:= s;goto done5;
end

/*:1043*/
#line 25369 "pdftexdir/pdftex.web"
;
math_node:begin if subtype(cur_p)<L_code then auto_breaking:= odd(subtype(cur_p));
kern_break;
end;
penalty_node:try_break(penalty(cur_p),unhyphenated);
mark_node,ins_node,adjust_node:do_nothing;
othercases confusion("paragraph")

endcases;
prev_p:= cur_p;cur_p:= link(cur_p);
done5:end

/*:1040*/
#line 25279 "pdftexdir/pdftex.web"
;
if cur_p= null then
/*1047:*/
#line 25524 "pdftexdir/pdftex.web"

begin try_break(eject_penalty,hyphenated);
if link(active)<> last_active then
begin/*1048:*/
#line 25534 "pdftexdir/pdftex.web"

r:= link(active);fewest_demerits:= awful_bad;
repeat if type(r)<> delta_node then if total_demerits(r)<fewest_demerits then
begin fewest_demerits:= total_demerits(r);best_bet:= r;
end;
r:= link(r);
until r= last_active;
best_line:= line_number(best_bet)

/*:1048*/
#line 25527 "pdftexdir/pdftex.web"
;
if looseness= 0 then goto done;
/*1049:*/
#line 25548 "pdftexdir/pdftex.web"

begin r:= link(active);actual_looseness:= 0;
repeat if type(r)<> delta_node then
begin line_diff:= line_number(r)-best_line;
if((line_diff<actual_looseness)and(looseness<=line_diff))or
((line_diff> actual_looseness)and(looseness>=line_diff))then
begin best_bet:= r;actual_looseness:= line_diff;
fewest_demerits:= total_demerits(r);
end
else if(line_diff= actual_looseness)and
(total_demerits(r)<fewest_demerits)then
begin best_bet:= r;fewest_demerits:= total_demerits(r);
end;
end;
r:= link(r);
until r= last_active;
best_line:= line_number(best_bet);
end

/*:1049*/
#line 25529 "pdftexdir/pdftex.web"
;
if(actual_looseness= looseness)or final_pass then goto done;
end;
end

/*:1047*/
#line 25282 "pdftexdir/pdftex.web"
;
/*1039:*/
#line 25314 "pdftexdir/pdftex.web"

q:= link(active);
while q<> last_active do
begin cur_p:= link(q);
if type(q)= delta_node then free_node(q,delta_node_size)
else free_node(q,active_node_size);
q:= cur_p;
end;
q:= passive;
while q<> null do
begin cur_p:= link(q);
free_node(q,passive_node_size);
q:= cur_p;
end

/*:1039*/
#line 25283 "pdftexdir/pdftex.web"
;
if not second_pass then
begin stat if tracing_paragraphs> 0 then print_nl("@secondpass");tats
threshold:= tolerance;second_pass:= true;final_pass:= (emergency_stretch<=0);
end{if at first you don't succeed, \dots}
else begin stat if tracing_paragraphs> 0 then
print_nl("@emergencypass");tats
background[2]:= background[2]+emergency_stretch;final_pass:= true;
end;
end;
done:stat if tracing_paragraphs> 0 then
begin end_diagnostic(true);normalize_selector;
end;tats
if do_last_line_fit then/*1850:*/
#line 39793 "pdftexdir/pdftex.web"

if active_short(best_bet)= 0 then do_last_line_fit:= false
else begin q:= new_spec(glue_ptr(last_line_fill));
delete_glue_ref(glue_ptr(last_line_fill));
width(q):= width(q)+active_short(best_bet)-active_glue(best_bet);
stretch(q):= 0;glue_ptr(last_line_fill):= q;
end

/*:1850*/
#line 25296 "pdftexdir/pdftex.web"
;

/*:1037*/
#line 24009 "pdftexdir/pdftex.web"
;
/*1050:*/
#line 25572 "pdftexdir/pdftex.web"

post_line_break(d)

/*:1050*/
#line 24011 "pdftexdir/pdftex.web"
;
/*1039:*/
#line 25314 "pdftexdir/pdftex.web"

q:= link(active);
while q<> last_active do
begin cur_p:= link(q);
if type(q)= delta_node then free_node(q,delta_node_size)
else free_node(q,active_node_size);
q:= cur_p;
end;
q:= passive;
while q<> null do
begin cur_p:= link(q);
free_node(q,passive_node_size);
q:= cur_p;
end

/*:1039*/
#line 24012 "pdftexdir/pdftex.web"
;
pack_begin_line:= 0;
end;

/*1653:*/
#line 36876 "pdftexdir/pdftex.web"

function eTeX_enabled(b:boolean;j:quarterword;k:halfword):boolean;
begin if not b then
begin print_err("Improper ");print_cmd_chr(j,k);
help1("Sorry, this optional e-TeX feature has been disabled.");error;
end;
eTeX_enabled:= b;
end;

/*:1653*//*1676:*/
#line 37147 "pdftexdir/pdftex.web"

procedure show_save_groups;
label found1,found2,found,done;
var p:0..nest_size;{index into|nest|}
m:-mmode..mmode;{mode}
v:save_pointer;{saved value of|save_ptr|}
l:quarterword;{saved value of|cur_level|}
c:group_code;{saved value of|cur_group|}
a:-1. .1;{to keep track of alignments}
i:integer;
j:quarterword;
s:str_number;
begin p:= nest_ptr;nest[p]:= cur_list;{put the top level into the array}
v:= save_ptr;l:= cur_level;c:= cur_group;
save_ptr:= cur_boundary;decr(cur_level);
a:= 1;
print_nl("");print_ln;
loop begin print_nl("### ");print_group(true);
if cur_group= bottom_level then goto done;
repeat m:= nest[p].mode_field;
if p> 0 then decr(p)else m:= vmode;
until m<> hmode;
print(" (");
case cur_group of
simple_group:begin incr(p);goto found2;
end;
hbox_group,adjusted_hbox_group:s:= "hbox";
vbox_group:s:= "vbox";
vtop_group:s:= "vtop";
align_group:if a= 0 then
begin if m= -vmode then s:= "halign"else s:= "valign";
a:= 1;goto found1;
end
else begin if a= 1 then print("align entry")else print_esc("cr");
if p>=a then p:= p-a;
a:= 0;goto found;
end;
no_align_group:
begin incr(p);a:= -1;print_esc("noalign");goto found2;
end;
output_group:
begin print_esc("output");goto found;
end;
math_group:goto found2;
disc_group,math_choice_group:
begin if cur_group= disc_group then print_esc("discretionary")
else print_esc("mathchoice");
for i:= 1 to 3 do if i<=saved(-2)then print("{}");
goto found2;
end;
insert_group:
begin if saved(-2)= 255 then print_esc("vadjust")
else begin print_esc("insert");print_int(saved(-2));
end;
goto found2;
end;
vcenter_group:begin s:= "vcenter";goto found1;
end;
semi_simple_group:begin incr(p);print_esc("begingroup");goto found;
end;
math_shift_group:
begin if m= mmode then print_char("$")
else if nest[p].mode_field= mmode then
begin print_cmd_chr(eq_no,saved(-2));goto found;
end;
print_char("$");goto found;
end;
math_left_group:
begin if type(nest[p+1].eTeX_aux_field)= left_noad then print_esc("left")
else print_esc("middle");
goto found;
end;
end;{there are no other cases}
/*1678:*/
#line 37236 "pdftexdir/pdftex.web"

i:= saved(-4);
if i<> 0 then
if i<box_flag then
begin if abs(nest[p].mode_field)= vmode then j:= hmove else j:= vmove;
if i> 0 then print_cmd_chr(j,0)else print_cmd_chr(j,1);
print_scaled(abs(i));print("pt");
end
else if i<ship_out_flag then
begin if i>=global_box_flag then
begin print_esc("global");i:= i-(global_box_flag-box_flag);
end;
print_esc("setbox");print_int(i-box_flag);print_char("=");
end
else print_cmd_chr(leader_ship,i-(leader_flag-a_leaders))

/*:1678*/
#line 37220 "pdftexdir/pdftex.web"
;
found1:print_esc(s);/*1677:*/
#line 37229 "pdftexdir/pdftex.web"

if saved(-2)<> 0 then
begin print_char(" ");
if saved(-3)= exactly then print("to")else print("spread");
print_scaled(saved(-2));print("pt");
end

/*:1677*/
#line 37221 "pdftexdir/pdftex.web"
;
found2:print_char("{");
found:print_char(")");decr(cur_level);
cur_group:= save_level(save_ptr);save_ptr:= save_index(save_ptr)
end;
done:save_ptr:= v;cur_level:= l;cur_group:= c;
end;

/*:1676*//*1692:*/
#line 37378 "pdftexdir/pdftex.web"

procedure new_interaction;forward;

/*:1692*/
#line 24016 "pdftexdir/pdftex.web"


/*:989*//*1109:*/
#line 26706 "pdftexdir/pdftex.web"
procedure new_hyph_exceptions;{enters new exceptions}
label reswitch,exit,found,not_found,not_found1;
var n:0. .64;{length of current word;not always a|small_number|}
j:0. .64;{an index into|hc|}
h:hyph_pointer;{an index into|hyph_word|and|hyph_list|}
k:str_number;{an index into|str_start|}
p:pointer;{head of a list of hyphen positions}
q:pointer;{used when creating a new node for list|p|}
#line 3799 "pdftex-final.ch"
s:str_number;{strings being compared or stored}
#line 26715 "pdftexdir/pdftex.web"
u,v:pool_pointer;{indices into|str_pool|}
begin scan_left_brace;{a left brace must follow\.{\\hyphenation}}
set_cur_lang;
init if trie_not_ready then
begin hyph_index:= 0;goto not_found1;
end;
tini
set_hyph_index;
not_found1:
/*1110:*/
#line 26728 "pdftexdir/pdftex.web"

n:= 0;p:= null;
loop begin get_x_token;
reswitch:case cur_cmd of
letter,other_char,char_given:/*1112:*/
#line 26753 "pdftexdir/pdftex.web"

if cur_chr= "-"then/*1113:*/
#line 26768 "pdftexdir/pdftex.web"

begin if n<63 then
begin q:= get_avail;link(q):= p;info(q):= n;p:= q;
end;
end

/*:1113*/
#line 26754 "pdftexdir/pdftex.web"

else begin set_lc_code(cur_chr);
if hc[0]= 0 then
begin print_err("Not a letter");

help2("Letters in \hyphenation words must have \lccode>0.")
("Proceed; I'll ignore the character I just read.");
error;
end
else if n<63 then
begin incr(n);hc[n]:= hc[0];
end;
end

/*:1112*/
#line 26732 "pdftexdir/pdftex.web"
;
char_num:begin scan_char_num;cur_chr:= cur_val;cur_cmd:= char_given;
goto reswitch;
end;
spacer,right_brace:begin if n> 1 then/*1114:*/
#line 26774 "pdftexdir/pdftex.web"

begin incr(n);hc[n]:= cur_lang;str_room(n);h:= 0;
for j:= 1 to n do
#line 3805 "pdftex-final.ch"
 begin h:= (h+h+hc[j])mod hyph_prime;
#line 26778 "pdftexdir/pdftex.web"
append_char(hc[j]);
end;
s:= make_string;
/*1115:*/
#line 3820 "pdftex-final.ch"

if hyph_next<=hyph_prime then
while(hyph_next> 0)and(hyph_word[hyph_next-1]> 0)do decr(hyph_next);
if(hyph_count= hyph_size)or(hyph_next= 0)then
overflow("exception dictionary",hyph_size);

incr(hyph_count);
while hyph_word[h]<> 0 do
begin/*1116:*/
#line 3848 "pdftex-final.ch"

{This is now a simple hash list,not an ordered one,so
the module title is no longer descriptive.}
k:= hyph_word[h];
if length(k)<> length(s)then goto not_found;
#line 26799 "pdftexdir/pdftex.web"
u:= str_start[k];v:= str_start[s];
#line 3859 "pdftex-final.ch"
repeat if str_pool[u]<> str_pool[v]then goto not_found;
#line 26802 "pdftexdir/pdftex.web"
incr(u);incr(v);
until u= str_start[k+1];
#line 3867 "pdftex-final.ch"
{repeat hyphenation exception;flushing old data}
flush_string;s:= hyph_word[h];{avoid|slow_make_string|!}
decr(hyph_count);
{We could also|flush_list(hyph_list[h]);|,but it interferes
with\.{trip.log}.}
goto found;
not_found:
#line 26807 "pdftexdir/pdftex.web"

/*:1116*/
#line 3829 "pdftex-final.ch"
;
if hyph_link[h]= 0 then
begin
hyph_link[h]:= hyph_next;
if hyph_next>=hyph_size then hyph_next:= hyph_prime;
if hyph_next> hyph_prime then incr(hyph_next);
end;
h:= hyph_link[h]-1;
end;

found:hyph_word[h]:= s;hyph_list[h]:= p
#line 26794 "pdftexdir/pdftex.web"

#line 3848 "pdftex-final.ch"
/*:1115*/
#line 26781 "pdftexdir/pdftex.web"
;
end

#line 3820 "pdftex-final.ch"
/*:1114*/
#line 26736 "pdftexdir/pdftex.web"
;
if cur_cmd= right_brace then return;
n:= 0;p:= null;
end;
othercases/*1111:*/
#line 26744 "pdftexdir/pdftex.web"

begin print_err("Improper ");print_esc("hyphenation");

print(" will be flushed");
help2("Hyphenation exceptions must contain only letters")
("and hyphens. But continue; I'll forgive and forget.");
error;
end

/*:1111*/
#line 26740 "pdftexdir/pdftex.web"

endcases;
end

/*:1110*/
#line 26725 "pdftexdir/pdftex.web"
;
exit:end;

/*:1109*//*1143:*/
#line 27326 "pdftexdir/pdftex.web"
function prune_page_top(p:pointer;s:boolean):pointer;
label discard_or_move;
{adjust top after page break}
var prev_p:pointer;{lags one step behind|p|}
q,r:pointer;{temporary variables for list manipulation}
begin prev_p:= temp_head;link(temp_head):= p;
while p<> null do
case type(p)of
hlist_node,vlist_node,rule_node:/*1144:*/
#line 27367 "pdftexdir/pdftex.web"

begin q:= new_skip_param(split_top_skip_code);link(prev_p):= q;link(q):= p;
{now|temp_ptr= glue_ptr(q)|}
if width(temp_ptr)> height(p)then width(temp_ptr):= width(temp_ptr)-height(p)
else width(temp_ptr):= 0;
p:= null;
end

/*:1144*/
#line 27335 "pdftexdir/pdftex.web"
;
whatsit_node,mark_node,ins_node:begin
if(type(p)= whatsit_node)and
((subtype(p)= pdf_snapy_node)or
(subtype(p)= pdf_snapy_comp_node))then
begin
print("snap node being discarded");
goto discard_or_move;
end;
prev_p:= p;p:= link(prev_p);
end;
glue_node,kern_node,penalty_node:begin
discard_or_move:

print("discard_or_move: ");
show_node_list(p);
print_ln;

q:= p;p:= link(q);link(q):= null;
link(prev_p):= p;
if s then
begin if split_disc= null then split_disc:= q else link(r):= q;
r:= q;
end
else flush_node_list(q);
end;
othercases confusion("pruning")

endcases;
prune_page_top:= link(temp_head);
end;

/*:1143*//*1145:*/
#line 27393 "pdftexdir/pdftex.web"
function vert_break(p:pointer;h,d:scaled):pointer;
{finds optimum page break}
label done,not_found,update_heights;
var prev_p:pointer;{if|p|is a glue node,|type(prev_p)|determines
whether|p|is a legal breakpoint}
q,r:pointer;{glue specifications}
pi:integer;{penalty value}
b:integer;{badness at a trial breakpoint}
least_cost:integer;{the smallest badness plus penalties found so far}
best_place:pointer;{the most recent break that leads to|least_cost|}
prev_dp:scaled;{depth of previous box in the list}
t:small_number;{|type|of the node following a kern}
begin prev_p:= p;{an initial glue node is not a legal breakpoint}
least_cost:= awful_bad;do_all_six(set_height_zero);prev_dp:= 0;
loop begin/*1147:*/
#line 27427 "pdftexdir/pdftex.web"

if p= null then pi:= eject_penalty
else/*1148:*/
#line 27443 "pdftexdir/pdftex.web"

case type(p)of
hlist_node,vlist_node,rule_node:begin
cur_height:= cur_height+prev_dp+height(p);prev_dp:= depth(p);
goto not_found;
end;
whatsit_node:/*1609:*/
#line 35699 "pdftexdir/pdftex.web"

begin
if(subtype(p)= pdf_refxform_node)or(subtype(p)= pdf_refximage_node)then
begin cur_height:= cur_height+prev_dp+pdf_height(p);prev_dp:= pdf_depth(p);
end;
goto not_found;
end

/*:1609*/
#line 27449 "pdftexdir/pdftex.web"
;
glue_node:if precedes_break(prev_p)then pi:= 0
else goto update_heights;
kern_node:begin if link(p)= null then t:= penalty_node
else t:= type(link(p));
if t= glue_node then pi:= 0 else goto update_heights;
end;
penalty_node:pi:= penalty(p);
mark_node,ins_node:goto not_found;
othercases confusion("vertbreak")

endcases

/*:1148*/
#line 27432 "pdftexdir/pdftex.web"
;
/*1149:*/
#line 27464 "pdftexdir/pdftex.web"

if pi<inf_penalty then
begin/*1150:*/
#line 27479 "pdftexdir/pdftex.web"

if cur_height<h then
if(active_height[3]<> 0)or(active_height[4]<> 0)or
(active_height[5]<> 0)then b:= 0
else b:= badness(h-cur_height,active_height[2])
else if cur_height-h> active_height[6]then b:= awful_bad
else b:= badness(cur_height-h,active_height[6])

/*:1150*/
#line 27467 "pdftexdir/pdftex.web"
;
if b<awful_bad then
if pi<=eject_penalty then b:= pi
else if b<inf_bad then b:= b+pi
else b:= deplorable;
if b<=least_cost then
begin best_place:= p;least_cost:= b;
best_height_plus_depth:= cur_height+prev_dp;
end;
if(b= awful_bad)or(pi<=eject_penalty)then goto done;
end

/*:1149*/
#line 27434 "pdftexdir/pdftex.web"
;
if(type(p)<glue_node)or(type(p)> kern_node)then goto not_found;
update_heights:/*1151:*/
#line 27491 "pdftexdir/pdftex.web"

if type(p)= kern_node then q:= p
else begin q:= glue_ptr(p);
active_height[2+stretch_order(q)]:= 
active_height[2+stretch_order(q)]+stretch(q);
active_height[6]:= active_height[6]+shrink(q);
if(shrink_order(q)<> normal)and(shrink(q)<> 0)then
begin
print_err("Infinite glue shrinkage found in box being split");

help4("The box you are \vsplitting contains some infinitely")
("shrinkable glue, e.g., `\vss' or `\vskip 0pt minus 1fil'.")
("Such glue doesn't belong there; but you can safely proceed,")
("since the offensive shrinkability has been made finite.");
error;r:= new_spec(q);shrink_order(r):= normal;delete_glue_ref(q);
glue_ptr(p):= r;q:= r;
end;
end;
cur_height:= cur_height+prev_dp+width(q);prev_dp:= 0

/*:1151*/
#line 27437 "pdftexdir/pdftex.web"
;
not_found:if prev_dp> d then
begin cur_height:= cur_height+prev_dp-d;
prev_dp:= d;
end;

/*:1147*/
#line 27409 "pdftexdir/pdftex.web"
;
prev_p:= p;p:= link(prev_p);
end;
done:vert_break:= best_place;
end;

/*:1145*//*1152:*/
#line 27526 "pdftexdir/pdftex.web"
/*1822:*/
#line 39384 "pdftexdir/pdftex.web"

function do_marks(a,l:small_number;q:pointer):boolean;
var i:small_number;{a four bit index}
begin if l<4 then{|q|is an index node}
begin for i:= 0 to 15 do
begin get_sa_ptr;
if cur_ptr<> null then if do_marks(a,l+1,cur_ptr)then delete_sa_ptr;
end;
if sa_used(q)= 0 then
begin free_node(q,index_node_size);q:= null;
end;
end
else{|q|is the node for a mark class}
begin case a of
/*1823:*/
#line 39410 "pdftexdir/pdftex.web"

vsplit_init:if sa_split_first_mark(q)<> null then
begin delete_token_ref(sa_split_first_mark(q));sa_split_first_mark(q):= null;
delete_token_ref(sa_split_bot_mark(q));sa_split_bot_mark(q):= null;
end;

/*:1823*//*1825:*/
#line 39437 "pdftexdir/pdftex.web"

fire_up_init:if sa_bot_mark(q)<> null then
begin if sa_top_mark(q)<> null then delete_token_ref(sa_top_mark(q));
delete_token_ref(sa_first_mark(q));sa_first_mark(q):= null;
if link(sa_bot_mark(q))= null then{an empty token list}
begin delete_token_ref(sa_bot_mark(q));sa_bot_mark(q):= null;
end
else add_token_ref(sa_bot_mark(q));
sa_top_mark(q):= sa_bot_mark(q);
end;

/*:1825*//*1826:*/
#line 39448 "pdftexdir/pdftex.web"

fire_up_done:if(sa_top_mark(q)<> null)and(sa_first_mark(q)= null)then
begin sa_first_mark(q):= sa_top_mark(q);add_token_ref(sa_top_mark(q));
end;

/*:1826*//*1828:*/
#line 39471 "pdftexdir/pdftex.web"

init destroy_marks:for i:= top_mark_code to split_bot_mark_code do
begin get_sa_ptr;
if cur_ptr<> null then
begin delete_token_ref(cur_ptr);put_sa_ptr(null);
end;
end;
tini

/*:1828*/
#line 39398 "pdftexdir/pdftex.web"

end;{there are no other cases}
if sa_bot_mark(q)= null then if sa_split_bot_mark(q)= null then
begin free_node(q,mark_class_node_size);q:= null;
end;
end;
do_marks:= (q= null);
end;

/*:1822*/
#line 27526 "pdftexdir/pdftex.web"

function vsplit(n:halfword;h:scaled):pointer;
{extracts a page of height|h|from box|n|}
label exit,done;
var v:pointer;{the box to be split}
p:pointer;{runs through the vlist}
q:pointer;{points to where the break occurs}
begin cur_val:= n;fetch_box(v);
flush_node_list(split_disc);split_disc:= null;
if sa_mark<> null then
if do_marks(vsplit_init,0,sa_mark)then sa_mark:= null;
if split_first_mark<> null then
begin delete_token_ref(split_first_mark);split_first_mark:= null;
delete_token_ref(split_bot_mark);split_bot_mark:= null;
end;
/*1153:*/
#line 27552 "pdftexdir/pdftex.web"

if v= null then
begin vsplit:= null;return;
end;
if type(v)<> vlist_node then
begin print_err("");print_esc("vsplit");print(" needs a ");
print_esc("vbox");

help2("The box you are trying to split is an \hbox.")
("I can't split such a box, so I'll leave it alone.");
error;vsplit:= null;return;
end

/*:1153*/
#line 27541 "pdftexdir/pdftex.web"
;
q:= vert_break(list_ptr(v),h,split_max_depth);
/*1154:*/
#line 27568 "pdftexdir/pdftex.web"

p:= list_ptr(v);
if p= q then list_ptr(v):= null
else loop begin if type(p)= mark_node then
if mark_class(p)<> 0 then/*1824:*/
#line 39419 "pdftexdir/pdftex.web"

begin find_sa_element(mark_val,mark_class(p),true);
if sa_split_first_mark(cur_ptr)= null then
begin sa_split_first_mark(cur_ptr):= mark_ptr(p);
add_token_ref(mark_ptr(p));
end
else delete_token_ref(sa_split_bot_mark(cur_ptr));
sa_split_bot_mark(cur_ptr):= mark_ptr(p);
add_token_ref(mark_ptr(p));
end

/*:1824*/
#line 27572 "pdftexdir/pdftex.web"

else if split_first_mark= null then
begin split_first_mark:= mark_ptr(p);
split_bot_mark:= split_first_mark;
token_ref_count(split_first_mark):= 
token_ref_count(split_first_mark)+2;
end
else begin delete_token_ref(split_bot_mark);
split_bot_mark:= mark_ptr(p);
add_token_ref(split_bot_mark);
end;
if link(p)= q then
begin link(p):= null;goto done;
end;
p:= link(p);
end;
done:

/*:1154*/
#line 27544 "pdftexdir/pdftex.web"
;
q:= prune_page_top(q,saving_vdiscards> 0);
p:= list_ptr(v);free_node(v,box_node_size);
if q<> null then q:= vpack(q,natural);
change_box(q);{the|eq_level|of the box stays the same}
vsplit:= vpackage(p,h,exactly,split_max_depth);
exit:end;

/*:1152*//*1160:*/
#line 27759 "pdftexdir/pdftex.web"
procedure print_totals;
begin print_scaled(page_total);
print_plus(2)("");
print_plus(3)("fil");
print_plus(4)("fill");
print_plus(5)("filll");
if page_shrink<> 0 then
begin print(" minus ");print_scaled(page_shrink);
end;
end;

/*:1160*//*1162:*/
#line 27805 "pdftexdir/pdftex.web"
procedure freeze_page_specs(s:small_number);
begin page_contents:= s;
page_goal:= vsize;page_max_depth:= max_depth;
page_depth:= 0;do_all_six(set_page_so_far_zero);
least_page_cost:= awful_bad;
stat if tracing_pages> 0 then
begin begin_diagnostic;
print_nl("%% goal height=");print_scaled(page_goal);

print(", max depth=");print_scaled(page_max_depth);
end_diagnostic(false);
end;tats
end;

/*:1162*//*1167:*/
#line 27870 "pdftexdir/pdftex.web"
procedure box_error(n:eight_bits);
begin error;begin_diagnostic;
print_nl("The following box has been deleted:");

show_box(box(n));end_diagnostic(true);
flush_node_list(box(n));box(n):= null;
end;

/*:1167*//*1168:*/
#line 27881 "pdftexdir/pdftex.web"
procedure ensure_vbox(n:eight_bits);
var p:pointer;{the box register contents}
begin p:= box(n);
if p<> null then if type(p)= hlist_node then
begin print_err("Insertions can only be added to a vbox");

help3("Tut tut: You're trying to \insert into a")
("\box register that now contains an \hbox.")
("Proceed, and I'll discard its present contents.");
box_error(n);
end;
end;

/*:1168*//*1169:*/
#line 27902 "pdftexdir/pdftex.web"
/*1187:*/
#line 28208 "pdftexdir/pdftex.web"

procedure fire_up(c:pointer);
label exit;
var p,q,r,s:pointer;{nodes being examined and/or changed}
prev_p:pointer;{predecessor of|p|}
n:min_quarterword..255;{insertion box number}
wait:boolean;{should the present insertion be held over?}
save_vbadness:integer;{saved value of|vbadness|}
save_vfuzz:scaled;{saved value of|vfuzz|}
save_split_top_skip:pointer;{saved value of|split_top_skip|}
begin/*1188:*/
#line 28241 "pdftexdir/pdftex.web"

if type(best_page_break)= penalty_node then
begin geq_word_define(int_base+output_penalty_code,penalty(best_page_break));
penalty(best_page_break):= inf_penalty;
end
else geq_word_define(int_base+output_penalty_code,inf_penalty)

/*:1188*/
#line 28218 "pdftexdir/pdftex.web"
;
if sa_mark<> null then
if do_marks(fire_up_init,0,sa_mark)then sa_mark:= null;
if bot_mark<> null then
begin if top_mark<> null then delete_token_ref(top_mark);
top_mark:= bot_mark;add_token_ref(top_mark);
delete_token_ref(first_mark);first_mark:= null;
end;
/*1189:*/
#line 28253 "pdftexdir/pdftex.web"

if c= best_page_break then best_page_break:= null;{|c|not yet linked in}
/*1190:*/
#line 28279 "pdftexdir/pdftex.web"

if box(255)<> null then
begin print_err("");print_esc("box");print("255 is not void");

help2("You shouldn't use \box255 except in \output routines.")
("Proceed, and I'll discard its present contents.");
box_error(255);
end

/*:1190*/
#line 28255 "pdftexdir/pdftex.web"
;
insert_penalties:= 0;{this will count the number of insertions held over}
save_split_top_skip:= split_top_skip;
if holding_inserts<=0 then
/*1193:*/
#line 28333 "pdftexdir/pdftex.web"

begin r:= link(page_ins_head);
while r<> page_ins_head do
begin if best_ins_ptr(r)<> null then
begin n:= qo(subtype(r));ensure_vbox(n);
if box(n)= null then box(n):= new_null_box;
p:= box(n)+list_offset;
while link(p)<> null do p:= link(p);
last_ins_ptr(r):= p;
end;
r:= link(r);
end;
end

/*:1193*/
#line 28259 "pdftexdir/pdftex.web"
;
q:= hold_head;link(q):= null;prev_p:= page_head;p:= link(prev_p);
while p<> best_page_break do
begin if type(p)= ins_node then
begin if holding_inserts<=0 then
/*1195:*/
#line 28359 "pdftexdir/pdftex.web"

begin r:= link(page_ins_head);
while subtype(r)<> subtype(p)do r:= link(r);
if best_ins_ptr(r)= null then wait:= true
else begin wait:= false;s:= last_ins_ptr(r);link(s):= ins_ptr(p);
if best_ins_ptr(r)= p then
/*1196:*/
#line 28376 "pdftexdir/pdftex.web"

begin if type(r)= split_up then
if(broken_ins(r)= p)and(broken_ptr(r)<> null)then
begin while link(s)<> broken_ptr(r)do s:= link(s);
link(s):= null;
split_top_skip:= split_top_ptr(p);
ins_ptr(p):= prune_page_top(broken_ptr(r),false);
if ins_ptr(p)<> null then
begin temp_ptr:= vpack(ins_ptr(p),natural);
height(p):= height(temp_ptr)+depth(temp_ptr);
free_node(temp_ptr,box_node_size);wait:= true;
end;
end;
best_ins_ptr(r):= null;
n:= qo(subtype(r));
temp_ptr:= list_ptr(box(n));
free_node(box(n),box_node_size);
box(n):= vpack(temp_ptr,natural);
end

/*:1196*/
#line 28367 "pdftexdir/pdftex.web"

else begin while link(s)<> null do s:= link(s);
last_ins_ptr(r):= s;
end;
end;
/*1197:*/
#line 28396 "pdftexdir/pdftex.web"

link(prev_p):= link(p);link(p):= null;
if wait then
begin link(q):= p;q:= p;incr(insert_penalties);
end
else begin delete_glue_ref(split_top_ptr(p));
free_node(p,ins_node_size);
end;
p:= prev_p

/*:1197*/
#line 28373 "pdftexdir/pdftex.web"
;
end

/*:1195*/
#line 28266 "pdftexdir/pdftex.web"
;
end
else if type(p)= mark_node then
if mark_class(p)<> 0 then/*1827:*/
#line 39453 "pdftexdir/pdftex.web"

begin find_sa_element(mark_val,mark_class(p),true);
if sa_first_mark(cur_ptr)= null then
begin sa_first_mark(cur_ptr):= mark_ptr(p);
add_token_ref(mark_ptr(p));
end;
if sa_bot_mark(cur_ptr)<> null then delete_token_ref(sa_bot_mark(cur_ptr));
sa_bot_mark(cur_ptr):= mark_ptr(p);add_token_ref(mark_ptr(p));
end

/*:1827*/
#line 28269 "pdftexdir/pdftex.web"

else/*1191:*/
#line 28288 "pdftexdir/pdftex.web"

begin if first_mark= null then
begin first_mark:= mark_ptr(p);
add_token_ref(first_mark);
end;
if bot_mark<> null then delete_token_ref(bot_mark);
bot_mark:= mark_ptr(p);add_token_ref(bot_mark);
end

/*:1191*/
#line 28271 "pdftexdir/pdftex.web"
;
prev_p:= p;p:= link(prev_p);
end;
split_top_skip:= save_split_top_skip;
/*1192:*/
#line 28308 "pdftexdir/pdftex.web"

if p<> null then
begin if link(contrib_head)= null then
if nest_ptr= 0 then tail:= page_tail
else contrib_tail:= page_tail;
link(page_tail):= link(contrib_head);
link(contrib_head):= p;
link(prev_p):= null;
end;
save_vbadness:= vbadness;vbadness:= inf_bad;
save_vfuzz:= vfuzz;vfuzz:= max_dimen;{inhibit error messages}
box(255):= vpackage(link(page_head),best_size,exactly,page_max_depth);
vbadness:= save_vbadness;vfuzz:= save_vfuzz;
if last_glue<> max_halfword then delete_glue_ref(last_glue);
/*1166:*/
#line 27859 "pdftexdir/pdftex.web"

page_contents:= empty;page_tail:= page_head;link(page_head):= null;
last_glue:= max_halfword;last_penalty:= 0;last_kern:= 0;
last_node_type:= -1;
page_depth:= 0;page_max_depth:= 0

/*:1166*/
#line 28322 "pdftexdir/pdftex.web"
;{this sets|last_glue:= max_halfword|}
if q<> hold_head then
begin link(page_head):= link(hold_head);page_tail:= q;
end

/*:1192*/
#line 28276 "pdftexdir/pdftex.web"
;
/*1194:*/
#line 28347 "pdftexdir/pdftex.web"

r:= link(page_ins_head);
while r<> page_ins_head do
begin q:= link(r);free_node(r,page_ins_node_size);r:= q;
end;
link(page_ins_head):= page_ins_head

/*:1194*/
#line 28277 "pdftexdir/pdftex.web"


/*:1189*/
#line 28228 "pdftexdir/pdftex.web"
;
if sa_mark<> null then
if do_marks(fire_up_done,0,sa_mark)then sa_mark:= null;
if(top_mark<> null)and(first_mark= null)then
begin first_mark:= top_mark;add_token_ref(top_mark);
end;
if output_routine<> null then
if dead_cycles>=max_dead_cycles then
/*1199:*/
#line 28422 "pdftexdir/pdftex.web"

begin print_err("Output loop---");print_int(dead_cycles);

print(" consecutive dead cycles");
help3("I've concluded that your \output is awry; it never does a")
("\shipout, so I'm shipping \box255 out myself. Next time")
("increase \maxdeadcycles if you want me to be more patient!");error;
end

/*:1199*/
#line 28236 "pdftexdir/pdftex.web"

else/*1200:*/
#line 28431 "pdftexdir/pdftex.web"

begin output_active:= true;
incr(dead_cycles);
push_nest;mode:= -vmode;prev_depth:= pdf_ignored_dimen;mode_line:= -line;
begin_token_list(output_routine,output_text);
new_save_level(output_group);normal_paragraph;
scan_left_brace;
return;
end

/*:1200*/
#line 28237 "pdftexdir/pdftex.web"
;
/*1198:*/
#line 28410 "pdftexdir/pdftex.web"

begin if link(page_head)<> null then
begin if link(contrib_head)= null then
if nest_ptr= 0 then tail:= page_tail else contrib_tail:= page_tail
else link(page_tail):= link(contrib_head);
link(contrib_head):= link(page_head);
link(page_head):= null;page_tail:= page_head;
end;
flush_node_list(page_disc);page_disc:= null;
ship_out(box(255));box(255):= null;
end

/*:1198*/
#line 28238 "pdftexdir/pdftex.web"
;
exit:end;

/*:1187*/
#line 27902 "pdftexdir/pdftex.web"

procedure build_page;{append contributions to the current page}
label exit,done,done1,continue,contribute,update_heights;
var p:pointer;{the node being appended}
q,r:pointer;{nodes being examined}
b,c:integer;{badness and cost of current page}
pi:integer;{penalty to be added to the badness}
n:min_quarterword..255;{insertion box number}
delta,h,w:scaled;{sizes used for insertion calculations}
begin if(link(contrib_head)= null)or output_active then return;
repeat continue:p:= link(contrib_head);
/*1171:*/
#line 27927 "pdftexdir/pdftex.web"

if last_glue<> max_halfword then delete_glue_ref(last_glue);
last_penalty:= 0;last_kern:= 0;
last_node_type:= type(p)+1;
if type(p)= glue_node then
begin last_glue:= glue_ptr(p);add_glue_ref(last_glue);
end
else begin last_glue:= max_halfword;
if type(p)= penalty_node then last_penalty:= penalty(p)
else if type(p)= kern_node then last_kern:= width(p);
end

/*:1171*/
#line 27913 "pdftexdir/pdftex.web"
;
/*1172:*/
#line 27945 "pdftexdir/pdftex.web"

/*1175:*/
#line 27979 "pdftexdir/pdftex.web"

case type(p)of
hlist_node,vlist_node,rule_node:if page_contents<box_there then
/*1176:*/
#line 28009 "pdftexdir/pdftex.web"

begin if page_contents= empty then freeze_page_specs(box_there)
else page_contents:= box_there;
q:= new_skip_param(top_skip_code);{now|temp_ptr= glue_ptr(q)|}
if width(temp_ptr)> height(p)then width(temp_ptr):= width(temp_ptr)-height(p)
else width(temp_ptr):= 0;
link(q):= p;link(contrib_head):= q;goto continue;
end

/*:1176*/
#line 27983 "pdftexdir/pdftex.web"

else/*1177:*/
#line 28018 "pdftexdir/pdftex.web"

begin page_total:= page_total+page_depth+height(p);
page_depth:= depth(p);
goto contribute;
end

/*:1177*/
#line 27985 "pdftexdir/pdftex.web"
;
whatsit_node:if(page_contents<box_there)and
((subtype(p)= pdf_snapy_node)or
(subtype(p)= pdf_snapy_comp_node))then
begin
print("snap node being discarded");
goto done1;
end
else/*1608:*/
#line 35690 "pdftexdir/pdftex.web"

begin
if(subtype(p)= pdf_refxform_node)or(subtype(p)= pdf_refximage_node)then
begin page_total:= page_total+page_depth+pdf_height(p);
page_depth:= pdf_depth(p);
end;
goto contribute;
end

/*:1608*/
#line 27994 "pdftexdir/pdftex.web"
;
glue_node:if page_contents<box_there then goto done1
else if precedes_break(page_tail)then pi:= 0
else goto update_heights;
kern_node:if page_contents<box_there then goto done1
else if link(p)= null then return
else if type(link(p))= glue_node then pi:= 0
else goto update_heights;
penalty_node:if page_contents<box_there then goto done1 else pi:= penalty(p);
mark_node:goto contribute;
ins_node:/*1183:*/
#line 28101 "pdftexdir/pdftex.web"

begin if page_contents= empty then freeze_page_specs(inserts_only);
n:= subtype(p);r:= page_ins_head;
while n>=subtype(link(r))do r:= link(r);
n:= qo(n);
if subtype(r)<> qi(n)then
/*1184:*/
#line 28131 "pdftexdir/pdftex.web"

begin q:= get_node(page_ins_node_size);link(q):= link(r);link(r):= q;r:= q;
subtype(r):= qi(n);type(r):= inserting;ensure_vbox(n);
if box(n)= null then height(r):= 0
else height(r):= height(box(n))+depth(box(n));
best_ins_ptr(r):= null;
q:= skip(n);
if count(n)= 1000 then h:= height(r)
else h:= x_over_n(height(r),1000)*count(n);
page_goal:= page_goal-h-width(q);
page_so_far[2+stretch_order(q)]:= page_so_far[2+stretch_order(q)]+stretch(q);
page_shrink:= page_shrink+shrink(q);
if(shrink_order(q)<> normal)and(shrink(q)<> 0)then
begin print_err("Infinite glue shrinkage inserted from ");print_esc("skip");

print_int(n);
help3("The correction glue for page breaking with insertions")
("must have finite shrinkability. But you may proceed,")
("since the offensive shrinkability has been made finite.");
error;
end;
end

/*:1184*/
#line 28109 "pdftexdir/pdftex.web"
;
if type(r)= split_up then insert_penalties:= insert_penalties+float_cost(p)
else begin last_ins_ptr(r):= p;
delta:= page_goal-page_total-page_depth+page_shrink;
{this much room is left if we shrink the maximum}
if count(n)= 1000 then h:= height(p)
else h:= x_over_n(height(p),1000)*count(n);{this much room is needed}
if((h<=0)or(h<=delta))and(height(p)+height(r)<=dimen(n))then
begin page_goal:= page_goal-h;height(r):= height(r)+height(p);
end
else/*1185:*/
#line 28164 "pdftexdir/pdftex.web"

begin if count(n)<=0 then w:= max_dimen
else begin w:= page_goal-page_total-page_depth;
if count(n)<> 1000 then w:= x_over_n(w,count(n))*1000;
end;
if w> dimen(n)-height(r)then w:= dimen(n)-height(r);
q:= vert_break(ins_ptr(p),w,depth(p));
height(r):= height(r)+best_height_plus_depth;
stat if tracing_pages> 0 then/*1186:*/
#line 28181 "pdftexdir/pdftex.web"

begin begin_diagnostic;print_nl("% split");print_int(n);

print(" to ");print_scaled(w);
print_char(",");print_scaled(best_height_plus_depth);
print(" p=");
if q= null then print_int(eject_penalty)
else if type(q)= penalty_node then print_int(penalty(q))
else print_char("0");
end_diagnostic(false);
end

/*:1186*/
#line 28172 "pdftexdir/pdftex.web"
;tats
if count(n)<> 1000 then
best_height_plus_depth:= x_over_n(best_height_plus_depth,1000)*count(n);
page_goal:= page_goal-best_height_plus_depth;
type(r):= split_up;broken_ptr(r):= q;broken_ins(r):= p;
if q= null then insert_penalties:= insert_penalties+eject_penalty
else if type(q)= penalty_node then insert_penalties:= insert_penalties+penalty(q);
end

/*:1185*/
#line 28120 "pdftexdir/pdftex.web"
;
end;
goto contribute;
end

/*:1183*/
#line 28004 "pdftexdir/pdftex.web"
;
othercases confusion("page")

endcases

/*:1175*/
#line 27950 "pdftexdir/pdftex.web"
;
/*1180:*/
#line 28052 "pdftexdir/pdftex.web"

if pi<inf_penalty then
begin/*1182:*/
#line 28093 "pdftexdir/pdftex.web"

if page_total<page_goal then
if(page_so_far[3]<> 0)or(page_so_far[4]<> 0)or
(page_so_far[5]<> 0)then b:= 0
else b:= badness(page_goal-page_total,page_so_far[2])
else if page_total-page_goal> page_shrink then b:= awful_bad
else b:= badness(page_total-page_goal,page_shrink)

/*:1182*/
#line 28055 "pdftexdir/pdftex.web"
;
if b<awful_bad then
if pi<=eject_penalty then c:= pi
else if b<inf_bad then c:= b+pi+insert_penalties
else c:= deplorable
else c:= b;
if insert_penalties>=10000 then c:= awful_bad;
stat if tracing_pages> 0 then/*1181:*/
#line 28079 "pdftexdir/pdftex.web"

begin begin_diagnostic;print_nl("%");
print(" t=");print_totals;
print(" g=");print_scaled(page_goal);
print(" b=");
if b= awful_bad then print_char("*")else print_int(b);

print(" p=");print_int(pi);
print(" c=");
if c= awful_bad then print_char("*")else print_int(c);
if c<=least_page_cost then print_char("#");
end_diagnostic(false);
end

/*:1181*/
#line 28062 "pdftexdir/pdftex.web"
;tats
if c<=least_page_cost then
begin best_page_break:= p;best_size:= page_goal;
least_page_cost:= c;
r:= link(page_ins_head);
while r<> page_ins_head do
begin best_ins_ptr(r):= last_ins_ptr(r);
r:= link(r);
end;
end;
if(c= awful_bad)or(pi<=eject_penalty)then
begin fire_up(p);{output the current page at the best place}
if output_active then return;{user's output routine will act}
goto done;{the page has been shipped out by default output routine}
end;
end

/*:1180*/
#line 27953 "pdftexdir/pdftex.web"
;
if(type(p)<glue_node)or(type(p)> kern_node)then goto contribute;
update_heights:/*1179:*/
#line 28031 "pdftexdir/pdftex.web"

if type(p)= kern_node then q:= p
else begin q:= glue_ptr(p);
page_so_far[2+stretch_order(q)]:= 
page_so_far[2+stretch_order(q)]+stretch(q);
page_shrink:= page_shrink+shrink(q);
if(shrink_order(q)<> normal)and(shrink(q)<> 0)then
begin
print_err("Infinite glue shrinkage found on current page");

help4("The page about to be output contains some infinitely")
("shrinkable glue, e.g., `\vss' or `\vskip 0pt minus 1fil'.")
("Such glue doesn't belong there; but you can safely proceed,")
("since the offensive shrinkability has been made finite.");
error;
r:= new_spec(q);shrink_order(r):= normal;delete_glue_ref(q);
glue_ptr(p):= r;q:= r;
end;
end;
page_total:= page_total+page_depth+width(q);page_depth:= 0

/*:1179*/
#line 27956 "pdftexdir/pdftex.web"
;
contribute:/*1178:*/
#line 28024 "pdftexdir/pdftex.web"

if page_depth> page_max_depth then
begin page_total:= 
page_total+page_depth-page_max_depth;
page_depth:= page_max_depth;
end;

/*:1178*/
#line 27957 "pdftexdir/pdftex.web"
;
/*1173:*/
#line 27962 "pdftexdir/pdftex.web"

link(page_tail):= p;page_tail:= p;
link(contrib_head):= link(p);link(p):= null;goto done

/*:1173*/
#line 27958 "pdftexdir/pdftex.web"
;
done1:/*1174:*/
#line 27966 "pdftexdir/pdftex.web"

link(contrib_head):= link(p);link(p):= null;
if saving_vdiscards> 0 then
begin if page_disc= null then page_disc:= p else link(tail_page_disc):= p;
tail_page_disc:= p;
end
else flush_node_list(p)

/*:1174*/
#line 27959 "pdftexdir/pdftex.web"
;
done:

/*:1172*/
#line 27916 "pdftexdir/pdftex.web"
;
until link(contrib_head)= null;
/*1170:*/
#line 27923 "pdftexdir/pdftex.web"

if nest_ptr= 0 then tail:= contrib_head{vertical mode}
else contrib_tail:= contrib_head{other modes}

/*:1170*/
#line 27918 "pdftexdir/pdftex.web"
;
exit:end;

/*:1169*//*1205:*/
#line 28540 "pdftexdir/pdftex.web"
/*1219:*/
#line 28896 "pdftexdir/pdftex.web"

procedure app_space;{handle spaces when|space_factor<> 1000|}
var q:pointer;{glue node}
begin if(space_factor>=2000)and(xspace_skip<> zero_glue)then
q:= new_param_glue(xspace_skip_code)
else begin if space_skip<> zero_glue then main_p:= space_skip
else/*1218:*/
#line 28885 "pdftexdir/pdftex.web"

begin main_p:= font_glue[cur_font];
if main_p= null then
begin main_p:= new_spec(zero_glue);main_k:= param_base[cur_font]+space_code;
width(main_p):= font_info[main_k].sc;{that's |space(cur_font)|}
stretch(main_p):= font_info[main_k+1].sc;{and|space_stretch(cur_font)|}
shrink(main_p):= font_info[main_k+2].sc;{and|space_shrink(cur_font)|}
font_glue[cur_font]:= main_p;
end;
end

/*:1218*/
#line 28902 "pdftexdir/pdftex.web"
;
main_p:= new_spec(main_p);
/*1220:*/
#line 28910 "pdftexdir/pdftex.web"

if space_factor>=2000 then width(main_p):= width(main_p)+extra_space(cur_font);
stretch(main_p):= xn_over_d(stretch(main_p),space_factor,1000);
shrink(main_p):= xn_over_d(shrink(main_p),1000,space_factor)

/*:1220*/
#line 28904 "pdftexdir/pdftex.web"
;
q:= new_glue(main_p);glue_ref_count(main_p):= null;
end;
link(tail):= q;tail:= q;
end;

/*:1219*//*1223:*/
#line 28967 "pdftexdir/pdftex.web"

procedure insert_dollar_sign;
begin back_input;cur_tok:= math_shift_token+"$";
print_err("Missing $ inserted");

help2("I've inserted a begin-math/end-math symbol since I think")
("you left one out. Proceed, with fingers crossed.");ins_error;
end;

/*:1223*//*1225:*/
#line 28992 "pdftexdir/pdftex.web"

procedure you_cant;
begin print_err("You can't use `");

print_cmd_chr(cur_cmd,cur_chr);
#line 4132 "pdftex-final.ch"
print_in_mode(mode);
#line 28998 "pdftexdir/pdftex.web"
end;

/*:1225*//*1226:*/
#line 29000 "pdftexdir/pdftex.web"

procedure report_illegal_case;
begin you_cant;
help4("Sorry, but I'm not programmed to handle this case;")
("I'll just pretend that you didn't ask for it.")
("If you're in the wrong mode, you might be able to")
("return to the right one by typing `I}' or `I$' or `I\par'.");
error;
end;

/*:1226*//*1227:*/
#line 29015 "pdftexdir/pdftex.web"

function privileged:boolean;
begin if mode> 0 then privileged:= true
else begin report_illegal_case;privileged:= false;
end;
end;

/*:1227*//*1230:*/
#line 29042 "pdftexdir/pdftex.web"

function its_all_over:boolean;{do this when\.{\\end}or\.{\\dump}occurs}
label exit;
begin if privileged then
begin if(page_head= page_tail)and(head= tail)and(dead_cycles= 0)then
begin its_all_over:= true;return;
end;
back_input;{we will try to end again after ejecting residual material}
tail_append(new_null_box);
width(tail):= hsize;
tail_append(new_glue(fill_glue));
tail_append(new_penalty(-49
build_page;{append\.{\\hbox to\\hsize\{\}\\vfill\\penalty-'10000000000}}
end;
its_all_over:= false;
exit:end;

/*:1230*//*1236:*/
#line 29152 "pdftexdir/pdftex.web"

procedure append_glue;
var s:small_number;{modifier of skip command}
begin s:= cur_chr;
case s of
fil_code:cur_val:= fil_glue;
fill_code:cur_val:= fill_glue;
ss_code:cur_val:= ss_glue;
fil_neg_code:cur_val:= fil_neg_glue;
skip_code:scan_glue(glue_val);
mskip_code:scan_glue(mu_val);
end;{now|cur_val|points to the glue specification}
tail_append(new_glue(cur_val));
if s>=skip_code then
begin decr(glue_ref_count(cur_val));
if s> skip_code then subtype(tail):= mu_glue;
end;
end;

/*:1236*//*1237:*/
#line 29171 "pdftexdir/pdftex.web"

procedure append_kern;
var s:quarterword;{|subtype|of the kern node}
begin s:= cur_chr;scan_dimen(s= mu_glue,false,false);
tail_append(new_kern(cur_val));subtype(tail):= s;
end;

/*:1237*//*1240:*/
#line 29215 "pdftexdir/pdftex.web"

procedure off_save;
var p:pointer;{inserted token}
begin if cur_group= bottom_level then
/*1242:*/
#line 29255 "pdftexdir/pdftex.web"

begin print_err("Extra ");print_cmd_chr(cur_cmd,cur_chr);

help1("Things are pretty mixed up, but I think the worst is over.");
error;
end

/*:1242*/
#line 29219 "pdftexdir/pdftex.web"

else begin back_input;p:= get_avail;link(temp_head):= p;
print_err("Missing ");
/*1241:*/
#line 29236 "pdftexdir/pdftex.web"

case cur_group of
semi_simple_group:begin info(p):= cs_token_flag+frozen_end_group;
print_esc("endgroup");

end;
math_shift_group:begin info(p):= math_shift_token+"$";print_char("$");

end;
math_left_group:begin info(p):= cs_token_flag+frozen_right;link(p):= get_avail;
p:= link(p);info(p):= other_token+".";print_esc("right.");


end;
othercases begin info(p):= right_brace_token+"}";print_char("}");

end
endcases

/*:1241*/
#line 29223 "pdftexdir/pdftex.web"
;
print(" inserted");ins_list(link(temp_head));
help5("I've inserted something that you may have forgotten.")
("(See the <inserted text> above.)")
("With luck, this will get me unwedged. But if you")
("really didn't forget anything, try typing `2' now; then")
("my insertion and my current dilemma will both disappear.");
error;
end;
end;

/*:1240*//*1245:*/
#line 29292 "pdftexdir/pdftex.web"

procedure extra_right_brace;
begin print_err("Extra }, or forgotten ");

case cur_group of
semi_simple_group:print_esc("endgroup");
math_shift_group:print_char("$");
math_left_group:print_esc("right");
end;
help5("I've deleted a group-closing symbol because it seems to be")
("spurious, as in `$x}$'. But perhaps the } is legitimate and")
("you forgot something else, as in `\hbox{$x}'. In such cases")
("the way to recover is to insert both the forgotten and the")
("deleted material, e.g., by typing `I$}'.");error;
incr(align_state);
end;

/*:1245*//*1246:*/
#line 29312 "pdftexdir/pdftex.web"

procedure normal_paragraph;
begin if looseness<> 0 then eq_word_define(int_base+looseness_code,0);
if hang_indent<> 0 then eq_word_define(dimen_base+hang_indent_code,0);
if hang_after<> 1 then eq_word_define(int_base+hang_after_code,1);
if par_shape_ptr<> null then eq_define(par_shape_loc,shape_ref,null);
if inter_line_penalties_ptr<> null then
eq_define(inter_line_penalties_loc,shape_ref,null);
end;

/*:1246*//*1251:*/
#line 29436 "pdftexdir/pdftex.web"

procedure box_end(box_context:integer);
var p:pointer;{|ord_noad|for new box in math mode}
a:small_number;{global prefix}
begin if box_context<box_flag then/*1252:*/
#line 29453 "pdftexdir/pdftex.web"

begin if cur_box<> null then
begin shift_amount(cur_box):= box_context;
if abs(mode)= vmode then
begin
if pre_adjust_tail<> null then begin
if pre_adjust_head<> pre_adjust_tail then
append_list(pre_adjust_head)(pre_adjust_tail);
pre_adjust_tail:= null;
end;
append_to_vlist(cur_box);
if adjust_tail<> null then begin
if adjust_head<> adjust_tail then
append_list(adjust_head)(adjust_tail);
adjust_tail:= null;
end;
if mode> 0 then build_page;
end
else begin if abs(mode)= hmode then space_factor:= 1000
else begin p:= new_noad;
math_type(nucleus(p)):= sub_box;
info(nucleus(p)):= cur_box;cur_box:= p;
end;
link(tail):= cur_box;tail:= cur_box;
end;
end;
end

/*:1252*/
#line 29441 "pdftexdir/pdftex.web"

else if box_context<ship_out_flag then/*1253:*/
#line 29481 "pdftexdir/pdftex.web"

begin if box_context<global_box_flag then
begin cur_val:= box_context-box_flag;a:= 0;
end
else begin cur_val:= box_context-global_box_flag;a:= 4;
end;
if cur_val<256 then define(box_base+cur_val,box_ref,cur_box)
else sa_def_box;
end

/*:1253*/
#line 29442 "pdftexdir/pdftex.web"

else if cur_box<> null then
if box_context> ship_out_flag then/*1254:*/
#line 29491 "pdftexdir/pdftex.web"

begin/*430:*/
#line 9537 "pdftexdir/pdftex.web"

repeat get_x_token;
until(cur_cmd<> spacer)and(cur_cmd<> relax)

/*:430*/
#line 29492 "pdftexdir/pdftex.web"
;
if((cur_cmd= hskip)and(abs(mode)<> vmode))or
((cur_cmd= vskip)and(abs(mode)= vmode))then
begin append_glue;subtype(tail):= box_context-(leader_flag-a_leaders);
leader_ptr(tail):= cur_box;
end
else begin print_err("Leaders not followed by proper glue");

help3("You should say `\leaders <box or rule><hskip or vskip>'.")
("I found the <box or rule>, but there's no suitable")
("<hskip or vskip>, so I'm ignoring these leaders.");back_error;
flush_node_list(cur_box);
end;
end

/*:1254*/
#line 29445 "pdftexdir/pdftex.web"

else ship_out(cur_box);
end;

/*:1251*//*1255:*/
#line 29512 "pdftexdir/pdftex.web"

procedure begin_box(box_context:integer);
label exit,done;
var p,q:pointer;{run through the current list}
r:pointer;{running behind|p|}
fm:boolean;{a final\.{\\beginM}\.{\\endM}node pair?}
tx:pointer;{effective tail node}
m:quarterword;{the length of a replacement list}
k:halfword;{0 or|vmode|or|hmode|}
n:halfword;{a box number}
begin case cur_chr of
box_code:begin scan_register_num;fetch_box(cur_box);
change_box(null);{the box becomes void,at the same level}
end;
copy_code:begin scan_register_num;fetch_box(q);cur_box:= copy_node_list(q);
end;
last_box_code:/*1256:*/
#line 29561 "pdftexdir/pdftex.web"

begin cur_box:= null;
if abs(mode)= mmode then
begin you_cant;help1("Sorry; this \lastbox will be void.");error;
end
else if(mode= vmode)and(head= tail)then
begin you_cant;
help2("Sorry...I usually can't take things from the current page.")
("This \lastbox will therefore be void.");error;
end
else begin check_effective_tail(goto done);
if not is_char_node(tx)then
if(type(tx)= hlist_node)or(type(tx)= vlist_node)then
/*1257:*/
#line 29578 "pdftexdir/pdftex.web"

begin fetch_effective_tail(goto done);
cur_box:= tx;shift_amount(cur_box):= 0;
end

/*:1257*/
#line 29574 "pdftexdir/pdftex.web"
;
done:end;
end

/*:1256*/
#line 29529 "pdftexdir/pdftex.web"
;
vsplit_code:/*1258:*/
#line 29585 "pdftexdir/pdftex.web"

begin scan_register_num;n:= cur_val;
if not scan_keyword("to")then

begin print_err("Missing `to' inserted");

help2("I'm working on `\vsplit<box number> to <dimen>';")
("will look for the <dimen> next.");error;
end;
scan_normal_dimen;
cur_box:= vsplit(n,cur_val);
end

/*:1258*/
#line 29530 "pdftexdir/pdftex.web"
;
othercases/*1259:*/
#line 29601 "pdftexdir/pdftex.web"

begin k:= cur_chr-vtop_code;saved(0):= box_context;
if k= hmode then
if(box_context<box_flag)and(abs(mode)= vmode)then
scan_spec(adjusted_hbox_group,true)
else scan_spec(hbox_group,true)
else begin if k= vmode then scan_spec(vbox_group,true)
else begin scan_spec(vtop_group,true);k:= vmode;
end;
normal_paragraph;
end;
push_nest;mode:= -k;
if k= vmode then
begin prev_depth:= pdf_ignored_dimen;
if every_vbox<> null then begin_token_list(every_vbox,every_vbox_text);
end
else begin space_factor:= 1000;
if every_hbox<> null then begin_token_list(every_hbox,every_hbox_text);
end;
return;
end

/*:1259*/
#line 29531 "pdftexdir/pdftex.web"

endcases;
box_end(box_context);{in simple cases,we use the box immediately}
exit:end;

/*:1255*//*1260:*/
#line 29623 "pdftexdir/pdftex.web"

procedure scan_box(box_context:integer);
{the next input should specify a box or perhaps a rule}
begin/*430:*/
#line 9537 "pdftexdir/pdftex.web"

repeat get_x_token;
until(cur_cmd<> spacer)and(cur_cmd<> relax)

/*:430*/
#line 29626 "pdftexdir/pdftex.web"
;
if cur_cmd= make_box then begin_box(box_context)
else if(box_context>=leader_flag)and((cur_cmd= hrule)or(cur_cmd= vrule))then
begin cur_box:= scan_rule_spec;box_end(box_context);
end
else begin
print_err("A <box> was supposed to be here");

help3("I was expecting to see \hbox or \vbox or \copy or \box or")
("something like that. So you might find something missing in")
("your output. But keep trying; you can fix this later.");back_error;
end;
end;

/*:1260*//*1262:*/
#line 29654 "pdftexdir/pdftex.web"

procedure package(c:small_number);
var h:scaled;{height of box}
p:pointer;{first node in a box}
d:scaled;{max depth}
begin d:= box_max_depth;unsave;save_ptr:= save_ptr-3;
if mode= -hmode then cur_box:= hpack(link(head),saved(2),saved(1))
else begin cur_box:= vpackage(link(head),saved(2),saved(1),d);
if c= vtop_code then/*1263:*/
#line 29673 "pdftexdir/pdftex.web"

begin h:= 0;p:= list_ptr(cur_box);
if p<> null then if type(p)<=rule_node then h:= height(p);
depth(cur_box):= depth(cur_box)-h+height(cur_box);height(cur_box):= h;
end

/*:1263*/
#line 29663 "pdftexdir/pdftex.web"
;
end;
pop_nest;box_end(saved(0));
end;

/*:1262*//*1267:*/
#line 29708 "pdftexdir/pdftex.web"

function norm_min(h:integer):small_number;
begin if h<=0 then norm_min:= 1 else if h>=63 then norm_min:= 63
else norm_min:= h;
end;

procedure new_graf(indented:boolean);
begin prev_graf:= 0;
if(mode= vmode)or(head<> tail)then
tail_append(new_param_glue(par_skip_code));
push_nest;mode:= hmode;space_factor:= 1000;set_cur_lang;clang:= cur_lang;
prev_graf:= (norm_min(left_hyphen_min)*49
*50
#line 4140 "pdftex-final.ch"
 if indented then
begin tail:= new_null_box;link(head):= tail;width(tail):= par_indent;
if(insert_src_special_every_par)then insert_src_special;
end;
#line 29724 "pdftexdir/pdftex.web"
if every_par<> null then begin_token_list(every_par,every_par_text);
if nest_ptr= 1 then build_page;{put|par_skip|glue on current page}
end;

/*:1267*//*1269:*/
#line 29731 "pdftexdir/pdftex.web"

procedure indent_in_hmode;
var p,q:pointer;
begin if cur_chr> 0 then{\.{\\indent}}
begin p:= new_null_box;width(p):= par_indent;
if abs(mode)= hmode then space_factor:= 1000
else begin q:= new_noad;math_type(nucleus(q)):= sub_box;
info(nucleus(q)):= p;p:= q;
end;
tail_append(p);
end;
end;

/*:1269*//*1271:*/
#line 29759 "pdftexdir/pdftex.web"

procedure head_for_vmode;
begin if mode<0 then
if cur_cmd<> hrule then off_save
else begin print_err("You can't use `");
print_esc("hrule");print("' here except with leaders");

help2("To put a horizontal rule in an hbox or an alignment,")
("you should use \leaders or \hrulefill (see The TeXbook).");
error;
end
else begin back_input;cur_tok:= par_token;back_input;token_type:= inserted;
end;
end;

/*:1271*//*1272:*/
#line 29774 "pdftexdir/pdftex.web"

procedure end_graf;
begin if mode= hmode then
begin if head= tail then pop_nest{null paragraphs are ignored}
else line_break(false);
if LR_save<> null then
begin flush_list(LR_save);LR_save:= null;
end;
normal_paragraph;
error_count:= 0;
end;
end;

/*:1272*//*1275:*/
#line 29797 "pdftexdir/pdftex.web"

procedure begin_insert_or_adjust;
begin if cur_cmd= vadjust then cur_val:= 255
else begin scan_eight_bit_int;
if cur_val= 255 then
begin print_err("You can't ");print_esc("insert");print_int(255);

help1("I'm changing to \insert0; box 255 is special.");
error;cur_val:= 0;
end;
end;
saved(0):= cur_val;
if(cur_cmd= vadjust)and scan_keyword("pre")then
saved(1):= 1
else
saved(1):= 0;
save_ptr:= save_ptr+2;
new_save_level(insert_group);scan_left_brace;normal_paragraph;
push_nest;mode:= -vmode;prev_depth:= pdf_ignored_dimen;
end;

/*:1275*//*1277:*/
#line 29839 "pdftexdir/pdftex.web"

procedure make_mark;
var p:pointer;{new node}
c:halfword;{the mark class}
begin if cur_chr= 0 then c:= 0
else begin scan_register_num;c:= cur_val;
end;
p:= scan_toks(false,true);p:= get_node(small_node_size);
mark_class(p):= c;
type(p):= mark_node;subtype(p):= 0;{the|subtype|is not used}
mark_ptr(p):= def_ref;link(tail):= p;tail:= p;
end;

/*:1277*//*1279:*/
#line 29858 "pdftexdir/pdftex.web"

procedure append_penalty;
begin scan_int;tail_append(new_penalty(cur_val));
if mode= vmode then build_page;
end;

/*:1279*//*1281:*/
#line 29877 "pdftexdir/pdftex.web"

procedure delete_last;
label exit;
var p,q:pointer;{run through the current list}
r:pointer;{running behind|p|}
fm:boolean;{a final\.{\\beginM}\.{\\endM}node pair?}
tx:pointer;{effective tail node}
m:quarterword;{the length of a replacement list}
begin if(mode= vmode)and(tail= head)then
/*1282:*/
#line 29896 "pdftexdir/pdftex.web"

begin if(cur_chr<> glue_node)or(last_glue<> max_halfword)then
begin you_cant;
help2("Sorry...I usually can't take things from the current page.")
("Try `I\vskip-\lastskip' instead.");
if cur_chr= kern_node then help_line[0]:= 
("Try `I\kern-\lastkern' instead.")
else if cur_chr<> glue_node then help_line[0]:= 
("Perhaps you can make the output routine do it.");
error;
end;
end

/*:1282*/
#line 29887 "pdftexdir/pdftex.web"

else begin check_effective_tail(return);
if not is_char_node(tx)then if type(tx)= cur_chr then
begin fetch_effective_tail(return);
flush_node_list(tx);
end;
end;
exit:end;

/*:1281*//*1286:*/
#line 29940 "pdftexdir/pdftex.web"

procedure unpackage;
label done,exit;
var p:pointer;{the box}
r:pointer;{to remove marginal kern nodes}
c:box_code..copy_code;{should we copy?}
begin if cur_chr> copy_code then/*1860:*/
#line 39902 "pdftexdir/pdftex.web"

begin link(tail):= disc_ptr[cur_chr];disc_ptr[cur_chr]:= null;
goto done;
end

/*:1860*/
#line 29946 "pdftexdir/pdftex.web"
;
c:= cur_chr;scan_register_num;fetch_box(p);
if p= null then return;
if(abs(mode)= mmode)or((abs(mode)= vmode)and(type(p)<> vlist_node))or
((abs(mode)= hmode)and(type(p)<> hlist_node))then
begin print_err("Incompatible list can't be unboxed");

help3("Sorry, Pandora. (You sneaky devil.)")
("I refuse to unbox an \hbox in vertical mode or vice versa.")
("And I can't open any boxes in math mode.");
error;return;
end;
if c= copy_code then link(tail):= copy_node_list(list_ptr(p))
else begin link(tail):= list_ptr(p);change_box(null);
free_node(p,box_node_size);
end;
done:
while link(tail)<> null do begin
r:= link(tail);
if not is_char_node(r)and(type(r)= margin_kern_node)then begin
link(tail):= link(r);
free_avail(margin_char(r));
free_node(r,margin_kern_node_size);
end;
tail:= link(tail);
end;
exit:end;

/*:1286*//*1289:*/
#line 29984 "pdftexdir/pdftex.web"

procedure append_italic_correction;
label exit;
var p:pointer;{|char_node|at the tail of the current list}
f:internal_font_number;{the font in the|char_node|}
begin if tail<> head then
begin if is_char_node(tail)then p:= tail
else if type(tail)= ligature_node then p:= lig_char(tail)
else return;
f:= font(p);
tail_append(new_kern(char_italic(f)(char_info(f)(character(p)))));
subtype(tail):= explicit;
end;
exit:end;

/*:1289*//*1293:*/
#line 30018 "pdftexdir/pdftex.web"

procedure append_discretionary;
var c:integer;{hyphen character}
begin tail_append(new_disc);
if cur_chr= 1 then
begin c:= hyphen_char[cur_font];
if c>=0 then if c<256 then pre_break(tail):= new_character(cur_font,c);
end
else begin incr(save_ptr);saved(-1):= 0;new_save_level(disc_group);
scan_left_brace;push_nest;mode:= -hmode;space_factor:= 1000;
end;
end;

/*:1293*//*1295:*/
#line 30038 "pdftexdir/pdftex.web"

procedure build_discretionary;
label done,exit;
var p,q:pointer;{for link manipulation}
n:integer;{length of discretionary list}
begin unsave;
/*1297:*/
#line 30081 "pdftexdir/pdftex.web"

q:= head;p:= link(q);n:= 0;
while p<> null do
begin if not is_char_node(p)then if type(p)> rule_node then
if type(p)<> kern_node then if type(p)<> ligature_node then
begin print_err("Improper discretionary list");

help1("Discretionary lists must contain only boxes and kerns.");
error;
begin_diagnostic;
print_nl("The following discretionary sublist has been deleted:");

show_box(p);
end_diagnostic(true);
flush_node_list(p);link(q):= null;goto done;
end;
q:= p;p:= link(q);incr(n);
end;
done:

/*:1297*/
#line 30047 "pdftexdir/pdftex.web"
;
p:= link(head);pop_nest;
case saved(-1)of
0:pre_break(tail):= p;
1:post_break(tail):= p;
2:/*1296:*/
#line 30059 "pdftexdir/pdftex.web"

begin if(n> 0)and(abs(mode)= mmode)then
begin print_err("Illegal math ");print_esc("discretionary");

help2("Sorry: The third part of a discretionary break must be")
("empty, in math formulas. I had to delete your third part.");
flush_node_list(p);n:= 0;error;
end
else link(tail):= p;
if n<=max_quarterword then replace_count(tail):= n
else begin print_err("Discretionary list is too long");

help2("Wow---I never thought anybody would tweak me here.")
("You can't seriously need such a huge discretionary list?");
error;
end;
if n> 0 then tail:= q;
decr(save_ptr);return;
end

/*:1296*/
#line 30053 "pdftexdir/pdftex.web"
;
end;{there are no other cases}
incr(saved(-1));new_save_level(disc_group);scan_left_brace;
push_nest;mode:= -hmode;space_factor:= 1000;
exit:end;

/*:1295*//*1299:*/
#line 30115 "pdftexdir/pdftex.web"

procedure make_accent;
var s,t:real;{amount of slant}
p,q,r:pointer;{character,box,and kern nodes}
f:internal_font_number;{relevant font}
a,h,x,w,delta:scaled;{heights and widths,as explained above}
i:four_quarters;{character information}
begin scan_char_num;f:= cur_font;p:= new_character(f,cur_val);
if p<> null then
begin x:= x_height(f);s:= slant(f)/float_constant(65536);

a:= char_width(f)(char_info(f)(character(p)));
do_assignments;
/*1300:*/
#line 30136 "pdftexdir/pdftex.web"

q:= null;f:= cur_font;
if(cur_cmd= letter)or(cur_cmd= other_char)or(cur_cmd= char_given)then
q:= new_character(f,cur_chr)
else if cur_cmd= char_num then
begin scan_char_num;q:= new_character(f,cur_val);
end
else back_input

/*:1300*/
#line 30129 "pdftexdir/pdftex.web"
;
if q<> null then/*1301:*/
#line 30152 "pdftexdir/pdftex.web"

begin t:= slant(f)/float_constant(65536);

i:= char_info(f)(character(q));
w:= char_width(f)(i);h:= char_height(f)(height_depth(i));
if h<> x then{the accent must be shifted up or down}
begin p:= hpack(p,natural);shift_amount(p):= x-h;
end;
delta:= round((w-a)/float_constant(2)+h*t-x*s);


r:= new_kern(delta);subtype(r):= acc_kern;link(tail):= r;link(r):= p;
tail:= new_kern(-a-delta);subtype(tail):= acc_kern;link(p):= tail;p:= q;
end

/*:1301*/
#line 30131 "pdftexdir/pdftex.web"
;
link(tail):= p;tail:= p;space_factor:= 1000;
end;
end;

/*:1299*//*1303:*/
#line 30180 "pdftexdir/pdftex.web"

procedure align_error;
begin if abs(align_state)> 2 then
/*1304:*/
#line 30200 "pdftexdir/pdftex.web"

begin print_err("Misplaced ");print_cmd_chr(cur_cmd,cur_chr);



if cur_tok= tab_token+"&"then
begin help6("I can't figure out why you would want to use a tab mark")
("here. If you just want an ampersand, the remedy is")
("simple: Just type `I\&' now. But if some right brace")
("up above has ended a previous alignment prematurely,")
("you're probably due for more error messages, and you")
("might try typing `S' now just to see what is salvageable.");
end
else begin help5("I can't figure out why you would want to use a tab mark")
("or \cr or \span just now. If something like a right brace")
("up above has ended a previous alignment prematurely,")
("you're probably due for more error messages, and you")
("might try typing `S' now just to see what is salvageable.");
end;
error;
end

/*:1304*/
#line 30183 "pdftexdir/pdftex.web"

else begin back_input;
if align_state<0 then
begin print_err("Missing { inserted");

incr(align_state);cur_tok:= left_brace_token+"{";
end
else begin print_err("Missing } inserted");

decr(align_state);cur_tok:= right_brace_token+"}";
end;
help3("I've put in what seems to be necessary to fix")
("the current column of the current alignment.")
("Try to go on, since this might almost work.");ins_error;
end;
end;

/*:1303*//*1305:*/
#line 30225 "pdftexdir/pdftex.web"

procedure no_align_error;
begin print_err("Misplaced ");print_esc("noalign");

help2("I expect to see \noalign only after the \cr of")
("an alignment. Proceed, and I'll ignore this case.");error;
end;
procedure omit_error;
begin print_err("Misplaced ");print_esc("omit");

help2("I expect to see \omit only after tab marks or the \cr of")
("an alignment. Proceed, and I'll ignore this case.");error;
end;

/*:1305*//*1307:*/
#line 30256 "pdftexdir/pdftex.web"

procedure do_endv;
begin base_ptr:= input_ptr;input_stack[base_ptr]:= cur_input;
while(input_stack[base_ptr].index_field<> v_template)and
(input_stack[base_ptr].loc_field= null)and
(input_stack[base_ptr].state_field= token_list)do decr(base_ptr);
if(input_stack[base_ptr].index_field<> v_template)or
(input_stack[base_ptr].loc_field<> null)or
(input_stack[base_ptr].state_field<> token_list)then
fatal_error("(interwoven alignment preambles are not allowed)");

if cur_group= align_group then
begin end_graf;
if fin_col then fin_row;
end
else off_save;
end;

/*:1307*//*1311:*/
#line 30291 "pdftexdir/pdftex.web"

procedure cs_error;
#line 4151 "pdftex-final.ch"
begin
if cur_chr= 10 then
begin
print_err("Extra ");print_esc("endmubyte");

help1("I'm ignoring this, since I wasn't doing a \mubyte.");
end else begin
print_err("Extra ");print_esc("endcsname");

help1("I'm ignoring this, since I wasn't doing a \csname.");
end;
#line 30296 "pdftexdir/pdftex.web"
error;
end;

/*:1311*//*1312:*/
#line 30309 "pdftexdir/pdftex.web"

procedure push_math(c:group_code);
begin push_nest;mode:= -mmode;incompleat_noad:= null;new_save_level(c);
end;

/*:1312*//*1314:*/
#line 30322 "pdftexdir/pdftex.web"

/*1730:*/
#line 37842 "pdftexdir/pdftex.web"

procedure just_copy(p,h,t:pointer);
label found,not_found;
var r:pointer;{current node being fabricated for new list}
words:0. .5;{number of words remaining to be copied}
begin while p<> null do
begin words:= 1;{this setting occurs in more branches than any other}
if is_char_node(p)then r:= get_avail
else case type(p)of
#line 5882 "pdftex-final.ch"
 hlist_node,vlist_node:begin r:= get_node(box_node_size);
/*1932:*/
#line 7065 "pdftex-final.ch"

sync_tag(r+box_node_size):= sync_tag(p+box_node_size);
sync_line(r+box_node_size):= sync_line(p+box_node_size);

/*:1932*/
#line 5883 "pdftex-final.ch"
;
#line 37852 "pdftexdir/pdftex.web"
mem[r+6]:= mem[p+6];mem[r+5]:= mem[p+5];{copy the last two words}
words:= 5;list_ptr(r):= null;{this affects|mem[r+5]|}
end;
rule_node:begin r:= get_node(rule_node_size);words:= rule_node_size;
end;
ligature_node:begin r:= get_avail;{only|font|and|character|are needed}
mem[r]:= mem[lig_char(p)];goto found;
end;
#line 5894 "pdftex-final.ch"
kern_node,math_node:begin
words:= medium_node_size;{{\sl Sync\TeX}:proper size for math and kern}
r:= get_node(words);
end;
glue_node:begin r:= get_node(medium_node_size);add_glue_ref(glue_ptr(p));
{{\sl Sync\TeX}:proper size for glue}
/*1934:*/
#line 7073 "pdftex-final.ch"

sync_tag(r+medium_node_size):= sync_tag(p+medium_node_size);
sync_line(r+medium_node_size):= sync_line(p+medium_node_size);

/*:1934*/
#line 5900 "pdftex-final.ch"
;
glue_ptr(r):= glue_ptr(p);leader_ptr(r):= null;
end;
#line 37866 "pdftexdir/pdftex.web"
whatsit_node:/*1601:*/
#line 35453 "pdftexdir/pdftex.web"

case subtype(p)of
open_node:begin r:= get_node(open_node_size);words:= open_node_size;
end;
write_node,special_node:begin r:= get_node(write_node_size);
add_token_ref(write_tokens(p));words:= write_node_size;
end;
close_node,language_node:begin r:= get_node(small_node_size);
words:= small_node_size;
end;
pdf_literal_node:begin
r:= get_node(write_node_size);
add_token_ref(pdf_literal_data(p));
words:= write_node_size;
end;
pdf_colorstack_node:begin
if pdf_colorstack_cmd(p)<=colorstack_data then begin
r:= get_node(pdf_colorstack_setter_node_size);
add_token_ref(pdf_colorstack_data(p));
words:= pdf_colorstack_setter_node_size;
end
else begin
r:= get_node(pdf_colorstack_getter_node_size);
words:= pdf_colorstack_getter_node_size;
end;
end;
pdf_setmatrix_node:begin
r:= get_node(pdf_setmatrix_node_size);
add_token_ref(pdf_setmatrix_data(p));
words:= pdf_setmatrix_node_size;
end;
pdf_save_node:begin
r:= get_node(pdf_save_node_size);
words:= pdf_save_node_size;
end;
pdf_restore_node:begin
r:= get_node(pdf_restore_node_size);
words:= pdf_restore_node_size;
end;
pdf_refobj_node:begin
r:= get_node(pdf_refobj_node_size);
words:= pdf_refobj_node_size;
end;
pdf_refxform_node:begin
r:= get_node(pdf_refxform_node_size);
words:= pdf_refxform_node_size;
end;
pdf_refximage_node:begin
r:= get_node(pdf_refximage_node_size);
words:= pdf_refximage_node_size;
end;
pdf_annot_node:begin
r:= get_node(pdf_annot_node_size);
add_token_ref(pdf_annot_data(p));
words:= pdf_annot_node_size;
end;
pdf_start_link_node:begin
r:= get_node(pdf_annot_node_size);
pdf_height(r):= pdf_height(p);
pdf_depth(r):= pdf_depth(p);
pdf_width(r):= pdf_width(p);
pdf_link_attr(r):= pdf_link_attr(p);
if pdf_link_attr(r)<> null then
add_token_ref(pdf_link_attr(r));
pdf_link_action(r):= pdf_link_action(p);
add_action_ref(pdf_link_action(r));
pdf_link_objnum(r):= pdf_link_objnum(p);
end;
pdf_end_link_node:
r:= get_node(small_node_size);
pdf_dest_node:begin
r:= get_node(pdf_dest_node_size);
if pdf_dest_named_id(p)> 0 then
add_token_ref(pdf_dest_id(p));
words:= pdf_dest_node_size;
end;
pdf_thread_node,
pdf_start_thread_node:begin
r:= get_node(pdf_thread_node_size);
if pdf_thread_named_id(p)> 0 then
add_token_ref(pdf_thread_id(p));
if pdf_thread_attr(p)<> null then
add_token_ref(pdf_thread_attr(p));
words:= pdf_thread_node_size;
end;
pdf_end_thread_node:
r:= get_node(small_node_size);
pdf_save_pos_node:
r:= get_node(small_node_size);
pdf_snap_ref_point_node:
r:= get_node(small_node_size);
pdf_snapy_node:begin
add_glue_ref(snap_glue_ptr(p));
r:= get_node(snap_node_size);
words:= snap_node_size;
end;
pdf_snapy_comp_node:
r:= get_node(small_node_size);
pdf_interword_space_on_node:
r:= get_node(small_node_size);
pdf_interword_space_off_node:
r:= get_node(small_node_size);
pdf_fake_space_node:
r:= get_node(small_node_size);
pdf_running_link_off_node:
r:= get_node(small_node_size);
pdf_running_link_on_node:
r:= get_node(small_node_size);
othercases confusion("ext2")

endcases

/*:1601*/
#line 37866 "pdftexdir/pdftex.web"
;
othercases goto not_found
endcases;
while words> 0 do
begin decr(words);mem[r+words]:= mem[p+words];
end;
found:link(h):= r;h:= r;
not_found:p:= link(p);
end;
link(h):= t;
end;

/*:1730*//*1735:*/
#line 37933 "pdftexdir/pdftex.web"

#line 5909 "pdftex-final.ch"
procedure just_reverse(p:pointer);
label done;
#line 37936 "pdftexdir/pdftex.web"
var l:pointer;{the new list}
t:pointer;{tail of reversed segment}
q:pointer;{the next node}
m,n:halfword;{count of unmatched math nodes}
begin m:= min_halfword;n:= min_halfword;
if link(temp_head)= null then
begin just_copy(link(p),temp_head,null);q:= link(temp_head);
end
else begin q:= link(p);link(p):= null;flush_node_list(link(temp_head));
end;
t:= new_edge(cur_dir,0);l:= t;cur_dir:= reflected;
while q<> null do
if is_char_node(q)then
repeat p:= q;q:= link(p);link(p):= l;l:= p;
until not is_char_node(q)
else begin p:= q;q:= link(p);
if type(p)= math_node then
/*1736:*/
#line 37961 "pdftexdir/pdftex.web"

if end_LR(p)then
if info(LR_ptr)<> end_LR_type(p)then
#line 5938 "pdftex-final.ch"
 begin type(p):= kern_node;incr(LR_problems);
{{\sl Sync\TeX}node size watch point:|math_node|size==|kern_node|size}
end
else begin pop_LR;
if n> min_halfword then
begin decr(n);decr(subtype(p));{change|after|into|before|}
end
else begin if m> min_halfword then decr(m)else begin
width(t):= width(p);link(t):= q;free_node(p,medium_node_size);
{{\sl Sync\TeX}:no more"goto found",and proper node size}
goto done;
end;
type(p):= kern_node;
{{\sl Sync\TeX}node size watch point:|math_node|size==|kern_node|size}
end;
end
else begin push_LR(p);
if(n> min_halfword)or(LR_dir(p)<> cur_dir)then
begin incr(n);incr(subtype(p));{change|before|into|after|}
end
else begin type(p):= kern_node;incr(m);
{{\sl Sync\TeX}node size watch point:|math_node|size==|kern_node|size}
end;
end
#line 37981 "pdftexdir/pdftex.web"

/*:1736*/
#line 37953 "pdftexdir/pdftex.web"
;
link(p):= l;l:= p;
end;
goto done;
#line 5916 "pdftex-final.ch"
width(t):= width(p);link(t):= q;free_node(p,small_node_size);
#line 37958 "pdftexdir/pdftex.web"
done:link(temp_head):= l;
end;

/*:1735*/
#line 30323 "pdftexdir/pdftex.web"

procedure init_math;
label reswitch,found,not_found,done;
var w:scaled;{new or partial|pre_display_size|}
j:pointer;{prototype box for display}
x:integer;{new|pre_display_direction|}
l:scaled;{new|display_width|}
s:scaled;{new|display_indent|}
p:pointer;{current node when calculating|pre_display_size|}
q:pointer;{glue specification when calculating|pre_display_size|}
f:internal_font_number;{font in current|char_node|}
n:integer;{scope of paragraph shape specification}
v:scaled;{|w|plus possible glue amount}
d:scaled;{increment to|v|}
begin get_token;{|get_x_token|would fail on\.{\\ifmmode}\thinspace!}
if(cur_cmd= math_shift)and(mode> 0)then/*1321:*/
#line 30383 "pdftexdir/pdftex.web"

begin j:= null;w:= -max_dimen;
if head= tail then{`\.{\\noindent\$\$}' or `\.{\$\${ }\$\$}'}
/*1729:*/
#line 37832 "pdftexdir/pdftex.web"

begin pop_nest;/*1728:*/
#line 37828 "pdftexdir/pdftex.web"

if LR_save= null then x:= 0
else if info(LR_save)>=R_code then x:= -1 else x:= 1

/*:1728*/
#line 37833 "pdftexdir/pdftex.web"
;
end

/*:1729*/
#line 30386 "pdftexdir/pdftex.web"

else begin line_break(true);
/*1322:*/
#line 30406 "pdftexdir/pdftex.web"

/*1731:*/
#line 37881 "pdftexdir/pdftex.web"

if eTeX_ex then/*1737:*/
#line 37986 "pdftexdir/pdftex.web"

begin if right_skip= zero_glue then j:= new_kern(0)
else j:= new_param_glue(right_skip_code);
if left_skip= zero_glue then p:= new_kern(0)
else p:= new_param_glue(left_skip_code);
link(p):= j;j:= new_null_box;width(j):= width(just_box);
shift_amount(j):= shift_amount(just_box);list_ptr(j):= p;
glue_order(j):= glue_order(just_box);glue_sign(j):= glue_sign(just_box);
glue_set(j):= glue_set(just_box);
end

/*:1737*/
#line 37882 "pdftexdir/pdftex.web"
;
v:= shift_amount(just_box);
/*1728:*/
#line 37828 "pdftexdir/pdftex.web"

if LR_save= null then x:= 0
else if info(LR_save)>=R_code then x:= -1 else x:= 1

/*:1728*/
#line 37884 "pdftexdir/pdftex.web"
;
if x>=0 then
begin p:= list_ptr(just_box);link(temp_head):= null;
end
else begin v:= -v-width(just_box);
p:= new_math(0,begin_L_code);link(temp_head):= p;
just_copy(list_ptr(just_box),p,new_math(0,end_L_code));
cur_dir:= right_to_left;
end;
v:= v+2*quad(cur_font);
if TeXXeT_en then/*1707:*/
#line 37583 "pdftexdir/pdftex.web"

put_LR(before){this will never match}

/*:1707*/
#line 37894 "pdftexdir/pdftex.web"


/*:1731*/
#line 30407 "pdftexdir/pdftex.web"
;
while p<> null do
begin/*1323:*/
#line 30424 "pdftexdir/pdftex.web"

reswitch:if is_char_node(p)then
begin f:= font(p);d:= char_width(f)(char_info(f)(character(p)));
goto found;
end;
case type(p)of
hlist_node,vlist_node,rule_node:begin d:= width(p);goto found;
end;
ligature_node:/*824:*/
#line 20850 "pdftexdir/pdftex.web"

begin mem[lig_trick]:= mem[lig_char(p)];link(lig_trick):= link(p);
p:= lig_trick;goto reswitch;
end

/*:824*/
#line 30432 "pdftexdir/pdftex.web"
;
margin_kern_node:d:= width(p);
kern_node:d:= width(p);
/*1733:*/
#line 37910 "pdftexdir/pdftex.web"

math_node:begin d:= width(p);
if TeXXeT_en then/*1734:*/
#line 37920 "pdftexdir/pdftex.web"

if end_LR(p)then
begin if info(LR_ptr)= end_LR_type(p)then pop_LR
else if subtype(p)> L_code then
begin w:= max_dimen;goto done;
end
end
else begin push_LR(p);
if LR_dir(p)<> cur_dir then
begin just_reverse(p);p:= temp_head;
end;
end

/*:1734*/
#line 37912 "pdftexdir/pdftex.web"

else if subtype(p)>=L_code then
begin w:= max_dimen;goto done;
end;
end;
edge_node:begin d:= width(p);cur_dir:= subtype(p);
end;

/*:1733*/
#line 30435 "pdftexdir/pdftex.web"

glue_node:/*1324:*/
#line 30448 "pdftexdir/pdftex.web"

begin q:= glue_ptr(p);d:= width(q);
if glue_sign(just_box)= stretching then
begin if(glue_order(just_box)= stretch_order(q))and
(stretch(q)<> 0)then
v:= max_dimen;
end
else if glue_sign(just_box)= shrinking then
begin if(glue_order(just_box)= shrink_order(q))and
(shrink(q)<> 0)then
v:= max_dimen;
end;
if subtype(p)>=a_leaders then goto found;
end

/*:1324*/
#line 30437 "pdftexdir/pdftex.web"
;
whatsit_node:/*1605:*/
#line 35668 "pdftexdir/pdftex.web"

if(subtype(p)= pdf_refxform_node)or(subtype(p)= pdf_refximage_node)then
d:= pdf_width(p)
else
d:= 0

/*:1605*/
#line 30438 "pdftexdir/pdftex.web"
;
othercases d:= 0
endcases

/*:1323*/
#line 30411 "pdftexdir/pdftex.web"
;
if v<max_dimen then v:= v+d;
goto not_found;
found:if v<max_dimen then
begin v:= v+d;w:= v;
end
else begin w:= max_dimen;goto done;
end;
not_found:p:= link(p);
end;
done:
/*1732:*/
#line 37896 "pdftexdir/pdftex.web"

if TeXXeT_en then
begin while LR_ptr<> null do pop_LR;
if LR_problems<> 0 then
begin w:= max_dimen;LR_problems:= 0;
end;
end;
cur_dir:= left_to_right;flush_node_list(link(temp_head))

/*:1732*/
#line 30422 "pdftexdir/pdftex.web"


/*:1322*/
#line 30391 "pdftexdir/pdftex.web"
;
end;
{now we are in vertical mode,working on the list that will contain the display}
/*1325:*/
#line 30466 "pdftexdir/pdftex.web"

if par_shape_ptr= null then
if(hang_indent<> 0)and
(((hang_after>=0)and(prev_graf+2> hang_after))or
(prev_graf+1<-hang_after))then
begin l:= hsize-abs(hang_indent);
if hang_indent> 0 then s:= hang_indent else s:= 0;
end
else begin l:= hsize;s:= 0;
end
else begin n:= info(par_shape_ptr);
if prev_graf+2>=n then p:= par_shape_ptr+2*n
else p:= par_shape_ptr+2*(prev_graf+2);
s:= mem[p-1].sc;l:= mem[p].sc;
end

/*:1325*/
#line 30394 "pdftexdir/pdftex.web"
;
push_math(math_shift_group);mode:= mmode;
eq_word_define(int_base+cur_fam_code,-1);
eq_word_define(dimen_base+pre_display_size_code,w);
LR_box:= j;
if eTeX_ex then eq_word_define(int_base+pre_display_direction_code,x);
eq_word_define(dimen_base+display_width_code,l);
eq_word_define(dimen_base+display_indent_code,s);
if every_display<> null then begin_token_list(every_display,every_display_text);
if nest_ptr= 1 then build_page;
end

/*:1321*/
#line 30338 "pdftexdir/pdftex.web"

else begin back_input;/*1315:*/
#line 30343 "pdftexdir/pdftex.web"

begin push_math(math_shift_group);eq_word_define(int_base+cur_fam_code,-1);
#line 4167 "pdftex-final.ch"
if(insert_src_special_every_math)then insert_src_special;
if every_math<> null then begin_token_list(every_math,every_math_text);
#line 30346 "pdftexdir/pdftex.web"
end

/*:1315*/
#line 30339 "pdftexdir/pdftex.web"
;
end;
end;

/*:1314*//*1318:*/
#line 30367 "pdftexdir/pdftex.web"

procedure start_eq_no;
begin saved(0):= cur_chr;incr(save_ptr);
/*1315:*/
#line 30343 "pdftexdir/pdftex.web"

begin push_math(math_shift_group);eq_word_define(int_base+cur_fam_code,-1);
#line 4167 "pdftex-final.ch"
if(insert_src_special_every_math)then insert_src_special;
if every_math<> null then begin_token_list(every_math,every_math_text);
#line 30346 "pdftexdir/pdftex.web"
end

/*:1315*/
#line 30370 "pdftexdir/pdftex.web"
;
end;

/*:1318*//*1327:*/
#line 30510 "pdftexdir/pdftex.web"

procedure scan_math(p:pointer);
label restart,reswitch,exit;
var c:integer;{math character code}
begin restart:/*430:*/
#line 9537 "pdftexdir/pdftex.web"

repeat get_x_token;
until(cur_cmd<> spacer)and(cur_cmd<> relax)

/*:430*/
#line 30514 "pdftexdir/pdftex.web"
;
reswitch:case cur_cmd of
letter,other_char,char_given:begin c:= ho(math_code(cur_chr));
if c= 49
begin/*1328:*/
#line 30539 "pdftexdir/pdftex.web"

begin cur_cs:= cur_chr+active_base;
cur_cmd:= eq_type(cur_cs);cur_chr:= equiv(cur_cs);
x_token;back_input;
end

/*:1328*/
#line 30518 "pdftexdir/pdftex.web"
;
goto restart;
end;
end;
char_num:begin scan_char_num;cur_chr:= cur_val;cur_cmd:= char_given;
goto reswitch;
end;
math_char_num:begin scan_fifteen_bit_int;c:= cur_val;
end;
math_given:c:= cur_chr;
delim_num:begin scan_twenty_seven_bit_int;c:= cur_val div 49
end;
othercases/*1329:*/
#line 30548 "pdftexdir/pdftex.web"

begin back_input;scan_left_brace;
saved(0):= p;incr(save_ptr);push_math(math_group);return;
end

/*:1329*/
#line 30530 "pdftexdir/pdftex.web"

endcases;
math_type(p):= math_char;character(p):= qi(c mod 256);
if(c>=var_code)and fam_in_range then fam(p):= cur_fam
else fam(p):= (c div 256)mod 16;
exit:end;

/*:1327*//*1331:*/
#line 30578 "pdftexdir/pdftex.web"

procedure set_math_char(c:integer);
var p:pointer;{the new noad}
begin if c>=49
/*1328:*/
#line 30539 "pdftexdir/pdftex.web"

begin cur_cs:= cur_chr+active_base;
cur_cmd:= eq_type(cur_cs);cur_chr:= equiv(cur_cs);
x_token;back_input;
end

/*:1328*/
#line 30582 "pdftexdir/pdftex.web"

else begin p:= new_noad;math_type(nucleus(p)):= math_char;
character(nucleus(p)):= qi(c mod 256);
fam(nucleus(p)):= (c div 256)mod 16;
if c>=var_code then
begin if fam_in_range then fam(nucleus(p)):= cur_fam;
type(p):= ord_noad;
end
else type(p):= ord_noad+(c div 49
link(tail):= p;tail:= p;
end;
end;

/*:1331*//*1335:*/
#line 30650 "pdftexdir/pdftex.web"

procedure math_limit_switch;
label exit;
begin if head<> tail then if type(tail)= op_noad then
begin subtype(tail):= cur_chr;return;
end;
print_err("Limit controls must follow a math operator");

help1("I'm ignoring this misplaced \limits or \nolimits command.");error;
exit:end;

/*:1335*//*1336:*/
#line 30666 "pdftexdir/pdftex.web"

procedure scan_delimiter(p:pointer;r:boolean);
begin if r then scan_twenty_seven_bit_int
else begin/*430:*/
#line 9537 "pdftexdir/pdftex.web"

repeat get_x_token;
until(cur_cmd<> spacer)and(cur_cmd<> relax)

/*:430*/
#line 30669 "pdftexdir/pdftex.web"
;
case cur_cmd of
letter,other_char:cur_val:= del_code(cur_chr);
delim_num:scan_twenty_seven_bit_int;
othercases cur_val:= -1
endcases;
end;
if cur_val<0 then/*1337:*/
#line 30684 "pdftexdir/pdftex.web"

begin print_err("Missing delimiter (. inserted)");

help6("I was expecting to see something like `(' or `\{' or")
("`\}' here. If you typed, e.g., `{' instead of `\{', you")
("should probably delete the `{' by typing `1' now, so that")
("braces don't get unbalanced. Otherwise just proceed.")
("Acceptable delimiters are characters whose \delcode is")
("nonnegative, or you can use `\delimiter <delimiter code>'.");
back_error;cur_val:= 0;
end

/*:1337*/
#line 30677 "pdftexdir/pdftex.web"
;
small_fam(p):= (cur_val div 52
small_char(p):= qi((cur_val div 49
large_fam(p):= (cur_val div 256)mod 16;
large_char(p):= qi(cur_val mod 256);
end;

/*:1336*//*1339:*/
#line 30699 "pdftexdir/pdftex.web"

procedure math_radical;
begin tail_append(get_node(radical_noad_size));
type(tail):= radical_noad;subtype(tail):= normal;
mem[nucleus(tail)].hh:= empty_field;
mem[subscr(tail)].hh:= empty_field;
mem[supscr(tail)].hh:= empty_field;
scan_delimiter(left_delimiter(tail),true);scan_math(nucleus(tail));
end;

/*:1339*//*1341:*/
#line 30712 "pdftexdir/pdftex.web"

procedure math_ac;
begin if cur_cmd= accent then
/*1342:*/
#line 30729 "pdftexdir/pdftex.web"

begin print_err("Please use ");print_esc("mathaccent");
print(" for accents in math mode");

help2("I'm changing \accent to \mathaccent here; wish me luck.")
("(Accents are not the same in formulas as they are in text.)");
error;
end

/*:1342*/
#line 30715 "pdftexdir/pdftex.web"
;
tail_append(get_node(accent_noad_size));
type(tail):= accent_noad;subtype(tail):= normal;
mem[nucleus(tail)].hh:= empty_field;
mem[subscr(tail)].hh:= empty_field;
mem[supscr(tail)].hh:= empty_field;
math_type(accent_chr(tail)):= math_char;
scan_fifteen_bit_int;
character(accent_chr(tail)):= qi(cur_val mod 256);
if(cur_val>=var_code)and fam_in_range then fam(accent_chr(tail)):= cur_fam
else fam(accent_chr(tail)):= (cur_val div 256)mod 16;
scan_math(nucleus(tail));
end;

/*:1341*//*1348:*/
#line 30776 "pdftexdir/pdftex.web"

procedure append_choices;
begin tail_append(new_choice);incr(save_ptr);saved(-1):= 0;
push_math(math_choice_group);scan_left_brace;
end;

/*:1348*//*1350:*/
#line 30785 "pdftexdir/pdftex.web"

/*1360:*/
#line 30930 "pdftexdir/pdftex.web"

function fin_mlist(p:pointer):pointer;
var q:pointer;{the mlist to return}
begin if incompleat_noad<> null then/*1361:*/
#line 30939 "pdftexdir/pdftex.web"

begin math_type(denominator(incompleat_noad)):= sub_mlist;
info(denominator(incompleat_noad)):= link(head);
if p= null then q:= incompleat_noad
else begin q:= info(numerator(incompleat_noad));
if(type(q)<> left_noad)or(delim_ptr= null)then confusion("right");

info(numerator(incompleat_noad)):= link(delim_ptr);
link(delim_ptr):= incompleat_noad;link(incompleat_noad):= p;
end;
end

/*:1361*/
#line 30933 "pdftexdir/pdftex.web"

else begin link(tail):= p;q:= link(head);
end;
pop_nest;fin_mlist:= q;
end;

/*:1360*/
#line 30786 "pdftexdir/pdftex.web"

procedure build_choices;
label exit;
var p:pointer;{the current mlist}
begin unsave;p:= fin_mlist(null);
case saved(-1)of
0:display_mlist(tail):= p;
1:text_mlist(tail):= p;
2:script_mlist(tail):= p;
3:begin script_script_mlist(tail):= p;decr(save_ptr);return;
end;
end;{there are no other cases}
incr(saved(-1));push_math(math_choice_group);scan_left_brace;
exit:end;

/*:1350*//*1352:*/
#line 30809 "pdftexdir/pdftex.web"

procedure sub_sup;
var t:small_number;{type of previous sub/superscript}
p:pointer;{field to be filled by|scan_math|}
begin t:= empty;p:= null;
if tail<> head then if scripts_allowed(tail)then
begin p:= supscr(tail)+cur_cmd-sup_mark;{|supscr|or|subscr|}
t:= math_type(p);
end;
if(p= null)or(t<> empty)then/*1353:*/
#line 30822 "pdftexdir/pdftex.web"

begin tail_append(new_noad);
p:= supscr(tail)+cur_cmd-sup_mark;{|supscr|or|subscr|}
if t<> empty then
begin if cur_cmd= sup_mark then
begin print_err("Double superscript");

help1("I treat `x^1^2' essentially like `x^1{}^2'.");
end
else begin print_err("Double subscript");

help1("I treat `x_1_2' essentially like `x_1{}_2'.");
end;
error;
end;
end

/*:1353*/
#line 30818 "pdftexdir/pdftex.web"
;
scan_math(p);
end;

/*:1352*//*1357:*/
#line 30879 "pdftexdir/pdftex.web"

procedure math_fraction;
var c:small_number;{the type of generalized fraction we are scanning}
begin c:= cur_chr;
if incompleat_noad<> null then
/*1359:*/
#line 30911 "pdftexdir/pdftex.web"

begin if c>=delimited_code then
begin scan_delimiter(garbage,false);scan_delimiter(garbage,false);
end;
if c mod delimited_code= above_code then scan_normal_dimen;
print_err("Ambiguous; you need another { and }");

help3("I'm ignoring this fraction specification, since I don't")
("know whether a construction like `x \over y \over z'")
("means `{x \over y} \over z' or `x \over {y \over z}'.");
error;
end

/*:1359*/
#line 30884 "pdftexdir/pdftex.web"

else begin incompleat_noad:= get_node(fraction_noad_size);
type(incompleat_noad):= fraction_noad;
subtype(incompleat_noad):= normal;
math_type(numerator(incompleat_noad)):= sub_mlist;
info(numerator(incompleat_noad)):= link(head);
mem[denominator(incompleat_noad)].hh:= empty_field;
mem[left_delimiter(incompleat_noad)].qqqq:= null_delimiter;
mem[right_delimiter(incompleat_noad)].qqqq:= null_delimiter;
link(head):= null;tail:= head;
/*1358:*/
#line 30898 "pdftexdir/pdftex.web"

if c>=delimited_code then
begin scan_delimiter(left_delimiter(incompleat_noad),false);
scan_delimiter(right_delimiter(incompleat_noad),false);
end;
case c mod delimited_code of
above_code:begin scan_normal_dimen;
thickness(incompleat_noad):= cur_val;
end;
over_code:thickness(incompleat_noad):= default_code;
atop_code:thickness(incompleat_noad):= 0;
end{there are no other cases}

/*:1358*/
#line 30894 "pdftexdir/pdftex.web"
;
end;
end;

/*:1357*//*1367:*/
#line 30995 "pdftexdir/pdftex.web"

procedure math_left_right;
var t:small_number;{|left_noad|or|right_noad|}
p:pointer;{new noad}
q:pointer;{resulting mlist}
begin t:= cur_chr;
if(t<> left_noad)and(cur_group<> math_left_group)then
/*1368:*/
#line 31023 "pdftexdir/pdftex.web"

begin if cur_group= math_shift_group then
begin scan_delimiter(garbage,false);
print_err("Extra ");
if t= middle_noad then
begin print_esc("middle");

help1("I'm ignoring a \middle that had no matching \left.");
end
else begin print_esc("right");

help1("I'm ignoring a \right that had no matching \left.");
end;
error;
end
else off_save;
end

/*:1368*/
#line 31002 "pdftexdir/pdftex.web"

else begin p:= new_noad;type(p):= t;
scan_delimiter(delimiter(p),false);
if t= middle_noad then
begin type(p):= right_noad;subtype(p):= middle_noad;
end;
if t= left_noad then q:= p
else begin q:= fin_mlist(p);unsave;{end of|math_left_group|}
end;
if t<> right_noad then
begin push_math(math_left_group);link(head):= q;tail:= p;
delim_ptr:= p;
end
else begin
tail_append(new_noad);type(tail):= inner_noad;
math_type(nucleus(tail)):= sub_mlist;
info(nucleus(tail)):= q;
end;
end;
end;

/*:1367*//*1370:*/
#line 31047 "pdftexdir/pdftex.web"

/*1741:*/
#line 38013 "pdftexdir/pdftex.web"

procedure app_display(j,b:pointer;d:scaled);
var z:scaled;{width of the line}
s:scaled;{move the line right this much}
e:scaled;{distance from right edge of box to end of line}
x:integer;{|pre_display_direction|}
p,q,r,t,u:pointer;{for list manipulation}
begin s:= display_indent;x:= pre_display_direction;
if x= 0 then shift_amount(b):= s+d
else begin z:= display_width;p:= b;
/*1742:*/
#line 38034 "pdftexdir/pdftex.web"

if x> 0 then e:= z-d-width(p)
else begin e:= d;d:= z-e-width(p);
end;
if j<> null then
begin b:= copy_node_list(j);height(b):= height(p);depth(b):= depth(p);
s:= s-shift_amount(b);d:= d+s;e:= e+width(b)-z-s;
end;
if box_lr(p)= dlist then q:= p{display or equation number}
else begin{display and equation number}
r:= list_ptr(p);free_node(p,box_node_size);
if r= null then confusion("LR4");
if x> 0 then
begin p:= r;
repeat q:= r;r:= link(r);{find tail of list}
until r= null;
end
else begin p:= null;q:= r;
repeat t:= link(r);link(r):= p;p:= r;r:= t;{reverse list}
until r= null;
end;
end

/*:1742*/
#line 38023 "pdftexdir/pdftex.web"
;
/*1743:*/
#line 38076 "pdftexdir/pdftex.web"

if j= null then
begin r:= new_kern(0);t:= new_kern(0);{the widths will be set later}
end
else begin r:= list_ptr(b);t:= link(r);
end;
u:= new_math(0,end_M_code);
if type(t)= glue_node then{|t|is\.{\\rightskip}glue}
begin cancel_glue(right_skip_code)(q)(u)(t)(e);link(u):= t;
end
else begin width(t):= e;link(t):= u;link(q):= t;
end;
u:= new_math(0,begin_M_code);
if type(r)= glue_node then{|r|is\.{\\leftskip}glue}
begin cancel_glue(left_skip_code)(u)(p)(r)(d);link(r):= u;
end
else begin width(r):= d;link(r):= p;link(u):= r;
if j= null then
begin b:= hpack(u,natural);shift_amount(b):= s;
end
else list_ptr(b):= u;
end

/*:1743*/
#line 38024 "pdftexdir/pdftex.web"
;
end;
append_to_vlist(b);
end;

/*:1741*/
#line 31048 "pdftexdir/pdftex.web"

procedure after_math;
var l:boolean;{`\.{\\leqno}' instead of `\.{\\eqno}'}
danger:boolean;{not enough symbol fonts are present}
m:integer;{|mmode|or|-mmode|}
p:pointer;{the formula}
a:pointer;{box containing equation number}
/*1374:*/
#line 31135 "pdftexdir/pdftex.web"

b:pointer;{box containing the equation}
w:scaled;{width of the equation}
z:scaled;{width of the line}
e:scaled;{width of equation number}
q:scaled;{width of equation number plus space to separate from equation}
d:scaled;{displacement of equation in the line}
s:scaled;{move the line right this much}
g1,g2:small_number;{glue parameter codes for before and after}
r:pointer;{kern node used to position the display}
t:pointer;{tail of adjustment list}
pre_t:pointer;{tail of pre-adjustment list}

/*:1374*//*1738:*/
#line 37999 "pdftexdir/pdftex.web"

j:pointer;{prototype box}

/*:1738*/
#line 31055 "pdftexdir/pdftex.web"

begin danger:= false;
/*1739:*/
#line 38002 "pdftexdir/pdftex.web"

if mode= mmode then j:= LR_box

/*:1739*/
#line 31057 "pdftexdir/pdftex.web"
;
/*1371:*/
#line 31081 "pdftexdir/pdftex.web"

if(font_params[fam_fnt(2+text_size)]<total_mathsy_params)or
(font_params[fam_fnt(2+script_size)]<total_mathsy_params)or
(font_params[fam_fnt(2+script_script_size)]<total_mathsy_params)then
begin print_err("Math formula deleted: Insufficient symbol fonts");

help3("Sorry, but I can't typeset math unless \textfont 2")
("and \scriptfont 2 and \scriptscriptfont 2 have all")
("the \fontdimen values needed in math symbol fonts.");
error;flush_math;danger:= true;
end
else if(font_params[fam_fnt(3+text_size)]<total_mathex_params)or
(font_params[fam_fnt(3+script_size)]<total_mathex_params)or
(font_params[fam_fnt(3+script_script_size)]<total_mathex_params)then
begin print_err("Math formula deleted: Insufficient extension fonts");
help3("Sorry, but I can't typeset math unless \textfont 3")
("and \scriptfont 3 and \scriptscriptfont 3 have all")
("the \fontdimen values needed in math extension fonts.");
error;flush_math;danger:= true;
end

/*:1371*/
#line 31059 "pdftexdir/pdftex.web"
;
m:= mode;l:= false;p:= fin_mlist(null);{this pops the nest}
if mode= -m then{end of equation number}
begin/*1373:*/
#line 31120 "pdftexdir/pdftex.web"

begin get_x_token;
if cur_cmd<> math_shift then
begin print_err("Display math should end with $$");

help2("The `$' that I just saw supposedly matches a previous `$$'.")
("So I shall assume that you typed `$$' both times.");
back_error;
end;
end

/*:1373*/
#line 31062 "pdftexdir/pdftex.web"
;
cur_mlist:= p;cur_style:= text_style;mlist_penalties:= false;
mlist_to_hlist;a:= hpack(link(temp_head),natural);
set_box_lr(a)(dlist);
unsave;decr(save_ptr);{now|cur_group= math_shift_group|}
if saved(0)= 1 then l:= true;
danger:= false;
/*1739:*/
#line 38002 "pdftexdir/pdftex.web"

if mode= mmode then j:= LR_box

/*:1739*/
#line 31069 "pdftexdir/pdftex.web"
;
/*1371:*/
#line 31081 "pdftexdir/pdftex.web"

if(font_params[fam_fnt(2+text_size)]<total_mathsy_params)or
(font_params[fam_fnt(2+script_size)]<total_mathsy_params)or
(font_params[fam_fnt(2+script_script_size)]<total_mathsy_params)then
begin print_err("Math formula deleted: Insufficient symbol fonts");

help3("Sorry, but I can't typeset math unless \textfont 2")
("and \scriptfont 2 and \scriptscriptfont 2 have all")
("the \fontdimen values needed in math symbol fonts.");
error;flush_math;danger:= true;
end
else if(font_params[fam_fnt(3+text_size)]<total_mathex_params)or
(font_params[fam_fnt(3+script_size)]<total_mathex_params)or
(font_params[fam_fnt(3+script_script_size)]<total_mathex_params)then
begin print_err("Math formula deleted: Insufficient extension fonts");
help3("Sorry, but I can't typeset math unless \textfont 3")
("and \scriptfont 3 and \scriptscriptfont 3 have all")
("the \fontdimen values needed in math extension fonts.");
error;flush_math;danger:= true;
end

/*:1371*/
#line 31071 "pdftexdir/pdftex.web"
;
m:= mode;p:= fin_mlist(null);
end
else a:= null;
if m<0 then/*1372:*/
#line 31108 "pdftexdir/pdftex.web"

begin tail_append(new_math(math_surround,before));
cur_mlist:= p;cur_style:= text_style;mlist_penalties:= (mode> 0);mlist_to_hlist;
link(tail):= link(temp_head);
while link(tail)<> null do tail:= link(tail);
tail_append(new_math(math_surround,after));
space_factor:= 1000;unsave;
end

/*:1372*/
#line 31075 "pdftexdir/pdftex.web"

else begin if a= null then/*1373:*/
#line 31120 "pdftexdir/pdftex.web"

begin get_x_token;
if cur_cmd<> math_shift then
begin print_err("Display math should end with $$");

help2("The `$' that I just saw supposedly matches a previous `$$'.")
("So I shall assume that you typed `$$' both times.");
back_error;
end;
end

/*:1373*/
#line 31076 "pdftexdir/pdftex.web"
;
/*1375:*/
#line 31152 "pdftexdir/pdftex.web"

cur_mlist:= p;cur_style:= display_style;mlist_penalties:= false;
mlist_to_hlist;p:= link(temp_head);
adjust_tail:= adjust_head;pre_adjust_tail:= pre_adjust_head;
b:= hpack(p,natural);p:= list_ptr(b);
t:= adjust_tail;adjust_tail:= null;
pre_t:= pre_adjust_tail;pre_adjust_tail:= null;
w:= width(b);z:= display_width;s:= display_indent;
if pre_display_direction<0 then s:= -s-z;
if(a= null)or danger then
begin e:= 0;q:= 0;
end
else begin e:= width(a);q:= e+math_quad(text_size);
end;
if w+q> z then
/*1377:*/
#line 31193 "pdftexdir/pdftex.web"

begin if(e<> 0)and((w-total_shrink[normal]+q<=z)or
(total_shrink[fil]<> 0)or(total_shrink[fill]<> 0)or
(total_shrink[filll]<> 0))then
begin free_node(b,box_node_size);
b:= hpack(p,z-q,exactly);
end
else begin e:= 0;
if w> z then
begin free_node(b,box_node_size);
b:= hpack(p,z,exactly);
end;
end;
w:= width(b);
end

/*:1377*/
#line 31169 "pdftexdir/pdftex.web"
;
/*1378:*/
#line 31217 "pdftexdir/pdftex.web"

set_box_lr(b)(dlist);
d:= half(z-w);
if(e> 0)and(d<2*e)then{too close}
begin d:= half(z-w-e);
if p<> null then if not is_char_node(p)then if type(p)= glue_node then d:= 0;
end

/*:1378*/
#line 31171 "pdftexdir/pdftex.web"
;
/*1379:*/
#line 31231 "pdftexdir/pdftex.web"

tail_append(new_penalty(pre_display_penalty));
if(d+s<=pre_display_size)or l then{not enough clearance}
begin g1:= above_display_skip_code;g2:= below_display_skip_code;
end
else begin g1:= above_display_short_skip_code;
g2:= below_display_short_skip_code;
end;
if l and(e= 0)then{it follows that|type(a)= hlist_node|}
begin app_display(j,a,0);
tail_append(new_penalty(inf_penalty));
end
else tail_append(new_param_glue(g1))

/*:1379*/
#line 31172 "pdftexdir/pdftex.web"
;
/*1380:*/
#line 31245 "pdftexdir/pdftex.web"

if e<> 0 then
begin r:= new_kern(z-w-e-d);
if l then
begin link(a):= r;link(r):= b;b:= a;d:= 0;
end
else begin link(b):= r;link(r):= a;
end;
b:= hpack(b,natural);
end;
app_display(j,b,d)

/*:1380*/
#line 31173 "pdftexdir/pdftex.web"
;
/*1381:*/
#line 31257 "pdftexdir/pdftex.web"

if(a<> null)and(e= 0)and not l then
begin tail_append(new_penalty(inf_penalty));
app_display(j,a,z-width(a));
g2:= 0;
end;
if t<> adjust_head then{migrating material comes after equation number}
begin link(tail):= link(adjust_head);tail:= t;
end;
if pre_t<> pre_adjust_head then
begin link(tail):= link(pre_adjust_head);tail:= pre_t;
end;
tail_append(new_penalty(post_display_penalty));
if g2> 0 then tail_append(new_param_glue(g2))

/*:1381*/
#line 31174 "pdftexdir/pdftex.web"
;
/*1740:*/
#line 38005 "pdftexdir/pdftex.web"

flush_node_list(j)

/*:1740*/
#line 31175 "pdftexdir/pdftex.web"
;
resume_after_display

/*:1375*/
#line 31077 "pdftexdir/pdftex.web"
;
end;
end;

/*:1370*//*1376:*/
#line 31178 "pdftexdir/pdftex.web"

procedure resume_after_display;
begin if cur_group<> math_shift_group then confusion("display");

unsave;prev_graf:= prev_graf+3;
push_nest;mode:= hmode;space_factor:= 1000;set_cur_lang;clang:= cur_lang;
prev_graf:= (norm_min(left_hyphen_min)*49
*50
/*469:*/
#line 10264 "pdftexdir/pdftex.web"

begin get_x_token;if cur_cmd<> spacer then back_input;
end

/*:469*/
#line 31186 "pdftexdir/pdftex.web"
;
if nest_ptr= 1 then build_page;
end;

/*:1376*//*1387:*/
#line 31383 "pdftexdir/pdftex.web"

/*1391:*/
#line 31461 "pdftexdir/pdftex.web"

procedure get_r_token;
label restart;
begin restart:repeat get_token;
until cur_tok<> space_token;
#line 4187 "pdftex-final.ch"
if(cur_cs= 0)or(cur_cs> eqtb_top)or
((cur_cs> frozen_control_sequence)and(cur_cs<=eqtb_size))then
#line 31467 "pdftexdir/pdftex.web"
 begin print_err("Missing control sequence inserted");

help5("Please don't say `\def cs{...}', say `\def\cs{...}'.")
("I've inserted an inaccessible control sequence so that your")
("definition will be completed without mixing me up too badly.")
("You can recover graciously from this error, if you're")
("careful; see exercise 27.2 in The TeXbook.");

if cur_cs= 0 then back_input;
cur_tok:= cs_token_flag+frozen_protection;ins_error;goto restart;
end;
end;

/*:1391*//*1405:*/
#line 31702 "pdftexdir/pdftex.web"

procedure trap_zero_glue;
begin if(width(cur_val)= 0)and(stretch(cur_val)= 0)and(shrink(cur_val)= 0)then
begin add_glue_ref(zero_glue);
delete_glue_ref(cur_val);cur_val:= zero_glue;
end;
end;

/*:1405*//*1412:*/
#line 31782 "pdftexdir/pdftex.web"

procedure do_register_command(a:small_number);
label found,exit;
var l,q,r,s:pointer;{for list manipulation}
p:int_val..mu_val;{type of register involved}
e:boolean;{does|l|refer to a sparse array element?}
w:integer;{integer or dimen value of|l|}
begin q:= cur_cmd;
e:= false;{just in case,will be set|true|for sparse array elements}
/*1413:*/
#line 31815 "pdftexdir/pdftex.web"

begin if q<> register then
begin get_x_token;
if(cur_cmd>=assign_int)and(cur_cmd<=assign_mu_glue)then
begin l:= cur_chr;p:= cur_cmd-assign_int;goto found;
end;
if cur_cmd<> register then
begin print_err("You can't use `");print_cmd_chr(cur_cmd,cur_chr);

print("' after ");print_cmd_chr(q,0);
help1("I'm forgetting what you said and not changing anything.");
error;return;
end;
end;
if(cur_chr<mem_bot)or(cur_chr> lo_mem_stat_max)then
begin l:= cur_chr;p:= sa_type(l);e:= true;
end
else begin p:= cur_chr-mem_bot;scan_register_num;
if cur_val> 255 then
begin find_sa_element(p,cur_val,true);l:= cur_ptr;e:= true;
end
else
case p of
int_val:l:= cur_val+count_base;
dimen_val:l:= cur_val+scaled_base;
glue_val:l:= cur_val+skip_base;
mu_val:l:= cur_val+mu_skip_base;
end;{there are no other cases}
end;
end;
found:if p<glue_val then if e then w:= sa_int(l)else w:= eqtb[l].int
else if e then s:= sa_ptr(l)else s:= equiv(l)

/*:1413*/
#line 31791 "pdftexdir/pdftex.web"
;
if q= register then scan_optional_equals
else if scan_keyword("by")then do_nothing;{optional`\.{by}'}

arith_error:= false;
if q<multiply then/*1414:*/
#line 31848 "pdftexdir/pdftex.web"

if p<glue_val then
begin if p= int_val then scan_int else scan_normal_dimen;
if q= advance then cur_val:= cur_val+w;
end
else begin scan_glue(p);
if q= advance then/*1415:*/
#line 31857 "pdftexdir/pdftex.web"

begin q:= new_spec(cur_val);r:= s;
delete_glue_ref(cur_val);
width(q):= width(q)+width(r);
if stretch(q)= 0 then stretch_order(q):= normal;
if stretch_order(q)= stretch_order(r)then stretch(q):= stretch(q)+stretch(r)
else if(stretch_order(q)<stretch_order(r))and(stretch(r)<> 0)then
begin stretch(q):= stretch(r);stretch_order(q):= stretch_order(r);
end;
if shrink(q)= 0 then shrink_order(q):= normal;
if shrink_order(q)= shrink_order(r)then shrink(q):= shrink(q)+shrink(r)
else if(shrink_order(q)<shrink_order(r))and(shrink(r)<> 0)then
begin shrink(q):= shrink(r);shrink_order(q):= shrink_order(r);
end;
cur_val:= q;
end

/*:1415*/
#line 31854 "pdftexdir/pdftex.web"
;
end

/*:1414*/
#line 31797 "pdftexdir/pdftex.web"

else/*1416:*/
#line 31874 "pdftexdir/pdftex.web"

begin scan_int;
if p<glue_val then
if q= multiply then
if p= int_val then cur_val:= mult_integers(w,cur_val)
else cur_val:= nx_plus_y(w,cur_val,0)
else cur_val:= x_over_n(w,cur_val)
else begin r:= new_spec(s);
if q= multiply then
begin width(r):= nx_plus_y(width(s),cur_val,0);
stretch(r):= nx_plus_y(stretch(s),cur_val,0);
shrink(r):= nx_plus_y(shrink(s),cur_val,0);
end
else begin width(r):= x_over_n(width(s),cur_val);
stretch(r):= x_over_n(stretch(s),cur_val);
shrink(r):= x_over_n(shrink(s),cur_val);
end;
cur_val:= r;
end;
end

/*:1416*/
#line 31798 "pdftexdir/pdftex.web"
;
if arith_error then
begin print_err("Arithmetic overflow");

help2("I can't carry out that multiplication or division,")
("since the result is out of range.");
if p>=glue_val then delete_glue_ref(cur_val);
error;return;
end;
if p<glue_val then sa_word_define(l,cur_val)
else begin trap_zero_glue;sa_define(l,cur_val)(l,glue_ref,cur_val);
end;
exit:end;

/*:1412*//*1419:*/
#line 31926 "pdftexdir/pdftex.web"

procedure alter_aux;
var c:halfword;{|hmode|or|vmode|}
begin if cur_chr<> abs(mode)then report_illegal_case
else begin c:= cur_chr;scan_optional_equals;
if c= vmode then
begin scan_normal_dimen;prev_depth:= cur_val;
end
else begin scan_int;
if(cur_val<=0)or(cur_val> 32767)then
begin print_err("Bad space factor");

help1("I allow only values in the range 1..32767 here.");
int_error(cur_val);
end
else space_factor:= cur_val;
end;
end;
end;

/*:1419*//*1420:*/
#line 31946 "pdftexdir/pdftex.web"

procedure alter_prev_graf;
var p:0..nest_size;{index into|nest|}
begin nest[nest_ptr]:= cur_list;p:= nest_ptr;
while abs(nest[p].mode_field)<> vmode do decr(p);
scan_optional_equals;scan_int;
if cur_val<0 then
begin print_err("Bad ");print_esc("prevgraf");

help1("I allow only nonnegative values here.");
int_error(cur_val);
end
else begin nest[p].pg_field:= cur_val;cur_list:= nest[nest_ptr];
end;
end;

/*:1420*//*1421:*/
#line 31962 "pdftexdir/pdftex.web"

procedure alter_page_so_far;
var c:0. .7;{index into|page_so_far|}
begin c:= cur_chr;scan_optional_equals;scan_normal_dimen;
page_so_far[c]:= cur_val;
end;

/*:1421*//*1422:*/
#line 31969 "pdftexdir/pdftex.web"

procedure alter_integer;
var c:small_number;
{0 for\.{\\deadcycles},1 for\.{\\insertpenalties},etc.}
begin c:= cur_chr;scan_optional_equals;scan_int;
if c= 0 then dead_cycles:= cur_val
/*1693:*/
#line 37381 "pdftexdir/pdftex.web"

else if c= 2 then
begin if(cur_val<batch_mode)or(cur_val> error_stop_mode)then
begin print_err("Bad interaction mode");

help2("Modes are 0=batch, 1=nonstop, 2=scroll, and")
("3=errorstop. Proceed, and I'll ignore this case.");
int_error(cur_val);
end
else begin cur_chr:= cur_val;new_interaction;
end;
end

/*:1693*/
#line 31975 "pdftexdir/pdftex.web"

else insert_penalties:= cur_val;
end;

/*:1422*//*1423:*/
#line 31979 "pdftexdir/pdftex.web"

procedure alter_box_dimen;
var c:small_number;{|width_offset|or|height_offset|or|depth_offset|}
b:pointer;{box register}
begin c:= cur_chr;scan_register_num;fetch_box(b);scan_optional_equals;
scan_normal_dimen;
if b<> null then mem[b+c].sc:= cur_val;
end;

/*:1423*//*1433:*/
#line 32122 "pdftexdir/pdftex.web"

procedure new_font(a:small_number);
label common_ending;
var u:pointer;{user's font identifier}
s:scaled;{stated``at''size,or negative of scaled magnification}
f:internal_font_number;{runs through existing fonts}
t:str_number;{name for the frozen font identifier}
old_setting:0..max_selector;{holds|selector|setting}
#line 32131 "pdftexdir/pdftex.web"
begin if job_name= 0 then open_log_file;
{avoid confusing\.{texput}with the font name}

get_r_token;u:= cur_cs;
if u>=hash_base then t:= text(u)
else if u>=single_base then
if u= null_cs then t:= "FONT"else t:= u-single_base
else begin old_setting:= selector;selector:= new_string;
print("FONT");print(u-active_base);selector:= old_setting;

str_room(1);t:= make_string;
end;
define(u,set_font,null_font);scan_optional_equals;scan_file_name;
/*1434:*/
#line 32151 "pdftexdir/pdftex.web"

name_in_progress:= true;{this keeps|cur_name|from being changed}
if scan_keyword("at")then/*1435:*/
#line 32168 "pdftexdir/pdftex.web"

begin scan_normal_dimen;s:= cur_val;
if(s<=0)or(s>=49
begin print_err("Improper `at' size (");
print_scaled(s);print("pt), replaced by 10pt");

help2("I can only handle fonts at positive sizes that are")
("less than 2048pt, so I've changed what you said to 10pt.");
error;s:= 10*unity;
end;
end

/*:1435*/
#line 32153 "pdftexdir/pdftex.web"


else if scan_keyword("scaled")then

begin scan_int;s:= -cur_val;
if(cur_val<=0)or(cur_val> 32768)then
begin print_err("Illegal magnification has been changed to 1000");

help1("The magnification ratio must be between 1 and 32768.");
int_error(cur_val);s:= -1000;
end;
end
else s:= -1000;
name_in_progress:= false

/*:1434*/
#line 32144 "pdftexdir/pdftex.web"
;
/*1436:*/
#line 32184 "pdftexdir/pdftex.web"

#line 32186 "pdftexdir/pdftex.web"
for f:= font_base+1 to font_ptr do
if str_eq_str(font_name[f],cur_name)and str_eq_str(font_area[f],cur_area)then
#line 4440 "pdftex-final.ch"
 begin
if pdf_font_step[f]= 0 then begin
if s> 0 then
begin if s= font_size[f]then goto common_ending;
end
else if font_size[f]= xn_over_d(font_dsize[f],-s,1000)then
goto common_ending;
end
end
#line 32197 "pdftexdir/pdftex.web"

/*:1436*/
#line 32146 "pdftexdir/pdftex.web"
;
f:= read_font_info(u,cur_name,cur_area,s);
common_ending:define(u,set_font,f);eqtb[font_id_base+f]:= eqtb[u];font_id_text(f):= t;
end;

/*:1433*//*1441:*/
#line 32227 "pdftexdir/pdftex.web"

procedure new_interaction;
begin print_ln;
#line 4454 "pdftex-final.ch"
interaction:= cur_chr;
if interaction= batch_mode
then kpse_make_tex_discard_errors:= 1
else kpse_make_tex_discard_errors:= 0;
#line 32231 "pdftexdir/pdftex.web"
/*75:*/
#line 1908 "pdftexdir/pdftex.web"

if interaction= batch_mode then selector:= no_print else selector:= term_only

/*:75*/
#line 32231 "pdftexdir/pdftex.web"
;
if log_opened then selector:= selector+2;
end;

/*:1441*/
#line 31384 "pdftexdir/pdftex.web"

procedure prefixed_command;
label done,exit;
var a:small_number;{accumulated prefix codes so far}
f:internal_font_number;{identifies a font}
j:halfword;{index into a\.{\\parshape}specification}
k:font_index;{index into|font_info|}
#line 4181 "pdftex-final.ch"
p,q,r:pointer;{for temporary short-term use}
#line 31392 "pdftexdir/pdftex.web"
n:integer;{ditto}
e:boolean;{should a definition be expanded?or was\.{\\let}not done?}
begin a:= 0;
while cur_cmd= prefix do
begin if not odd(a div cur_chr)then a:= a+cur_chr;
/*430:*/
#line 9537 "pdftexdir/pdftex.web"

repeat get_x_token;
until(cur_cmd<> spacer)and(cur_cmd<> relax)

/*:430*/
#line 31397 "pdftexdir/pdftex.web"
;
if cur_cmd<=max_non_prefixed_command then
/*1388:*/
#line 31412 "pdftexdir/pdftex.web"

begin print_err("You can't use a prefix with `");

print_cmd_chr(cur_cmd,cur_chr);print_char("'");
help1("I'll pretend you didn't say \long or \outer or \global.");
if eTeX_ex then help_line[0]:= 
"I'll pretend you didn't say \long or \outer or \global or \protected.";
back_error;return;
end

/*:1388*/
#line 31399 "pdftexdir/pdftex.web"
;
if tracing_commands> 2 then if eTeX_ex then show_cur_cmd_chr;
end;
/*1389:*/
#line 31422 "pdftexdir/pdftex.web"

if a>=8 then
begin j:= protected_token;a:= a-8;
end
else j:= 0;
if(cur_cmd<> def)and((a mod 4<> 0)or(j<> 0))then
begin print_err("You can't use `");print_esc("long");print("' or `");
print_esc("outer");
help1("I'll pretend you didn't say \long or \outer here.");
if eTeX_ex then
begin help_line[0]:= 
"I'll pretend you didn't say \long or \outer or \protected here.";
print("' or `");print_esc("protected");
end;
print("' with `");

print_cmd_chr(cur_cmd,cur_chr);print_char("'");
error;
end

/*:1389*/
#line 31402 "pdftexdir/pdftex.web"
;
/*1390:*/
#line 31449 "pdftexdir/pdftex.web"

if global_defs<> 0 then
if global_defs<0 then
begin if global then a:= a-4;
end
else begin if not global then a:= a+4;
end

/*:1390*/
#line 31403 "pdftexdir/pdftex.web"
;
case cur_cmd of
/*1393:*/
#line 31486 "pdftexdir/pdftex.web"

set_font:define(cur_font_loc,data,cur_chr);

/*:1393*//*1394:*/
#line 31493 "pdftexdir/pdftex.web"

def:begin if odd(cur_chr)and not global and(global_defs>=0)then a:= a+4;
e:= (cur_chr>=2);get_r_token;p:= cur_cs;
q:= scan_toks(true,e);
if j<> 0 then
begin q:= get_avail;info(q):= j;link(q):= link(def_ref);
link(def_ref):= q;
end;
define(p,call+(a mod 4),def_ref);
end;

/*:1394*//*1397:*/
#line 31515 "pdftexdir/pdftex.web"

#line 4219 "pdftex-final.ch"
let:if cur_chr= normal+11 then do_nothing{noconvert primitive}
else if cur_chr= normal+10 then{mubyte primitive}
begin
selector:= term_and_log;
get_token;
mubyte_stoken:= cur_tok;
if cur_tok<=cs_token_flag then mubyte_stoken:= cur_tok mod 256;
mubyte_prefix:= 60;mubyte_relax:= false;
mubyte_tablein:= true;mubyte_tableout:= true;
get_x_token;
if cur_cmd= spacer then get_x_token;
if cur_cmd= sub_mark then
begin
mubyte_tableout:= false;get_x_token;
if cur_cmd= sub_mark then
begin
mubyte_tableout:= true;mubyte_tablein:= false;
get_x_token;
end;
end else if(mubyte_stoken> cs_token_flag)and
(cur_cmd= mac_param)then
begin
mubyte_tableout:= false;
scan_int;mubyte_prefix:= cur_val;get_x_token;
if mubyte_prefix> 50 then mubyte_prefix:= 52;
if mubyte_prefix<=0 then mubyte_prefix:= 51;
end
else if(mubyte_stoken> cs_token_flag)and(cur_cmd= relax)then
begin
mubyte_tableout:= true;mubyte_tablein:= false;
mubyte_relax:= true;get_x_token;
end;
r:= get_avail;p:= r;
while cur_cs= 0 do begin store_new_token(cur_tok);get_x_token;end;
if(cur_cmd<> end_cs_name)or(cur_chr<> 10)then
begin
print_err("Missing ");print_esc("endmubyte");print(" inserted");
help2("The control sequence marked <to be read again> should")
("not appear in <byte sequence> between \mubyte and \endmubyte.");
back_error;
end;
p:= link(r);
if(p= null)and mubyte_tablein then
begin
print_err("The empty <byte sequence>, ");
print_esc("mubyte");print(" ignored");
help2("The <byte sequence> in")
("\mubyte <token> <byte sequence>\endmubyte should not be empty.");
error;
end else begin
while p<> null do
begin
append_char(info(p)mod 256);
p:= link(p);
end;
flush_list(r);
if(str_start[str_ptr]+1= pool_ptr)and
(str_pool[pool_ptr-1]= mubyte_stoken)then
begin
if mubyte_read[mubyte_stoken]<> null
and mubyte_tablein then{clearing data}
dispose_munode(mubyte_read[mubyte_stoken]);
if mubyte_tablein then mubyte_read[mubyte_stoken]:= null;
if mubyte_tableout then mubyte_write[mubyte_stoken]:= 0;
pool_ptr:= str_start[str_ptr];
end else begin
if mubyte_tablein then mubyte_update;{updating input side}
if mubyte_tableout then{updating output side}
begin
if mubyte_stoken> cs_token_flag then{control sequence}
begin
dispose_mutableout(mubyte_stoken-cs_token_flag);
if(str_start[str_ptr]<pool_ptr)or mubyte_relax then
begin{store data}
r:= mubyte_cswrite[(mubyte_stoken-cs_token_flag)mod 128];
p:= get_avail;
mubyte_cswrite[(mubyte_stoken-cs_token_flag)mod 128]:= p;
info(p):= mubyte_stoken-cs_token_flag;
link(p):= get_avail;
p:= link(p);
if mubyte_relax then begin
info(p):= 0;pool_ptr:= str_start[str_ptr];
end else info(p):= slow_make_string;
link(p):= r;
end;
end else begin{single character}
if str_start[str_ptr]= pool_ptr then
mubyte_write[mubyte_stoken]:= 0
else
mubyte_write[mubyte_stoken]:= slow_make_string;
end;
end else pool_ptr:= str_start[str_ptr];
end;
end;
end else begin{let primitive}
n:= cur_chr;
#line 31517 "pdftexdir/pdftex.web"
get_r_token;p:= cur_cs;
if n= normal then
begin repeat get_token;
until cur_cmd<> spacer;
if cur_tok= other_token+"="then
begin get_token;
if cur_cmd= spacer then get_token;
end;
end
else begin get_token;q:= cur_tok;get_token;back_input;
cur_tok:= q;back_input;{look ahead,then back up}
end;{note that|back_input|doesn't affect |cur_cmd|, |cur_chr|}
if cur_cmd>=call then add_token_ref(cur_chr)
else if(cur_cmd= register)or(cur_cmd= toks_register)then
if(cur_chr<mem_bot)or(cur_chr> lo_mem_stat_max)then
add_sa_ref(cur_chr);
define(p,cur_cmd,cur_chr);
end;

/*:1397*//*1400:*/
#line 31587 "pdftexdir/pdftex.web"

#line 4345 "pdftex-final.ch"
shorthand_def:if cur_chr= char_sub_def_code then
begin scan_char_num;p:= char_sub_code_base+cur_val;scan_optional_equals;
scan_char_num;n:= cur_val;{accent character in substitution}
scan_char_num;
if(tracing_char_sub_def> 0)then
begin begin_diagnostic;print_nl("New character substitution: ");
print_ASCII(p-char_sub_code_base);print(" = ");
print_ASCII(n);print_char(" ");
print_ASCII(cur_val);end_diagnostic(false);
end;
n:= n*256+cur_val;
define(p,data,hi(n));
if(p-char_sub_code_base)<char_sub_def_min then
word_define(int_base+char_sub_def_min_code,p-char_sub_code_base);
if(p-char_sub_code_base)> char_sub_def_max then
word_define(int_base+char_sub_def_max_code,p-char_sub_code_base);
end
else begin n:= cur_chr;get_r_token;p:= cur_cs;define(p,relax,256);
#line 31589 "pdftexdir/pdftex.web"
scan_optional_equals;
case n of
char_def_code:begin scan_char_num;define(p,char_given,cur_val);
end;
math_char_def_code:begin scan_fifteen_bit_int;define(p,math_given,cur_val);
end;
othercases begin scan_register_num;
if cur_val> 255 then
begin j:= n-count_def_code;{|int_val..box_val|}
if j> mu_val then j:= tok_val;{|int_val..mu_val|or|tok_val|}
find_sa_element(j,cur_val,true);add_sa_ref(cur_ptr);
if j= tok_val then j:= toks_register else j:= register;
define(p,j,cur_ptr);
end
else
case n of
count_def_code:define(p,assign_int,count_base+cur_val);
dimen_def_code:define(p,assign_dimen,scaled_base+cur_val);
skip_def_code:define(p,assign_glue,skip_base+cur_val);
mu_skip_def_code:define(p,assign_mu_glue,mu_skip_base+cur_val);
toks_def_code:define(p,assign_toks,toks_base+cur_val);
end;{there are no other cases}
end
endcases;
end;

/*:1400*//*1401:*/
#line 31615 "pdftexdir/pdftex.web"

read_to_cs:begin j:= cur_chr;scan_int;n:= cur_val;
if not scan_keyword("to")then

begin print_err("Missing `to' inserted");

help2("You should have said `\read<number> to \cs'.")
("I'm going to look for the \cs now.");error;
end;
get_r_token;
p:= cur_cs;read_toks(n,p,j);define(p,call,cur_val);
end;

/*:1401*//*1402:*/
#line 31632 "pdftexdir/pdftex.web"

toks_register,assign_toks:begin q:= cur_cs;
e:= false;{just in case,will be set|true|for sparse array elements}
if cur_cmd= toks_register then
if cur_chr= mem_bot then
begin scan_register_num;
if cur_val> 255 then
begin find_sa_element(tok_val,cur_val,true);
cur_chr:= cur_ptr;e:= true;
end
else cur_chr:= toks_base+cur_val;
end
else e:= true;
p:= cur_chr;{|p= every_par_loc|or|output_routine_loc|or\dots}
scan_optional_equals;
/*430:*/
#line 9537 "pdftexdir/pdftex.web"

repeat get_x_token;
until(cur_cmd<> spacer)and(cur_cmd<> relax)

/*:430*/
#line 31647 "pdftexdir/pdftex.web"
;
if cur_cmd<> left_brace then/*1403:*/
#line 31664 "pdftexdir/pdftex.web"

if(cur_cmd= toks_register)or(cur_cmd= assign_toks)then
begin if cur_cmd= toks_register then
if cur_chr= mem_bot then
begin scan_register_num;
if cur_val<256 then q:= equiv(toks_base+cur_val)
else begin find_sa_element(tok_val,cur_val,false);
if cur_ptr= null then q:= null
else q:= sa_ptr(cur_ptr);
end;
end
else q:= sa_ptr(cur_chr)
else q:= equiv(cur_chr);
if q= null then sa_define(p,null)(p,undefined_cs,null)
else begin add_token_ref(q);sa_define(p,q)(p,call,q);
end;
goto done;
end

/*:1403*/
#line 31649 "pdftexdir/pdftex.web"
;
back_input;cur_cs:= q;q:= scan_toks(false,false);
if link(def_ref)= null then{empty list:revert to the default}
begin sa_define(p,null)(p,undefined_cs,null);free_avail(def_ref);
end
else begin if(p= output_routine_loc)and not e then{enclose in curlies}
begin link(q):= get_avail;q:= link(q);
info(q):= right_brace_token+"}";
q:= get_avail;info(q):= left_brace_token+"{";
link(q):= link(def_ref);link(def_ref):= q;
end;
sa_define(p,def_ref)(p,call,def_ref);
end;
end;

/*:1402*//*1404:*/
#line 31685 "pdftexdir/pdftex.web"

assign_int:begin p:= cur_chr;scan_optional_equals;scan_int;
word_define(p,cur_val);
end;
assign_dimen:begin p:= cur_chr;scan_optional_equals;
scan_normal_dimen;word_define(p,cur_val);
end;
assign_glue,assign_mu_glue:begin p:= cur_chr;n:= cur_cmd;scan_optional_equals;
if n= assign_mu_glue then scan_glue(mu_val)else scan_glue(glue_val);
trap_zero_glue;
define(p,glue_ref,cur_val);
end;

/*:1404*//*1408:*/
#line 31745 "pdftexdir/pdftex.web"

def_code:begin/*1409:*/
#line 31763 "pdftexdir/pdftex.web"

if cur_chr= cat_code_base then n:= max_char_code
else if cur_chr= math_code_base then n:= 49
else if cur_chr= sf_code_base then n:= 55
else if cur_chr= del_code_base then n:= 55
else n:= 255

/*:1409*/
#line 31746 "pdftexdir/pdftex.web"
;
#line 4395 "pdftex-final.ch"
p:= cur_chr;scan_char_num;
if p= xord_code_base then p:= cur_val
else if p= xchr_code_base then p:= cur_val+256
else if p= xprn_code_base then p:= cur_val+512
else p:= p+cur_val;
scan_optional_equals;
scan_int;
#line 31749 "pdftexdir/pdftex.web"
if((cur_val<0)and(p<del_code_base))or(cur_val> n)then
begin print_err("Invalid code (");print_int(cur_val);

if p<del_code_base then print("), should be in the range 0..")
else print("), should be at most ");
print_int(n);
help1("I'm going to use 0 instead of that illegal code value.");
error;cur_val:= 0;
end;
#line 4407 "pdftex-final.ch"
if p<256 then xord[p]:= cur_val
else if p<512 then xchr[p-256]:= cur_val
else if p<768 then xprn[p-512]:= cur_val
else if p<math_code_base then define(p,data,cur_val)
#line 31759 "pdftexdir/pdftex.web"
else if p<del_code_base then define(p,data,hi(cur_val))
else word_define(p,cur_val);
end;

/*:1408*//*1410:*/
#line 31770 "pdftexdir/pdftex.web"

def_family:begin p:= cur_chr;scan_four_bit_int;p:= p+cur_val;
scan_optional_equals;scan_font_ident;define(p,data,cur_val);
end;

/*:1410*//*1411:*/
#line 31777 "pdftexdir/pdftex.web"

register,advance,multiply,divide:do_register_command(a);

/*:1411*//*1417:*/
#line 31899 "pdftexdir/pdftex.web"

set_box:begin scan_register_num;
if global then n:= global_box_flag+cur_val else n:= box_flag+cur_val;
scan_optional_equals;
if set_box_allowed then scan_box(n)
else begin print_err("Improper ");print_esc("setbox");

help2("Sorry, \setbox is not allowed after \halign in a display,")
("or between \accent and an accented character.");error;
end;
end;

/*:1417*//*1418:*/
#line 31919 "pdftexdir/pdftex.web"

set_aux:alter_aux;
set_prev_graf:alter_prev_graf;
set_page_dimen:alter_page_so_far;
set_page_int:alter_integer;
set_box_dimen:alter_box_dimen;

/*:1418*//*1424:*/
#line 31990 "pdftexdir/pdftex.web"

set_shape:begin q:= cur_chr;scan_optional_equals;scan_int;n:= cur_val;
if n<=0 then p:= null
else if q> par_shape_loc then
begin n:= (cur_val div 2)+1;p:= get_node(2*n+1);info(p):= n;
n:= cur_val;mem[p+1].int:= n;{number of penalties}
for j:= p+2 to p+n+1 do
begin scan_int;mem[j].int:= cur_val;{penalty values}
end;
if not odd(n)then mem[p+n+2].int:= 0;{unused}
end
else begin p:= get_node(2*n+1);info(p):= n;
for j:= 1 to n do
begin scan_normal_dimen;
mem[p+2*j-1].sc:= cur_val;{indentation}
scan_normal_dimen;
mem[p+2*j].sc:= cur_val;{width}
end;
end;
define(q,shape_ref,p);
end;

/*:1424*//*1428:*/
#line 32031 "pdftexdir/pdftex.web"

hyph_data:if cur_chr= 1 then
#line 4416 "pdftex-final.ch"
 begin Init new_patterns;goto done;Tini
#line 32034 "pdftexdir/pdftex.web"
 print_err("Patterns can be loaded only by INITEX");

help0;error;
repeat get_token;until cur_cmd= right_brace;{flush the patterns}
return;
end
else begin new_hyph_exceptions;goto done;
end;

/*:1428*//*1429:*/
#line 32046 "pdftexdir/pdftex.web"

assign_font_dimen:begin find_font_dimen(true);k:= cur_val;
scan_optional_equals;scan_normal_dimen;font_info[k].sc:= cur_val;
end;
assign_font_int:begin n:= cur_chr;scan_font_ident;f:= cur_val;
if n= no_lig_code then set_no_ligatures(f)
else if n<lp_code_base then begin
scan_optional_equals;scan_int;
if n= 0 then hyphen_char[f]:= cur_val else skew_char[f]:= cur_val;
end
else begin
scan_char_num;p:= cur_val;
scan_optional_equals;scan_int;
case n of
lp_code_base:set_lp_code(f,p,cur_val);
rp_code_base:set_rp_code(f,p,cur_val);
ef_code_base:set_ef_code(f,p,cur_val);
tag_code:set_tag_code(f,p,cur_val);
kn_bs_code_base:set_kn_bs_code(f,p,cur_val);
st_bs_code_base:set_st_bs_code(f,p,cur_val);
sh_bs_code_base:set_sh_bs_code(f,p,cur_val);
kn_bc_code_base:set_kn_bc_code(f,p,cur_val);
kn_ac_code_base:set_kn_ac_code(f,p,cur_val);
end;
end;
end;

/*:1429*//*1432:*/
#line 32117 "pdftexdir/pdftex.web"

def_font:new_font(a);
letterspace_font:new_letterspaced_font(a);
pdf_copy_font:make_font_copy(a);

/*:1432*//*1440:*/
#line 32224 "pdftexdir/pdftex.web"

set_interaction:new_interaction;

/*:1440*/
#line 31405 "pdftexdir/pdftex.web"

othercases confusion("prefix")

endcases;
done:/*1445:*/
#line 32249 "pdftexdir/pdftex.web"

if after_token<> 0 then
begin cur_tok:= after_token;back_input;after_token:= 0;
end

/*:1445*/
#line 31409 "pdftexdir/pdftex.web"
;
exit:end;

/*:1387*//*1446:*/
#line 32257 "pdftexdir/pdftex.web"

procedure do_assignments;
label exit;
begin loop begin/*430:*/
#line 9537 "pdftexdir/pdftex.web"

repeat get_x_token;
until(cur_cmd<> spacer)and(cur_cmd<> relax)

/*:430*/
#line 32260 "pdftexdir/pdftex.web"
;
if cur_cmd<=max_non_prefixed_command then return;
set_box_allowed:= false;prefixed_command;set_box_allowed:= true;
end;
exit:end;

/*:1446*//*1451:*/
#line 32285 "pdftexdir/pdftex.web"

procedure open_or_close_in;
var c:0. .1;{1 for\.{\\openin},0 for\.{\\closein}}
n:0. .15;{stream number}
begin c:= cur_chr;scan_four_bit_int;n:= cur_val;
if read_open[n]<> closed then
begin a_close(read_file[n]);read_open[n]:= closed;
end;
if c<> 0 then
begin scan_optional_equals;scan_file_name;
#line 4465 "pdftex-final.ch"
pack_cur_name;
tex_input_type:= 0;{Tell|open_input|we are\.{\\openin}.}
if kpse_in_name_ok(stringcast(name_of_file+1))
and a_open_in(read_file[n],kpse_tex_format)then
read_open[n]:= just_open;
#line 32298 "pdftexdir/pdftex.web"
end;
end;

/*:1451*//*1455:*/
#line 32317 "pdftexdir/pdftex.web"

procedure issue_message;
var old_setting:0..max_selector;{holds|selector|setting}
c:0. .1;{identifies\.{\\message}and\.{\\errmessage}}
s:str_number;{the message}
begin c:= cur_chr;link(garbage):= scan_toks(false,true);
#line 4476 "pdftex-final.ch"
old_setting:= selector;selector:= new_string;
message_printing:= true;active_noconvert:= true;
token_show(def_ref);
message_printing:= false;active_noconvert:= false;
selector:= old_setting;
#line 32325 "pdftexdir/pdftex.web"
flush_list(def_ref);
str_room(1);s:= make_string;
if c= 0 then/*1456:*/
#line 32332 "pdftexdir/pdftex.web"

begin if term_offset+length(s)> max_print_line-2 then print_ln
else if(term_offset> 0)or(file_offset> 0)then print_char(" ");
#line 4486 "pdftex-final.ch"
print(s);update_terminal;
#line 32336 "pdftexdir/pdftex.web"
end

/*:1456*/
#line 32327 "pdftexdir/pdftex.web"

else/*1459:*/
#line 32347 "pdftexdir/pdftex.web"

#line 4492 "pdftex-final.ch"
 begin print_err("");print(s);
#line 32349 "pdftexdir/pdftex.web"
if err_help<> null then use_err_help:= true
else if long_help_seen then help1("(That was another \errmessage.)")
else begin if interaction<error_stop_mode then long_help_seen:= true;
help4("This error message was generated by an \errmessage")
("command, so I can't give any explicit help.")
("Pretend that you're Hercule Poirot: Examine all clues,")

("and deduce the truth by order and method.");
end;
error;use_err_help:= false;
end

/*:1459*/
#line 32328 "pdftexdir/pdftex.web"
;
flush_string;
end;

/*:1455*//*1464:*/
#line 32384 "pdftexdir/pdftex.web"

procedure shift_case;
var b:pointer;{|lc_code_base|or|uc_code_base|}
p:pointer;{runs through the token list}
t:halfword;{token}
c:eight_bits;{character code}
begin b:= cur_chr;p:= scan_toks(false,false);p:= link(def_ref);
while p<> null do
begin/*1465:*/
#line 32403 "pdftexdir/pdftex.web"

t:= info(p);
if t<cs_token_flag+single_base then
begin c:= t mod 256;
if equiv(b+c)<> 0 then info(p):= t-c+equiv(b+c);
end

/*:1465*/
#line 32392 "pdftexdir/pdftex.web"
;
p:= link(p);
end;
back_list(link(def_ref));free_avail(def_ref);{omit reference count}
end;

/*:1464*//*1469:*/
#line 32440 "pdftexdir/pdftex.web"

procedure show_whatever;
label common_ending;
var p:pointer;{tail of a token list to show}
t:small_number;{type of conditional being shown}
m:normal..or_code;{upper bound on|fi_or_else|codes}
l:integer;{line where that conditional began}
n:integer;{level of\.{\\if...\\fi}nesting}
begin case cur_chr of
show_lists:begin begin_diagnostic;show_activities;
end;
show_box_code:/*1472:*/
#line 32499 "pdftexdir/pdftex.web"

begin scan_register_num;fetch_box(p);begin_diagnostic;
print_nl("> \box");print_int(cur_val);print_char("=");
if p= null then print("void")else show_box(p);
end

/*:1472*/
#line 32451 "pdftexdir/pdftex.web"
;
show_code:/*1470:*/
#line 32477 "pdftexdir/pdftex.web"

begin get_token;
if interaction= error_stop_mode then wake_up_terminal;
print_nl("> ");
if cur_cs<> 0 then
begin sprint_cs(cur_cs);print_char("=");
end;
print_meaning;goto common_ending;
end

/*:1470*/
#line 32452 "pdftexdir/pdftex.web"
;
/*1674:*/
#line 37131 "pdftexdir/pdftex.web"

show_groups:begin begin_diagnostic;show_save_groups;
end;

/*:1674*//*1688:*/
#line 37348 "pdftexdir/pdftex.web"

show_ifs:begin begin_diagnostic;print_nl("");print_ln;
if cond_ptr= null then
begin print_nl("### ");print("no active conditionals");
end
else begin p:= cond_ptr;n:= 0;
repeat incr(n);p:= link(p);until p= null;
p:= cond_ptr;t:= cur_if;l:= if_line;m:= if_limit;
repeat print_nl("### level ");print_int(n);print(": ");
print_cmd_chr(if_test,t);
if m= fi_code then print_esc("else");
print_if_line(l);
decr(n);t:= subtype(p);l:= if_line_field(p);m:= type(p);p:= link(p);
until p= null;
end;
end;

/*:1688*/
#line 32453 "pdftexdir/pdftex.web"

othercases/*1473:*/
#line 32505 "pdftexdir/pdftex.web"

begin p:= the_toks;
if interaction= error_stop_mode then wake_up_terminal;
print_nl("> ");token_show(temp_head);
flush_list(link(temp_head));goto common_ending;
end

/*:1473*/
#line 32455 "pdftexdir/pdftex.web"

endcases;
/*1474:*/
#line 32512 "pdftexdir/pdftex.web"

end_diagnostic(true);print_err("OK");

if selector= term_and_log then if tracing_online<=0 then
begin selector:= term_only;print(" (see the transcript file)");
selector:= term_and_log;
end

/*:1474*/
#line 32457 "pdftexdir/pdftex.web"
;
common_ending:if interaction<error_stop_mode then
begin help0;decr(error_count);
end
else if tracing_online> 0 then
begin
help3("This isn't an error message; I'm just \showing something.")
("Type `I\show...' to show more (e.g., \show\cs,")
("\showthe\count10, \showbox255, \showlists).");
end
else begin
help5("This isn't an error message; I'm just \showing something.")
("Type `I\show...' to show more (e.g., \show\cs,")
("\showthe\count10, \showbox255, \showlists).")
("And type `I\tracingonline=1\show...' to show boxes and")
("lists on your terminal as well as in the transcript file.");
end;
error;
end;

/*:1469*//*1478:*/
#line 32546 "pdftexdir/pdftex.web"

init procedure store_fmt_file;
label found1,found2,done1,done2;
var j,k,l:integer;{all-purpose indices}
p,q:pointer;{all-purpose pointers}
x:integer;{something to dump}
#line 4504 "pdftex-final.ch"
format_engine:^text_char;
#line 32553 "pdftexdir/pdftex.web"
begin/*1480:*/
#line 32606 "pdftexdir/pdftex.web"

if save_ptr<> 0 then
begin print_err("You can't dump inside a group");

help1("`{...\dump}' is a no-no.");succumb;
end

/*:1480*/
#line 32553 "pdftexdir/pdftex.web"
;
/*1506:*/
#line 33068 "pdftexdir/pdftex.web"

selector:= new_string;
print(" (preloaded format=");print(job_name);print_char(" ");
print_int(year);print_char(".");
print_int(month);print_char(".");print_int(day);print_char(")");
if interaction= batch_mode then selector:= log_only
else selector:= term_and_log;
str_room(1);
format_ident:= make_string;
pack_job_name(format_extension);
while not w_open_out(fmt_file)do
prompt_file_name("format file name",format_extension);
print_nl("Beginning to dump on file ");

slow_print(w_make_name_string(fmt_file));flush_string;
print_nl("");slow_print(format_ident)

/*:1506*/
#line 32555 "pdftexdir/pdftex.web"
;
#line 4510 "pdftex-final.ch"
/*1483:*/
#line 32643 "pdftexdir/pdftex.web"

#line 4565 "pdftex-final.ch"
dump_int(57325458);{Web2C\TeX's magic constant: "W2TX"}
{Align engine to 4 bytes with one or more trailing NUL}
x:= strlen(engine_name);
format_engine:= xmalloc_array(text_char,x+4);
strcpy(stringcast(format_engine),engine_name);
for k:= x to x+3 do format_engine[k]:= 0;
x:= x+4-(x mod 4);
dump_int(x);dump_things(format_engine[0],x);
libc_free(format_engine);
dump_int();
/*1871:*/
#line 6101 "pdftex-final.ch"

dump_things(xord[0],256);
dump_things(xchr[0],256);
dump_things(xprn[0],256);

/*:1871*/
#line 4575 "pdftex-final.ch"
;
dump_int(max_halfword);
dump_int(hash_high);
#line 32645 "pdftexdir/pdftex.web"
/*1651:*/
#line 36859 "pdftexdir/pdftex.web"

dump_int(eTeX_mode);
for j:= 0 to eTeX_states-1 do eTeX_state(j):= 0;{disable all enhancements}

/*:1651*//*1755:*/
#line 38229 "pdftexdir/pdftex.web"

while pseudo_files<> null do pseudo_close;{flush pseudo files}

/*:1755*/
#line 32645 "pdftexdir/pdftex.web"

dump_int(mem_bot);
dump_int(mem_top);
dump_int(eqtb_size);
dump_int(hash_prime);
#line 4583 "pdftex-final.ch"
dump_int(hyph_prime)
#line 32651 "pdftexdir/pdftex.web"

/*:1483*/
#line 4510 "pdftex-final.ch"
;
/*1890:*/
#line 6547 "pdftex-final.ch"

dump_int(4 D4C5458);{ML\TeX's magic constant: "MLTX"}
if mltex_p then dump_int(1)
else dump_int(0);

/*:1890*/
#line 4511 "pdftex-final.ch"
;
/*1899:*/
#line 6839 "pdftex-final.ch"

dump_int(45435458);{enc\TeX's magic constant: "ECTX"}
if not enctex_p then dump_int(0)
else begin
dump_int(1);
dump_things(mubyte_read[0],256);
dump_things(mubyte_write[0],256);
dump_things(mubyte_cswrite[0],128);
end;

/*:1899*/
#line 4512 "pdftex-final.ch"
;
#line 32557 "pdftexdir/pdftex.web"
/*1485:*/
#line 32678 "pdftexdir/pdftex.web"

dump_int(pool_ptr);
dump_int(str_ptr);
#line 4678 "pdftex-final.ch"
dump_things(str_start[0],str_ptr+1);
dump_things(str_pool[0],pool_ptr);
#line 32687 "pdftexdir/pdftex.web"
print_ln;print_int(str_ptr);print(" strings of total length ");
print_int(pool_ptr)

/*:1485*/
#line 32557 "pdftexdir/pdftex.web"
;
/*1487:*/
#line 32713 "pdftexdir/pdftex.web"

sort_avail;var_used:= 0;
dump_int(lo_mem_max);dump_int(rover);
if eTeX_ex then for k:= int_val to tok_val do dump_int(sa_root[k]);
p:= mem_bot;q:= rover;x:= 0;
#line 4707 "pdftex-final.ch"
repeat dump_things(mem[p],q+2-p);
#line 32719 "pdftexdir/pdftex.web"
x:= x+q+2-p;var_used:= var_used+q-p;
p:= q+node_size(q);q:= rlink(q);
until q= rover;
var_used:= var_used+lo_mem_max-p;dyn_used:= mem_end+1-hi_mem_min;
#line 4713 "pdftex-final.ch"
dump_things(mem[p],lo_mem_max+1-p);
#line 32724 "pdftexdir/pdftex.web"
x:= x+lo_mem_max+1-p;
dump_int(hi_mem_min);dump_int(avail);
#line 4719 "pdftex-final.ch"
dump_things(mem[hi_mem_min],mem_end+1-hi_mem_min);
#line 32727 "pdftexdir/pdftex.web"
x:= x+mem_end+1-hi_mem_min;
p:= avail;
while p<> null do
begin decr(dyn_used);p:= link(p);
end;
dump_int(var_used);dump_int(dyn_used);
print_ln;print_int(x);
print(" memory locations dumped; current usage is ");
print_int(var_used);print_char("&");print_int(dyn_used)

/*:1487*/
#line 32558 "pdftexdir/pdftex.web"
;
/*1489:*/
#line 32761 "pdftexdir/pdftex.web"

/*1491:*/
#line 32779 "pdftexdir/pdftex.web"

k:= active_base;
repeat j:= k;
while j<int_base-1 do
begin if(equiv(j)= equiv(j+1))and(eq_type(j)= eq_type(j+1))and
(eq_level(j)= eq_level(j+1))then goto found1;
incr(j);
end;
l:= int_base;goto done1;{|j= int_base-1|}
found1:incr(j);l:= j;
while j<int_base-1 do
begin if(equiv(j)<> equiv(j+1))or(eq_type(j)<> eq_type(j+1))or
(eq_level(j)<> eq_level(j+1))then goto done1;
incr(j);
end;
done1:dump_int(l-k);
#line 4755 "pdftex-final.ch"
dump_things(eqtb[k],l-k);
#line 32798 "pdftexdir/pdftex.web"
k:= j+1;dump_int(k-l);
until k= int_base

/*:1491*/
#line 32762 "pdftexdir/pdftex.web"
;
/*1492:*/
#line 32801 "pdftexdir/pdftex.web"

repeat j:= k;
while j<eqtb_size do
begin if eqtb[j].int= eqtb[j+1].int then goto found2;
incr(j);
end;
l:= eqtb_size+1;goto done2;{|j= eqtb_size|}
found2:incr(j);l:= j;
while j<eqtb_size do
begin if eqtb[j].int<> eqtb[j+1].int then goto done2;
incr(j);
end;
done2:dump_int(l-k);
#line 4763 "pdftex-final.ch"
dump_things(eqtb[k],l-k);
#line 4770 "pdftex-final.ch"
k:= j+1;dump_int(k-l);
until k> eqtb_size;
if hash_high> 0 then dump_things(eqtb[eqtb_size+1],hash_high);
{dump|hash_extra|part}
#line 32819 "pdftexdir/pdftex.web"

/*:1492*/
#line 32763 "pdftexdir/pdftex.web"
;
dump_int(par_loc);dump_int(write_loc);
/*1494:*/
#line 32837 "pdftexdir/pdftex.web"

for p:= 0 to prim_size do dump_hh(prim[p]);
#line 4793 "pdftex-final.ch"
dump_int(hash_used);cs_count:= frozen_control_sequence-1-hash_used+hash_high;
#line 32840 "pdftexdir/pdftex.web"
for p:= hash_base to hash_used do if text(p)<> 0 then
begin dump_int(p);dump_hh(hash[p]);incr(cs_count);
end;
#line 4799 "pdftex-final.ch"
dump_things(hash[hash_used+1],undefined_control_sequence-1-hash_used);
if hash_high> 0 then dump_things(hash[eqtb_size+1],hash_high);
#line 32844 "pdftexdir/pdftex.web"
dump_int(cs_count);
print_ln;print_int(cs_count);print(" multiletter control sequences")

/*:1494*/
#line 32765 "pdftexdir/pdftex.web"


/*:1489*/
#line 32559 "pdftexdir/pdftex.web"
;
/*1496:*/
#line 32855 "pdftexdir/pdftex.web"

dump_int(fmem_ptr);
#line 4824 "pdftex-final.ch"
dump_things(font_info[0],fmem_ptr);
dump_int(font_ptr);
/*1498:*/
#line 4886 "pdftex-final.ch"

begin
dump_things(font_check[null_font],font_ptr+1-null_font);
dump_things(font_size[null_font],font_ptr+1-null_font);
dump_things(font_dsize[null_font],font_ptr+1-null_font);
dump_things(font_params[null_font],font_ptr+1-null_font);
dump_things(hyphen_char[null_font],font_ptr+1-null_font);
dump_things(skew_char[null_font],font_ptr+1-null_font);
dump_things(font_name[null_font],font_ptr+1-null_font);
dump_things(font_area[null_font],font_ptr+1-null_font);
dump_things(font_bc[null_font],font_ptr+1-null_font);
dump_things(font_ec[null_font],font_ptr+1-null_font);
dump_things(char_base[null_font],font_ptr+1-null_font);
dump_things(width_base[null_font],font_ptr+1-null_font);
dump_things(height_base[null_font],font_ptr+1-null_font);
dump_things(depth_base[null_font],font_ptr+1-null_font);
dump_things(italic_base[null_font],font_ptr+1-null_font);
dump_things(lig_kern_base[null_font],font_ptr+1-null_font);
dump_things(kern_base[null_font],font_ptr+1-null_font);
dump_things(exten_base[null_font],font_ptr+1-null_font);
dump_things(param_base[null_font],font_ptr+1-null_font);
dump_things(font_glue[null_font],font_ptr+1-null_font);
dump_things(bchar_label[null_font],font_ptr+1-null_font);
dump_things(font_bchar[null_font],font_ptr+1-null_font);
dump_things(font_false_bchar[null_font],font_ptr+1-null_font);
for k:= null_font to font_ptr do
begin print_nl("\font");print_esc(font_id_text(k));print_char("=");
print_file_name(font_name[k],font_area[k],"");
if font_size[k]<> font_dsize[k]then
begin print(" at ");print_scaled(font_size[k]);print("pt");
end;
end;
end
#line 32902 "pdftexdir/pdftex.web"

#line 4948 "pdftex-final.ch"
/*:1498*/
#line 4826 "pdftex-final.ch"
;
#line 32861 "pdftexdir/pdftex.web"
print_ln;print_int(fmem_ptr-7);print(" words of font info for ");
#line 4833 "pdftex-final.ch"
print_int(font_ptr-font_base);
if font_ptr<> font_base+1 then print(" preloaded fonts")
else print(" preloaded font")
#line 32864 "pdftexdir/pdftex.web"

/*:1496*/
#line 32560 "pdftexdir/pdftex.web"
;
/*1500:*/
#line 32929 "pdftexdir/pdftex.web"

#line 5071 "pdftex-final.ch"
dump_int(hyph_count);
if hyph_next<=hyph_prime then hyph_next:= hyph_size;
dump_int(hyph_next);{minimum value of|hyphen_size|needed}
for k:= 0 to hyph_size do if hyph_word[k]<> 0 then
begin dump_int(k+65536*hyph_link[k]);
{assumes number of hyphen exceptions does not exceed 65535}
dump_int(hyph_word[k]);dump_int(hyph_list[k]);
end;
#line 5085 "pdftex-final.ch"
print_ln;print_int(hyph_count);
if hyph_count<> 1 then print(" hyphenation exceptions")
else print(" hyphenation exception");
#line 32936 "pdftexdir/pdftex.web"
if trie_not_ready then init_trie;
dump_int(trie_max);
dump_int(hyph_start);
#line 5093 "pdftex-final.ch"
dump_things(trie_trl[0],trie_max+1);
dump_things(trie_tro[0],trie_max+1);
dump_things(trie_trc[0],trie_max+1);
#line 32940 "pdftexdir/pdftex.web"
dump_int(trie_op_ptr);
#line 5105 "pdftex-final.ch"
dump_things(hyf_distance[1],trie_op_ptr);
dump_things(hyf_num[1],trie_op_ptr);
dump_things(hyf_next[1],trie_op_ptr);
#line 32946 "pdftexdir/pdftex.web"
print_nl("Hyphenation trie of length ");print_int(trie_max);

#line 5114 "pdftex-final.ch"
print(" has ");print_int(trie_op_ptr);
if trie_op_ptr<> 1 then print(" ops")
else print(" op");
#line 32950 "pdftexdir/pdftex.web"
print(" out of ");print_int(trie_op_size);
for k:= 255 downto 0 do if trie_used[k]> min_quarterword then
begin print_nl("  ");print_int(qo(trie_used[k]));
print(" for language ");print_int(k);
dump_int(k);dump_int(qo(trie_used[k]));
end

/*:1500*/
#line 32561 "pdftexdir/pdftex.web"
;
/*1502:*/
#line 32991 "pdftexdir/pdftex.web"

begin
dumpimagemeta;{the image information array}
dump_int(pdf_mem_size);
dump_int(pdf_mem_ptr);
for k:= 1 to pdf_mem_ptr-1 do begin
dump_int(pdf_mem[k]);
end;
print_ln;print_int(pdf_mem_ptr-1);print(" words of pdfTeX memory");
dump_int(obj_tab_size);
dump_int(obj_ptr);
dump_int(sys_obj_ptr);
for k:= 1 to sys_obj_ptr do begin
dump_int(obj_tab[k].int0);
dump_int(obj_tab[k].int1);
dump_int(obj_tab[k].int3);
dump_int(obj_tab[k].int4);
end;
print_ln;print_int(sys_obj_ptr);print(" indirect objects");
dump_int(pdf_obj_count);
dump_int(pdf_xform_count);
dump_int(pdf_ximage_count);
dump_int(head_tab[obj_type_obj]);
dump_int(head_tab[obj_type_xform]);
dump_int(head_tab[obj_type_ximage]);
dump_int(pdf_last_obj);
dump_int(pdf_last_xform);
dump_int(pdf_last_ximage);
end

/*:1502*/
#line 32562 "pdftexdir/pdftex.web"
;
/*1504:*/
#line 33058 "pdftexdir/pdftex.web"

dump_int(interaction);dump_int(format_ident);dump_int(69069);
tracing_stats:= 0

/*:1504*/
#line 32563 "pdftexdir/pdftex.web"
;
/*1507:*/
#line 33085 "pdftexdir/pdftex.web"

w_close(fmt_file)

/*:1507*/
#line 32564 "pdftexdir/pdftex.web"
;
end;
tini

/*:1478*//*1526:*/
#line 33737 "pdftexdir/pdftex.web"

/*1527:*/
#line 33800 "pdftexdir/pdftex.web"

procedure new_whatsit(s:small_number;w:small_number);
var p:pointer;{the new node}
begin p:= get_node(w);type(p):= whatsit_node;subtype(p):= s;
link(tail):= p;tail:= p;
end;

/*:1527*//*1528:*/
#line 33810 "pdftexdir/pdftex.web"

procedure new_write_whatsit(w:small_number);
begin new_whatsit(cur_chr,w);
if w<> write_node_size then scan_four_bit_int
else begin scan_int;
if cur_val<0 then cur_val:= 17
#line 5588 "pdftex-final.ch"
 else if(cur_val> 15)and(cur_val<> 18)then cur_val:= 16;
#line 33817 "pdftexdir/pdftex.web"
end;
#line 5594 "pdftex-final.ch"
write_stream(tail):= cur_val;
if mubyte_out+mubyte_zero<0 then write_mubyte(tail):= 0
else if mubyte_out+mubyte_zero>=2*mubyte_zero then
write_mubyte(tail):= 2*mubyte_zero-1
else write_mubyte(tail):= mubyte_out+mubyte_zero;
#line 33819 "pdftexdir/pdftex.web"
end;

/*:1528*//*1535:*/
#line 33879 "pdftexdir/pdftex.web"

procedure check_pdfoutput(s:str_number;is_error:boolean);
begin
if pdf_output<=0 then
begin
if is_error then
pdf_error(s,"not allowed in DVI mode (\pdfoutput <= 0)")
else
pdf_warning(s,"not allowed in DVI mode (\pdfoutput <= 0); ignoring it",true,true);
end
end;

procedure scan_pdf_ext_toks;
begin
call_func(scan_toks(false,true));{like\.{\\special}}
end;

procedure compare_strings;{to implement\.{\\pdfstrcmp}}
label done;
var s1,s2:str_number;
i1,i2,j1,j2:pool_pointer;
save_cur_cs:pointer;
begin
save_cur_cs:= cur_cs;call_func(scan_toks(false,true));
s1:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
cur_cs:= save_cur_cs;call_func(scan_toks(false,true));
s2:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
i1:= str_start[s1];
j1:= str_start[s1+1];
i2:= str_start[s2];
j2:= str_start[s2+1];
while(i1<j1)and(i2<j2)do begin
if str_pool[i1]<str_pool[i2]then begin
cur_val:= -1;
goto done;
end;
if str_pool[i1]> str_pool[i2]then begin
cur_val:= 1;
goto done;
end;
incr(i1);
incr(i2);
end;
if(i1= j1)and(i2= j2)then
cur_val:= 0
else if i1<j1 then
cur_val:= 1
else
cur_val:= -1;
done:
flush_str(s2);
flush_str(s1);
cur_val_level:= int_val;
end;

/*:1535*//*1550:*/
#line 34192 "pdftexdir/pdftex.web"

procedure scale_image(n:integer);
var x,y,xr,yr:integer;{size and resolution of image}
w,h:scaled;{indeed size corresponds to image resolution}
default_res:integer;
image:integer;
begin
image:= obj_ximage_data(n);
if(image_rotate(image)= 90)or(image_rotate(image)= 270)then begin
y:= image_width(image);
x:= image_height(image);
yr:= image_x_res(image);
xr:= image_y_res(image);
end else begin
x:= image_width(image);
y:= image_height(image);
xr:= image_x_res(image);
yr:= image_y_res(image);
end;

if(xr> 65535)or(yr> 65535)then begin
xr:= 0;
yr:= 0;
pdf_warning("ext1","too large image resolution ignored",true,true);
end;
if(x<=0)or(y<=0)or(xr<0)or(yr<0)then
pdf_error("ext1","invalid image dimensions");
if is_pdf_image(image)then begin
w:= x;
h:= y;
end
else begin
default_res:= fix_int(pdf_image_resolution,0,65535);
if(default_res> 0)and((xr= 0)or(yr= 0))then begin
xr:= default_res;
yr:= default_res;
end;
if is_running(obj_ximage_width(n))and
is_running(obj_ximage_height(n))then
begin
if(xr> 0)and(yr> 0)then begin
w:= ext_xn_over_d(one_hundred_inch,x,100*xr);
h:= ext_xn_over_d(one_hundred_inch,y,100*yr);
end
else begin
w:= ext_xn_over_d(one_hundred_inch,x,7200);
h:= ext_xn_over_d(one_hundred_inch,y,7200);
end;
end;
end;
if is_running(obj_ximage_width(n))and is_running(obj_ximage_height(n))and
is_running(obj_ximage_depth(n))then begin
obj_ximage_width(n):= w;
obj_ximage_height(n):= h;
obj_ximage_depth(n):= 0;
end
else if is_running(obj_ximage_width(n))then begin
{image depth or height is explicitly specified}
if is_running(obj_ximage_height(n))then begin
{image depth is explicitly specified}
obj_ximage_width(n):= ext_xn_over_d(h,x,y);
obj_ximage_height(n):= h-obj_ximage_depth(n);
end
else if is_running(obj_ximage_depth(n))then begin
{image height is explicitly specified}
obj_ximage_width(n):= ext_xn_over_d(obj_ximage_height(n),x,y);
obj_ximage_depth(n):= 0;
end
else begin
{both image depth and height are explicitly specified}
obj_ximage_width(n):= ext_xn_over_d(obj_ximage_height(n)+
obj_ximage_depth(n),x,y);
end;
end
else begin
{image width is explicitly specified}
if is_running(obj_ximage_height(n))and
is_running(obj_ximage_depth(n))then begin
{both image depth and height are not specified}
obj_ximage_height(n):= ext_xn_over_d(obj_ximage_width(n),y,x);
obj_ximage_depth(n):= 0;
end
{image depth is explicitly specified}
else if is_running(obj_ximage_height(n))then begin
obj_ximage_height(n):= 
ext_xn_over_d(obj_ximage_width(n),y,x)-obj_ximage_depth(n);
end
{image height is explicitly specified}
else if is_running(obj_ximage_depth(n))then begin
obj_ximage_depth(n):= 0;
end
{both image depth and height are explicitly specified}
else
do_nothing;
end;
end;

function scan_pdf_box_spec:integer;{scans PDF pagebox specification}
begin
scan_pdf_box_spec:= 0;
if scan_keyword("mediabox")then
scan_pdf_box_spec:= pdf_box_spec_media
else if scan_keyword("cropbox")then
scan_pdf_box_spec:= pdf_box_spec_crop
else if scan_keyword("bleedbox")then
scan_pdf_box_spec:= pdf_box_spec_bleed
else if scan_keyword("trimbox")then
scan_pdf_box_spec:= pdf_box_spec_trim
else if scan_keyword("artbox")then
scan_pdf_box_spec:= pdf_box_spec_art
end;

procedure scan_alt_rule;{scans rule spec to|alt_rule|}
label reswitch;
begin
if alt_rule= null then
alt_rule:= new_rule;
width(alt_rule):= null_flag;
height(alt_rule):= null_flag;
depth(alt_rule):= null_flag;
reswitch:
if scan_keyword("width")then begin
scan_normal_dimen;
width(alt_rule):= cur_val;
goto reswitch;
end;
if scan_keyword("height")then begin
scan_normal_dimen;
height(alt_rule):= cur_val;
goto reswitch;
end;
if scan_keyword("depth")then begin
scan_normal_dimen;
depth(alt_rule):= cur_val;
goto reswitch;
end;
end;

procedure scan_image;
label reswitch;
var k:integer;
named:str_number;
s:str_number;
page,pagebox,colorspace:integer;
begin
incr(pdf_ximage_count);
pdf_create_obj(obj_type_ximage,pdf_ximage_count);
k:= obj_ptr;
obj_data_ptr(k):= pdf_get_mem(pdfmem_ximage_size);
scan_alt_rule;{scans|<rule spec> |to|alt_rule|}
obj_ximage_width(k):= width(alt_rule);
obj_ximage_height(k):= height(alt_rule);
obj_ximage_depth(k):= depth(alt_rule);
if scan_keyword("attr")then begin
scan_pdf_ext_toks;
obj_ximage_attr(k):= def_ref;
end
else
obj_ximage_attr(k):= null;
named:= 0;
if scan_keyword("named")then begin
scan_pdf_ext_toks;
named:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
end
else if scan_keyword("page")then begin
scan_int;
page:= cur_val;
end
else
page:= 1;
if scan_keyword("colorspace")then begin
scan_int;
colorspace:= cur_val;
end
else
colorspace:= 0;
pagebox:= scan_pdf_box_spec;
if pagebox= 0 then
pagebox:= pdf_pagebox;
scan_pdf_ext_toks;
s:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
if pdf_option_always_use_pdfpagebox<> 0 then begin
pdf_warning("PDF inclusion","Primitive \pdfoptionalwaysusepdfpagebox is obsolete; use \pdfpagebox instead.",true,true);
pdf_force_pagebox:= pdf_option_always_use_pdfpagebox;
pdf_option_always_use_pdfpagebox:= 0;{warn once}
warn_pdfpagebox:= false;
end;
if pdf_option_pdf_inclusion_errorlevel<> 0 then begin
pdf_warning("PDF inclusion","Primitive \pdfoptionpdfinclusionerrorlevel is obsolete; use \pdfinclusionerrorlevel instead.",true,true);
pdf_inclusion_errorlevel:= pdf_option_pdf_inclusion_errorlevel;
pdf_option_pdf_inclusion_errorlevel:= 0;{warn once}
end;
if pdf_force_pagebox> 0 then begin
if warn_pdfpagebox then begin
pdf_warning("PDF inclusion","Primitive \pdfforcepagebox is obsolete; use \pdfpagebox instead.",true,true);
warn_pdfpagebox:= false;
end;
pagebox:= pdf_force_pagebox;
end;
if pagebox= 0 then{no pagebox specification given}
pagebox:= pdf_box_spec_crop;
obj_ximage_data(k):= read_image(s,page,named,colorspace,pagebox,
pdf_major_version,pdf_minor_version,
pdf_inclusion_errorlevel);
if named<> 0 then flush_str(named);
flush_str(s);
scale_image(k);
pdf_last_ximage:= k;
pdf_last_ximage_pages:= image_pages(obj_ximage_data(k));
pdf_last_ximage_colordepth:= image_colordepth(obj_ximage_data(k));
end;

/*:1550*//*1554:*/
#line 34486 "pdftexdir/pdftex.web"

function scan_action:pointer;{read an action specification}
var p:integer;
begin
p:= get_node(pdf_action_size);
scan_action:= p;
pdf_action_file(p):= null;
pdf_action_refcount(p):= null;
if scan_keyword("user")then
pdf_action_type(p):= pdf_action_user
else if scan_keyword("goto")then
pdf_action_type(p):= pdf_action_goto
else if scan_keyword("thread")then
pdf_action_type(p):= pdf_action_thread
else
pdf_error("ext1","action type missing");
if pdf_action_type(p)= pdf_action_user then begin
scan_pdf_ext_toks;
pdf_action_user_tokens(p):= def_ref;
return;
end;
if scan_keyword("file")then begin
scan_pdf_ext_toks;
pdf_action_file(p):= def_ref;
end;
if scan_keyword("page")then begin
if pdf_action_type(p)<> pdf_action_goto then
pdf_error("ext1","only GoTo action can be used with `page'");
pdf_action_type(p):= pdf_action_page;
scan_int;
if cur_val<=0 then
pdf_error("ext1","page number must be positive");
pdf_action_id(p):= cur_val;
pdf_action_named_id(p):= 0;
scan_pdf_ext_toks;
pdf_action_page_tokens(p):= def_ref;
end
else if scan_keyword("name")then begin
scan_pdf_ext_toks;
pdf_action_named_id(p):= 1;
pdf_action_id(p):= def_ref;
end
else if scan_keyword("num")then begin
if(pdf_action_type(p)= pdf_action_goto)and
(pdf_action_file(p)<> null)then
pdf_error("ext1",
"`goto' option cannot be used with both `file' and `num'");
scan_int;
if cur_val<=0 then
pdf_error("ext1","num identifier must be positive");
pdf_action_named_id(p):= 0;
pdf_action_id(p):= cur_val;
end
else
pdf_error("ext1","identifier type missing");
if scan_keyword("newwindow")then begin
pdf_action_new_window(p):= 1;
/*469:*/
#line 10264 "pdftexdir/pdftex.web"

begin get_x_token;if cur_cmd<> spacer then back_input;
end

/*:469*/
#line 34543 "pdftexdir/pdftex.web"
;end
else if scan_keyword("nonewwindow")then begin
pdf_action_new_window(p):= 2;
/*469:*/
#line 10264 "pdftexdir/pdftex.web"

begin get_x_token;if cur_cmd<> spacer then back_input;
end

/*:469*/
#line 34546 "pdftexdir/pdftex.web"
;end
else
pdf_action_new_window(p):= 0;
if(pdf_action_new_window(p)> 0)and
(((pdf_action_type(p)<> pdf_action_goto)and
(pdf_action_type(p)<> pdf_action_page))or
(pdf_action_file(p)= null))then
pdf_error("ext1",
"`newwindow'/`nonewwindow' must be used with `goto' and `file' option");
end;

procedure new_annot_whatsit(w,s:small_number);{create a new whatsit node for
annotation}
begin
new_whatsit(w,s);
scan_alt_rule;{scans|<rule spec> |to|alt_rule|}
pdf_width(tail):= width(alt_rule);
pdf_height(tail):= height(alt_rule);
pdf_depth(tail):= depth(alt_rule);
if(w= pdf_start_link_node)then begin
if scan_keyword("attr")then begin
scan_pdf_ext_toks;
pdf_link_attr(tail):= def_ref;
end
else
pdf_link_attr(tail):= null;
end;
if(w= pdf_thread_node)or(w= pdf_start_thread_node)then begin
if scan_keyword("attr")then begin
scan_pdf_ext_toks;
pdf_thread_attr(tail):= def_ref;
end
else
pdf_thread_attr(tail):= null;
end;
end;

/*:1554*//*1560:*/
#line 34636 "pdftexdir/pdftex.web"

function outline_list_count(p:pointer):integer;{return number of outline
entries in the same level with|p|}
var k:integer;
begin
k:= 1;
while obj_outline_prev(p)<> 0 do begin
incr(k);
p:= obj_outline_prev(p);
end;
outline_list_count:= k;
end;

/*:1560*//*1564:*/
#line 34822 "pdftexdir/pdftex.web"

procedure scan_thread_id;
begin
if scan_keyword("num")then begin
scan_int;
if cur_val<=0 then
pdf_error("ext1","num identifier must be positive");
if cur_val> max_halfword then
pdf_error("ext1","number too big");
pdf_thread_id(tail):= cur_val;
pdf_thread_named_id(tail):= 0;
end
else if scan_keyword("name")then begin
scan_pdf_ext_toks;
pdf_thread_id(tail):= def_ref;
pdf_thread_named_id(tail):= 1;
end
else
pdf_error("ext1","identifier type missing");
end;

/*:1564*//*1571:*/
#line 34879 "pdftexdir/pdftex.web"

function new_snap_node(s:small_number):pointer;
var p:pointer;
begin
scan_glue(glue_val);
if width(cur_val)<0 then
pdf_error("ext1","negative snap glue");
p:= get_node(snap_node_size);
type(p):= whatsit_node;
subtype(p):= s;
link(p):= null;
snap_glue_ptr(p):= cur_val;
final_skip(p):= 0;
new_snap_node:= p;
end;

/*:1571*//*1575:*/
#line 34917 "pdftexdir/pdftex.web"

function concat_tokens(q,r:pointer):pointer;{concat|q|and|r|and
returns the result tokens list}
var p:pointer;
begin
if q= null then begin
concat_tokens:= r;
return;
end;
p:= q;
while link(p)<> null do
p:= link(p);
link(p):= link(r);
free_avail(r);
concat_tokens:= q;
end;

/*:1575*//*1585:*/
#line 35011 "pdftexdir/pdftex.web"

procedure pdf_include_chars;
var s:str_number;
k:pool_pointer;{running indices}
f:internal_font_number;
begin
scan_font_ident;
f:= cur_val;
if f= null_font then
pdf_error("font","invalid font identifier");
pdf_check_vf_cur_val;
if not font_used[f]then
pdf_init_font(f);
scan_pdf_ext_toks;
s:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
k:= str_start[s];
while k<str_start[s+1]do begin
pdf_mark_char(f,str_pool[k]);
incr(k);
end;
flush_str(s);
end;

procedure glyph_to_unicode;
var s1,s2:str_number;
begin
scan_pdf_ext_toks;
s1:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
scan_pdf_ext_toks;
s2:= tokens_to_string(def_ref);
delete_token_ref(def_ref);
def_tounicode(s1,s2);
flush_str(s2);
flush_str(s1);
end;

/*:1585*//*1597:*/
#line 35129 "pdftexdir/pdftex.web"

procedure thread_title(thread:integer);
begin
pdf_print("/Title (");
if obj_info(thread)<0 then
pdf_print(-obj_info(thread))
else
pdf_print_int(obj_info(thread));
pdf_print_ln(")");
end;

procedure pdf_fix_thread(thread:integer);
var a:pointer;
begin
pdf_warning("thread","destination ",false,false);
if obj_info(thread)<0 then begin
print("name{");
print(-obj_info(thread));
print("}");
end
else begin
print("num");
print_int(obj_info(thread));
end;
print(" has been referenced but does not exist, replaced by a fixed one");
print_ln;print_ln;
pdf_new_dict(obj_type_others,0,0);
a:= obj_ptr;
pdf_indirect_ln("T",thread);
pdf_indirect_ln("V",a);
pdf_indirect_ln("N",a);
pdf_indirect_ln("P",head_tab[obj_type_page]);
pdf_print("/R [0 0 ");
pdf_print_bp(pdf_page_width);pdf_out(" ");
pdf_print_bp(pdf_page_height);
pdf_print_ln("]");
pdf_end_dict;
pdf_begin_dict(thread,1);
pdf_print_ln("/I << ");
thread_title(thread);
pdf_print_ln(">>");
pdf_indirect_ln("F",a);
pdf_end_dict;
end;

procedure out_thread(thread:integer);
var a,b:pointer;
last_attr:integer;
begin
if obj_thread_first(thread)= 0 then begin
pdf_fix_thread(thread);
return;
end;
pdf_begin_dict(thread,1);
a:= obj_thread_first(thread);
b:= a;
last_attr:= 0;
repeat
if obj_bead_attr(a)<> 0 then
last_attr:= obj_bead_attr(a);
a:= obj_bead_next(a);
until a= b;
if last_attr<> 0 then
pdf_print_ln(last_attr)
else begin
pdf_print_ln("/I << ");
thread_title(thread);
pdf_print_ln(">>");
end;
pdf_indirect_ln("F",a);
pdf_end_dict;
repeat
pdf_begin_dict(a,1);
if a= b then
pdf_indirect_ln("T",thread);
pdf_indirect_ln("V",obj_bead_prev(a));
pdf_indirect_ln("N",obj_bead_next(a));
pdf_indirect_ln("P",obj_bead_page(a));
pdf_indirect_ln("R",obj_bead_rect(a));
pdf_end_dict;
a:= obj_bead_next(a);
until a= b;
end;

/*:1597*/
#line 33738 "pdftexdir/pdftex.web"

procedure do_extension;
#line 5581 "pdftex-final.ch"
var i,j,k:integer;{all-purpose integers}
p,q,r:pointer;{all-purpose pointers}
#line 33742 "pdftexdir/pdftex.web"
begin case cur_chr of
open_node:/*1529:*/
#line 33821 "pdftexdir/pdftex.web"

begin new_write_whatsit(open_node_size);
scan_optional_equals;scan_file_name;
open_name(tail):= cur_name;open_area(tail):= cur_area;open_ext(tail):= cur_ext;
end

/*:1529*/
#line 33743 "pdftexdir/pdftex.web"
;
write_node:/*1530:*/
#line 33831 "pdftexdir/pdftex.web"

begin k:= cur_cs;new_write_whatsit(write_node_size);
cur_cs:= k;p:= scan_toks(false,false);write_tokens(tail):= def_ref;
end

/*:1530*/
#line 33744 "pdftexdir/pdftex.web"
;
close_node:/*1531:*/
#line 33836 "pdftexdir/pdftex.web"

begin new_write_whatsit(write_node_size);write_tokens(tail):= null;
end

/*:1531*/
#line 33745 "pdftexdir/pdftex.web"
;
special_node:/*1532:*/
#line 33843 "pdftexdir/pdftex.web"

#line 5605 "pdftex-final.ch"
begin new_whatsit(special_node,write_node_size);
if spec_out+mubyte_zero<0 then write_stream(tail):= 0
else if spec_out+mubyte_zero>=2*mubyte_zero then
write_stream(tail):= 2*mubyte_zero-1
else write_stream(tail):= spec_out+mubyte_zero;
if mubyte_out+mubyte_zero<0 then write_mubyte(tail):= 0
else if mubyte_out+mubyte_zero>=2*mubyte_zero then
write_mubyte(tail):= 2*mubyte_zero-1
else write_mubyte(tail):= mubyte_out+mubyte_zero;
if(spec_out= 2)or(spec_out= 3)then
if(mubyte_out> 2)or(mubyte_out= -1)or(mubyte_out= -2)then
write_noexpanding:= true;
p:= scan_toks(false,true);write_tokens(tail):= def_ref;
write_noexpanding:= false;
#line 33846 "pdftexdir/pdftex.web"
end

/*:1532*/
#line 33746 "pdftexdir/pdftex.web"
;
immediate_code:/*1620:*/
#line 35858 "pdftexdir/pdftex.web"

begin get_x_token;
if cur_cmd= extension then begin
if cur_chr<=close_node then
begin p:= tail;do_extension;{append a whatsit node}
out_what(tail);{do the action immediately}
flush_node_list(tail);tail:= p;link(p):= null;
end
else case cur_chr of
pdf_obj_code:begin
do_extension;{scan object and set|pdf_last_obj|}
if obj_data_ptr(pdf_last_obj)= 0 then{this object has not been initialized yet}
pdf_error("ext1","`\pdfobj reserveobjnum' cannot be used with \immediate");
pdf_write_obj(pdf_last_obj);
end;
pdf_xform_code:begin
do_extension;{scan form and set|pdf_last_xform|}
pdf_cur_form:= pdf_last_xform;
pdf_ship_out(obj_xform_box(pdf_last_xform),false);
end;
pdf_ximage_code:begin
do_extension;{scan image and set|pdf_last_ximage|}
pdf_write_image(pdf_last_ximage);
end;
othercases back_input
endcases;
end
else
back_input;
end

/*:1620*/
#line 33747 "pdftexdir/pdftex.web"
;
set_language_code:/*1622:*/
#line 35907 "pdftexdir/pdftex.web"

if abs(mode)<> hmode then report_illegal_case
else begin new_whatsit(language_node,small_node_size);
scan_int;
if cur_val<=0 then clang:= 0
else if cur_val> 255 then clang:= 0
else clang:= cur_val;
what_lang(tail):= clang;
what_lhm(tail):= norm_min(left_hyphen_min);
what_rhm(tail):= norm_min(right_hyphen_min);
end

/*:1622*/
#line 33748 "pdftexdir/pdftex.web"
;
pdf_annot_node:/*1556:*/
#line 34586 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfannot",true);
if scan_keyword("reserveobjnum")then begin
pdf_last_annot:= pdf_new_objnum;
/*469:*/
#line 10264 "pdftexdir/pdftex.web"

begin get_x_token;if cur_cmd<> spacer then back_input;
end

/*:469*/
#line 34591 "pdftexdir/pdftex.web"
;end
else begin
if scan_keyword("useobjnum")then begin
scan_int;
k:= cur_val;
if(k<=0)or(k> obj_ptr)or(obj_annot_ptr(k)<> 0)then
pdf_error("ext1","invalid object number");
end
else
k:= pdf_new_objnum;
new_annot_whatsit(pdf_annot_node,pdf_annot_node_size);
pdf_annot_objnum(tail):= k;
scan_pdf_ext_toks;
pdf_annot_data(tail):= def_ref;
pdf_last_annot:= k;
end
end

/*:1556*/
#line 33749 "pdftexdir/pdftex.web"
;
pdf_catalog_code:/*1577:*/
#line 34942 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfcatalog",false);
scan_pdf_ext_toks;
if pdf_output> 0 then
pdf_catalog_toks:= concat_tokens(pdf_catalog_toks,def_ref);
if scan_keyword("openaction")then begin
if pdf_catalog_openaction<> 0 then
pdf_error("ext1","duplicate of openaction")
else begin
p:= scan_action;
pdf_new_obj(obj_type_others,0,1);
if pdf_output> 0 then
pdf_catalog_openaction:= obj_ptr;
write_action(p);
pdf_end_obj;
delete_action_ref(p);
end;
end
end

/*:1577*/
#line 33750 "pdftexdir/pdftex.web"
;
pdf_dest_node:/*1563:*/
#line 34751 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfdest",true);
q:= tail;
new_whatsit(pdf_dest_node,pdf_dest_node_size);
if scan_keyword("num")then begin
scan_int;
if cur_val<=0 then
pdf_error("ext1","num identifier must be positive");
if cur_val> max_halfword then
pdf_error("ext1","number too big");
pdf_dest_id(tail):= cur_val;
pdf_dest_named_id(tail):= 0;
end
else if scan_keyword("name")then begin
scan_pdf_ext_toks;
pdf_dest_id(tail):= def_ref;
pdf_dest_named_id(tail):= 1;
end
else
pdf_error("ext1","identifier type missing");
if scan_keyword("xyz")then begin
pdf_dest_type(tail):= pdf_dest_xyz;
if scan_keyword("zoom")then begin
scan_int;
if cur_val> max_halfword then
pdf_error("ext1","number too big");
pdf_dest_xyz_zoom(tail):= cur_val;
end
else
pdf_dest_xyz_zoom(tail):= null;
end
else if scan_keyword("fitbh")then
pdf_dest_type(tail):= pdf_dest_fitbh
else if scan_keyword("fitbv")then
pdf_dest_type(tail):= pdf_dest_fitbv
else if scan_keyword("fitb")then
pdf_dest_type(tail):= pdf_dest_fitb
else if scan_keyword("fith")then
pdf_dest_type(tail):= pdf_dest_fith
else if scan_keyword("fitv")then
pdf_dest_type(tail):= pdf_dest_fitv
else if scan_keyword("fitr")then
pdf_dest_type(tail):= pdf_dest_fitr
else if scan_keyword("fit")then
pdf_dest_type(tail):= pdf_dest_fit
else
pdf_error("ext1","destination type missing");
/*469:*/
#line 10264 "pdftexdir/pdftex.web"

begin get_x_token;if cur_cmd<> spacer then back_input;
end

/*:469*/
#line 34799 "pdftexdir/pdftex.web"
;
if pdf_dest_type(tail)= pdf_dest_fitr then begin
scan_alt_rule;{scans|<rule spec> |to|alt_rule|}
pdf_width(tail):= width(alt_rule);
pdf_height(tail):= height(alt_rule);
pdf_depth(tail):= depth(alt_rule);
end;
if pdf_dest_named_id(tail)<> 0 then begin
i:= tokens_to_string(pdf_dest_id(tail));
k:= find_obj(obj_type_dest,i,true);
flush_str(i);
end
else
k:= find_obj(obj_type_dest,pdf_dest_id(tail),false);
if(k<> 0)and(obj_dest_ptr(k)<> null)then begin
warn_dest_dup(pdf_dest_id(tail),pdf_dest_named_id(tail),
"ext4","has been already used, duplicate ignored");
flush_node_list(tail);
tail:= q;
link(q):= null;
end;
end

/*:1563*/
#line 33751 "pdftexdir/pdftex.web"
;
pdf_end_link_node:/*1559:*/
#line 34628 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfendlink",true);
if abs(mode)= vmode then
pdf_error("ext1","\pdfendlink cannot be used in vertical mode");
new_whatsit(pdf_end_link_node,small_node_size);
end

/*:1559*/
#line 33752 "pdftexdir/pdftex.web"
;
pdf_end_thread_node:/*1567:*/
#line 34857 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfendthread",true);
new_whatsit(pdf_end_thread_node,small_node_size);
end

/*:1567*/
#line 33753 "pdftexdir/pdftex.web"
;
pdf_font_attr_code:/*1587:*/
#line 35055 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdffontattr",true);
scan_font_ident;
k:= cur_val;
if k= null_font then
pdf_error("font","invalid font identifier");
scan_pdf_ext_toks;
pdf_font_attr[k]:= tokens_to_string(def_ref);
end

/*:1587*/
#line 33754 "pdftexdir/pdftex.web"
;
pdf_font_expand_code:/*1533:*/
#line 33848 "pdftexdir/pdftex.web"

read_expand_font

/*:1533*/
#line 33755 "pdftexdir/pdftex.web"
;
pdf_include_chars_code:/*1586:*/
#line 35049 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfincludechars",true);
pdf_include_chars;
end

/*:1586*/
#line 33756 "pdftexdir/pdftex.web"
;
pdf_info_code:/*1576:*/
#line 34934 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfinfo",false);
scan_pdf_ext_toks;
if pdf_output> 0 then
pdf_info_toks:= concat_tokens(pdf_info_toks,def_ref);
end

/*:1576*/
#line 33757 "pdftexdir/pdftex.web"
;
pdf_literal_node:/*1536:*/
#line 33936 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfliteral",true);
new_whatsit(pdf_literal_node,write_node_size);
if scan_keyword("direct")then
pdf_literal_mode(tail):= direct_always
else if scan_keyword("page")then
pdf_literal_mode(tail):= direct_page
else
pdf_literal_mode(tail):= set_origin;
scan_pdf_ext_toks;
pdf_literal_data(tail):= def_ref;
end

/*:1536*/
#line 33758 "pdftexdir/pdftex.web"
;
pdf_colorstack_node:/*1537:*/
#line 33950 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfcolorstack",true);
{Scan and check the stack number and store in|cur_val|}
scan_int;
if cur_val>=colorstackused then begin
print_err("Unknown color stack number ");
print_int(cur_val);

help3("Allocate and initialize a color stack with \\pdfcolorstackinit.")
("I'll use default color stack 0 here.")
("Proceed, with fingers crossed.");
error;
cur_val:= 0;
end;
if cur_val<0 then begin
print_err("Invalid negative color stack number");

help2("I'll use default color stack 0 here.")
("Proceed, with fingers crossed.");
error;
cur_val:= 0;
end;
{Scan the command and store in i,j holds the node size}
if scan_keyword("set")then begin
i:= colorstack_set;
j:= pdf_colorstack_setter_node_size;
end
else if scan_keyword("push")then begin
i:= colorstack_push;
j:= pdf_colorstack_setter_node_size;
end
else if scan_keyword("pop")then begin
i:= colorstack_pop;
j:= pdf_colorstack_getter_node_size;
end
else if scan_keyword("current")then begin
i:= colorstack_current;
j:= pdf_colorstack_getter_node_size;
end
else begin
i:= -1;{error}
end;
if i>=0 then begin
new_whatsit(pdf_colorstack_node,j);
pdf_colorstack_stack(tail):= cur_val;
pdf_colorstack_cmd(tail):= i;
if i<=colorstack_data then begin
scan_pdf_ext_toks;
pdf_colorstack_data(tail):= def_ref;
end;
end
else begin
print_err("Color stack action is missing");

help3("The expected actions for \pdfcolorstack:")
("    set, push, pop, current")
("I'll ignore the color stack command.");
error;
end
end

/*:1537*/
#line 33759 "pdftexdir/pdftex.web"
;
pdf_setmatrix_node:/*1538:*/
#line 34012 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfsetmatrix",true);
new_whatsit(pdf_setmatrix_node,pdf_setmatrix_node_size);
scan_pdf_ext_toks;
pdf_setmatrix_data(tail):= def_ref;
end

/*:1538*/
#line 33760 "pdftexdir/pdftex.web"
;
pdf_save_node:/*1539:*/
#line 34020 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfsave",true);
new_whatsit(pdf_save_node,pdf_save_node_size);
end

/*:1539*/
#line 33761 "pdftexdir/pdftex.web"
;
pdf_restore_node:/*1540:*/
#line 34026 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfrestore",true);
new_whatsit(pdf_restore_node,pdf_restore_node_size);
end

/*:1540*/
#line 33762 "pdftexdir/pdftex.web"
;
pdf_map_file_code:/*1588:*/
#line 35066 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfmapfile",true);
scan_pdf_ext_toks;
pdfmapfile(def_ref);
delete_token_ref(def_ref);
end

/*:1588*/
#line 33763 "pdftexdir/pdftex.web"
;
pdf_map_line_code:/*1589:*/
#line 35074 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfmapline",true);
scan_pdf_ext_toks;
pdfmapline(def_ref);
delete_token_ref(def_ref);
end

/*:1589*/
#line 33764 "pdftexdir/pdftex.web"
;
pdf_names_code:/*1578:*/
#line 34963 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfnames",true);
scan_pdf_ext_toks;
pdf_names_toks:= concat_tokens(pdf_names_toks,def_ref);
end

/*:1578*/
#line 33765 "pdftexdir/pdftex.web"
;
pdf_obj_code:/*1542:*/
#line 34042 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfobj",true);
if scan_keyword("reserveobjnum")then begin
/*469:*/
#line 10264 "pdftexdir/pdftex.web"

begin get_x_token;if cur_cmd<> spacer then back_input;
end

/*:469*/
#line 34046 "pdftexdir/pdftex.web"
;
incr(pdf_obj_count);
pdf_create_obj(obj_type_obj,pdf_obj_count);
pdf_last_obj:= obj_ptr;
end
else begin
k:= -1;
if scan_keyword("useobjnum")then begin
scan_int;
k:= cur_val;
if(k<=0)or(k> obj_ptr)or(obj_data_ptr(k)<> 0)then begin
pdf_warning("\pdfobj","invalid object number being ignored",true,true);
pdf_retval:= -1;{signal the problem}
k:= -1;{will be generated again}
end;
end;
if k<0 then begin
incr(pdf_obj_count);
pdf_create_obj(obj_type_obj,pdf_obj_count);
k:= obj_ptr;
end;
obj_data_ptr(k):= pdf_get_mem(pdfmem_obj_size);
if scan_keyword("stream")then begin
obj_obj_is_stream(k):= 1;
if scan_keyword("attr")then begin
scan_pdf_ext_toks;
obj_obj_stream_attr(k):= def_ref;
end
else
obj_obj_stream_attr(k):= null;
end
else
obj_obj_is_stream(k):= 0;
if scan_keyword("file")then
obj_obj_is_file(k):= 1
else
obj_obj_is_file(k):= 0;
scan_pdf_ext_toks;
obj_obj_data(k):= def_ref;
pdf_last_obj:= k;
end;
end

/*:1542*/
#line 33766 "pdftexdir/pdftex.web"
;
pdf_outline_code:/*1561:*/
#line 34649 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfoutline",true);
if scan_keyword("attr")then begin
scan_pdf_ext_toks;
r:= def_ref;
end
else
r:= 0;
p:= scan_action;
if scan_keyword("count")then begin
scan_int;
i:= cur_val;
end
else
i:= 0;
scan_pdf_ext_toks;
q:= def_ref;
pdf_new_obj(obj_type_others,0,1);
j:= obj_ptr;
write_action(p);
pdf_end_obj;
delete_action_ref(p);
pdf_create_obj(obj_type_outline,0);
k:= obj_ptr;
obj_outline_ptr(k):= pdf_get_mem(pdfmem_outline_size);
obj_outline_action_objnum(k):= j;
obj_outline_count(k):= i;
pdf_new_obj(obj_type_others,0,1);
pdf_print_str_ln(tokens_to_string(q));
flush_str(last_tokens_string);
delete_token_ref(q);
pdf_end_obj;
obj_outline_title(k):= obj_ptr;
obj_outline_prev(k):= 0;
obj_outline_next(k):= 0;
obj_outline_first(k):= 0;
obj_outline_last(k):= 0;
obj_outline_parent(k):= pdf_parent_outline;
obj_outline_attr(k):= r;
if pdf_first_outline= 0 then
pdf_first_outline:= k;
if pdf_last_outline= 0 then begin
if pdf_parent_outline<> 0 then
obj_outline_first(pdf_parent_outline):= k;
end
else begin
obj_outline_next(pdf_last_outline):= k;
obj_outline_prev(k):= pdf_last_outline;
end;
pdf_last_outline:= k;
if obj_outline_count(k)<> 0 then begin
pdf_parent_outline:= k;
pdf_last_outline:= 0;
end
else if(pdf_parent_outline<> 0)and
(outline_list_count(k)= abs(obj_outline_count(pdf_parent_outline)))then
begin
j:= pdf_last_outline;
repeat
obj_outline_last(pdf_parent_outline):= j;
j:= pdf_parent_outline;
pdf_parent_outline:= obj_outline_parent(pdf_parent_outline);
until(pdf_parent_outline= 0)or
(outline_list_count(j)<abs(obj_outline_count(pdf_parent_outline)));
if pdf_parent_outline= 0 then
pdf_last_outline:= pdf_first_outline
else
pdf_last_outline:= obj_outline_first(pdf_parent_outline);
while obj_outline_next(pdf_last_outline)<> 0 do
pdf_last_outline:= obj_outline_next(pdf_last_outline);
end;
end

/*:1561*/
#line 33767 "pdftexdir/pdftex.web"
;
pdf_refobj_node:/*1544:*/
#line 34119 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfrefobj",true);
scan_int;
pdf_check_obj(obj_type_obj,cur_val);
new_whatsit(pdf_refobj_node,pdf_refobj_node_size);
pdf_obj_objnum(tail):= cur_val;
end

/*:1544*/
#line 33768 "pdftexdir/pdftex.web"
;
pdf_refxform_node:/*1547:*/
#line 34165 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfrefxform",true);
scan_int;
pdf_check_obj(obj_type_xform,cur_val);
new_whatsit(pdf_refxform_node,pdf_refxform_node_size);
pdf_xform_objnum(tail):= cur_val;
pdf_width(tail):= obj_xform_width(cur_val);
pdf_height(tail):= obj_xform_height(cur_val);
pdf_depth(tail):= obj_xform_depth(cur_val);
end

/*:1547*/
#line 33769 "pdftexdir/pdftex.web"
;
pdf_refximage_node:/*1552:*/
#line 34413 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfrefximage",true);
scan_int;
pdf_check_obj(obj_type_ximage,cur_val);
new_whatsit(pdf_refximage_node,pdf_refximage_node_size);
pdf_ximage_objnum(tail):= cur_val;
pdf_width(tail):= obj_ximage_width(cur_val);
pdf_height(tail):= obj_ximage_height(cur_val);
pdf_depth(tail):= obj_ximage_depth(cur_val);
end

/*:1552*/
#line 33770 "pdftexdir/pdftex.web"
;
pdf_save_pos_node:/*1574:*/
#line 34909 "pdftexdir/pdftex.web"

begin
new_whatsit(pdf_save_pos_node,small_node_size);
end

/*:1574*/
#line 33771 "pdftexdir/pdftex.web"
;
pdf_snap_ref_point_node:/*1570:*/
#line 34873 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfsnaprefpoint",true);
new_whatsit(pdf_snap_ref_point_node,small_node_size);
end

/*:1570*/
#line 33772 "pdftexdir/pdftex.web"
;
pdf_snapy_comp_node:/*1573:*/
#line 34901 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfsnapycomp",true);
new_whatsit(pdf_snapy_comp_node,small_node_size);
scan_int;
snapy_comp_ratio(tail):= fix_int(cur_val,0,1000);
end

/*:1573*/
#line 33773 "pdftexdir/pdftex.web"
;
pdf_snapy_node:/*1572:*/
#line 34895 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfsnapy",true);
tail_append(new_snap_node(pdf_snapy_node));
end

/*:1572*/
#line 33774 "pdftexdir/pdftex.web"
;
pdf_start_link_node:/*1558:*/
#line 34613 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfstartlink",true);
if abs(mode)= vmode then
pdf_error("ext1","\pdfstartlink cannot be used in vertical mode");
k:= pdf_new_objnum;
new_annot_whatsit(pdf_start_link_node,pdf_annot_node_size);
pdf_link_action(tail):= scan_action;
pdf_link_objnum(tail):= k;
pdf_last_link:= k;
{N.B.:although it is possible to set|obj_annot_ptr(k):= tail|here,it
is not safe if nodes are later copied/destroyed/moved;a better place
to do this is inside|do_link|,when the whatsit node is written out}
end

/*:1558*/
#line 33775 "pdftexdir/pdftex.web"
;
pdf_start_thread_node:/*1566:*/
#line 34850 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfstartthread",true);
new_annot_whatsit(pdf_start_thread_node,pdf_thread_node_size);
scan_thread_id;
end

/*:1566*/
#line 33776 "pdftexdir/pdftex.web"
;
pdf_thread_node:/*1565:*/
#line 34843 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfthread",true);
new_annot_whatsit(pdf_thread_node,pdf_thread_node_size);
scan_thread_id;
end

/*:1565*/
#line 33777 "pdftexdir/pdftex.web"
;
pdf_trailer_code:/*1579:*/
#line 34970 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdftrailer",false);
scan_pdf_ext_toks;
if pdf_output> 0 then
pdf_trailer_toks:= concat_tokens(pdf_trailer_toks,def_ref);
end

/*:1579*/
#line 33778 "pdftexdir/pdftex.web"
;
pdf_trailer_id_code:/*1580:*/
#line 34978 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdftrailerid",false);
scan_pdf_ext_toks;
if pdf_output> 0 then
pdf_trailer_id_toks:= concat_tokens(pdf_trailer_id_toks,def_ref);
end

/*:1580*/
#line 33779 "pdftexdir/pdftex.web"
;
pdf_xform_code:/*1546:*/
#line 34134 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfxform",true);
incr(pdf_xform_count);
pdf_create_obj(obj_type_xform,pdf_xform_count);
k:= obj_ptr;
obj_data_ptr(k):= pdf_get_mem(pdfmem_xform_size);
if scan_keyword("attr")then begin
scan_pdf_ext_toks;
obj_xform_attr(k):= def_ref;
end
else
obj_xform_attr(k):= null;
if scan_keyword("resources")then begin
scan_pdf_ext_toks;
obj_xform_resources(k):= def_ref;
end
else
obj_xform_resources(k):= null;
scan_register_num;
fetch_box(p);
if p= null then
pdf_error("ext1","\pdfxform cannot be used with a void box");
obj_xform_width(k):= width(p);
obj_xform_height(k):= height(p);
obj_xform_depth(k):= depth(p);
obj_xform_box(k):= p;{save pointer to the box}
change_box(null);
pdf_last_xform:= k;
end

/*:1546*/
#line 33780 "pdftexdir/pdftex.web"
;
pdf_ximage_code:/*1551:*/
#line 34406 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfximage",true);
check_pdfversion;
scan_image;
end

/*:1551*/
#line 33781 "pdftexdir/pdftex.web"
;
reset_timer_code:/*1584:*/
#line 35003 "pdftexdir/pdftex.web"

begin
seconds_and_micros(epochseconds,microseconds);
end


/*:1584*/
#line 33782 "pdftexdir/pdftex.web"
;
set_random_seed_code:/*1583:*/
#line 34995 "pdftexdir/pdftex.web"

begin
scan_int;
if cur_val<0 then negate(cur_val);
random_seed:= cur_val;
init_randoms(random_seed);
end

/*:1583*/
#line 33783 "pdftexdir/pdftex.web"
;
pdf_glyph_to_unicode_code:/*1590:*/
#line 35082 "pdftexdir/pdftex.web"

begin
glyph_to_unicode;
end

/*:1590*/
#line 33784 "pdftexdir/pdftex.web"
;
pdf_nobuiltin_tounicode_code:/*1591:*/
#line 35087 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfnobuiltintounicode",true);
scan_font_ident;
k:= cur_val;
if k= null_font then
pdf_error("font","invalid font identifier");
pdf_font_nobuiltin_tounicode[k]:= true;
end

/*:1591*/
#line 33785 "pdftexdir/pdftex.web"
;
pdf_interword_space_on_node:/*1592:*/
#line 35097 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfinterwordspaceon",true);
new_whatsit(pdf_interword_space_on_node,small_node_size);
end

/*:1592*/
#line 33786 "pdftexdir/pdftex.web"
;
pdf_interword_space_off_node:/*1593:*/
#line 35103 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfinterwordspaceoff",true);
new_whatsit(pdf_interword_space_off_node,small_node_size);
end

/*:1593*/
#line 33787 "pdftexdir/pdftex.web"
;
pdf_fake_space_node:/*1594:*/
#line 35109 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdffakespace",true);
new_whatsit(pdf_fake_space_node,small_node_size);
end

/*:1594*/
#line 33788 "pdftexdir/pdftex.web"
;
pdf_running_link_off_node:/*1595:*/
#line 35115 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfrunninglinkoff",true);
new_whatsit(pdf_running_link_off_node,small_node_size);
end

/*:1595*/
#line 33789 "pdftexdir/pdftex.web"
;
pdf_running_link_on_node:/*1596:*/
#line 35121 "pdftexdir/pdftex.web"

begin
check_pdfoutput("\pdfrunninglinkon",true);
new_whatsit(pdf_running_link_on_node,small_node_size);
end

/*:1596*/
#line 33790 "pdftexdir/pdftex.web"
;
othercases confusion("ext1")

endcases;
end;

/*:1526*//*1621:*/
#line 35893 "pdftexdir/pdftex.web"

procedure fix_language;
var l:ASCII_code;{the new current language}
begin if language<=0 then l:= 0
else if language> 255 then l:= 0
else l:= language;
if l<> clang then
begin new_whatsit(language_node,small_node_size);
what_lang(tail):= l;clang:= l;
what_lhm(tail):= norm_min(left_hyphen_min);
what_rhm(tail):= norm_min(right_hyphen_min);
end;
end;

/*:1621*//*1936:*/
#line 7095 "pdftex-final.ch"


procedure insert_src_special;
var toklist,p,q:pointer;
begin
if(source_filename_stack[in_open]> 0 and is_new_source(source_filename_stack[in_open]
,line))then begin
toklist:= get_avail;
p:= toklist;
info(p):= cs_token_flag+frozen_special;
link(p):= get_avail;p:= link(p);
info(p):= left_brace_token+"{";
q:= str_toks(make_src_special(source_filename_stack[in_open],line));
link(p):= link(temp_head);
p:= q;
link(p):= get_avail;p:= link(p);
info(p):= right_brace_token+"}";
ins_list(toklist);
remember_source_info(source_filename_stack[in_open],line);
end;
end;

procedure append_src_special;
var q:pointer;
begin
if(source_filename_stack[in_open]> 0 and is_new_source(source_filename_stack[in_open]
,line))then begin
new_whatsit(special_node,write_node_size);
write_stream(tail):= 0;
def_ref:= get_avail;
token_ref_count(def_ref):= null;
q:= str_toks(make_src_special(source_filename_stack[in_open],line));
link(def_ref):= link(temp_head);
write_tokens(tail):= def_ref;
remember_source_info(source_filename_stack[in_open],line);
end;
end;

/*:1936*/
#line 28540 "pdftexdir/pdftex.web"

/*1244:*/
#line 29272 "pdftexdir/pdftex.web"

procedure handle_right_brace;
var p,q:pointer;{for short-term use}
d:scaled;{holds|split_max_depth|in|insert_group|}
f:integer;{holds|floating_penalty|in|insert_group|}
begin case cur_group of
simple_group:unsave;
bottom_level:begin print_err("Too many }'s");

help2("You've closed more groups than you opened.")
("Such booboos are generally harmless, so keep going.");error;
end;
semi_simple_group,math_shift_group,math_left_group:extra_right_brace;
/*1261:*/
#line 29644 "pdftexdir/pdftex.web"

hbox_group:package(0);
adjusted_hbox_group:begin adjust_tail:= adjust_head;
pre_adjust_tail:= pre_adjust_head;package(0);
end;
vbox_group:begin end_graf;package(0);
end;
vtop_group:begin end_graf;package(vtop_code);
end;

/*:1261*//*1276:*/
#line 29818 "pdftexdir/pdftex.web"

insert_group:begin end_graf;q:= split_top_skip;add_glue_ref(q);
d:= split_max_depth;f:= floating_penalty;unsave;save_ptr:= save_ptr-2;
{now|saved(0)|is the insertion number,or 255 for|vadjust|}
p:= vpack(link(head),natural);pop_nest;
if saved(0)<255 then
begin tail_append(get_node(ins_node_size));
type(tail):= ins_node;subtype(tail):= qi(saved(0));
height(tail):= height(p)+depth(p);ins_ptr(tail):= list_ptr(p);
split_top_ptr(tail):= q;depth(tail):= d;float_cost(tail):= f;
end
else begin tail_append(get_node(small_node_size));
type(tail):= adjust_node;
adjust_pre(tail):= saved(1);{the|subtype|is used for|adjust_pre|}
adjust_ptr(tail):= list_ptr(p);delete_glue_ref(q);
end;
free_node(p,box_node_size);
if nest_ptr= 0 then build_page;
end;
output_group:/*1201:*/
#line 28444 "pdftexdir/pdftex.web"

begin if(loc<> null)or
((token_type<> output_text)and(token_type<> backed_up))then
/*1202:*/
#line 28465 "pdftexdir/pdftex.web"

begin print_err("Unbalanced output routine");

help2("Your sneaky output routine has problematic {'s and/or }'s.")
("I can't handle that very well; good luck.");error;
repeat get_token;
until loc= null;
end{loops forever if reading from a file,since|null= min_halfword<=0|}

/*:1202*/
#line 28447 "pdftexdir/pdftex.web"
;
end_token_list;{conserve stack space in case more outputs are triggered}
end_graf;unsave;output_active:= false;insert_penalties:= 0;
/*1203:*/
#line 28474 "pdftexdir/pdftex.web"

if box(255)<> null then
begin print_err("Output routine didn't use all of ");
print_esc("box");print_int(255);

help3("Your \output commands should empty \box255,")
("e.g., by saying `\shipout\box255'.")
("Proceed; I'll discard its present contents.");
box_error(255);
end

/*:1203*/
#line 28450 "pdftexdir/pdftex.web"
;
if tail<> head then{current list goes after heldover insertions}
begin link(page_tail):= link(head);
page_tail:= tail;
end;
if link(page_head)<> null then{and both go before heldover contributions}
begin if link(contrib_head)= null then contrib_tail:= page_tail;
link(page_tail):= link(contrib_head);
link(contrib_head):= link(page_head);
link(page_head):= null;page_tail:= page_head;
end;
flush_node_list(page_disc);page_disc:= null;
pop_nest;build_page;
end

/*:1201*/
#line 29837 "pdftexdir/pdftex.web"
;

/*:1276*//*1294:*/
#line 30035 "pdftexdir/pdftex.web"

disc_group:build_discretionary;

/*:1294*//*1308:*/
#line 30274 "pdftexdir/pdftex.web"

align_group:begin back_input;cur_tok:= cs_token_flag+frozen_cr;
print_err("Missing ");print_esc("cr");print(" inserted");

help1("I'm guessing that you meant to end an alignment here.");
ins_error;
end;

/*:1308*//*1309:*/
#line 30282 "pdftexdir/pdftex.web"

no_align_group:begin end_graf;unsave;align_peek;
end;

/*:1309*//*1344:*/
#line 30744 "pdftexdir/pdftex.web"

vcenter_group:begin end_graf;unsave;save_ptr:= save_ptr-2;
p:= vpack(link(head),saved(1),saved(0));pop_nest;
tail_append(new_noad);type(tail):= vcenter_noad;
math_type(nucleus(tail)):= sub_box;info(nucleus(tail)):= p;
end;

/*:1344*//*1349:*/
#line 30782 "pdftexdir/pdftex.web"

math_choice_group:build_choices;

/*:1349*//*1362:*/
#line 30956 "pdftexdir/pdftex.web"

math_group:begin unsave;decr(save_ptr);
math_type(saved(0)):= sub_mlist;p:= fin_mlist(null);info(saved(0)):= p;
if p<> null then if link(p)= null then
if type(p)= ord_noad then
begin if math_type(subscr(p))= empty then
if math_type(supscr(p))= empty then
begin mem[saved(0)].hh:= mem[nucleus(p)].hh;
free_node(p,noad_size);
end;
end
else if type(p)= accent_noad then if saved(0)= nucleus(tail)then
if type(tail)= ord_noad then/*1363:*/
#line 30971 "pdftexdir/pdftex.web"

begin q:= head;while link(q)<> tail do q:= link(q);
link(q):= p;free_node(tail,noad_size);tail:= p;
end

/*:1363*/
#line 30968 "pdftexdir/pdftex.web"
;
end;

/*:1362*/
#line 29286 "pdftexdir/pdftex.web"

othercases confusion("rightbrace")

endcases;
end;

/*:1244*/
#line 28541 "pdftexdir/pdftex.web"

procedure main_control;{governs\TeX's activities}
label big_switch,reswitch,main_loop,main_loop_wrapup,
main_loop_move,main_loop_move+1,main_loop_move+2,main_loop_move_lig,
main_loop_lookahead,main_loop_lookahead+1,
main_lig_loop,main_lig_loop+1,main_lig_loop+2,
append_normal_space,exit;
var t:integer;{general-purpose temporary variable}
tmp_k1,tmp_k2:pointer;{for testing whether an auto kern should be inserted}
begin if every_job<> null then begin_token_list(every_job,every_job_text);
big_switch:get_x_token;
reswitch:/*1206:*/
#line 28580 "pdftexdir/pdftex.web"

if interrupt<> 0 then if OK_to_interrupt then
begin back_input;check_interrupt;goto big_switch;
end;
debug if panicking then check_mem(false);gubed
if tracing_commands> 0 then show_cur_cmd_chr

/*:1206*/
#line 28552 "pdftexdir/pdftex.web"
;
case abs(mode)+cur_cmd of
hmode+letter,hmode+other_char,hmode+char_given:goto main_loop;
hmode+char_num:begin scan_char_num;cur_chr:= cur_val;goto main_loop;end;
hmode+no_boundary:begin get_x_token;
if(cur_cmd= letter)or(cur_cmd= other_char)or(cur_cmd= char_given)or
(cur_cmd= char_num)then cancel_boundary:= true;
goto reswitch;
end;
hmode+spacer:
if(space_factor= 1000)or(pdf_adjust_interword_glue> 0)then
goto append_normal_space
else app_space;
hmode+ex_space,mmode+ex_space:goto append_normal_space;
/*1221:*/
#line 28920 "pdftexdir/pdftex.web"

any_mode(relax),vmode+spacer,mmode+spacer,mmode+no_boundary:do_nothing;
any_mode(ignore_spaces):begin
if cur_chr= 0 then begin
/*432:*/
#line 9549 "pdftexdir/pdftex.web"

repeat get_x_token;
until cur_cmd<> spacer

/*:432*/
#line 28924 "pdftexdir/pdftex.web"
;
goto reswitch;
end
else begin
t:= scanner_status;
scanner_status:= normal;
get_next;
scanner_status:= t;
if cur_cs<hash_base then
cur_cs:= prim_lookup(cur_cs-single_base)
else
cur_cs:= prim_lookup(text(cur_cs));
if cur_cs<> undefined_primitive then begin
cur_cmd:= prim_eq_type(cur_cs);
cur_chr:= prim_equiv(cur_cs);
cur_tok:= cs_token_flag+prim_eqtb_base+cur_cs;
goto reswitch;
end;
end;
end;
vmode+stop:if its_all_over then return;{this is the only way out}
/*1224:*/
#line 28986 "pdftexdir/pdftex.web"

vmode+vmove,hmode+hmove,mmode+hmove,any_mode(last_item),

/*:1224*//*1274:*/
#line 29794 "pdftexdir/pdftex.web"

vmode+vadjust,

/*:1274*//*1287:*/
#line 29974 "pdftexdir/pdftex.web"
vmode+ital_corr,

/*:1287*//*1320:*/
#line 30376 "pdftexdir/pdftex.web"
non_math(eq_no),

/*:1320*/
#line 28945 "pdftexdir/pdftex.web"
any_mode(mac_param):
report_illegal_case;
/*1222:*/
#line 28957 "pdftexdir/pdftex.web"

non_math(sup_mark),non_math(sub_mark),non_math(math_char_num),
non_math(math_given),non_math(math_comp),non_math(delim_num),
non_math(left_right),non_math(above),non_math(radical),
non_math(math_style),non_math(math_choice),non_math(vcenter),
non_math(non_script),non_math(mkern),non_math(limit_switch),
non_math(mskip),non_math(math_accent),
mmode+endv,mmode+par_end,mmode+stop,mmode+vskip,mmode+un_vbox,
mmode+valign,mmode+hrule

/*:1222*/
#line 28947 "pdftexdir/pdftex.web"
:insert_dollar_sign;
/*1232:*/
#line 29075 "pdftexdir/pdftex.web"

vmode+hrule,hmode+vrule,mmode+vrule:begin tail_append(scan_rule_spec);
if abs(mode)= vmode then prev_depth:= pdf_ignored_dimen
else if abs(mode)= hmode then space_factor:= 1000;
end;

/*:1232*//*1233:*/
#line 29086 "pdftexdir/pdftex.web"

vmode+vskip,hmode+hskip,mmode+hskip,mmode+mskip:append_glue;
any_mode(kern),mmode+mkern:append_kern;

/*:1233*//*1239:*/
#line 29199 "pdftexdir/pdftex.web"

non_math(left_brace):new_save_level(simple_group);
any_mode(begin_group):new_save_level(semi_simple_group);
any_mode(end_group):if cur_group= semi_simple_group then unsave
else off_save;

/*:1239*//*1243:*/
#line 29269 "pdftexdir/pdftex.web"

any_mode(right_brace):handle_right_brace;

/*:1243*//*1249:*/
#line 29417 "pdftexdir/pdftex.web"

vmode+hmove,hmode+vmove,mmode+vmove:begin t:= cur_chr;
scan_normal_dimen;
if t= 0 then scan_box(cur_val)else scan_box(-cur_val);
end;
any_mode(leader_ship):scan_box(leader_flag-a_leaders+cur_chr);
any_mode(make_box):begin_box(0);

/*:1249*//*1266:*/
#line 29699 "pdftexdir/pdftex.web"

vmode+start_par:new_graf(cur_chr> 0);
vmode+letter,vmode+other_char,vmode+char_num,vmode+char_given,
vmode+math_shift,vmode+un_hbox,vmode+vrule,
vmode+accent,vmode+discretionary,vmode+hskip,vmode+valign,
vmode+ex_space,vmode+no_boundary:
begin back_input;new_graf(true);
end;

/*:1266*//*1268:*/
#line 29728 "pdftexdir/pdftex.web"

hmode+start_par,mmode+start_par:if cur_chr<> 2 then indent_in_hmode;

/*:1268*//*1270:*/
#line 29748 "pdftexdir/pdftex.web"

vmode+par_end:begin normal_paragraph;
if mode> 0 then build_page;
end;
hmode+par_end:begin if align_state<0 then off_save;{this tries to
recover from an alignment that didn't end properly}
end_graf;{this takes us to the enclosing mode,if|mode> 0|}
if mode= vmode then build_page;
end;
hmode+stop,hmode+vskip,hmode+hrule,hmode+un_vbox,hmode+halign:head_for_vmode;

/*:1270*//*1273:*/
#line 29790 "pdftexdir/pdftex.web"

any_mode(insert),hmode+vadjust,mmode+vadjust:begin_insert_or_adjust;
any_mode(mark):make_mark;

/*:1273*//*1278:*/
#line 29855 "pdftexdir/pdftex.web"

any_mode(break_penalty):append_penalty;

/*:1278*//*1280:*/
#line 29871 "pdftexdir/pdftex.web"

any_mode(remove_item):delete_last;

/*:1280*//*1285:*/
#line 29937 "pdftexdir/pdftex.web"

vmode+un_vbox,hmode+un_hbox,mmode+un_hbox:unpackage;

/*:1285*//*1288:*/
#line 29980 "pdftexdir/pdftex.web"

hmode+ital_corr:append_italic_correction;
mmode+ital_corr:tail_append(new_kern(0));

/*:1288*//*1292:*/
#line 30012 "pdftexdir/pdftex.web"

hmode+discretionary,mmode+discretionary:append_discretionary;

/*:1292*//*1298:*/
#line 30104 "pdftexdir/pdftex.web"

hmode+accent:make_accent;

/*:1298*//*1302:*/
#line 30175 "pdftexdir/pdftex.web"

any_mode(car_ret),any_mode(tab_mark):align_error;
any_mode(no_align):no_align_error;
any_mode(omit):omit_error;

/*:1302*//*1306:*/
#line 30242 "pdftexdir/pdftex.web"

vmode+halign:init_align;
hmode+valign:/*1700:*/
#line 37502 "pdftexdir/pdftex.web"

if cur_chr> 0 then
begin if eTeX_enabled(TeXXeT_en,cur_cmd,cur_chr)then




tail_append(new_math(0,cur_chr));
end
else

/*:1700*/
#line 30244 "pdftexdir/pdftex.web"
init_align;
mmode+halign:if privileged then
if cur_group= math_shift_group then init_align
else off_save;
vmode+endv,hmode+endv:do_endv;

/*:1306*//*1310:*/
#line 30288 "pdftexdir/pdftex.web"

any_mode(end_cs_name):cs_error;

/*:1310*//*1313:*/
#line 30319 "pdftexdir/pdftex.web"

hmode+math_shift:init_math;

/*:1313*//*1316:*/
#line 30352 "pdftexdir/pdftex.web"

mmode+eq_no:if privileged then
if cur_group= math_shift_group then start_eq_no
else off_save;

/*:1316*//*1326:*/
#line 30496 "pdftexdir/pdftex.web"

mmode+left_brace:begin tail_append(new_noad);
back_input;scan_math(nucleus(tail));
end;

/*:1326*//*1330:*/
#line 30560 "pdftexdir/pdftex.web"

mmode+letter,mmode+other_char,mmode+char_given:
set_math_char(ho(math_code(cur_chr)));
mmode+char_num:begin scan_char_num;cur_chr:= cur_val;
set_math_char(ho(math_code(cur_chr)));
end;
mmode+math_char_num:begin scan_fifteen_bit_int;set_math_char(cur_val);
end;
mmode+math_given:set_math_char(cur_chr);
mmode+delim_num:begin scan_twenty_seven_bit_int;
set_math_char(cur_val div 49
end;

/*:1330*//*1334:*/
#line 30644 "pdftexdir/pdftex.web"

mmode+math_comp:begin tail_append(new_noad);
type(tail):= cur_chr;scan_math(nucleus(tail));
end;
mmode+limit_switch:math_limit_switch;

/*:1334*//*1338:*/
#line 30696 "pdftexdir/pdftex.web"

mmode+radical:math_radical;

/*:1338*//*1340:*/
#line 30709 "pdftexdir/pdftex.web"

mmode+accent,mmode+math_accent:math_ac;

/*:1340*//*1343:*/
#line 30738 "pdftexdir/pdftex.web"

mmode+vcenter:begin scan_spec(vcenter_group,false);normal_paragraph;
push_nest;mode:= -vmode;prev_depth:= pdf_ignored_dimen;
#line 4174 "pdftex-final.ch"
if(insert_src_special_every_vbox)then insert_src_special;
if every_vbox<> null then begin_token_list(every_vbox,every_vbox_text);
#line 30742 "pdftexdir/pdftex.web"
end;

/*:1343*//*1347:*/
#line 30766 "pdftexdir/pdftex.web"

mmode+math_style:tail_append(new_style(cur_chr));
mmode+non_script:begin tail_append(new_glue(zero_glue));
subtype(tail):= cond_math_glue;
end;
mmode+math_choice:append_choices;

/*:1347*//*1351:*/
#line 30806 "pdftexdir/pdftex.web"

mmode+sub_mark,mmode+sup_mark:sub_sup;

/*:1351*//*1356:*/
#line 30876 "pdftexdir/pdftex.web"

mmode+above:math_fraction;

/*:1356*//*1366:*/
#line 30992 "pdftexdir/pdftex.web"

mmode+left_right:math_left_right;

/*:1366*//*1369:*/
#line 31043 "pdftexdir/pdftex.web"

mmode+math_shift:if cur_group= math_shift_group then after_math
else off_save;

/*:1369*/
#line 28948 "pdftexdir/pdftex.web"

/*1386:*/
#line 31346 "pdftexdir/pdftex.web"

any_mode(toks_register),
any_mode(assign_toks),
any_mode(assign_int),
any_mode(assign_dimen),
any_mode(assign_glue),
any_mode(assign_mu_glue),
any_mode(assign_font_dimen),
any_mode(assign_font_int),
any_mode(set_aux),
any_mode(set_prev_graf),
any_mode(set_page_dimen),
any_mode(set_page_int),
any_mode(set_box_dimen),
any_mode(set_shape),
any_mode(def_code),
any_mode(def_family),
any_mode(set_font),
any_mode(def_font),
any_mode(letterspace_font),
any_mode(pdf_copy_font),
any_mode(register),
any_mode(advance),
any_mode(multiply),
any_mode(divide),
any_mode(prefix),
any_mode(let),
any_mode(shorthand_def),
any_mode(read_to_cs),
any_mode(def),
any_mode(set_box),
any_mode(hyph_data),
any_mode(set_interaction):prefixed_command;

/*:1386*//*1444:*/
#line 32245 "pdftexdir/pdftex.web"

any_mode(after_assignment):begin get_token;after_token:= cur_tok;
end;

/*:1444*//*1447:*/
#line 32266 "pdftexdir/pdftex.web"

any_mode(after_group):begin get_token;save_for_after(cur_tok);
end;

/*:1447*//*1450:*/
#line 32282 "pdftexdir/pdftex.web"

any_mode(in_stream):open_or_close_in;

/*:1450*//*1452:*/
#line 32304 "pdftexdir/pdftex.web"

any_mode(message):issue_message;

/*:1452*//*1461:*/
#line 32371 "pdftexdir/pdftex.web"

any_mode(case_shift):shift_case;

/*:1461*//*1466:*/
#line 32413 "pdftexdir/pdftex.web"

any_mode(xray):show_whatever;

/*:1466*/
#line 28949 "pdftexdir/pdftex.web"

/*1525:*/
#line 33734 "pdftexdir/pdftex.web"

any_mode(extension):do_extension;

/*:1525*/
#line 28950 "pdftexdir/pdftex.web"


/*:1221*/
#line 28566 "pdftexdir/pdftex.web"

end;{of the big|case|statement}
goto big_switch;
main_loop:/*1209:*/
#line 4097 "pdftex-final.ch"

if((head= tail)and(mode> 0))then begin
if(insert_src_special_auto)then append_src_special;
end;
#line 28644 "pdftexdir/pdftex.web"
adjust_space_factor;
save_tail:= null;
main_f:= cur_font;
bchar:= font_bchar[main_f];false_bchar:= font_false_bchar[main_f];
if mode> 0 then if language<> clang then fix_language;
fast_get_avail(lig_stack);font(lig_stack):= main_f;cur_l:= qi(cur_chr);
character(lig_stack):= cur_l;
cur_q:= tail;
tmp_k1:= get_auto_kern(main_f,non_char,cur_l);
/*1215:*/
#line 28799 "pdftexdir/pdftex.web"

if tmp_k1<> null then begin
wrapup(rt_hit);
save_tail:= tail;
tail_append(tmp_k1);
goto main_loop_move;
end

/*:1215*/
#line 28653 "pdftexdir/pdftex.web"
;
if cancel_boundary then
begin cancel_boundary:= false;main_k:= non_address;
end
else main_k:= bchar_label[main_f];
if main_k= non_address then goto main_loop_move+2;{no left boundary processing}
cur_r:= cur_l;cur_l:= non_char;
goto main_lig_loop+1;{begin with cursor after left boundary}

main_loop_wrapup:/*1210:*/
#line 28716 "pdftexdir/pdftex.web"

wrapup(rt_hit)

/*:1210*/
#line 28663 "pdftexdir/pdftex.web"
;
main_loop_move:/*1211:*/
#line 28719 "pdftexdir/pdftex.web"


if lig_stack= null then goto reswitch;
cur_q:= tail;cur_l:= character(lig_stack);
main_loop_move+1:if not is_char_node(lig_stack)then goto main_loop_move_lig;
#line 4106 "pdftex-final.ch"
main_loop_move+2:
if(qo(effective_char(false,main_f,qi(cur_chr)))> font_ec[main_f])or
(qo(effective_char(false,main_f,qi(cur_chr)))<font_bc[main_f])then
#line 28725 "pdftexdir/pdftex.web"
 begin char_warning(main_f,cur_chr);free_avail(lig_stack);goto big_switch;
end;
#line 4114 "pdftex-final.ch"
main_i:= effective_char_info(main_f,cur_l);
#line 28728 "pdftexdir/pdftex.web"
if not char_exists(main_i)then
begin char_warning(main_f,cur_chr);free_avail(lig_stack);goto big_switch;
end;
link(tail):= lig_stack;tail:= lig_stack{|main_loop_lookahead|is next}

/*:1211*/
#line 28666 "pdftexdir/pdftex.web"
;
main_loop_lookahead:/*1213:*/
#line 28751 "pdftexdir/pdftex.web"

get_next;{set only|cur_cmd|and|cur_chr|,for speed}
if cur_cmd= letter then goto main_loop_lookahead+1;
if cur_cmd= other_char then goto main_loop_lookahead+1;
if cur_cmd= char_given then goto main_loop_lookahead+1;
x_token;{now expand and set|cur_cmd|,|cur_chr|,|cur_tok|}
if cur_cmd= letter then goto main_loop_lookahead+1;
if cur_cmd= other_char then goto main_loop_lookahead+1;
if cur_cmd= char_given then goto main_loop_lookahead+1;
if cur_cmd= char_num then
begin scan_char_num;cur_chr:= cur_val;goto main_loop_lookahead+1;
end;
if cur_cmd= no_boundary then bchar:= non_char;
cur_r:= bchar;lig_stack:= null;goto main_lig_loop;
main_loop_lookahead+1:adjust_space_factor;
fast_get_avail(lig_stack);font(lig_stack):= main_f;
cur_r:= qi(cur_chr);character(lig_stack):= cur_r;
if cur_r= false_bchar then cur_r:= non_char{this prevents spurious ligatures}

/*:1213*/
#line 28668 "pdftexdir/pdftex.web"
;
main_lig_loop:/*1214:*/
#line 28780 "pdftexdir/pdftex.web"

tmp_k1:= get_auto_kern(main_f,cur_l,cur_r);
/*1215:*/
#line 28799 "pdftexdir/pdftex.web"

if tmp_k1<> null then begin
wrapup(rt_hit);
save_tail:= tail;
tail_append(tmp_k1);
goto main_loop_move;
end

/*:1215*/
#line 28782 "pdftexdir/pdftex.web"
;
if char_tag(main_i)<> lig_tag then goto main_loop_wrapup;
if cur_r= non_char then goto main_loop_wrapup;
main_k:= lig_kern_start(main_f)(main_i);main_j:= font_info[main_k].qqqq;
if skip_byte(main_j)<=stop_flag then goto main_lig_loop+2;
main_k:= lig_kern_restart(main_f)(main_j);
main_lig_loop+1:main_j:= font_info[main_k].qqqq;
main_lig_loop+2:if next_char(main_j)= cur_r then
if skip_byte(main_j)<=stop_flag then
/*1216:*/
#line 28816 "pdftexdir/pdftex.web"

begin if op_byte(main_j)>=kern_flag then
begin wrapup(rt_hit);
tail_append(new_kern(char_kern(main_f)(main_j)));goto main_loop_move;
end;
if cur_l= non_char then lft_hit:= true
else if lig_stack= null then rt_hit:= true;
check_interrupt;{allow a way out in case there's an infinite ligature loop}
case op_byte(main_j)of
qi(1),qi(5):begin cur_l:= rem_byte(main_j);{\.{= :\?},\.{= :\?> }}
main_i:= char_info(main_f)(cur_l);ligature_present:= true;
end;
qi(2),qi(6):begin cur_r:= rem_byte(main_j);{\.{\?= :},\.{\?= :> }}
if lig_stack= null then{right boundary character is being consumed}
begin lig_stack:= new_lig_item(cur_r);bchar:= non_char;
end
else if is_char_node(lig_stack)then{|link(lig_stack)= null|}
begin main_p:= lig_stack;lig_stack:= new_lig_item(cur_r);
lig_ptr(lig_stack):= main_p;
end
else character(lig_stack):= cur_r;
end;
qi(3):begin cur_r:= rem_byte(main_j);{\.{\?= :\?}}
main_p:= lig_stack;lig_stack:= new_lig_item(cur_r);
link(lig_stack):= main_p;
end;
qi(7),qi(11):begin wrapup(false);{\.{\?= :\?> },\.{\?= :\?>>}}
cur_q:= tail;cur_l:= rem_byte(main_j);
main_i:= char_info(main_f)(cur_l);ligature_present:= true;
end;
othercases begin cur_l:= rem_byte(main_j);ligature_present:= true;{\.{= :}}
if lig_stack= null then goto main_loop_wrapup
else goto main_loop_move+1;
end
endcases;
if op_byte(main_j)> qi(4)then
if op_byte(main_j)<> qi(7)then goto main_loop_wrapup;
if cur_l<non_char then goto main_lig_loop;
main_k:= bchar_label[main_f];goto main_lig_loop+1;
end

/*:1216*/
#line 28792 "pdftexdir/pdftex.web"
;
if skip_byte(main_j)= qi(0)then incr(main_k)
else begin if skip_byte(main_j)>=stop_flag then goto main_loop_wrapup;
main_k:= main_k+qo(skip_byte(main_j))+1;
end;
goto main_lig_loop+1

/*:1214*/
#line 28670 "pdftexdir/pdftex.web"
;
main_loop_move_lig:/*1212:*/
#line 4120 "pdftex-final.ch"

#line 28737 "pdftexdir/pdftex.web"
main_p:= lig_ptr(lig_stack);
if main_p> null then tail_append(main_p);{append a single character}
temp_ptr:= lig_stack;lig_stack:= link(temp_ptr);
#line 4126 "pdftex-final.ch"
free_node(temp_ptr,small_node_size);{{\sl Sync\TeX}watch point:proper size!}
#line 28741 "pdftexdir/pdftex.web"
main_i:= char_info(main_f)(cur_l);ligature_present:= true;
if lig_stack= null then
if main_p> null then goto main_loop_lookahead
else cur_r:= bchar
else cur_r:= character(lig_stack);
goto main_lig_loop

/*:1212*/
#line 28672 "pdftexdir/pdftex.web"


/*:1209*/
#line 28571 "pdftexdir/pdftex.web"
;
append_normal_space:/*1217:*/
#line 28868 "pdftexdir/pdftex.web"

if space_skip= zero_glue then
begin/*1218:*/
#line 28885 "pdftexdir/pdftex.web"

begin main_p:= font_glue[cur_font];
if main_p= null then
begin main_p:= new_spec(zero_glue);main_k:= param_base[cur_font]+space_code;
width(main_p):= font_info[main_k].sc;{that's |space(cur_font)|}
stretch(main_p):= font_info[main_k+1].sc;{and|space_stretch(cur_font)|}
shrink(main_p):= font_info[main_k+2].sc;{and|space_shrink(cur_font)|}
font_glue[cur_font]:= main_p;
end;
end

/*:1218*/
#line 28871 "pdftexdir/pdftex.web"
;
temp_ptr:= new_glue(main_p);
end
else temp_ptr:= new_param_glue(space_skip_code);
if pdf_adjust_interword_glue> 0 then
adjust_interword_glue(tail,temp_ptr);
link(tail):= temp_ptr;tail:= temp_ptr;
goto big_switch

/*:1217*/
#line 28573 "pdftexdir/pdftex.web"
;
exit:end;

/*:1205*//*1460:*/
#line 32364 "pdftexdir/pdftex.web"
procedure give_err_help;
begin token_show(err_help);
end;

/*:1460*//*1479:*/
#line 32579 "pdftexdir/pdftex.web"
/*550:*/
#line 12273 "pdftexdir/pdftex.web"

function open_fmt_file:boolean;
label found,exit;
var j:0..buf_size;{the first space after the format file name}
begin j:= loc;
if buffer[loc]= "&"then
begin incr(loc);j:= loc;buffer[last]:= " ";
while buffer[j]<> " "do incr(j);
#line 2397 "pdftex-final.ch"
pack_buffered_name(0,loc,j-1);{Kpathsea does everything}
if w_open_in(fmt_file)then goto found;
#line 12286 "pdftexdir/pdftex.web"
wake_up_terminal;
#line 2404 "pdftex-final.ch"
wterm('Sorry, I can''t find the format `');
fputs(stringcast(name_of_file+1),stdout);
wterm('''; will try `');
fputs(TEX_format_default+1,stdout);
wterm_ln('''.');
#line 12288 "pdftexdir/pdftex.web"

update_terminal;
end;
{now pull out all the stops:try for the system\.{plain}file}
pack_buffered_name(format_default_length-format_ext_length,1,0);
if not w_open_in(fmt_file)then
begin wake_up_terminal;
#line 2415 "pdftex-final.ch"
wterm('I can''t find the format file `');
fputs(TEX_format_default+1,stdout);
wterm_ln('''!');

#line 12297 "pdftexdir/pdftex.web"

open_fmt_file:= false;return;
end;
found:loc:= j;open_fmt_file:= true;
exit:end;

/*:550*/
#line 32579 "pdftexdir/pdftex.web"

function load_fmt_file:boolean;
label bad_fmt,exit;
var j,k:integer;{all-purpose indices}
p,q:pointer;{all-purpose pointers}
x:integer;{something undumped}
#line 4518 "pdftex-final.ch"
format_engine:^text_char;
dummy_xord:ASCII_code;
dummy_xchr:text_char;
dummy_xprn:ASCII_code;
#line 4527 "pdftex-final.ch"
begin/*1484:*/
#line 32658 "pdftexdir/pdftex.web"

#line 4590 "pdftex-final.ch"
 Init
libc_free(font_info);libc_free(str_pool);libc_free(str_start);
libc_free(yhash);libc_free(zeqtb);libc_free(yzmem);
Tini
undump_int(x);
format_debug('format magic number')(x);
if x<> 57325458 then goto bad_fmt;{not a format file}
undump_int(x);
format_debug('engine name size')(x);
if(x<0)or(x> 256)then goto bad_fmt;{corrupted format file}
format_engine:= xmalloc_array(text_char,x);
undump_things(format_engine[0],x);
format_engine[x-1]:= 0;{force string termination,just in case}
if strcmp(engine_name,stringcast(format_engine))then
begin wake_up_terminal;
wterm_ln('---! ',stringcast(name_of_file+1),' was written by ',format_engine);
libc_free(format_engine);
goto bad_fmt;
end;
libc_free(format_engine);
undump_int(x);
format_debug('string pool checksum')(x);
if x<> then begin{check that strings are the same}
wake_up_terminal;
wterm_ln('---! ',stringcast(name_of_file+1),
' made by different executable version');
goto bad_fmt;
end;
/*1872:*/
#line 6113 "pdftex-final.ch"

if translate_filename then begin
for k:= 0 to 255 do undump_things(dummy_xord,1);
for k:= 0 to 255 do undump_things(dummy_xchr,1);
for k:= 0 to 255 do undump_things(dummy_xprn,1);
end
else begin
undump_things(xord[0],256);
undump_things(xchr[0],256);
undump_things(xprn[0],256);
if eight_bit_p then
for k:= 0 to 255 do
xprn[k]:= 1;
end;


/*:1872*/
#line 4618 "pdftex-final.ch"
;
undump_int(x);
if x<> max_halfword then goto bad_fmt;{check|max_halfword|}
undump_int(hash_high);
if(hash_high<0)or(hash_high> sup_hash_extra)then goto bad_fmt;
if hash_extra<hash_high then hash_extra:= hash_high;
eqtb_top:= eqtb_size+hash_extra;
if hash_extra= 0 then hash_top:= undefined_control_sequence else
hash_top:= eqtb_top;
yhash:= xmalloc_array(two_halves,1+hash_top-hash_offset);
hash:= yhash-hash_offset;
next(hash_base):= 0;text(hash_base):= 0;
for x:= hash_base+1 to hash_top do hash[x]:= hash[hash_base];
zeqtb:= xmalloc_array(memory_word,eqtb_top+1);
eqtb:= zeqtb;

eq_type(undefined_control_sequence):= undefined_cs;
equiv(undefined_control_sequence):= null;
eq_level(undefined_control_sequence):= level_zero;
for x:= eqtb_size+1 to eqtb_top do
eqtb[x]:= eqtb[undefined_control_sequence];
#line 32661 "pdftexdir/pdftex.web"
/*1652:*/
#line 36863 "pdftexdir/pdftex.web"

undump(0)(1)(eTeX_mode);
if eTeX_ex then
begin/*1810:*/
#line 39055 "pdftexdir/pdftex.web"

max_reg_num:= 32767;
max_reg_help_line:= "A register number must be between 0 and 32767.";

/*:1810*/
#line 36866 "pdftexdir/pdftex.web"

end
else begin/*1809:*/
#line 39051 "pdftexdir/pdftex.web"

max_reg_num:= 255;
max_reg_help_line:= "A register number must be between 0 and 255.";

/*:1809*/
#line 36868 "pdftexdir/pdftex.web"

end;

/*:1652*/
#line 32661 "pdftexdir/pdftex.web"

#line 4647 "pdftex-final.ch"
undump_int(x);format_debug('mem_bot')(x);
if x<> mem_bot then goto bad_fmt;
undump_int(mem_top);format_debug('mem_top')(mem_top);
if mem_bot+1100> mem_top then goto bad_fmt;


head:= contrib_head;tail:= contrib_head;
page_tail:= page_head;{page initialization}

mem_min:= mem_bot-extra_mem_bot;
mem_max:= mem_top+extra_mem_top;

yzmem:= xmalloc_array(memory_word,mem_max-mem_min+1);
zmem:= yzmem-mem_min;{this pointer arithmetic fails with some compilers}
mem:= zmem;
#line 32666 "pdftexdir/pdftex.web"
undump_int(x);
if x<> eqtb_size then goto bad_fmt;
undump_int(x);
if x<> hash_prime then goto bad_fmt;
undump_int(x);
#line 4667 "pdftex-final.ch"
if x<> hyph_prime then goto bad_fmt
#line 32672 "pdftexdir/pdftex.web"

/*:1484*/
#line 4527 "pdftex-final.ch"
;
/*1891:*/
#line 6555 "pdftex-final.ch"

undump_int(x);{check magic constant of ML\TeX}
if x<> 4 D4C5458 then goto bad_fmt;
undump_int(x);{undump|mltex_p|flag into|mltex_enabled_p|}
if x= 1 then mltex_enabled_p:= true
else if x<> 0 then goto bad_fmt;
#line 6566 "pdftex-final.ch"

/*:1891*/
#line 4528 "pdftex-final.ch"
;
/*1900:*/
#line 6852 "pdftex-final.ch"

undump_int(x);{check magic constant of enc\TeX}
if x<> 45435458 then goto bad_fmt;
undump_int(x);{undump|enctex_p|flag into|enctex_enabled_p|}
if x= 0 then enctex_enabled_p:= false
else if x<> 1 then goto bad_fmt
else begin
enctex_enabled_p:= true;
undump_things(mubyte_read[0],256);
undump_things(mubyte_write[0],256);
undump_things(mubyte_cswrite[0],128);
end;


/*:1900*/
#line 4529 "pdftex-final.ch"
;
#line 32587 "pdftexdir/pdftex.web"
/*1486:*/
#line 32695 "pdftexdir/pdftex.web"

#line 4692 "pdftex-final.ch"
undump_size(0)(sup_pool_size-pool_free)('string pool size')(pool_ptr);
if pool_size<pool_ptr+pool_free then
pool_size:= pool_ptr+pool_free;
undump_size(0)(sup_max_strings-strings_free)('sup strings')(str_ptr);
if max_strings<str_ptr+strings_free then
max_strings:= str_ptr+strings_free;
str_start:= xmalloc_array(pool_pointer,max_strings);
undump_checked_things(0,pool_ptr,str_start[0],str_ptr+1);
str_pool:= xmalloc_array(packed_ASCII_code,pool_size);
undump_things(str_pool[0],pool_ptr);
#line 32704 "pdftexdir/pdftex.web"
init_str_ptr:= str_ptr;init_pool_ptr:= pool_ptr

/*:1486*/
#line 32587 "pdftexdir/pdftex.web"
;
/*1488:*/
#line 32737 "pdftexdir/pdftex.web"

undump(lo_mem_stat_max+1000)(hi_mem_stat_min-1)(lo_mem_max);
undump(lo_mem_stat_max+1)(lo_mem_max)(rover);
if eTeX_ex then for k:= int_val to tok_val do
undump(null)(lo_mem_max)(sa_root[k]);
p:= mem_bot;q:= rover;
#line 4725 "pdftex-final.ch"
repeat undump_things(mem[p],q+2-p);
#line 32744 "pdftexdir/pdftex.web"
p:= q+node_size(q);
if(p> lo_mem_max)or((q>=rlink(q))and(rlink(q)<> rover))then goto bad_fmt;
q:= rlink(q);
until q= rover;
#line 4731 "pdftex-final.ch"
undump_things(mem[p],lo_mem_max+1-p);
#line 32749 "pdftexdir/pdftex.web"
if mem_min<mem_bot-2 then{make more low memory available}
begin p:= llink(rover);q:= mem_min+1;
link(mem_min):= null;info(mem_min):= null;{we don't use the bottom word}
rlink(p):= q;llink(rover):= q;
rlink(q):= rover;llink(q):= p;link(q):= empty_flag;
node_size(q):= mem_bot-q;
end;
undump(lo_mem_max+1)(hi_mem_stat_min)(hi_mem_min);
undump(null)(mem_top)(avail);mem_end:= mem_top;
#line 4737 "pdftex-final.ch"
undump_things(mem[hi_mem_min],mem_end+1-hi_mem_min);
#line 32759 "pdftexdir/pdftex.web"
undump_int(var_used);undump_int(dyn_used)

/*:1488*/
#line 32588 "pdftexdir/pdftex.web"
;
/*1490:*/
#line 32767 "pdftexdir/pdftex.web"

/*1493:*/
#line 32820 "pdftexdir/pdftex.web"

k:= active_base;
repeat undump_int(x);
if(x<1)or(k+x> eqtb_size+1)then goto bad_fmt;
#line 4779 "pdftex-final.ch"
undump_things(eqtb[k],x);
#line 32825 "pdftexdir/pdftex.web"
k:= k+x;
undump_int(x);
if(x<0)or(k+x> eqtb_size+1)then goto bad_fmt;
for j:= k to k+x-1 do eqtb[j]:= eqtb[k-1];
k:= k+x;
#line 4785 "pdftex-final.ch"
until k> eqtb_size;
if hash_high> 0 then undump_things(eqtb[eqtb_size+1],hash_high);
{undump|hash_extra|part}
#line 32831 "pdftexdir/pdftex.web"

/*:1493*/
#line 32768 "pdftexdir/pdftex.web"
;
#line 4745 "pdftex-final.ch"
undump(hash_base)(hash_top)(par_loc);
par_token:= cs_token_flag+par_loc;
undump(hash_base)(hash_top)(write_loc);
#line 32772 "pdftexdir/pdftex.web"
/*1495:*/
#line 32847 "pdftexdir/pdftex.web"

for p:= 0 to prim_size do undump_hh(prim[p]);
undump(hash_base)(frozen_control_sequence)(hash_used);p:= hash_base-1;
repeat undump(p+1)(hash_used)(p);undump_hh(hash[p]);
until p= hash_used;
#line 4806 "pdftex-final.ch"
undump_things(hash[hash_used+1],undefined_control_sequence-1-hash_used);
if debug_format_file then begin
print_csnames(hash_base,undefined_control_sequence-1);
end;
if hash_high> 0 then begin
undump_things(hash[eqtb_size+1],hash_high);
if debug_format_file then begin
print_csnames(eqtb_size+1,hash_high-(eqtb_size+1));
end;
end;
#line 32853 "pdftexdir/pdftex.web"
undump_int(cs_count)

/*:1495*/
#line 32772 "pdftexdir/pdftex.web"


/*:1490*/
#line 32589 "pdftexdir/pdftex.web"
;
/*1497:*/
#line 32865 "pdftexdir/pdftex.web"

#line 4845 "pdftex-final.ch"
undump_size(7)(sup_font_mem_size)('font mem size')(fmem_ptr);
if fmem_ptr> font_mem_size then font_mem_size:= fmem_ptr;
font_info:= xmalloc_array(fmemory_word,font_mem_size);
undump_things(font_info[0],fmem_ptr);
undump_size(font_base)(font_base+max_font_max)('font max')(font_ptr);
{This undumps all of the font info,despite the name.}
/*1499:*/
#line 4950 "pdftex-final.ch"

begin{Allocate the font arrays}
font_check:= xmalloc_array(four_quarters,font_max);
font_size:= xmalloc_array(scaled,font_max);
font_dsize:= xmalloc_array(scaled,font_max);
font_params:= xmalloc_array(font_index,font_max);
font_name:= xmalloc_array(str_number,font_max);
font_area:= xmalloc_array(str_number,font_max);
font_bc:= xmalloc_array(eight_bits,font_max);
font_ec:= xmalloc_array(eight_bits,font_max);
font_glue:= xmalloc_array(halfword,font_max);
hyphen_char:= xmalloc_array(integer,font_max);
skew_char:= xmalloc_array(integer,font_max);
bchar_label:= xmalloc_array(font_index,font_max);
font_bchar:= xmalloc_array(nine_bits,font_max);
font_false_bchar:= xmalloc_array(nine_bits,font_max);
char_base:= xmalloc_array(integer,font_max);
width_base:= xmalloc_array(integer,font_max);
height_base:= xmalloc_array(integer,font_max);
depth_base:= xmalloc_array(integer,font_max);
italic_base:= xmalloc_array(integer,font_max);
lig_kern_base:= xmalloc_array(integer,font_max);
kern_base:= xmalloc_array(integer,font_max);
exten_base:= xmalloc_array(integer,font_max);
param_base:= xmalloc_array(integer,font_max);

pdf_char_used:= xmalloc_array(char_used_array,font_max);
pdf_font_size:= xmalloc_array(scaled,font_max);
pdf_font_num:= xmalloc_array(integer,font_max);
pdf_font_map:= xmalloc_array(fm_entry_ptr,font_max);
pdf_font_type:= xmalloc_array(eight_bits,font_max);
pdf_font_attr:= xmalloc_array(str_number,font_max);
pdf_font_blink:= xmalloc_array(internal_font_number,font_max);
pdf_font_elink:= xmalloc_array(internal_font_number,font_max);
pdf_font_stretch:= xmalloc_array(integer,font_max);
pdf_font_shrink:= xmalloc_array(integer,font_max);
pdf_font_step:= xmalloc_array(integer,font_max);
pdf_font_expand_ratio:= xmalloc_array(integer,font_max);
pdf_font_auto_expand:= xmalloc_array(boolean,font_max);
pdf_font_lp_base:= xmalloc_array(integer,font_max);
pdf_font_rp_base:= xmalloc_array(integer,font_max);
pdf_font_ef_base:= xmalloc_array(integer,font_max);
pdf_font_kn_bs_base:= xmalloc_array(integer,font_max);
pdf_font_st_bs_base:= xmalloc_array(integer,font_max);
pdf_font_sh_bs_base:= xmalloc_array(integer,font_max);
pdf_font_kn_bc_base:= xmalloc_array(integer,font_max);
pdf_font_kn_ac_base:= xmalloc_array(integer,font_max);
vf_packet_base:= xmalloc_array(integer,font_max);
vf_default_font:= xmalloc_array(internal_font_number,font_max);
vf_local_font_num:= xmalloc_array(internal_font_number,font_max);
vf_e_fnts:= xmalloc_array(integer,font_max);
vf_i_fnts:= xmalloc_array(internal_font_number,font_max);
pdf_font_nobuiltin_tounicode:= xmalloc_array(boolean,font_max);

for font_k:= font_base to font_max do begin
for k:= 0 to 31 do
pdf_char_used[font_k,k]:= 0;
pdf_font_size[font_k]:= 0;
pdf_font_num[font_k]:= 0;
pdf_font_map[font_k]:= 0;
pdf_font_type[font_k]:= new_font_type;
pdf_font_attr[font_k]:= "";
pdf_font_blink[font_k]:= null_font;
pdf_font_elink[font_k]:= null_font;
pdf_font_stretch[font_k]:= null_font;
pdf_font_shrink[font_k]:= null_font;
pdf_font_step[font_k]:= 0;
pdf_font_expand_ratio[font_k]:= 0;
pdf_font_auto_expand[font_k]:= false;
pdf_font_lp_base[font_k]:= 0;
pdf_font_rp_base[font_k]:= 0;
pdf_font_ef_base[font_k]:= 0;
pdf_font_kn_bs_base[font_k]:= 0;
pdf_font_st_bs_base[font_k]:= 0;
pdf_font_sh_bs_base[font_k]:= 0;
pdf_font_kn_bc_base[font_k]:= 0;
pdf_font_kn_ac_base[font_k]:= 0;
pdf_font_nobuiltin_tounicode[font_k]:= false;
end;

make_pdftex_banner;
undump_things(font_check[null_font],font_ptr+1-null_font);
undump_things(font_size[null_font],font_ptr+1-null_font);
undump_things(font_dsize[null_font],font_ptr+1-null_font);
undump_checked_things(min_halfword,max_halfword,
font_params[null_font],font_ptr+1-null_font);
undump_things(hyphen_char[null_font],font_ptr+1-null_font);
undump_things(skew_char[null_font],font_ptr+1-null_font);
undump_upper_check_things(str_ptr,font_name[null_font],font_ptr+1-null_font);
undump_upper_check_things(str_ptr,font_area[null_font],font_ptr+1-null_font);
{There's no point in checking these values against the range $[0,255]$,
since the data type is|unsigned char|,and all values of that type are
in that range by definition.}
undump_things(font_bc[null_font],font_ptr+1-null_font);
undump_things(font_ec[null_font],font_ptr+1-null_font);
undump_things(char_base[null_font],font_ptr+1-null_font);
undump_things(width_base[null_font],font_ptr+1-null_font);
undump_things(height_base[null_font],font_ptr+1-null_font);
undump_things(depth_base[null_font],font_ptr+1-null_font);
undump_things(italic_base[null_font],font_ptr+1-null_font);
undump_things(lig_kern_base[null_font],font_ptr+1-null_font);
undump_things(kern_base[null_font],font_ptr+1-null_font);
undump_things(exten_base[null_font],font_ptr+1-null_font);
undump_things(param_base[null_font],font_ptr+1-null_font);
undump_checked_things(min_halfword,lo_mem_max,
font_glue[null_font],font_ptr+1-null_font);
undump_checked_things(0,fmem_ptr-1,
bchar_label[null_font],font_ptr+1-null_font);
undump_checked_things(min_quarterword,non_char,
font_bchar[null_font],font_ptr+1-null_font);
undump_checked_things(min_quarterword,non_char,
font_false_bchar[null_font],font_ptr+1-null_font);
end
#line 32928 "pdftexdir/pdftex.web"

/*:1499*/
#line 4851 "pdftex-final.ch"
;
#line 32871 "pdftexdir/pdftex.web"

#line 4886 "pdftex-final.ch"
/*:1497*/
#line 32590 "pdftexdir/pdftex.web"
;
/*1501:*/
#line 32959 "pdftexdir/pdftex.web"

#line 5127 "pdftex-final.ch"
undump_size(0)(hyph_size)('hyph_size')(hyph_count);
undump_size(hyph_prime)(hyph_size)('hyph_size')(hyph_next);
j:= 0;
for k:= 1 to hyph_count do
begin undump_int(j);if j<0 then goto bad_fmt;
if j> 65535 then
begin hyph_next:= j div 65536;j:= j-hyph_next*65536;end
else hyph_next:= 0;
if(j>=hyph_size)or(hyph_next> hyph_size)then goto bad_fmt;
hyph_link[j]:= hyph_next;
undump(0)(str_ptr)(hyph_word[j]);
undump(min_halfword)(max_halfword)(hyph_list[j]);
end;
{|j|is now the largest occupied location in|hyph_word|}
incr(j);
if j<hyph_prime then j:= hyph_prime;
hyph_next:= j;
if hyph_next>=hyph_size then hyph_next:= hyph_prime else
if hyph_next>=hyph_prime then incr(hyph_next);
#line 32966 "pdftexdir/pdftex.web"
undump_size(0)(trie_size)('trie size')(j);init trie_max:= j;tini
undump(0)(j)(hyph_start);
#line 5151 "pdftex-final.ch"
{These first three haven't been allocated yet unless we're\.{INITEX};
we do that precisely so we don't allocate more space than necessary.}
if not trie_trl then trie_trl:= xmalloc_array(trie_pointer,j+1);
undump_things(trie_trl[0],j+1);
if not trie_tro then trie_tro:= xmalloc_array(trie_pointer,j+1);
undump_things(trie_tro[0],j+1);
if not trie_trc then trie_trc:= xmalloc_array(quarterword,j+1);
undump_things(trie_trc[0],j+1);
#line 32969 "pdftexdir/pdftex.web"
undump_size(0)(trie_op_size)('trie op size')(j);init trie_op_ptr:= j;tini
#line 5168 "pdftex-final.ch"
{I'm not sure we have such a strict limitation (64) on these values, so
let's leave them unchecked.}
undump_things(hyf_distance[1],j);
undump_things(hyf_num[1],j);
undump_upper_check_things(max_trie_op,hyf_next[1],j);
#line 32975 "pdftexdir/pdftex.web"
init for k:= 0 to 255 do trie_used[k]:= min_quarterword;tini
k:= 256;
while j> 0 do
begin undump(0)(k-1)(k);undump(1)(j)(x);init trie_used[k]:= qi(x);tini
j:= j-x;op_start[k]:= qo(j);
end;
init trie_not_ready:= false tini

/*:1501*/
#line 32591 "pdftexdir/pdftex.web"
;
/*1503:*/
#line 33025 "pdftexdir/pdftex.web"

begin
undumpimagemeta(pdf_major_version,pdf_minor_version,pdf_inclusion_errorlevel);{the image information array}
undump_int(pdf_mem_size);
pdf_mem:= xrealloc_array(pdf_mem,integer,pdf_mem_size);
undump_int(pdf_mem_ptr);
for k:= 1 to pdf_mem_ptr-1 do begin
undump_int(pdf_mem[k]);
end;
undump_int(obj_tab_size);
undump_int(obj_ptr);
undump_int(sys_obj_ptr);
for k:= 1 to sys_obj_ptr do begin
undump_int(obj_tab[k].int0);
undump_int(obj_tab[k].int1);
obj_tab[k].int2:= -1;
undump_int(obj_tab[k].int3);
undump_int(obj_tab[k].int4);
end;
undump_int(pdf_obj_count);
undump_int(pdf_xform_count);
undump_int(pdf_ximage_count);
undump_int(head_tab[obj_type_obj]);
undump_int(head_tab[obj_type_xform]);
undump_int(head_tab[obj_type_ximage]);
undump_int(pdf_last_obj);
undump_int(pdf_last_xform);
undump_int(pdf_last_ximage);
end

/*:1503*/
#line 32592 "pdftexdir/pdftex.web"
;
/*1505:*/
#line 33062 "pdftexdir/pdftex.web"

#line 5178 "pdftex-final.ch"
undump(batch_mode)(error_stop_mode)(interaction);
if interaction_option<> unspecified_mode then interaction:= interaction_option;
#line 33064 "pdftexdir/pdftex.web"
undump(0)(str_ptr)(format_ident);
undump_int(x);
#line 5185 "pdftex-final.ch"
if x<> 69069 then goto bad_fmt
#line 33067 "pdftexdir/pdftex.web"

/*:1505*/
#line 32593 "pdftexdir/pdftex.web"
;
prev_depth:= pdf_ignored_dimen;
load_fmt_file:= true;return;{it worked!}
bad_fmt:wake_up_terminal;
wterm_ln('(Fatal format file error; I''m stymied)');

load_fmt_file:= false;
exit:end;

/*:1479*//*1508:*/
#line 33095 "pdftexdir/pdftex.web"
/*1511:*/
#line 33189 "pdftexdir/pdftex.web"

#line 5349 "pdftex-final.ch"
procedure close_files_and_terminate;
#line 33191 "pdftexdir/pdftex.web"
label done,done1;
var a,b,c,i,j,k,l:integer;{all-purpose index}
is_root:boolean;{|pdf_last_pages|is root of Pages tree?}
is_names:boolean;{flag for name tree output:is it Names or Kids?}
root,outlines,threads,names_tree,dests:integer;
xref_offset_width,names_head,names_tail:integer;
begin/*1623:*/
#line 35919 "pdftexdir/pdftex.web"

for k:= 0 to 15 do if write_open[k]then a_close(write_file[k])

/*:1623*/
#line 33197 "pdftexdir/pdftex.web"
;
stat if tracing_stats> 0 then/*1512:*/
#line 33245 "pdftexdir/pdftex.web"

if log_opened then
begin wlog_ln(' ');
wlog_ln('Here is how much of TeX''s memory',' you used:');

wlog(' ',str_ptr-init_str_ptr:1,' string');
if str_ptr<> init_str_ptr+1 then wlog('s');
wlog_ln(' out of ',max_strings-init_str_ptr:1);
wlog_ln(' ',pool_ptr-init_pool_ptr:1,' string characters out of ',
pool_size-init_pool_ptr:1);
wlog_ln(' ',lo_mem_max-mem_min+mem_end-hi_mem_min+2:1,
' words of memory out of ',mem_end+1-mem_min:1);
#line 5383 "pdftex-final.ch"
wlog_ln(' ',cs_count:1,' multiletter control sequences out of ',
hash_size:1,'+',hash_extra:1);
#line 33259 "pdftexdir/pdftex.web"
wlog(' ',fmem_ptr:1,' words of font info for ',
font_ptr-font_base:1,' font');
if font_ptr<> font_base+1 then wlog('s');
wlog_ln(', out of ',font_mem_size:1,' for ',font_max-font_base:1);
wlog(' ',hyph_count:1,' hyphenation exception');
if hyph_count<> 1 then wlog('s');
wlog_ln(' out of ',hyph_size:1);
wlog_ln(' ',max_in_stack:1,'i,',max_nest_stack:1,'n,',
max_param_stack:1,'p,',
max_buf_stack+1:1,'b,',
max_save_stack+6:1,'s stack positions out of ',
stack_size:1,'i,',
nest_size:1,'n,',
param_size:1,'p,',
buf_size:1,'b,',
save_size:1,'s');
end

/*:1512*/
#line 33198 "pdftexdir/pdftex.web"
;tats
wake_up_terminal;
if not fixed_pdfoutput_set then
fix_pdfoutput;
if fixed_pdfoutput> 0 then begin
if history= fatal_error_stop then begin
#line 5355 "pdftex-final.ch"
 remove_pdffile;
synctex_abort(log_opened);
#line 33205 "pdftexdir/pdftex.web"
print_err(" ==> Fatal error occurred, no output PDF file produced!")
end
else begin
/*794:*/
#line 19797 "pdftexdir/pdftex.web"

if total_pages= 0 then begin
print_nl("No pages of output.");

if pdf_gone> 0 then
garbage_warning;
end
else begin
if fixed_pdf_draftmode= 0 then begin
pdf_flush;{to make sure that the output file name has been already
created}
if total_pages mod pages_tree_kids_max<> 0 then
obj_info(pdf_last_pages):= total_pages mod pages_tree_kids_max;
{last pages object may have less than|pages_tree_kids_max|children}
flush_jbig2_page0_objects;{flush page 0 objects from JBIG2 images,if any}
/*797:*/
#line 19879 "pdftexdir/pdftex.web"

k:= head_tab[obj_type_page];
while obj_aux(k)= 0 do begin
pdf_warning("dest","Page ",false,false);
print_int(obj_info(k));
print(" has been referenced but does not exist!");
print_ln;print_ln;
k:= obj_link(k);
end;
head_tab[obj_type_page]:= k

/*:797*/
#line 19812 "pdftexdir/pdftex.web"
;
/*798:*/
#line 19890 "pdftexdir/pdftex.web"

k:= head_tab[obj_type_page];
l:= 0;
repeat
i:= obj_link(k);
obj_link(k):= l;
l:= k;
k:= i;
until k= 0;
head_tab[obj_type_page]:= l;
k:= head_tab[obj_type_pages];
pages_tail:= k;
l:= 0;
repeat
i:= obj_link(k);
obj_link(k):= l;
l:= k;
k:= i;
until k= 0;
head_tab[obj_type_pages]:= l

/*:798*/
#line 19813 "pdftexdir/pdftex.web"
;
/*796:*/
#line 19872 "pdftexdir/pdftex.web"

k:= head_tab[obj_type_dest];
while k<> 0 do begin
pdf_fix_dest(k);
k:= obj_link(k);
end

/*:796*/
#line 19814 "pdftexdir/pdftex.web"
;
/*799:*/
#line 19911 "pdftexdir/pdftex.web"

for k:= font_base+1 to font_ptr do
if font_used[k]and hasfmentry(k)and(pdf_font_num[k]<0)then begin
i:= -pdf_font_num[k];
pdfassert(pdf_font_num[i]> 0);
for j:= 0 to 255 do
if pdf_char_marked(k,j)then
pdf_mark_char(i,j);
if(length(pdf_font_attr[i])= 0)and(length(pdf_font_attr[k])<> 0)then
pdf_font_attr[i]:= pdf_font_attr[k]
else if(length(pdf_font_attr[k])= 0)and(length(pdf_font_attr[i])<> 0)then
pdf_font_attr[k]:= pdf_font_attr[i]
else if(length(pdf_font_attr[i])<> 0)and(length(pdf_font_attr[k])<> 0)and
not str_eq_str(pdf_font_attr[i],pdf_font_attr[k])then begin
pdf_warning("\pdffontattr","fonts ",false,false);
print_font_identifier(i);
print(" and ");
print_font_identifier(k);
print(" have conflicting attributes; I will ignore the attributes assigned to ");
print_font_identifier(i);
print_ln;print_ln;
end;
end;
fixed_gen_tounicode:= pdf_gen_tounicode;
k:= head_tab[obj_type_font];
while k<> 0 do begin
f:= obj_info(k);
pdfassert(pdf_font_num[f]> 0);
do_pdf_font(k,f);
k:= obj_link(k);
end;
write_fontstuff

/*:799*/
#line 19815 "pdftexdir/pdftex.web"
;
/*800:*/
#line 19949 "pdftexdir/pdftex.web"

a:= sys_obj_ptr+1;{all Pages objects whose children are not Page objects
should have index greater than|a|}
l:= head_tab[obj_type_pages];{|l|is the index of current Pages object
which is being output}
k:= head_tab[obj_type_page];{|k|is the index of current child of|l|}
b:= 0;
repeat
i:= 0;{counter of Pages object in current level}
c:= 0;{first Pages object in previous level}
if obj_link(l)= 0 then
is_root:= true{only Pages object;total pages is
not greater than|pages_tree_kids_max|}
else
is_root:= false;
repeat
if not is_root then begin
if i mod pages_tree_kids_max= 0 then begin{create a new Pages object
for next level}
pdf_last_pages:= pdf_new_objnum;
if c= 0 then
c:= pdf_last_pages;
obj_link(pages_tail):= pdf_last_pages;
pages_tail:= pdf_last_pages;
obj_link(pdf_last_pages):= 0;
obj_info(pdf_last_pages):= obj_info(l);
end
else
obj_info(pdf_last_pages):= obj_info(pdf_last_pages)+
obj_info(l);
end;
/*801:*/
#line 19990 "pdftexdir/pdftex.web"

pdf_begin_dict(l,1);
pdf_print_ln("/Type /Pages");
pdf_int_entry_ln("Count",obj_info(l));
if not is_root then
pdf_indirect_ln("Parent",pdf_last_pages);
pdf_print("/Kids [");
j:= 0;
repeat
pdf_print_int(k);
pdf_print(" 0 R ");
k:= obj_link(k);
incr(j);
until((l<a)and(j= obj_info(l)))or
(k= 0)or((k= b)and(b<> 0))or
(j= pages_tree_kids_max);
remove_last_space;
pdf_print_ln("]");
if k= 0 then begin
k:= head_tab[obj_type_pages];
head_tab[obj_type_pages]:= 0;
end;
if is_root and(pdf_pages_attr<> null)then
pdf_print_toks_ln(pdf_pages_attr);
pdf_end_dict;

/*:801*/
#line 19980 "pdftexdir/pdftex.web"
;
incr(i);
l:= obj_link(l);
until(l= c);
b:= c;
if l= 0 then
goto done;
until false;
done:

/*:800*/
#line 19816 "pdftexdir/pdftex.web"
;
/*788:*/
#line 19583 "pdftexdir/pdftex.web"

if pdf_first_outline<> 0 then begin
pdf_new_dict(obj_type_others,0,1);
outlines:= obj_ptr;
l:= pdf_first_outline;k:= 0;
repeat
incr(k);
a:= open_subentries(l);
if obj_outline_count(l)> 0 then
k:= k+a;
obj_outline_parent(l):= obj_ptr;
l:= obj_outline_next(l);
until l= 0;
pdf_print_ln("/Type /Outlines");
pdf_indirect_ln("First",pdf_first_outline);
pdf_indirect_ln("Last",pdf_last_outline);
pdf_int_entry_ln("Count",k);
pdf_end_dict;
/*789:*/
#line 19606 "pdftexdir/pdftex.web"

k:= head_tab[obj_type_outline];
while k<> 0 do begin
if obj_outline_parent(k)= pdf_parent_outline then begin
if obj_outline_prev(k)= 0 then
pdf_first_outline:= k;
if obj_outline_next(k)= 0 then
pdf_last_outline:= k;
end;
pdf_begin_dict(k,1);
pdf_indirect_ln("Title",obj_outline_title(k));
pdf_indirect_ln("A",obj_outline_action_objnum(k));
if obj_outline_parent(k)<> 0 then
pdf_indirect_ln("Parent",obj_outline_parent(k));
if obj_outline_prev(k)<> 0 then
pdf_indirect_ln("Prev",obj_outline_prev(k));
if obj_outline_next(k)<> 0 then
pdf_indirect_ln("Next",obj_outline_next(k));
if obj_outline_first(k)<> 0 then
pdf_indirect_ln("First",obj_outline_first(k));
if obj_outline_last(k)<> 0 then
pdf_indirect_ln("Last",obj_outline_last(k));
if obj_outline_count(k)<> 0 then
pdf_int_entry_ln("Count",obj_outline_count(k));
if obj_outline_attr(k)<> 0 then begin
pdf_print_toks_ln(obj_outline_attr(k));
delete_toks(obj_outline_attr(k));
end;
pdf_end_dict;
k:= obj_link(k);
end

/*:789*/
#line 19601 "pdftexdir/pdftex.web"
;
end
else
outlines:= 0

/*:788*/
#line 19817 "pdftexdir/pdftex.web"
;
/*802:*/
#line 20023 "pdftexdir/pdftex.web"

if pdf_dest_names_ptr= 0 then begin
dests:= 0;
goto done1;
end;
sort_dest_names(0,pdf_dest_names_ptr-1);
names_head:= 0;
names_tail:= 0;
k:= 0;{index of current child of|l|;if|k<pdf_dest_names_ptr|
then this is pointer to|dest_names|array;
otherwise it is the pointer to|obj_tab|(object number)}
is_names:= true;{flag whether Names or Kids}
b:= 0;
repeat
repeat
pdf_create_obj(obj_type_others,0);{create a new node}
l:= obj_ptr;
if b= 0 then
b:= l;{first in this level}
if names_head= 0 then begin
names_head:= l;
names_tail:= l;
end else begin
obj_link(names_tail):= l;
names_tail:= l;
end;
obj_link(names_tail):= 0;
/*803:*/
#line 20072 "pdftexdir/pdftex.web"

pdf_begin_dict(l,1);
j:= 0;
if is_names then begin
obj_info(l):= dest_names[k].objname;
pdf_print("/Names [");
repeat
pdf_print_str(dest_names[k].objname);
pdf_out(" ");
pdf_print_int(dest_names[k].objnum);
pdf_print(" 0 R ");
incr(j);
incr(k);
until(j= name_tree_kids_max)or(k= pdf_dest_names_ptr);
remove_last_space;
pdf_print_ln("]");
obj_aux(l):= dest_names[k-1].objname;
if k= pdf_dest_names_ptr then begin
is_names:= false;
k:= names_head;
b:= 0;
end;
end
else begin
obj_info(l):= obj_info(k);
pdf_print("/Kids [");
repeat
pdf_print_int(k);
pdf_print(" 0 R ");
incr(j);
obj_aux(l):= obj_aux(k);
k:= obj_link(k);
until(j= name_tree_kids_max)or(k= b)or(obj_link(k)= 0);
remove_last_space;
pdf_print_ln("]");
if k= b then
b:= 0;
end;
pdf_print("/Limits [");
pdf_print_str(obj_info(l));
pdf_out(" ");
pdf_print_str(obj_aux(l));
pdf_print_ln("]");
pdf_end_dict;

/*:803*/
#line 20050 "pdftexdir/pdftex.web"
;
until b= 0;
if k= l then begin
dests:= l;
goto done1;
end;
until false;
done1:
if(dests<> 0)or(pdf_names_toks<> null)then begin
pdf_new_dict(obj_type_others,0,1);
if(dests<> 0)then
pdf_indirect_ln("Dests",dests);
if pdf_names_toks<> null then begin
pdf_print_toks_ln(pdf_names_toks);
delete_toks(pdf_names_toks);
end;
pdf_end_dict;
names_tree:= obj_ptr;
end
else
names_tree:= 0

/*:802*/
#line 19818 "pdftexdir/pdftex.web"
;
/*790:*/
#line 19638 "pdftexdir/pdftex.web"

if head_tab[obj_type_thread]<> 0 then begin
pdf_new_obj(obj_type_others,0,1);
threads:= obj_ptr;
pdf_out("[");
k:= head_tab[obj_type_thread];
while k<> 0 do begin
pdf_print_int(k);
pdf_print(" 0 R ");
k:= obj_link(k);
end;
remove_last_space;
pdf_print_ln("]");
pdf_end_obj;
k:= head_tab[obj_type_thread];
while k<> 0 do begin
out_thread(k);
k:= obj_link(k);
end;
end
else
threads:= 0

/*:790*/
#line 19819 "pdftexdir/pdftex.web"
;
/*804:*/
#line 20117 "pdftexdir/pdftex.web"

pdf_new_dict(obj_type_others,0,1);
root:= obj_ptr;
pdf_print_ln("/Type /Catalog");
pdf_indirect_ln("Pages",pdf_last_pages);
if threads<> 0 then
pdf_indirect_ln("Threads",threads);
if outlines<> 0 then
pdf_indirect_ln("Outlines",outlines);
if names_tree<> 0 then
pdf_indirect_ln("Names",names_tree);
if pdf_catalog_toks<> null then begin
pdf_print_toks_ln(pdf_catalog_toks);
delete_toks(pdf_catalog_toks);
end;
if pdf_catalog_openaction<> 0 then
pdf_indirect_ln("OpenAction",pdf_catalog_openaction);
pdf_end_dict

/*:804*/
#line 19820 "pdftexdir/pdftex.web"
;
pdf_print_info;{last candidate for object stream}
if pdf_os_enable then begin
pdf_os_switch(true);
pdf_os_write_objstream;
pdf_flush;
pdf_os_switch(false);
/*812:*/
#line 20234 "pdftexdir/pdftex.web"

pdf_new_dict(obj_type_others,0,0);
if((obj_offset(sys_obj_ptr)/256)> 16777215)then
xref_offset_width:= 5
else if obj_offset(sys_obj_ptr)> 16777215 then
xref_offset_width:= 4
else if obj_offset(sys_obj_ptr)> 65535 then
xref_offset_width:= 3
else
xref_offset_width:= 2;
/*810:*/
#line 20206 "pdftexdir/pdftex.web"

l:= 0;
set_obj_fresh(l);{null object at begin of list of free objects}
for k:= 1 to sys_obj_ptr do
if not is_obj_written(k)then begin
obj_link(l):= k;
l:= k;
end;
obj_link(l):= 0

/*:810*/
#line 20244 "pdftexdir/pdftex.web"
;
pdf_print_ln("/Type /XRef");
pdf_print("/Index [0 ");
pdf_print_int(obj_ptr+1);
pdf_print_ln("]");
pdf_int_entry_ln("Size",obj_ptr+1);
pdf_print("/W [1 ");
pdf_print_int(xref_offset_width);
pdf_print_ln(" 1]");
pdf_indirect_ln("Root",root);
pdf_indirect_ln("Info",obj_ptr-1);
if pdf_trailer_toks<> null then begin
pdf_print_toks_ln(pdf_trailer_toks);
delete_toks(pdf_trailer_toks);
end;
if pdf_trailer_id_toks<> null then
print_ID_alt(pdf_trailer_id_toks)
else
print_ID(output_file_name);
pdf_print_nl;
pdf_begin_stream;
for k:= 0 to sys_obj_ptr do begin
if not is_obj_written(k)then begin{a free object}
pdf_out(0);
pdf_out_bytes(obj_link(k),xref_offset_width);
pdf_out(255);
end else begin
if obj_os_idx(k)= -1 then begin{object not in object stream}
pdf_out(1);
pdf_out_bytes(obj_offset(k),xref_offset_width);
pdf_out(0);
end else begin{object in object stream}
pdf_out(2);
pdf_out_bytes(obj_offset(k),xref_offset_width);
pdf_out(obj_os_idx(k));
end;
end;
end;
pdf_end_stream;

/*:812*/
#line 19827 "pdftexdir/pdftex.web"
;
pdf_flush;
end else begin
/*811:*/
#line 20216 "pdftexdir/pdftex.web"

/*810:*/
#line 20206 "pdftexdir/pdftex.web"

l:= 0;
set_obj_fresh(l);{null object at begin of list of free objects}
for k:= 1 to sys_obj_ptr do
if not is_obj_written(k)then begin
obj_link(l):= k;
l:= k;
end;
obj_link(l):= 0

/*:810*/
#line 20217 "pdftexdir/pdftex.web"
;
pdf_save_offset:= pdf_offset;
pdf_print_ln("xref");
pdf_print("0 ");pdf_print_int_ln(obj_ptr+1);
pdf_print_fw_int(obj_link(0),10);
pdf_print_ln(" 65535 f ");
for k:= 1 to obj_ptr do begin
if not is_obj_written(k)then begin
pdf_print_fw_int(obj_link(k),10);
pdf_print_ln(" 00000 f ");
end
else begin
pdf_print_fw_int(obj_offset(k),10);
pdf_print_ln(" 00000 n ");
end;
end

/*:811*/
#line 19830 "pdftexdir/pdftex.web"
;
end;
/*813:*/
#line 20284 "pdftexdir/pdftex.web"

if not pdf_os_enable then begin
pdf_print_ln("trailer");
pdf_print("<< ");
pdf_int_entry_ln("Size",sys_obj_ptr+1);
pdf_indirect_ln("Root",root);
pdf_indirect_ln("Info",sys_obj_ptr);
if pdf_trailer_toks<> null then begin
pdf_print_toks_ln(pdf_trailer_toks);
delete_toks(pdf_trailer_toks);
end;
if pdf_trailer_id_toks<> null then
print_ID_alt(pdf_trailer_id_toks)
else
print_ID(output_file_name);
pdf_print_ln(" >>");
end;
pdf_print_ln("startxref");
if pdf_os_enable then
pdf_print_int_ln(obj_offset(sys_obj_ptr))
else
pdf_print_int_ln(pdf_save_offset);
pdf_print_ln("%%EOF")

/*:813*/
#line 19832 "pdftexdir/pdftex.web"
;
pdf_flush;
print_nl("Output written on ");print_file_name(0,output_file_name,0);

print(" (");print_int(total_pages);print(" page");
if total_pages<> 1 then print_char("s");
print(", ");print_int(pdf_offset);print(" bytes).");
end;
libpdffinish;
if fixed_pdf_draftmode= 0 then b_close(pdf_file)
else pdf_warning(0,"\pdfdraftmode enabled, not changing output pdf",true,true)
end

/*:794*/
#line 33208 "pdftexdir/pdftex.web"
;
if log_opened then
begin wlog_cr;
wlog_ln('PDF statistics:');
wlog_ln(' ',obj_ptr:1,' PDF objects out of ',obj_tab_size:1,
' (max. ',sup_obj_tab_size:1,')');
if pdf_os_cntr> 0 then begin
wlog(' ',((pdf_os_cntr-1)*pdf_os_max_objs+pdf_os_objidx+1):1,
' compressed objects within ',pdf_os_cntr:1,' object stream');
if pdf_os_cntr> 1 then
wlog('s');
wlog_cr;
end;
wlog_ln(' ',pdf_dest_names_ptr:1,' named destinations out of ',dest_names_size:1,
' (max. ',sup_dest_names_size:1,')');
wlog_ln(' ',pdf_mem_ptr:1,' words of extra memory for PDF output out of ',pdf_mem_size:1,
' (max. ',sup_pdf_mem_size:1,')');
end;
end;
end
else begin
/*670:*/
#line 15036 "pdftexdir/pdftex.web"

while cur_s> -1 do
begin if cur_s> 0 then dvi_out(pop)
else begin dvi_out(eop);incr(total_pages);
end;
decr(cur_s);
end;
if total_pages= 0 then print_nl("No pages of output.")

#line 3336 "pdftex-final.ch"
else if cur_s<> -2 then
begin dvi_out(post);{beginning of the postamble}
#line 15046 "pdftexdir/pdftex.web"
dvi_four(last_bop);last_bop:= dvi_offset+dvi_ptr-5;{|post|location}
dvi_four(25400000);dvi_four(473628672);{conversion ratio for sp}
prepare_mag;dvi_four(mag);{magnification factor}
dvi_four(max_v);dvi_four(max_h);
dvi_out(max_push div 256);dvi_out(max_push mod 256);
dvi_out((total_pages div 256)mod 256);dvi_out(total_pages mod 256);
/*671:*/
#line 15067 "pdftexdir/pdftex.web"

while font_ptr> font_base do
begin if font_used[font_ptr]then dvi_font_def(font_ptr);
decr(font_ptr);
end


/*:671*/
#line 15052 "pdftexdir/pdftex.web"
;
dvi_out(post_post);dvi_four(last_bop);dvi_out(id_byte);
#line 3343 "pdftex-final.ch"
ifdef('IPC')
k:= 7-((3+dvi_offset+dvi_ptr)mod 4);{the number of 223's}
endif('IPC')
ifndef('IPC')
k:= 4+((dvi_buf_size-dvi_ptr)mod 4);{the number of 223's}
endifn('IPC')
#line 15055 "pdftexdir/pdftex.web"
while k> 0 do
begin dvi_out(223);decr(k);
end;
/*626:*/
#line 14143 "pdftexdir/pdftex.web"

if dvi_limit= half_buf then write_dvi(half_buf,dvi_buf_size-1);
#line 3086 "pdftex-final.ch"
if dvi_ptr> (7FFFFFFF-dvi_offset)then
begin cur_s:= -2;
fatal_error("dvi length exceeds ""7FFFFFFF");

end;
if dvi_ptr> 0 then write_dvi(0,dvi_ptr-1)
#line 14146 "pdftexdir/pdftex.web"

/*:626*/
#line 15058 "pdftexdir/pdftex.web"
;
#line 3354 "pdftex-final.ch"
print_nl("Output written on ");print_file_name(0,output_file_name,0);
#line 15060 "pdftexdir/pdftex.web"

#line 3361 "pdftex-final.ch"
print(" (");print_int(total_pages);
if total_pages<> 1 then print(" pages")
else print(" page");
#line 15063 "pdftexdir/pdftex.web"
print(", ");print_int(dvi_offset+dvi_ptr);print(" bytes).");
b_close(dvi_file);
end

/*:670*/
#line 33229 "pdftexdir/pdftex.web"
;
end;
#line 5362 "pdftex-final.ch"
/*1918:*/
#line 7006 "pdftex-final.ch"

synctex_terminate(log_opened);{Let the{\sl Sync\TeX}controller close its files.}

/*:1918*/
#line 5362 "pdftex-final.ch"
;
if log_opened then
#line 33232 "pdftexdir/pdftex.web"
 begin wlog_cr;a_close(log_file);selector:= selector-2;
if selector= term_only then
begin print_nl("Transcript written on ");

#line 5371 "pdftex-final.ch"
print_file_name(0,log_name,0);print_char(".");
end;
end;
print_ln;
if(edit_name_start<> 0)and(interaction> batch_mode)then
call_edit(str_pool,edit_name_start,edit_name_length,edit_line);
#line 33239 "pdftexdir/pdftex.web"
end;

/*:1511*//*1513:*/
#line 33280 "pdftexdir/pdftex.web"

procedure final_cleanup;
label exit;
var c:small_number;{0 for\.{\\end},1 for\.{\\dump}}
begin c:= cur_chr;
if job_name= 0 then open_log_file;
while input_ptr> 0 do
if state= token_list then end_token_list else end_file_reading;
while open_parens> 0 do
begin print(" )");decr(open_parens);
end;
if cur_level> level_one then
begin print_nl("(");print_esc("end occurred ");
print("inside a group at level ");

print_int(cur_level-level_one);print_char(")");
if eTeX_ex then show_save_groups;
end;
while cond_ptr<> null do
begin print_nl("(");print_esc("end occurred ");
print("when ");print_cmd_chr(if_test,cur_if);
if if_line<> 0 then
begin print(" on line ");print_int(if_line);
end;
print(" was incomplete)");
if_line:= if_line_field(cond_ptr);
cur_if:= subtype(cond_ptr);temp_ptr:= cond_ptr;
cond_ptr:= link(cond_ptr);free_node(temp_ptr,if_node_size);
end;
if history<> spotless then
if((history= warning_issued)or(interaction<error_stop_mode))then
if selector= term_and_log then
begin selector:= term_only;
print_nl("(see the transcript file for additional information)");

selector:= term_and_log;
end;
if c= 1 then
#line 5390 "pdftex-final.ch"
 begin Init for c:= top_mark_code to split_bot_mark_code do
#line 33319 "pdftexdir/pdftex.web"
 if cur_mark[c]<> null then delete_token_ref(cur_mark[c]);
if sa_mark<> null then
if do_marks(destroy_marks,0,sa_mark)then sa_mark:= null;
for c:= last_box_code to vsplit_code do flush_node_list(disc_ptr[c]);
if last_glue<> max_halfword then delete_glue_ref(last_glue);
#line 5396 "pdftex-final.ch"
store_fmt_file;return;Tini
#line 33325 "pdftexdir/pdftex.web"
 print_nl("(\dump is performed only by INITEX)");return;

end;
exit:end;

/*:1513*//*1514:*/
#line 33330 "pdftexdir/pdftex.web"

init procedure init_prim;{initialize all the primitives}
begin no_new_control_sequence:= false;
first:= 0;
/*244:*/
#line 5295 "pdftexdir/pdftex.web"

primitive("lineskip",assign_glue,glue_base+line_skip_code);

primitive("baselineskip",assign_glue,glue_base+baseline_skip_code);

primitive("parskip",assign_glue,glue_base+par_skip_code);

primitive("abovedisplayskip",assign_glue,glue_base+above_display_skip_code);

primitive("belowdisplayskip",assign_glue,glue_base+below_display_skip_code);

primitive("abovedisplayshortskip",
assign_glue,glue_base+above_display_short_skip_code);

primitive("belowdisplayshortskip",
assign_glue,glue_base+below_display_short_skip_code);

primitive("leftskip",assign_glue,glue_base+left_skip_code);

primitive("rightskip",assign_glue,glue_base+right_skip_code);

primitive("topskip",assign_glue,glue_base+top_skip_code);

primitive("splittopskip",assign_glue,glue_base+split_top_skip_code);

primitive("tabskip",assign_glue,glue_base+tab_skip_code);

primitive("spaceskip",assign_glue,glue_base+space_skip_code);

primitive("xspaceskip",assign_glue,glue_base+xspace_skip_code);

primitive("parfillskip",assign_glue,glue_base+par_fill_skip_code);

primitive("thinmuskip",assign_mu_glue,glue_base+thin_mu_skip_code);

primitive("medmuskip",assign_mu_glue,glue_base+med_mu_skip_code);

primitive("thickmuskip",assign_mu_glue,glue_base+thick_mu_skip_code);


/*:244*//*248:*/
#line 5441 "pdftexdir/pdftex.web"

primitive("output",assign_toks,output_routine_loc);

primitive("everypar",assign_toks,every_par_loc);

primitive("everymath",assign_toks,every_math_loc);

primitive("everydisplay",assign_toks,every_display_loc);

primitive("everyhbox",assign_toks,every_hbox_loc);

primitive("everyvbox",assign_toks,every_vbox_loc);

primitive("everyjob",assign_toks,every_job_loc);

primitive("everycr",assign_toks,every_cr_loc);

primitive("errhelp",assign_toks,err_help_loc);

primitive("pdfpagesattr",assign_toks,pdf_pages_attr_loc);

primitive("pdfpageattr",assign_toks,pdf_page_attr_loc);

primitive("pdfpageresources",assign_toks,pdf_page_resources_loc);

primitive("pdfpkmode",assign_toks,pdf_pk_mode_loc);


/*:248*//*256:*/
#line 5927 "pdftexdir/pdftex.web"

primitive("pretolerance",assign_int,int_base+pretolerance_code);

primitive("tolerance",assign_int,int_base+tolerance_code);

primitive("linepenalty",assign_int,int_base+line_penalty_code);

primitive("hyphenpenalty",assign_int,int_base+hyphen_penalty_code);

primitive("exhyphenpenalty",assign_int,int_base+ex_hyphen_penalty_code);

primitive("clubpenalty",assign_int,int_base+club_penalty_code);

primitive("widowpenalty",assign_int,int_base+widow_penalty_code);

primitive("displaywidowpenalty",
assign_int,int_base+display_widow_penalty_code);

primitive("brokenpenalty",assign_int,int_base+broken_penalty_code);

primitive("binoppenalty",assign_int,int_base+bin_op_penalty_code);

primitive("relpenalty",assign_int,int_base+rel_penalty_code);

primitive("predisplaypenalty",assign_int,int_base+pre_display_penalty_code);

primitive("postdisplaypenalty",assign_int,int_base+post_display_penalty_code);

primitive("interlinepenalty",assign_int,int_base+inter_line_penalty_code);

primitive("doublehyphendemerits",
assign_int,int_base+double_hyphen_demerits_code);

primitive("finalhyphendemerits",
assign_int,int_base+final_hyphen_demerits_code);

primitive("adjdemerits",assign_int,int_base+adj_demerits_code);

primitive("mag",assign_int,int_base+mag_code);

primitive("delimiterfactor",assign_int,int_base+delimiter_factor_code);

primitive("looseness",assign_int,int_base+looseness_code);

primitive("time",assign_int,int_base+time_code);

primitive("day",assign_int,int_base+day_code);

primitive("month",assign_int,int_base+month_code);

primitive("year",assign_int,int_base+year_code);

primitive("showboxbreadth",assign_int,int_base+show_box_breadth_code);

primitive("showboxdepth",assign_int,int_base+show_box_depth_code);

primitive("hbadness",assign_int,int_base+hbadness_code);

primitive("vbadness",assign_int,int_base+vbadness_code);

primitive("pausing",assign_int,int_base+pausing_code);

primitive("tracingonline",assign_int,int_base+tracing_online_code);

primitive("tracingmacros",assign_int,int_base+tracing_macros_code);

primitive("tracingstats",assign_int,int_base+tracing_stats_code);

primitive("tracingparagraphs",assign_int,int_base+tracing_paragraphs_code);

primitive("tracingpages",assign_int,int_base+tracing_pages_code);

primitive("tracingoutput",assign_int,int_base+tracing_output_code);

primitive("tracinglostchars",assign_int,int_base+tracing_lost_chars_code);

primitive("tracingcommands",assign_int,int_base+tracing_commands_code);

primitive("tracingrestores",assign_int,int_base+tracing_restores_code);

primitive("uchyph",assign_int,int_base+uc_hyph_code);

primitive("outputpenalty",assign_int,int_base+output_penalty_code);

primitive("maxdeadcycles",assign_int,int_base+max_dead_cycles_code);

primitive("hangafter",assign_int,int_base+hang_after_code);

primitive("floatingpenalty",assign_int,int_base+floating_penalty_code);

primitive("globaldefs",assign_int,int_base+global_defs_code);

primitive("fam",assign_int,int_base+cur_fam_code);

primitive("escapechar",assign_int,int_base+escape_char_code);

primitive("defaulthyphenchar",assign_int,int_base+default_hyphen_char_code);

primitive("defaultskewchar",assign_int,int_base+default_skew_char_code);

primitive("endlinechar",assign_int,int_base+end_line_char_code);

primitive("newlinechar",assign_int,int_base+new_line_char_code);

primitive("language",assign_int,int_base+language_code);

primitive("lefthyphenmin",assign_int,int_base+left_hyphen_min_code);

primitive("righthyphenmin",assign_int,int_base+right_hyphen_min_code);

primitive("holdinginserts",assign_int,int_base+holding_inserts_code);

primitive("errorcontextlines",assign_int,int_base+error_context_lines_code);
#line 1522 "pdftex-final.ch"

if mltex_p then
begin mltex_enabled_p:= true;{enable character substitution}
if false then{remove the if-clause to enable\.{\\charsubdefmin}}
primitive("charsubdefmin",assign_int,int_base+char_sub_def_min_code);

primitive("charsubdefmax",assign_int,int_base+char_sub_def_max_code);

primitive("tracingcharsubdef",assign_int,int_base+tracing_char_sub_def_code);

end;
if enctex_p then
begin enctex_enabled_p:= true;
primitive("mubytein",assign_int,int_base+mubyte_in_code);

primitive("mubyteout",assign_int,int_base+mubyte_out_code);

primitive("mubytelog",assign_int,int_base+mubyte_log_code);

primitive("specialout",assign_int,int_base+spec_out_code);

end;
#line 6041 "pdftexdir/pdftex.web"
primitive("pdfoutput",assign_int,int_base+pdf_output_code);

primitive("pdfcompresslevel",assign_int,int_base+pdf_compress_level_code);

primitive("pdfobjcompresslevel",assign_int,int_base+pdf_objcompresslevel_code);

primitive("pdfdecimaldigits",assign_int,int_base+pdf_decimal_digits_code);

primitive("pdfmovechars",assign_int,int_base+pdf_move_chars_code);

primitive("pdfimageresolution",assign_int,int_base+pdf_image_resolution_code);

primitive("pdfpkresolution",assign_int,int_base+pdf_pk_resolution_code);

primitive("pdfuniqueresname",assign_int,int_base+pdf_unique_resname_code);

primitive("pdfoptionpdfminorversion",assign_int,int_base+pdf_minor_version_code);

primitive("pdfoptionalwaysusepdfpagebox",assign_int,int_base+pdf_option_always_use_pdfpagebox_code);

primitive("pdfoptionpdfinclusionerrorlevel",assign_int,int_base+pdf_option_pdf_inclusion_errorlevel_code);

primitive("pdfmajorversion",assign_int,int_base+pdf_major_version_code);

primitive("pdfminorversion",assign_int,int_base+pdf_minor_version_code);

primitive("pdfforcepagebox",assign_int,int_base+pdf_force_pagebox_code);

primitive("pdfpagebox",assign_int,int_base+pdf_pagebox_code);

primitive("pdfinclusionerrorlevel",assign_int,int_base+pdf_inclusion_errorlevel_code);

primitive("pdfgamma",assign_int,int_base+pdf_gamma_code);

primitive("pdfimagegamma",assign_int,int_base+pdf_image_gamma_code);

primitive("pdfimagehicolor",assign_int,int_base+pdf_image_hicolor_code);

primitive("pdfimageapplygamma",assign_int,int_base+pdf_image_apply_gamma_code);

primitive("pdfadjustspacing",assign_int,int_base+pdf_adjust_spacing_code);

primitive("pdfprotrudechars",assign_int,int_base+pdf_protrude_chars_code);

primitive("pdftracingfonts",assign_int,int_base+pdf_tracing_fonts_code);

primitive("pdfadjustinterwordglue",assign_int,int_base+pdf_adjust_interword_glue_code);

primitive("pdfprependkern",assign_int,int_base+pdf_prepend_kern_code);

primitive("pdfappendkern",assign_int,int_base+pdf_append_kern_code);

primitive("pdfgentounicode",assign_int,int_base+pdf_gen_tounicode_code);

primitive("pdfdraftmode",assign_int,int_base+pdf_draftmode_code);

primitive("pdfinclusioncopyfonts",assign_int,int_base+pdf_inclusion_copy_font_code);


primitive("pdfsuppresswarningdupdest",assign_int,int_base+pdf_suppress_warning_dup_dest_code);


primitive("pdfsuppresswarningdupmap",assign_int,int_base+pdf_suppress_warning_dup_map_code);


primitive("pdfsuppresswarningpagegroup",assign_int,int_base+pdf_suppress_warning_page_group_code);


primitive("pdfinfoomitdate",assign_int,int_base+pdf_info_omit_date_code);


primitive("pdfsuppressptexinfo",assign_int,int_base+pdf_suppress_ptex_info_code);


primitive("pdfomitcharset",assign_int,int_base+pdf_omit_charset_code);


/*:256*//*266:*/
#line 6309 "pdftexdir/pdftex.web"

primitive("parindent",assign_dimen,dimen_base+par_indent_code);

primitive("mathsurround",assign_dimen,dimen_base+math_surround_code);

primitive("lineskiplimit",assign_dimen,dimen_base+line_skip_limit_code);

primitive("hsize",assign_dimen,dimen_base+hsize_code);

primitive("vsize",assign_dimen,dimen_base+vsize_code);

primitive("maxdepth",assign_dimen,dimen_base+max_depth_code);

primitive("splitmaxdepth",assign_dimen,dimen_base+split_max_depth_code);

primitive("boxmaxdepth",assign_dimen,dimen_base+box_max_depth_code);

primitive("hfuzz",assign_dimen,dimen_base+hfuzz_code);

primitive("vfuzz",assign_dimen,dimen_base+vfuzz_code);

primitive("delimitershortfall",
assign_dimen,dimen_base+delimiter_shortfall_code);

primitive("nulldelimiterspace",
assign_dimen,dimen_base+null_delimiter_space_code);

primitive("scriptspace",assign_dimen,dimen_base+script_space_code);

primitive("predisplaysize",assign_dimen,dimen_base+pre_display_size_code);

primitive("displaywidth",assign_dimen,dimen_base+display_width_code);

primitive("displayindent",assign_dimen,dimen_base+display_indent_code);

primitive("overfullrule",assign_dimen,dimen_base+overfull_rule_code);

primitive("hangindent",assign_dimen,dimen_base+hang_indent_code);

primitive("hoffset",assign_dimen,dimen_base+h_offset_code);

primitive("voffset",assign_dimen,dimen_base+v_offset_code);

primitive("emergencystretch",assign_dimen,dimen_base+emergency_stretch_code);

primitive("pdfhorigin",assign_dimen,dimen_base+pdf_h_origin_code);

primitive("pdfvorigin",assign_dimen,dimen_base+pdf_v_origin_code);

primitive("pdfpagewidth",assign_dimen,dimen_base+pdf_page_width_code);

primitive("pdfpageheight",assign_dimen,dimen_base+pdf_page_height_code);

primitive("pdflinkmargin",assign_dimen,dimen_base+pdf_link_margin_code);

primitive("pdfdestmargin",assign_dimen,dimen_base+pdf_dest_margin_code);

primitive("pdfthreadmargin",assign_dimen,dimen_base+pdf_thread_margin_code);

primitive("pdffirstlineheight",assign_dimen,dimen_base+pdf_first_line_height_code);

primitive("pdflastlinedepth",assign_dimen,dimen_base+pdf_last_line_depth_code);

primitive("pdfeachlineheight",assign_dimen,dimen_base+pdf_each_line_height_code);

primitive("pdfeachlinedepth",assign_dimen,dimen_base+pdf_each_line_depth_code);

primitive("pdfignoreddimen",assign_dimen,dimen_base+pdf_ignored_dimen_code);

primitive("pdfpxdimen",assign_dimen,dimen_base+pdf_px_dimen_code);


/*:266*//*287:*/
#line 6764 "pdftexdir/pdftex.web"

primitive(" ",ex_space,0);

primitive("/",ital_corr,0);

primitive("accent",accent,0);

primitive("advance",advance,0);

primitive("afterassignment",after_assignment,0);

primitive("aftergroup",after_group,0);

primitive("begingroup",begin_group,0);

primitive("char",char_num,0);

primitive("csname",cs_name,0);

primitive("delimiter",delim_num,0);

primitive("divide",divide,0);

#line 1720 "pdftex-final.ch"
primitive("endcsname",end_cs_name,0);

if enctex_p then
begin
primitive("endmubyte",end_cs_name,10);

end;
#line 6789 "pdftexdir/pdftex.web"
primitive("endgroup",end_group,0);

text(frozen_end_group):= "endgroup";eqtb[frozen_end_group]:= eqtb[cur_val];
primitive("expandafter",expand_after,0);

primitive("font",def_font,0);

primitive("letterspacefont",letterspace_font,0);

primitive("pdfcopyfont",pdf_copy_font,0);

primitive("fontdimen",assign_font_dimen,0);

primitive("halign",halign,0);

primitive("hrule",hrule,0);

primitive("ignorespaces",ignore_spaces,0);

primitive("insert",insert,0);

primitive("mark",mark,0);

primitive("mathaccent",math_accent,0);

primitive("mathchar",math_char_num,0);

primitive("mathchoice",math_choice,0);

primitive("multiply",multiply,0);

primitive("noalign",no_align,0);

primitive("noboundary",no_boundary,0);

primitive("noexpand",no_expand,0);

primitive("pdfprimitive",no_expand,1);

primitive("nonscript",non_script,0);

primitive("omit",omit,0);

primitive("parshape",set_shape,par_shape_loc);

primitive("penalty",break_penalty,0);

primitive("prevgraf",set_prev_graf,0);

primitive("radical",radical,0);

primitive("read",read_to_cs,0);

primitive("relax",relax,256);{cf.\|scan_file_name|}

text(frozen_relax):= "relax";eqtb[frozen_relax]:= eqtb[cur_val];
primitive("setbox",set_box,0);

primitive("the",the,0);

primitive("toks",toks_register,mem_bot);

primitive("vadjust",vadjust,0);

primitive("valign",valign,0);

primitive("vcenter",vcenter,0);

primitive("vrule",vrule,0);


/*:287*//*356:*/
#line 8355 "pdftexdir/pdftex.web"

primitive("par",par_end,256);{cf.\|scan_file_name|}

par_loc:= cur_val;par_token:= cs_token_flag+par_loc;

/*:356*//*402:*/
#line 9116 "pdftexdir/pdftex.web"

primitive("input",input,0);

primitive("endinput",input,1);


/*:402*//*410:*/
#line 9206 "pdftexdir/pdftex.web"

primitive("topmark",top_bot_mark,top_mark_code);

primitive("firstmark",top_bot_mark,first_mark_code);

primitive("botmark",top_bot_mark,bot_mark_code);

primitive("splitfirstmark",top_bot_mark,split_first_mark_code);

primitive("splitbotmark",top_bot_mark,split_bot_mark_code);


/*:410*//*437:*/
#line 9663 "pdftexdir/pdftex.web"

primitive("count",register,mem_bot+int_val);

primitive("dimen",register,mem_bot+dimen_val);

primitive("skip",register,mem_bot+glue_val);

primitive("muskip",register,mem_bot+mu_val);


/*:437*//*442:*/
#line 9796 "pdftexdir/pdftex.web"

primitive("spacefactor",set_aux,hmode);

primitive("prevdepth",set_aux,vmode);

primitive("deadcycles",set_page_int,0);

primitive("insertpenalties",set_page_int,1);

primitive("wd",set_box_dimen,width_offset);

primitive("ht",set_box_dimen,height_offset);

primitive("dp",set_box_dimen,depth_offset);

primitive("lastpenalty",last_item,int_val);

primitive("lastkern",last_item,dimen_val);

primitive("lastskip",last_item,glue_val);

primitive("inputlineno",last_item,input_line_no_code);

primitive("badness",last_item,badness_code);

primitive("pdftexversion",last_item,pdftex_version_code);

primitive("pdflastobj",last_item,pdf_last_obj_code);

primitive("pdflastxform",last_item,pdf_last_xform_code);

primitive("pdflastximage",last_item,pdf_last_ximage_code);

primitive("pdflastximagepages",last_item,pdf_last_ximage_pages_code);

primitive("pdflastannot",last_item,pdf_last_annot_code);

primitive("pdflastxpos",last_item,pdf_last_x_pos_code);

primitive("pdflastypos",last_item,pdf_last_y_pos_code);

primitive("pdfretval",last_item,pdf_retval_code);

primitive("pdflastximagecolordepth",last_item,pdf_last_ximage_colordepth_code);

primitive("pdfelapsedtime",last_item,elapsed_time_code);

primitive("pdfshellescape",last_item,pdf_shell_escape_code);

primitive("pdfrandomseed",last_item,random_seed_code);

primitive("pdflastlink",last_item,pdf_last_link_code);


/*:442*//*494:*/
#line 10796 "pdftexdir/pdftex.web"

primitive("number",convert,number_code);

primitive("romannumeral",convert,roman_numeral_code);

primitive("string",convert,string_code);

primitive("meaning",convert,meaning_code);

primitive("fontname",convert,font_name_code);


primitive("expanded",convert,expanded_code);


primitive("pdftexrevision",convert,pdftex_revision_code);

primitive("pdftexbanner",convert,pdftex_banner_code);

primitive("pdffontname",convert,pdf_font_name_code);

primitive("pdffontobjnum",convert,pdf_font_objnum_code);

primitive("pdffontsize",convert,pdf_font_size_code);

primitive("pdfpageref",convert,pdf_page_ref_code);

primitive("leftmarginkern",convert,left_margin_kern_code);

primitive("rightmarginkern",convert,right_margin_kern_code);

primitive("pdfxformname",convert,pdf_xform_name_code);

primitive("pdfescapestring",convert,pdf_escape_string_code);

primitive("pdfescapename",convert,pdf_escape_name_code);

primitive("pdfescapehex",convert,pdf_escape_hex_code);

primitive("pdfunescapehex",convert,pdf_unescape_hex_code);

primitive("pdfcreationdate",convert,pdf_creation_date_code);

primitive("pdffilemoddate",convert,pdf_file_mod_date_code);

primitive("pdffilesize",convert,pdf_file_size_code);

primitive("pdfmdfivesum",convert,pdf_mdfive_sum_code);

primitive("pdffiledump",convert,pdf_file_dump_code);

primitive("pdfmatch",convert,pdf_match_code);

primitive("pdflastmatch",convert,pdf_last_match_code);

primitive("pdfstrcmp",convert,pdf_strcmp_code);

primitive("pdfcolorstackinit",convert,pdf_colorstack_init_code);

primitive("pdfuniformdeviate",convert,uniform_deviate_code);

primitive("pdfnormaldeviate",convert,normal_deviate_code);


primitive("jobname",convert,job_name_code);

primitive("pdfinsertht",convert,pdf_insert_ht_code);

primitive("pdfximagebbox",convert,pdf_ximage_bbox_code);


/*:494*//*513:*/
#line 11644 "pdftexdir/pdftex.web"

primitive("if",if_test,if_char_code);

primitive("ifcat",if_test,if_cat_code);

primitive("ifnum",if_test,if_int_code);

primitive("ifdim",if_test,if_dim_code);

primitive("ifodd",if_test,if_odd_code);

primitive("ifvmode",if_test,if_vmode_code);

primitive("ifhmode",if_test,if_hmode_code);

primitive("ifmmode",if_test,if_mmode_code);

primitive("ifinner",if_test,if_inner_code);

primitive("ifvoid",if_test,if_void_code);

primitive("ifhbox",if_test,if_hbox_code);

primitive("ifvbox",if_test,if_vbox_code);

primitive("ifx",if_test,ifx_code);

primitive("ifeof",if_test,if_eof_code);

primitive("iftrue",if_test,if_true_code);

primitive("iffalse",if_test,if_false_code);

primitive("ifcase",if_test,if_case_code);

primitive("ifpdfprimitive",if_test,if_pdfprimitive_code);


/*:513*//*517:*/
#line 11739 "pdftexdir/pdftex.web"

primitive("fi",fi_or_else,fi_code);

text(frozen_fi):= "fi";eqtb[frozen_fi]:= eqtb[cur_val];
primitive("or",fi_or_else,or_code);

primitive("else",fi_or_else,else_code);


/*:517*//*579:*/
#line 12930 "pdftexdir/pdftex.web"

primitive("nullfont",set_font,null_font);

text(frozen_null_font):= "nullfont";eqtb[frozen_null_font]:= eqtb[cur_val];

/*:579*//*954:*/
#line 23348 "pdftexdir/pdftex.web"

primitive("span",tab_mark,span_code);

primitive("cr",car_ret,cr_code);

text(frozen_cr):= "cr";eqtb[frozen_cr]:= eqtb[cur_val];
primitive("crcr",car_ret,cr_cr_code);

text(frozen_end_template):= "endtemplate";text(frozen_endv):= "endtemplate";
eq_type(frozen_endv):= endv;equiv(frozen_endv):= null_list;
eq_level(frozen_endv):= level_one;
eqtb[frozen_end_template]:= eqtb[frozen_endv];
eq_type(frozen_end_template):= end_template;

/*:954*//*1158:*/
#line 27725 "pdftexdir/pdftex.web"

primitive("pagegoal",set_page_dimen,0);

primitive("pagetotal",set_page_dimen,1);

primitive("pagestretch",set_page_dimen,2);

primitive("pagefilstretch",set_page_dimen,3);

primitive("pagefillstretch",set_page_dimen,4);

primitive("pagefilllstretch",set_page_dimen,5);

primitive("pageshrink",set_page_dimen,6);

primitive("pagedepth",set_page_dimen,7);


/*:1158*//*1228:*/
#line 29025 "pdftexdir/pdftex.web"

primitive("end",stop,0);

primitive("dump",stop,1);


/*:1228*//*1234:*/
#line 29101 "pdftexdir/pdftex.web"

primitive("hskip",hskip,skip_code);

primitive("hfil",hskip,fil_code);

primitive("hfill",hskip,fill_code);

primitive("hss",hskip,ss_code);

primitive("hfilneg",hskip,fil_neg_code);

primitive("vskip",vskip,skip_code);

primitive("vfil",vskip,fil_code);

primitive("vfill",vskip,fill_code);

primitive("vss",vskip,ss_code);

primitive("vfilneg",vskip,fil_neg_code);

primitive("mskip",mskip,mskip_code);

primitive("kern",kern,explicit);

primitive("mkern",mkern,mu_glue);


/*:1234*//*1247:*/
#line 29363 "pdftexdir/pdftex.web"

primitive("moveleft",hmove,1);

primitive("moveright",hmove,0);

primitive("raise",vmove,1);

primitive("lower",vmove,0);


primitive("box",make_box,box_code);

primitive("copy",make_box,copy_code);

primitive("lastbox",make_box,last_box_code);

primitive("vsplit",make_box,vsplit_code);

primitive("vtop",make_box,vtop_code);

primitive("vbox",make_box,vtop_code+vmode);

primitive("hbox",make_box,vtop_code+hmode);

primitive("shipout",leader_ship,a_leaders-1);{|ship_out_flag= leader_flag-1|}

primitive("leaders",leader_ship,a_leaders);

primitive("cleaders",leader_ship,c_leaders);

primitive("xleaders",leader_ship,x_leaders);


/*:1247*//*1264:*/
#line 29688 "pdftexdir/pdftex.web"

primitive("indent",start_par,1);

primitive("noindent",start_par,0);

primitive("quitvmode",start_par,2);


/*:1264*//*1283:*/
#line 29909 "pdftexdir/pdftex.web"

primitive("unpenalty",remove_item,penalty_node);

primitive("unkern",remove_item,kern_node);

primitive("unskip",remove_item,glue_node);

primitive("unhbox",un_hbox,box_code);

primitive("unhcopy",un_hbox,copy_code);

primitive("unvbox",un_vbox,box_code);

primitive("unvcopy",un_vbox,copy_code);


/*:1283*//*1290:*/
#line 30002 "pdftexdir/pdftex.web"

primitive("-",discretionary,1);

primitive("discretionary",discretionary,0);


/*:1290*//*1317:*/
#line 30357 "pdftexdir/pdftex.web"

primitive("eqno",eq_no,0);

primitive("leqno",eq_no,1);


/*:1317*//*1332:*/
#line 30599 "pdftexdir/pdftex.web"

primitive("mathord",math_comp,ord_noad);

primitive("mathop",math_comp,op_noad);

primitive("mathbin",math_comp,bin_noad);

primitive("mathrel",math_comp,rel_noad);

primitive("mathopen",math_comp,open_noad);

primitive("mathclose",math_comp,close_noad);

primitive("mathpunct",math_comp,punct_noad);

primitive("mathinner",math_comp,inner_noad);

primitive("underline",math_comp,under_noad);

primitive("overline",math_comp,over_noad);

primitive("displaylimits",limit_switch,normal);

primitive("limits",limit_switch,limits);

primitive("nolimits",limit_switch,no_limits);


/*:1332*//*1345:*/
#line 30753 "pdftexdir/pdftex.web"

primitive("displaystyle",math_style,display_style);

primitive("textstyle",math_style,text_style);

primitive("scriptstyle",math_style,script_style);

primitive("scriptscriptstyle",math_style,script_script_style);


/*:1345*//*1354:*/
#line 30852 "pdftexdir/pdftex.web"

primitive("above",above,above_code);

primitive("over",above,over_code);

primitive("atop",above,atop_code);

primitive("abovewithdelims",above,delimited_code+above_code);

primitive("overwithdelims",above,delimited_code+over_code);

primitive("atopwithdelims",above,delimited_code+atop_code);


/*:1354*//*1364:*/
#line 30980 "pdftexdir/pdftex.web"

primitive("left",left_right,left_noad);

primitive("right",left_right,right_noad);

text(frozen_right):= "right";eqtb[frozen_right]:= eqtb[cur_val];

/*:1364*//*1384:*/
#line 31315 "pdftexdir/pdftex.web"

primitive("long",prefix,1);

primitive("outer",prefix,2);

primitive("global",prefix,4);

primitive("def",def,0);

primitive("gdef",def,1);

primitive("edef",def,2);

primitive("xdef",def,3);


/*:1384*//*1395:*/
#line 31506 "pdftexdir/pdftex.web"

primitive("let",let,normal);

#line 4195 "pdftex-final.ch"
primitive("futurelet",let,normal+1);

if enctex_p then
begin
primitive("mubyte",let,normal+10);

primitive("noconvert",let,normal+11);

end;
#line 31511 "pdftexdir/pdftex.web"

/*:1395*//*1398:*/
#line 31551 "pdftexdir/pdftex.web"

primitive("chardef",shorthand_def,char_def_code);

primitive("mathchardef",shorthand_def,math_char_def_code);

primitive("countdef",shorthand_def,count_def_code);

primitive("dimendef",shorthand_def,dimen_def_code);

primitive("skipdef",shorthand_def,skip_def_code);

primitive("muskipdef",shorthand_def,mu_skip_def_code);

primitive("toksdef",shorthand_def,toks_def_code);
#line 4327 "pdftex-final.ch"

if mltex_p then
begin
primitive("charsubdef",shorthand_def,char_sub_def_code);

end;
#line 31566 "pdftexdir/pdftex.web"

/*:1398*//*1406:*/
#line 31713 "pdftexdir/pdftex.web"

#line 4369 "pdftex-final.ch"
primitive("catcode",def_code,cat_code_base);

if enctex_p then
begin
primitive("xordcode",def_code,xord_code_base);

primitive("xchrcode",def_code,xchr_code_base);

primitive("xprncode",def_code,xprn_code_base);

end;
#line 31716 "pdftexdir/pdftex.web"
primitive("mathcode",def_code,math_code_base);

primitive("lccode",def_code,lc_code_base);

primitive("uccode",def_code,uc_code_base);

primitive("sfcode",def_code,sf_code_base);

primitive("delcode",def_code,del_code_base);

primitive("textfont",def_family,math_font_base);

primitive("scriptfont",def_family,math_font_base+script_size);

primitive("scriptscriptfont",def_family,math_font_base+script_script_size);


/*:1406*//*1426:*/
#line 32021 "pdftexdir/pdftex.web"

primitive("hyphenation",hyph_data,0);

primitive("patterns",hyph_data,1);


/*:1426*//*1430:*/
#line 32073 "pdftexdir/pdftex.web"

primitive("hyphenchar",assign_font_int,0);

primitive("skewchar",assign_font_int,1);

primitive("lpcode",assign_font_int,lp_code_base);

primitive("rpcode",assign_font_int,rp_code_base);

primitive("efcode",assign_font_int,ef_code_base);

primitive("tagcode",assign_font_int,tag_code);

primitive("knbscode",assign_font_int,kn_bs_code_base);

primitive("stbscode",assign_font_int,st_bs_code_base);

primitive("shbscode",assign_font_int,sh_bs_code_base);

primitive("knbccode",assign_font_int,kn_bc_code_base);

primitive("knaccode",assign_font_int,kn_ac_code_base);

primitive("pdfnoligatures",assign_font_int,no_lig_code);


/*:1430*//*1438:*/
#line 32206 "pdftexdir/pdftex.web"

primitive("batchmode",set_interaction,batch_mode);

primitive("nonstopmode",set_interaction,nonstop_mode);

primitive("scrollmode",set_interaction,scroll_mode);

primitive("errorstopmode",set_interaction,error_stop_mode);


/*:1438*//*1448:*/
#line 32272 "pdftexdir/pdftex.web"

primitive("openin",in_stream,1);

primitive("closein",in_stream,0);


/*:1448*//*1453:*/
#line 32307 "pdftexdir/pdftex.web"

primitive("message",message,0);

primitive("errmessage",message,1);


/*:1453*//*1462:*/
#line 32374 "pdftexdir/pdftex.web"

primitive("lowercase",case_shift,lc_code_base);

primitive("uppercase",case_shift,uc_code_base);


/*:1462*//*1467:*/
#line 32421 "pdftexdir/pdftex.web"

primitive("show",xray,show_code);

primitive("showbox",xray,show_box_code);

primitive("showthe",xray,show_the_code);

primitive("showlists",xray,show_lists);


/*:1467*//*1522:*/
#line 33574 "pdftexdir/pdftex.web"

primitive("openout",extension,open_node);

primitive("write",extension,write_node);write_loc:= cur_val;

primitive("closeout",extension,close_node);

#line 5573 "pdftex-final.ch"
primitive("special",extension,special_node);
text(frozen_special):= "special";eqtb[frozen_special]:= eqtb[cur_val];
#line 33582 "pdftexdir/pdftex.web"

primitive("immediate",extension,immediate_code);

primitive("setlanguage",extension,set_language_code);

primitive("pdfliteral",extension,pdf_literal_node);

primitive("pdfcolorstack",extension,pdf_colorstack_node);

primitive("pdfsetmatrix",extension,pdf_setmatrix_node);

primitive("pdfsave",extension,pdf_save_node);

primitive("pdfrestore",extension,pdf_restore_node);

primitive("pdfobj",extension,pdf_obj_code);

primitive("pdfrefobj",extension,pdf_refobj_node);

primitive("pdfxform",extension,pdf_xform_code);

primitive("pdfrefxform",extension,pdf_refxform_node);

primitive("pdfximage",extension,pdf_ximage_code);

primitive("pdfrefximage",extension,pdf_refximage_node);

primitive("pdfannot",extension,pdf_annot_node);

primitive("pdfstartlink",extension,pdf_start_link_node);

primitive("pdfendlink",extension,pdf_end_link_node);

primitive("pdfoutline",extension,pdf_outline_code);

primitive("pdfdest",extension,pdf_dest_node);

primitive("pdfthread",extension,pdf_thread_node);

primitive("pdfstartthread",extension,pdf_start_thread_node);

primitive("pdfendthread",extension,pdf_end_thread_node);

primitive("pdfsavepos",extension,pdf_save_pos_node);

primitive("pdfsnaprefpoint",extension,pdf_snap_ref_point_node);

primitive("pdfsnapy",extension,pdf_snapy_node);

primitive("pdfsnapycomp",extension,pdf_snapy_comp_node);

primitive("pdfinfo",extension,pdf_info_code);

primitive("pdfcatalog",extension,pdf_catalog_code);

primitive("pdfnames",extension,pdf_names_code);

primitive("pdfincludechars",extension,pdf_include_chars_code);

primitive("pdffontattr",extension,pdf_font_attr_code);

primitive("pdfmapfile",extension,pdf_map_file_code);

primitive("pdfmapline",extension,pdf_map_line_code);

primitive("pdftrailer",extension,pdf_trailer_code);

primitive("pdftrailerid",extension,pdf_trailer_id_code);

primitive("pdfresettimer",extension,reset_timer_code);

primitive("pdfsetrandomseed",extension,set_random_seed_code);

primitive("pdffontexpand",extension,pdf_font_expand_code);

primitive("pdfglyphtounicode",extension,pdf_glyph_to_unicode_code);

primitive("pdfnobuiltintounicode",extension,pdf_nobuiltin_tounicode_code);

primitive("pdfinterwordspaceon",extension,pdf_interword_space_on_node);

primitive("pdfinterwordspaceoff",extension,pdf_interword_space_off_node);

primitive("pdffakespace",extension,pdf_fake_space_node);

primitive("pdfrunninglinkoff",extension,pdf_running_link_off_node);

primitive("pdfrunninglinkon",extension,pdf_running_link_on_node);


/*:1522*//*1905:*/
#line 6907 "pdftex-final.ch"

primitive("synctex",assign_int,int_base+synctex_code);


/*:1905*/
#line 33334 "pdftexdir/pdftex.web"
;
no_new_control_sequence:= true;
end;
tini

/*:1514*//*1516:*/
#line 33396 "pdftexdir/pdftex.web"

debug procedure debug_help;{routine to display various things}
label breakpoint,exit;
var k,l,m,n:integer;
begin loop begin wake_up_terminal;
print_nl("debug # (-1 to exit):");update_terminal;

read(term_in,m);
if m<0 then return
else if m= 0 then
#line 5548 "pdftex-final.ch"
 dump_core{do something to cause a core dump}
#line 33409 "pdftexdir/pdftex.web"
else begin read(term_in,n);
case m of
/*1517:*/
#line 33419 "pdftexdir/pdftex.web"

1:print_word(mem[n]);{display|mem[n]|in all forms}
2:print_int(info(n));
3:print_int(link(n));
4:print_word(eqtb[n]);
#line 5554 "pdftex-final.ch"
5:begin print_scaled(font_info[n].sc);print_char(" ");
print_int(font_info[n].qqqq.b0);print_char(":");
print_int(font_info[n].qqqq.b1);print_char(":");
print_int(font_info[n].qqqq.b2);print_char(":");
print_int(font_info[n].qqqq.b3);
end;
#line 33425 "pdftexdir/pdftex.web"
6:print_word(save_stack[n]);
7:show_box(n);
{show a box,abbreviated by|show_box_depth|and|show_box_breadth|}
8:begin breadth_max:= 10000;depth_threshold:= pool_size-pool_ptr-10;
show_node_list(n);{show a box in its entirety}
end;
9:show_token_list(n,null,1000);
10:slow_print(n);
11:check_mem(n> 0);{check wellformedness;print new busy locations if|n> 0|}
12:search_mem(n);{look for pointers to|n|}
13:begin read(term_in,l);print_cmd_chr(n,l);
end;
14:for k:= 0 to n do print(buffer[k]);
15:begin font_in_short_display:= null_font;short_display(n);
end;
16:panicking:= not panicking;

/*:1517*/
#line 33411 "pdftexdir/pdftex.web"

othercases print("?")
endcases;
end;
end;
exit:end;
gubed

/*:1516*/
#line 33095 "pdftexdir/pdftex.web"


/*:1508*//*1510:*/
#line 5200 "pdftex-final.ch"
procedure main_body;
begin{|start_here|}

{Bounds that may be set from the configuration file.We want the user to
be able to specify the names with underscores,but\.{TANGLE}removes
underscores,so we're stuck giving the names twice, once as a string,
once as the identifier.How ugly.}
setup_bound_var(0)('mem_bot')(mem_bot);
setup_bound_var(250000)('main_memory')(main_memory);
{|memory_word|s for|mem|in\.{INITEX}}
setup_bound_var(0)('extra_mem_top')(extra_mem_top);
{increase high mem in\.{VIRTEX}}
setup_bound_var(0)('extra_mem_bot')(extra_mem_bot);
{increase low mem in\.{VIRTEX}}
setup_bound_var(200000)('pool_size')(pool_size);
setup_bound_var(75000)('string_vacancies')(string_vacancies);
setup_bound_var(5000)('pool_free')(pool_free);{min pool avail after fmt}
setup_bound_var(15000)('max_strings')(max_strings);
setup_bound_var(100)('strings_free')(strings_free);
setup_bound_var(100000)('font_mem_size')(font_mem_size);
setup_bound_var(500)('font_max')(font_max);
setup_bound_var(20000)('trie_size')(trie_size);
{if|ssup_trie_size|increases,recompile}
setup_bound_var(659)('hyph_size')(hyph_size);
setup_bound_var(3000)('buf_size')(buf_size);
setup_bound_var(50)('nest_size')(nest_size);
setup_bound_var(15)('max_in_open')(max_in_open);
setup_bound_var(60)('param_size')(param_size);
setup_bound_var(4000)('save_size')(save_size);
setup_bound_var(300)('stack_size')(stack_size);
setup_bound_var(16384)('dvi_buf_size')(dvi_buf_size);
setup_bound_var(79)('error_line')(error_line);
setup_bound_var(50)('half_error_line')(half_error_line);
setup_bound_var(79)('max_print_line')(max_print_line);
setup_bound_var(0)('hash_extra')(hash_extra);
setup_bound_var(10000)('expand_depth')(expand_depth);
setup_bound_var(72)('pk_dpi')(pk_dpi);
const_chk(mem_bot);
const_chk(main_memory);
Init
extra_mem_top:= 0;
extra_mem_bot:= 0;
Tini
if extra_mem_bot> sup_main_memory then extra_mem_bot:= sup_main_memory;
if extra_mem_top> sup_main_memory then extra_mem_top:= sup_main_memory;
{|mem_top|is an index,|main_memory|a size}
mem_top:= mem_bot+main_memory-1;
mem_min:= mem_bot;
mem_max:= mem_top;

{Check other constants against their sup and inf.}
const_chk(trie_size);
const_chk(hyph_size);
const_chk(buf_size);
const_chk(nest_size);
const_chk(max_in_open);
const_chk(param_size);
const_chk(save_size);
const_chk(stack_size);
const_chk(dvi_buf_size);
const_chk(pool_size);
const_chk(string_vacancies);
const_chk(pool_free);
const_chk(max_strings);
const_chk(strings_free);
const_chk(font_mem_size);
const_chk(font_max);
const_chk(hash_extra);
const_chk(obj_tab_size);
const_chk(pdf_mem_size);
const_chk(dest_names_size);
const_chk(pk_dpi);
if error_line> ssup_error_line then error_line:= ssup_error_line;

{array memory allocation}
buffer:= xmalloc_array(ASCII_code,buf_size);
nest:= xmalloc_array(list_state_record,nest_size);
save_stack:= xmalloc_array(memory_word,save_size);
input_stack:= xmalloc_array(in_state_record,stack_size);
input_file:= xmalloc_array(alpha_file,max_in_open);
line_stack:= xmalloc_array(integer,max_in_open);
eof_seen:= xmalloc_array(boolean,max_in_open);
grp_stack:= xmalloc_array(save_pointer,max_in_open);
if_stack:= xmalloc_array(pointer,max_in_open);
source_filename_stack:= xmalloc_array(str_number,max_in_open);
full_source_filename_stack:= xmalloc_array(str_number,max_in_open);
param_stack:= xmalloc_array(halfword,param_size);
dvi_buf:= xmalloc_array(eight_bits,dvi_buf_size);
hyph_word:= xmalloc_array(str_number,hyph_size);
hyph_list:= xmalloc_array(halfword,hyph_size);
hyph_link:= xmalloc_array(hyph_pointer,hyph_size);
obj_tab:= xmalloc_array(obj_entry,inf_obj_tab_size);{will grow dynamically}
pdf_mem:= xmalloc_array(integer,inf_pdf_mem_size);{will grow dynamically}
dest_names:= xmalloc_array(dest_name_entry,inf_dest_names_size);{will grow dynamically}
pdf_op_buf:= xmalloc_array(eight_bits,pdf_op_buf_size);
pdf_os_buf:= xmalloc_array(eight_bits,inf_pdf_os_buf_size);{will grow dynamically}
pdf_os_objnum:= xmalloc_array(integer,pdf_os_max_objs);
pdf_os_objoff:= xmalloc_array(integer,pdf_os_max_objs);
Init
yzmem:= xmalloc_array(memory_word,mem_top-mem_bot+1);
zmem:= yzmem-mem_bot;{Some compilers require|mem_bot= 0|}
eqtb_top:= eqtb_size+hash_extra;
if hash_extra= 0 then hash_top:= undefined_control_sequence else
hash_top:= eqtb_top;
yhash:= xmalloc_array(two_halves,1+hash_top-hash_offset);
hash:= yhash-hash_offset;{Some compilers require|hash_offset= 0|}
next(hash_base):= 0;text(hash_base):= 0;
for hash_used:= hash_base+1 to hash_top do hash[hash_used]:= hash[hash_base];
zeqtb:= xmalloc_array(memory_word,eqtb_top);
eqtb:= zeqtb;

str_start:= xmalloc_array(pool_pointer,max_strings);
str_pool:= xmalloc_array(packed_ASCII_code,pool_size);
font_info:= xmalloc_array(fmemory_word,font_mem_size);
Tini
#line 33150 "pdftexdir/pdftex.web"
 history:= fatal_error_stop;{in case we quit during initialization}
t_open_out;{open the terminal for output}
if ready_already= 314159 then goto start_of_TEX;
/*14:*/
#line 597 "pdftexdir/pdftex.web"

bad:= 0;
if(half_error_line<30)or(half_error_line> error_line-15)then bad:= 1;
if max_print_line<60 then bad:= 2;
if dvi_buf_size mod 8<> 0 then bad:= 3;
if mem_bot+1100> mem_top then bad:= 4;
if hash_prime> hash_size then bad:= 5;
if max_in_open>=128 then bad:= 6;
if mem_top<256+11 then bad:= 7;{we will want|null_list> 255|}

/*:14*//*129:*/
#line 2926 "pdftexdir/pdftex.web"

init if(mem_min<> mem_bot)or(mem_max<> mem_top)then bad:= 10;tini
if(mem_min> mem_bot)or(mem_max<mem_top)then bad:= 10;
if(min_quarterword> 0)or(max_quarterword<127)then bad:= 11;
if(min_halfword> 0)or(max_halfword<32767)then bad:= 12;
if(min_quarterword<min_halfword)or
(max_quarterword> max_halfword)then bad:= 13;
#line 1002 "pdftex-final.ch"
if(mem_bot-sup_main_memory<min_halfword)or
(mem_top+sup_main_memory>=max_halfword)then bad:= 14;
#line 1010 "pdftex-final.ch"
if(max_font_max<min_halfword)or(max_font_max> max_halfword)then bad:= 15;
if font_max> font_base+max_font_max then bad:= 16;
#line 2937 "pdftexdir/pdftex.web"
if(save_size> max_halfword)or(max_strings> max_halfword)then bad:= 17;
if buf_size> max_halfword then bad:= 18;
if max_quarterword-min_quarterword<255 then bad:= 19;

/*:129*//*312:*/
#line 7356 "pdftexdir/pdftex.web"

#line 1751 "pdftex-final.ch"
if cs_token_flag+eqtb_size+hash_extra> max_halfword then bad:= 21;
if(hash_offset<0)or(hash_offset> hash_base)then bad:= 42;
#line 7358 "pdftexdir/pdftex.web"

/*:312*//*548:*/
#line 12237 "pdftexdir/pdftex.web"

if format_default_length> file_name_size then bad:= 31;

/*:548*//*1425:*/
#line 32016 "pdftexdir/pdftex.web"

if 2*max_halfword<mem_top-mem_min then bad:= 41;

/*:1425*/
#line 33153 "pdftexdir/pdftex.web"

if bad> 0 then
begin wterm_ln('Ouch---my internal constants have been clobbered!',
'---case ',bad:1);

goto final_end;
end;
initialize;{set global variables to their starting values}
#line 5323 "pdftex-final.ch"
Init if not get_strings_started then goto final_end;
init_prim;{call|primitive|for each primitive}
init_str_ptr:= str_ptr;init_pool_ptr:= pool_ptr;fix_date_and_time;
Tini
#line 33165 "pdftexdir/pdftex.web"
 ready_already:= 314159;
start_of_TEX:/*55:*/
#line 1580 "pdftexdir/pdftex.web"

selector:= term_only;tally:= 0;term_offset:= 0;file_offset:= 0;

/*:55*//*61:*/
#line 1708 "pdftexdir/pdftex.web"

#line 787 "pdftex-final.ch"
if src_specials_p or file_line_error_style_p or parse_first_line_p then
wterm(banner_k)
else
wterm(banner);
#line 798 "pdftex-final.ch"
wterm(version_string);
if format_ident= 0 then wterm_ln(' (preloaded format=',dump_name,')')
else begin slow_print(format_ident);print_ln;
end;
if shellenabledp then begin
wterm(' ');
if restrictedshell then begin
wterm('restricted ');
end;
wterm_ln('\write18 enabled.');
end;
if src_specials_p then begin
wterm_ln(' Source specials enabled.')
end;
if translate_filename then begin
wterm(' (');
fputs(translate_filename,stdout);
wterm_ln(')');
end;
#line 1713 "pdftexdir/pdftex.web"
update_terminal;

/*:61*//*554:*/
#line 12371 "pdftexdir/pdftex.web"

job_name:= 0;name_in_progress:= false;log_opened:= false;

/*:554*//*559:*/
#line 12439 "pdftexdir/pdftex.web"
output_file_name:= 0;

/*:559*/
#line 33166 "pdftexdir/pdftex.web"
;
/*1515:*/
#line 33346 "pdftexdir/pdftex.web"

begin/*353:*/
#line 8309 "pdftexdir/pdftex.web"

#line 1868 "pdftex-final.ch"
 begin input_ptr:= 0;max_in_stack:= 0;
source_filename_stack[0]:= 0;full_source_filename_stack[0]:= 0;
#line 8311 "pdftexdir/pdftex.web"
in_open:= 0;open_parens:= 0;max_buf_stack:= 0;
grp_stack[0]:= 0;if_stack[0]:= null;
param_ptr:= 0;max_param_stack:= 0;
first:= buf_size;repeat buffer[first]:= 0;decr(first);until first= 0;
scanner_status:= normal;warning_index:= null;first:= 1;
state:= new_line;start:= 1;index:= 0;line:= 0;name:= 0;
force_eof:= false;
align_state:= 1000000;
if not init_terminal then goto final_end;
limit:= last;first:= last+1;{|init_terminal|has set|loc|and|last|}
end

/*:353*/
#line 33347 "pdftexdir/pdftex.web"
;
/*1645:*/
#line 36810 "pdftexdir/pdftex.web"

#line 5814 "pdftex-final.ch"
init if(etex_p or(buffer[loc]= "*"))and(format_ident= " (INITEX)")then
#line 36812 "pdftexdir/pdftex.web"
 begin no_new_control_sequence:= false;
/*1646:*/
#line 36835 "pdftexdir/pdftex.web"

primitive("lastnodetype",last_item,last_node_type_code);

primitive("eTeXversion",last_item,eTeX_version_code);

primitive("eTeXrevision",convert,eTeX_revision_code);


/*:1646*//*1654:*/
#line 36888 "pdftexdir/pdftex.web"

primitive("everyeof",assign_toks,every_eof_loc);

primitive("tracingassigns",assign_int,int_base+tracing_assigns_code);

primitive("tracinggroups",assign_int,int_base+tracing_groups_code);

primitive("tracingifs",assign_int,int_base+tracing_ifs_code);

primitive("tracingscantokens",assign_int,int_base+tracing_scan_tokens_code);

primitive("tracingnesting",assign_int,int_base+tracing_nesting_code);

primitive("predisplaydirection",
assign_int,int_base+pre_display_direction_code);

primitive("lastlinefit",assign_int,int_base+last_line_fit_code);

primitive("savingvdiscards",assign_int,int_base+saving_vdiscards_code);

primitive("savinghyphcodes",assign_int,int_base+saving_hyph_codes_code);


/*:1654*//*1660:*/
#line 36993 "pdftexdir/pdftex.web"

primitive("currentgrouplevel",last_item,current_group_level_code);

primitive("currentgrouptype",last_item,current_group_type_code);


/*:1660*//*1663:*/
#line 37015 "pdftexdir/pdftex.web"

primitive("currentiflevel",last_item,current_if_level_code);

primitive("currentiftype",last_item,current_if_type_code);

primitive("currentifbranch",last_item,current_if_branch_code);


/*:1663*//*1666:*/
#line 37051 "pdftexdir/pdftex.web"

primitive("fontcharwd",last_item,font_char_wd_code);

primitive("fontcharht",last_item,font_char_ht_code);

primitive("fontchardp",last_item,font_char_dp_code);

primitive("fontcharic",last_item,font_char_ic_code);


/*:1666*//*1669:*/
#line 37092 "pdftexdir/pdftex.web"

primitive("parshapelength",last_item,par_shape_length_code);

primitive("parshapeindent",last_item,par_shape_indent_code);

primitive("parshapedimen",last_item,par_shape_dimen_code);


/*:1669*//*1672:*/
#line 37124 "pdftexdir/pdftex.web"

primitive("showgroups",xray,show_groups);


/*:1672*//*1681:*/
#line 37295 "pdftexdir/pdftex.web"

primitive("showtokens",xray,show_tokens);


/*:1681*//*1683:*/
#line 37310 "pdftexdir/pdftex.web"

primitive("unexpanded",the,1);

primitive("detokenize",the,show_tokens);


/*:1683*//*1686:*/
#line 37336 "pdftexdir/pdftex.web"

primitive("showifs",xray,show_ifs);


/*:1686*//*1689:*/
#line 37368 "pdftexdir/pdftex.web"

primitive("interactionmode",set_page_int,2);


/*:1689*//*1694:*/
#line 37397 "pdftexdir/pdftex.web"

primitive("middle",left_right,middle_noad);


/*:1694*//*1698:*/
#line 37482 "pdftexdir/pdftex.web"

primitive("TeXXeTstate",assign_int,eTeX_state_base+TeXXeT_code);

primitive("beginL",valign,begin_L_code);

primitive("endL",valign,end_L_code);

primitive("beginR",valign,begin_R_code);

primitive("endR",valign,end_R_code);


/*:1698*//*1744:*/
#line 38102 "pdftexdir/pdftex.web"

primitive("scantokens",input,2);


/*:1744*//*1756:*/
#line 38232 "pdftexdir/pdftex.web"

primitive("readline",read_to_cs,1);


/*:1756*//*1759:*/
#line 38260 "pdftexdir/pdftex.web"

primitive("unless",expand_after,1);

primitive("ifdefined",if_test,if_def_code);

primitive("ifcsname",if_test,if_cs_code);

primitive("iffontchar",if_test,if_font_char_code);

primitive("ifincsname",if_test,if_in_csname_code);

primitive("ifpdfabsnum",if_test,if_pdfabs_num_code);

primitive("ifpdfabsdim",if_test,if_pdfabs_dim_code);


/*:1759*//*1767:*/
#line 38386 "pdftexdir/pdftex.web"

primitive("protected",prefix,8);


/*:1767*//*1775:*/
#line 38521 "pdftexdir/pdftex.web"

primitive("numexpr",last_item,eTeX_expr-int_val+int_val);

primitive("dimexpr",last_item,eTeX_expr-int_val+dimen_val);

primitive("glueexpr",last_item,eTeX_expr-int_val+glue_val);

primitive("muexpr",last_item,eTeX_expr-int_val+mu_val);


/*:1775*//*1798:*/
#line 38943 "pdftexdir/pdftex.web"

primitive("gluestretchorder",last_item,glue_stretch_order_code);

primitive("glueshrinkorder",last_item,glue_shrink_order_code);

primitive("gluestretch",last_item,glue_stretch_code);

primitive("glueshrink",last_item,glue_shrink_code);


/*:1798*//*1802:*/
#line 38982 "pdftexdir/pdftex.web"

primitive("mutoglue",last_item,mu_to_glue_code);

primitive("gluetomu",last_item,glue_to_mu_code);


/*:1802*//*1806:*/
#line 39020 "pdftexdir/pdftex.web"

primitive("marks",mark,marks_code);

primitive("topmarks",top_bot_mark,top_mark_code+marks_code);

primitive("firstmarks",top_bot_mark,first_mark_code+marks_code);

primitive("botmarks",top_bot_mark,bot_mark_code+marks_code);

primitive("splitfirstmarks",top_bot_mark,split_first_mark_code+marks_code);

primitive("splitbotmarks",top_bot_mark,split_bot_mark_code+marks_code);


/*:1806*//*1858:*/
#line 39892 "pdftexdir/pdftex.web"

primitive("pagediscards",un_vbox,last_box_code);

primitive("splitdiscards",un_vbox,vsplit_code);


/*:1858*//*1861:*/
#line 39916 "pdftexdir/pdftex.web"

primitive("interlinepenalties",set_shape,inter_line_penalties_loc);

primitive("clubpenalties",set_shape,club_penalties_loc);

primitive("widowpenalties",set_shape,widow_penalties_loc);

primitive("displaywidowpenalties",set_shape,display_widow_penalties_loc);


/*:1861*/
#line 36813 "pdftexdir/pdftex.web"

#line 5820 "pdftex-final.ch"
if(buffer[loc]= "*")then incr(loc);
eTeX_mode:= 1;{enter extended mode}
#line 36815 "pdftexdir/pdftex.web"
/*1810:*/
#line 39055 "pdftexdir/pdftex.web"

max_reg_num:= 32767;
max_reg_help_line:= "A register number must be between 0 and 32767.";

/*:1810*/
#line 36815 "pdftexdir/pdftex.web"

end;
tini
if not no_new_control_sequence then{just entered extended mode?}
no_new_control_sequence:= true else

/*:1645*/
#line 33348 "pdftexdir/pdftex.web"

#line 5402 "pdftex-final.ch"
if(format_ident= 0)or(buffer[loc]= "&")or dump_line then
#line 33350 "pdftexdir/pdftex.web"
 begin if format_ident<> 0 then initialize;{erase preloaded format}
if not open_fmt_file then goto final_end;
if not load_fmt_file then
begin w_close(fmt_file);goto final_end;
end;
#line 5408 "pdftex-final.ch"
w_close(fmt_file);
eqtb:= zeqtb;
#line 33356 "pdftexdir/pdftex.web"
while(loc<limit)and(buffer[loc]= " ")do incr(loc);
end;
if(pdf_output_option<> 0)then pdf_output:= pdf_output_value;
if(pdf_draftmode_option<> 0)then pdf_draftmode:= pdf_draftmode_value;
pdf_init_map_file('pdftex.map');
if eTeX_ex then wterm_ln('entering extended mode');
if end_line_char_inactive then decr(limit)
else buffer[limit]:= end_line_char;
#line 5415 "pdftex-final.ch"
if mltex_enabled_p then
begin wterm_ln('MLTeX v2.2 enabled');
end;
if enctex_enabled_p then
begin wterm(encTeX_banner);wterm_ln(', reencoding enabled.');
if translate_filename then begin
wterm_ln(' (\xordcode, \xchrcode, \xprncode overridden by TCX)');
end;
end;
fix_date_and_time;

init
if trie_not_ready then begin{initex without format loaded}
trie_trl:= xmalloc_array(trie_pointer,trie_size);
trie_tro:= xmalloc_array(trie_pointer,trie_size);
trie_trc:= xmalloc_array(quarterword,trie_size);

trie_c:= xmalloc_array(packed_ASCII_code,trie_size);
trie_o:= xmalloc_array(trie_opcode,trie_size);
trie_l:= xmalloc_array(trie_pointer,trie_size);
trie_r:= xmalloc_array(trie_pointer,trie_size);
trie_hash:= xmalloc_array(trie_pointer,trie_size);
trie_taken:= xmalloc_array(boolean,trie_size);

trie_root:= 0;trie_c[0]:= si(0);trie_ptr:= 0;
hyph_root:= 0;hyph_start:= 0;

{Allocate and initialize font arrays}
font_check:= xmalloc_array(four_quarters,font_max);
font_size:= xmalloc_array(scaled,font_max);
font_dsize:= xmalloc_array(scaled,font_max);
font_params:= xmalloc_array(font_index,font_max);
font_name:= xmalloc_array(str_number,font_max);
font_area:= xmalloc_array(str_number,font_max);
font_bc:= xmalloc_array(eight_bits,font_max);
font_ec:= xmalloc_array(eight_bits,font_max);
font_glue:= xmalloc_array(halfword,font_max);
hyphen_char:= xmalloc_array(integer,font_max);
skew_char:= xmalloc_array(integer,font_max);
bchar_label:= xmalloc_array(font_index,font_max);
font_bchar:= xmalloc_array(nine_bits,font_max);
font_false_bchar:= xmalloc_array(nine_bits,font_max);
char_base:= xmalloc_array(integer,font_max);
width_base:= xmalloc_array(integer,font_max);
height_base:= xmalloc_array(integer,font_max);
depth_base:= xmalloc_array(integer,font_max);
italic_base:= xmalloc_array(integer,font_max);
lig_kern_base:= xmalloc_array(integer,font_max);
kern_base:= xmalloc_array(integer,font_max);
exten_base:= xmalloc_array(integer,font_max);
param_base:= xmalloc_array(integer,font_max);

pdf_char_used:= xmalloc_array(char_used_array,font_max);
pdf_font_size:= xmalloc_array(scaled,font_max);
pdf_font_num:= xmalloc_array(integer,font_max);
pdf_font_map:= xmalloc_array(fm_entry_ptr,font_max);
pdf_font_type:= xmalloc_array(eight_bits,font_max);
pdf_font_attr:= xmalloc_array(str_number,font_max);
pdf_font_blink:= xmalloc_array(internal_font_number,font_max);
pdf_font_elink:= xmalloc_array(internal_font_number,font_max);
pdf_font_stretch:= xmalloc_array(integer,font_max);
pdf_font_shrink:= xmalloc_array(integer,font_max);
pdf_font_step:= xmalloc_array(integer,font_max);
pdf_font_expand_ratio:= xmalloc_array(integer,font_max);
pdf_font_auto_expand:= xmalloc_array(boolean,font_max);
pdf_font_lp_base:= xmalloc_array(integer,font_max);
pdf_font_rp_base:= xmalloc_array(integer,font_max);
pdf_font_ef_base:= xmalloc_array(integer,font_max);
pdf_font_kn_bs_base:= xmalloc_array(integer,font_max);
pdf_font_st_bs_base:= xmalloc_array(integer,font_max);
pdf_font_sh_bs_base:= xmalloc_array(integer,font_max);
pdf_font_kn_bc_base:= xmalloc_array(integer,font_max);
pdf_font_kn_ac_base:= xmalloc_array(integer,font_max);
vf_packet_base:= xmalloc_array(integer,font_max);
vf_default_font:= xmalloc_array(internal_font_number,font_max);
vf_local_font_num:= xmalloc_array(internal_font_number,font_max);
vf_e_fnts:= xmalloc_array(integer,font_max);
vf_i_fnts:= xmalloc_array(internal_font_number,font_max);
pdf_font_nobuiltin_tounicode:= xmalloc_array(boolean,font_max);

for font_k:= font_base to font_max do begin
for k:= 0 to 31 do
pdf_char_used[font_k,k]:= 0;
pdf_font_size[font_k]:= 0;
pdf_font_num[font_k]:= 0;
pdf_font_map[font_k]:= 0;
pdf_font_type[font_k]:= new_font_type;
pdf_font_attr[font_k]:= "";
pdf_font_blink[font_k]:= null_font;
pdf_font_elink[font_k]:= null_font;
pdf_font_stretch[font_k]:= null_font;
pdf_font_shrink[font_k]:= null_font;
pdf_font_step[font_k]:= 0;
pdf_font_expand_ratio[font_k]:= 0;
pdf_font_auto_expand[font_k]:= false;
pdf_font_lp_base[font_k]:= 0;
pdf_font_rp_base[font_k]:= 0;
pdf_font_ef_base[font_k]:= 0;
pdf_font_kn_bs_base[font_k]:= 0;
pdf_font_st_bs_base[font_k]:= 0;
pdf_font_sh_bs_base[font_k]:= 0;
pdf_font_kn_bc_base[font_k]:= 0;
pdf_font_kn_ac_base[font_k]:= 0;
pdf_font_nobuiltin_tounicode[font_k]:= false;
end;

font_ptr:= null_font;fmem_ptr:= 7;
make_pdftex_banner;
font_name[null_font]:= "nullfont";font_area[null_font]:= "";
hyphen_char[null_font]:= "-";skew_char[null_font]:= -1;
bchar_label[null_font]:= non_address;
font_bchar[null_font]:= non_char;font_false_bchar[null_font]:= non_char;
font_bc[null_font]:= 1;font_ec[null_font]:= 0;
font_size[null_font]:= 0;font_dsize[null_font]:= 0;
char_base[null_font]:= 0;width_base[null_font]:= 0;
height_base[null_font]:= 0;depth_base[null_font]:= 0;
italic_base[null_font]:= 0;lig_kern_base[null_font]:= 0;
kern_base[null_font]:= 0;exten_base[null_font]:= 0;
font_glue[null_font]:= null;font_params[null_font]:= 7;
param_base[null_font]:= -1;
for font_k:= 0 to 6 do font_info[font_k].sc:= 0;
end;
tini

font_used:= xmalloc_array(boolean,font_max);
for font_k:= font_base to font_max do font_used[font_k]:= false;
#line 33365 "pdftexdir/pdftex.web"
random_seed:= (microseconds*1000)+(epochseconds mod 1000000);
init_randoms(random_seed);
/*939:*/
#line 23003 "pdftexdir/pdftex.web"

magic_offset:= str_start[math_spacing]-9*ord_noad

/*:939*/
#line 33367 "pdftexdir/pdftex.web"
;
/*75:*/
#line 1908 "pdftexdir/pdftex.web"

if interaction= batch_mode then selector:= no_print else selector:= term_only

/*:75*/
#line 33368 "pdftexdir/pdftex.web"
;
if(loc<limit)and(cat_code(buffer[loc])<> escape)then start_input;
{\.{\\input}assumed}
end

/*:1515*/
#line 33167 "pdftexdir/pdftex.web"
;
#line 5332 "pdftex-final.ch"
history:= spotless;{ready to go!}
/*1910:*/
#line 6926 "pdftex-final.ch"

synctex_init_command;

/*:1910*/
#line 5333 "pdftex-final.ch"

#line 33169 "pdftexdir/pdftex.web"
main_control;{come to life}
final_cleanup;{prepare for death}
#line 5341 "pdftex-final.ch"
close_files_and_terminate;
final_end:do_final_end;
end{|main_body|};
#line 33174 "pdftexdir/pdftex.web"

/*:1510*//*1877:*/
#line 6207 "pdftex-final.ch"
procedure scan_file_name_braced;
var
save_scanner_status:small_number;{|scanner_status|upon entry}
save_def_ref:pointer;{|def_ref|upon entry,important if inside`\.{\\message}}
save_cur_cs:pointer;
s:str_number;{temp string}
p:pointer;{temp pointer}
i:integer;{loop tally}
save_stop_at_space:boolean;{this should be in tex.ch}
dummy:boolean;
{Initializing}
begin save_scanner_status:= scanner_status;{|scan_toks|sets|scanner_status|to|absorbing|}
save_def_ref:= def_ref;{|scan_toks|uses|def_ref|to point to the token list just read}
save_cur_cs:= cur_cs;{we set|cur_cs|back a few tokens to use in runaway errors}
{Scanning a token list}
cur_cs:= warning_index;{for possible runaway error}
{mimick|call_func|from pdfTeX}
if scan_toks(false,true)<> 0 then do_nothing;{actually do the scanning}
{|s:= tokens_to_string(def_ref);|}
old_setting:= selector;selector:= new_string;
show_token_list(link(def_ref),null,pool_size-pool_ptr);
selector:= old_setting;
s:= make_string;
{turns the token list read in a string to input}
{Restoring some variables}
delete_token_ref(def_ref);{remove the token list from memory}
def_ref:= save_def_ref;{and restore|def_ref|}
cur_cs:= save_cur_cs;{restore|cur_cs|}
scanner_status:= save_scanner_status;{restore|scanner_status|}
{Passing the read string to the input machinery}
save_stop_at_space:= stop_at_space;{save|stop_at_space|}
stop_at_space:= false;{set|stop_at_space|to false to allow spaces in file names}
begin_name;
for i:= str_start[s]to str_start[s+1]-1 do
dummy:= more_name(str_pool[i]);{add each read character to the current file name}
stop_at_space:= save_stop_at_space;{restore|stop_at_space|}
end;


/*:1877*//*1937:*/
#line 7135 "pdftex-final.ch"
function get_nullstr:str_number;
begin
get_nullstr:= "";
end;


/*:1937*/
